{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenido!","text":"<p>Si est\u00e1s leyendo esto es porque tienes mucha fuerza de voluntad y unas enormes ganas de aprender a desarrollar con el stack tecnol\u00f3gico de CCA (Java Spring Boot, Nodejs, Angular, React, Vue) o porque te han mandando hacer este tutorial en tu etapa de formaci\u00f3n. En cualquier caso, te agradecemos el esfuerzo que est\u00e1s haciendo y te deseamos suerte .</p> <p>Por favor, si detectas que hay algo incorrecto en el tutorial, que no funciona o que est\u00e1 mal escrito, contacta con nosotros para que podamos solventarlo para futuras lecturas. Escr\u00edbenos un issue aqu\u00ed.</p>"},{"location":"#que-vamos-a-hacer","title":"\u00bfQue vamos a hacer?","text":"<p>Durante este tutorial, vamos a crear una aplicaci\u00f3n web paso a paso con Spring Boot o Nodejs para la parte servidora y con Angular o React para la parte frontal. Intentar\u00e9 comentar todo lo m\u00e1s detallado posible, pero si echas en falta alguna explicaci\u00f3n por favor, escr\u00edbenos un issue aqu\u00ed para que podamos a\u00f1adirla.</p>"},{"location":"#como-lo-vamos-a-hacer","title":"\u00bfComo lo vamos a hacer?","text":"<p>En primer lugar te comentar\u00e9 brevemente las herramientas que usaremos en el tutorial y la forma de instalarlas (altamente recomendado). Luego veremos un vistazo general de lo que vamos a construir para que tengas un contexto general de la aplicaci\u00f3n. Y por \u00faltimo desarrollaremos paso a paso el backend y el frontend de la aplicaci\u00f3n.</p> <p>Durante todo el tutorial intentar\u00e9 dar unas pautas y consejos de buenas pr\u00e1cticas que todos deber\u00edamos adoptar, en la medida de lo posible, para homogeneizar el desarrollo de todos los proyectos.</p> <p>Adem\u00e1s para cada uno de los cap\u00edtulos que lo requieran, voy a desdoblar el tutorial por cada una de las tecnolog\u00edas disponibles para que vayas construyendo con la que m\u00e1s c\u00f3modo te sientas. </p> <p>As\u00ed que antes de empezar debes elegir bien con que tecnolog\u00edas vas a comenzar de las que tengo disponibles. Puedes volver a este tutorial m\u00e1s adelante por si he ido a\u00f1adiendo nuevas tecnolog\u00edas. </p> <p>Elige UNA tecnolog\u00eda de backend y UNA tecnolog\u00eda de frontend y completa el tutorial con esas dos tecnolog\u00edas. No mezcles ni hagas todas las tecnolog\u00edas a la vez ya que si no, te vas a volver loco.</p>"},{"location":"#hay-pre-requisitos","title":"\u00bfHay pre-requisitos?","text":"<p>No es obligado tener ning\u00fan conocimiento previo, pero es altamente recomendable que al menos conozcas lo b\u00e1sico de las tecnolog\u00edas que vamos a ver en el tutorial. Si no tienes ni idea, ni has oido hablar de las tecnolog\u00edas que has seleccionado para el tutorial, te sugiero que visites los itinerarios formativos y realices los cursos de nivel <code>Esencial</code>. De momento tenemos estos itinerarios:</p> <ul> <li>\ud83d\udd35 Frontend - Angular</li> <li>\ud83d\udd35 Frontend - React</li> <li>\ud83d\udd35 Frontend - Vue</li> <li>\ud83d\udfe2 Backend - SpringBoot</li> <li>\ud83d\udfe2 Backend - Nodejs</li> </ul> <p>Una vez hayas hecho los cursos esenciales, ya puedes volver y continuar con este tutorial. Repito que no es obligado, si ya tienes conocimientos previos de las tecnolog\u00edas no es necesario que hagas los cursos. Cuando termines el tutorial, ya puedes realizar el resto de cursos de otros niveles.</p>"},{"location":"#y-luego-que","title":"\u00bfY luego qu\u00e9?","text":"<p>Pues al final del tutorial, expondremos unos ejercicios pr\u00e1cticos para que los resuelvas tu mismo, aplicando los conocimientos adquiridos en el tutorial. Para ver si has comprendido correctamente todo lo aqu\u00ed descrito.</p> <p>No te preocupes, no es un examen </p>"},{"location":"#recomendaciones","title":"Recomendaciones","text":"<p>Te recomiendo que leas todo el tutorial, que no te saltes ning\u00fan punto y si se hace referencia a los anexos, que los visites y los leas tambi\u00e9n. Si tan solo copias y pegas, no ser\u00e1s capaz de hacer el \u00faltimo ejercicio por ti mismo. Debes leer y comprender lo que se est\u00e1 haciendo.</p> <p>Adem\u00e1s, los anexos est\u00e1n ah\u00ed por algo, sirven para completar informaci\u00f3n y para que conozcas los motivos por los que estamos programando as\u00ed el tutorial. Por favor, \u00e9chales un ojo tambi\u00e9n cuando te lo indique.</p>"},{"location":"#por-ultimo-no-te-olvides","title":"Por \u00faltimo, \u00a1no te olvides!","text":"<p>Cuando lo tengas todo listo, por favor no te olvides de subir los proyectos a alg\u00fan repositorio Github propio y av\u00edsanos para que podamos echarle un ojo y darte sugerencias y feedback .</p>"},{"location":"exercise/","title":"Ahora hazlo tu!","text":"<p>Ahora vamos a ver si has comprendido bien el tutorial. Voy a poner dos ejercicios uno m\u00e1s sencillo que el otro para ver si eres capaz de llevarlos a cabo. \u00a1Vamos alla, mucha suerte!</p> <p>Nuestro amigo Ernesto Esvida ya tiene disponible su web para gestionar su cat\u00e1logo de juegos, autores y categor\u00edas, pero todav\u00eda le falta un poco m\u00e1s para poder hacer buen uso de su ludoteca. As\u00ed que nos ha pedido dos funcionalidades extra.</p>"},{"location":"exercise/#gestion-de-clientes","title":"Gesti\u00f3n de clientes","text":""},{"location":"exercise/#requisitos","title":"Requisitos","text":"<p>Por un lado necesita poder tener una base de datos de sus clientes. Para ello nos ha pedido que si podemos crearle una pantalla de CRUD sencilla, al igual que hicimos con las categor\u00edas donde \u00e9l pueda dar de alta a sus clientes.</p> <p>Nos ha pasado un esquema muy sencillo de lo que quiere, tan solo quiere guardar un listado de los nombres de sus clientes para tenerlos fichados, y nos ha hecho un par de pantallas sencillas muy similares a Categor\u00edas.</p> <p></p> <p></p> <p>Un listado sin filtros de ning\u00fan tipo ni paginaci\u00f3n.</p> <p>Un formulario de edici\u00f3n / alta, cuyo \u00fanico dato editable sea el nombre. Adem\u00e1s, la \u00fanica restricci\u00f3n que nos ha pedido es que NO podamos dar de alta a un cliente con el mismo nombre que otro existente. As\u00ed que deberemos comprobar el nombre, antes de guardar el cliente.</p>"},{"location":"exercise/#consejos","title":"Consejos","text":"<p>Para empezar te dar\u00e9 unos consejos:</p> <ul> <li>Recuerda crear la tabla de la BBDD y sus datos</li> <li>Intenta primero hacer el listado completo, en el orden que m\u00e1s te guste: frontend o backend.</li> <li>Completa el listado conectando ambas capas.</li> <li>Termina el caso de uso haciendo las funcionalidades de edici\u00f3n, nuevo y borrado. Presta atenci\u00f3n a la validaci\u00f3n a la hora de guardar un cliente, NO se puede guardar si el nombre ya existe.</li> </ul>"},{"location":"exercise/#gestion-de-prestamos","title":"Gesti\u00f3n de pr\u00e9stamos","text":""},{"location":"exercise/#requisitos_1","title":"Requisitos","text":"<p>Por otro lado, quiere hacer uso de su cat\u00e1logo de juegos y de sus clientes, y quiere saber que juegos ha prestado a cada cliente. Para ello nos ha pedido una p\u00e1gina bastante compleja donde se podr\u00e1 consultar diferente informaci\u00f3n y se permitir\u00e1 realizar el pr\u00e9stamo de los juegos.</p> <p>Nos ha pasado el siguiente boceto y requisitos:</p> <p></p> <p>La pantalla tendr\u00e1 dos zonas:</p> <ul> <li>Una zona de filtrado donde se permitir\u00e1 filtrar por:<ul> <li>T\u00edtulo del juego, que deber\u00e1 ser un combo seleccionable con los juegos del cat\u00e1logo de la Ludoteca.</li> <li>Cliente, que deber\u00e1 ser un combo seleccionable con los clientes dados de alta en la aplicaci\u00f3n.</li> <li>Fecha, que deber\u00e1 ser de tipo Datepicker y que permitir\u00e1 elegir una fecha de b\u00fasqueda. Al elegir un d\u00eda nos deber\u00e1 mostrar que juegos est\u00e1n prestados para dicho d\u00eda. OJO que los pr\u00e9stamos son con fecha de inicio y de fin, si elijo un d\u00eda intermedio deber\u00eda aparecer el elemento en la tabla.</li> </ul> </li> <li>Una zona de listado paginado que deber\u00e1 mostrar<ul> <li>El identificador del pr\u00e9stamo</li> <li>El nombre del juego prestado</li> <li>El nombre del cliente que lo solicit\u00f3</li> <li>La fecha de inicio del pr\u00e9stamo</li> <li>La fecha de fin del pr\u00e9stamo</li> <li>Un bot\u00f3n que permite eliminar el pr\u00e9stamo</li> </ul> </li> </ul> <p></p> <p>Al pulsar el bot\u00f3n de <code>Nuevo pr\u00e9stamo</code> se abrir\u00e1 una pantalla donde se podr\u00e1 ingresar la siguiente informaci\u00f3n, toda ella obligatoria:</p> <ul> <li>Identificador, inicialmente vac\u00edo y en modo lectura</li> <li>Nombre del cliente, mediante un combo seleccionable</li> <li>Nombre del juego, mediante un combo seleccionable</li> <li>Fechas del pr\u00e9stamo, donde se podr\u00e1 introducir dos fechas, de inicio y fin del pr\u00e9stamo.</li> </ul> <p>Las validaciones son sencillas aunque laboriosas:</p> <ul> <li>La fecha de fin NO podr\u00e1 ser anterior a la fecha de inicio</li> <li>El periodo de pr\u00e9stamo m\u00e1ximo solo podr\u00e1 ser de 14 d\u00edas. Si el usuario quiere un pr\u00e9stamo para m\u00e1s de 14 d\u00edas la aplicaci\u00f3n no debe permitirlo mostrando una alerta al intentar guardar.</li> <li>El mismo juego no puede estar prestado a dos clientes distintos en un mismo d\u00eda. OJO que los pr\u00e9stamos tienen fecha de inicio y fecha fin, el juego no puede estar prestado a m\u00e1s de un cliente para ninguno de los d\u00edas que contemplan las fechas actuales del rango.</li> <li>Un mismo cliente no puede tener prestados m\u00e1s de 2 juegos en un mismo d\u00eda. OJO que los pr\u00e9stamos tienen fecha de inicio y fecha fin, el cliente no puede tener m\u00e1s de dos pr\u00e9stamos para ninguno de los d\u00edas que contemplan las fechas actuales del rango.</li> </ul>"},{"location":"exercise/#consejos_1","title":"Consejos","text":"<p>Para empezar te dar\u00e9 unos consejos:</p> <ul> <li>Recuerda crear la tabla de la BBDD y sus datos</li> <li>Intenta primero hacer el listado paginado sin filtros, en el orden que m\u00e1s te guste: frontend o backend. Recuerda que se trata de un listado paginado, as\u00ed que deber\u00e1s utilizar el obtejo <code>Page</code>.</li> <li>Completa el listado conectando ambas capas.</li> <li>Ahora implementa los filtros, presta atenci\u00f3n al filtro de fecha, es el m\u00e1s complejo.</li> <li>Para la paginaci\u00f3n filtrada solo tienes que mezclar los conceptos que hemos visto en los puntos del tutorial anteriores. <ul> <li>Si hiciste el backend en Springboot recuerda revisar Baeldung por si tienes dudas sobre las queries y recuerda que las <code>Specifications</code> son muy \u00fatiles, pero en este caso deber\u00e1s implementar otro tipo de operaciones, no te sirve solo con la operaci\u00f3n de igualdad <code>:</code>, que ya vimos en el tutorial.</li> </ul> </li> <li>Implementa la pantalla de alta de pr\u00e9stamo, sin ninguna validaci\u00f3n.</li> <li>Cuando ya te funcione, intenta ir a\u00f1adiendo una a una las validaciones. Algunas de ellas pueden hacerse en frontend, mientras que otras deber\u00e1n validarse en backend</li> </ul>"},{"location":"exercise/#ya-has-terminado","title":"\u00bfYa has terminado?","text":"<p>Si has llegado a este punto es porque ya tienes terminado el tutorial. Por favor no te olvides de subir los proyectos a alg\u00fan repositorio Github propio (puedes revisar el anexo Tutorial b\u00e1sico de Git) y av\u00edsarnos para que podamos echarle un ojo y darte sugerencias y feedback .</p>"},{"location":"thanks/","title":"Agradecimientos!","text":"<p>Antes de empezar quer\u00edamos dar las gracias a todos los que hab\u00e9is participado de manera directa o indirecta en la elaboraci\u00f3n de este tutorial, y a todos aquellos que lo hab\u00e9is sufrido haciendolo. </p> <p>De verdad</p> <pre><code>                                G R A C I A S\n</code></pre>"},{"location":"thanks/#colaboradores","title":"Colaboradores","text":"<p>Menci\u00f3n especial a las personas que han participado en el tutorial ya sea como testers, como promotores o como desarrolladores, por orden temporal de colaboraci\u00f3n:</p> <ul> <li>Felipe Garcia (@fgarciafer)</li> <li>Armen Mirzoyan (@armirzoya)</li> <li>Carlos Aguilar (@caaguila)</li> <li>Jhonatan Core (@corevill)</li> <li>Carlos Navarro (@DarkWarlord)</li> <li>Cesar Cardona (@Cazs03)</li> <li>Marina Valls (@mvalemany)</li> <li>Jaume Segarra (@jaumesegarra)</li> <li>Laura Medina (@larulirea)</li> <li>Yolanda Ubeda</li> <li>Pablo Jimenez (@pajimene)</li> </ul>"},{"location":"usecases/","title":"Contexto de la aplicaci\u00f3n","text":""},{"location":"usecases/#introduccion","title":"Introducci\u00f3n","text":"<p>Nuestro amigo Ernesto Esvida es muy aficionado a los juegos de mesa y desde muy peque\u00f1o ha ido coleccionando muchos juegos. Hasta tal punto que ha decidido regentar una Ludoteca.</p> <p>Como la colecci\u00f3n de juegos era suya personal, toda la informaci\u00f3n del cat\u00e1logo de juegos la ten\u00eda perfectamente clasificado en fichas de cart\u00f3n. Pero ahora que va abrir su propio negocio, necesita digitalizar esa informaci\u00f3n y hacerla m\u00e1s accesible.</p> <p>Como es un buen amigo de la infancia, hemos decidido ayudar a Ernesto y colaborar haciendo una peque\u00f1a aplicaci\u00f3n web que le sirva de cat\u00e1logo de juegos. Es m\u00e1s o menos el mismo sistema que estaba utilizando, pero esta vez en digital.</p> <p>Por cierto, la Ludoteca al final se va a llamar Ludoteca T\u00e1n.</p> <p>Info</p> <p>Las im\u00e1genes que aparecen a continuaci\u00f3n son mockups o dise\u00f1os de alambre de las pantallas que vamos a desarrollar durante el tutorial. No quiere decir que el estilo final de las pantallas deba ser as\u00ed, ni mucho menos. Es simplemente una forma sencilla de ejemplificar como debe quedar m\u00e1s o menos una pantalla.</p>"},{"location":"usecases/#estructura-de-un-proyecto-web","title":"Estructura de un proyecto Web","text":"<p>En todas las aplicaciones web modernas y los proyectos en los que trabajamos se pueden diferenciar, de forma general, tres grandes bloques funcionales, como se muestra en la imagen inferior.</p> <p></p> <p>El funcionamiento es muy sencillo y difiere de las aplicaciones instalables que se ejecuta todo en una misma m\u00e1quina o servidor.</p> <ul> <li>Con esta estructura, el usuario accede a la aplicaci\u00f3n mediante un navegador web instalado en su m\u00e1quina local.</li> <li>Este navegador solicita informaci\u00f3n mediante una URL a un servidor de recursos est\u00e1ticos. Esto es lo que denominaremos un servidor frontend. Para programar servidores frontend se pueden usar muchas tecnolog\u00edas, en este tutorial lo desarrollaremos en Angular o en React. Este c\u00f3digo frontend se descarga y se ejecuta dentro del navegador, y contiene la representaci\u00f3n visual de las pantallas y ciertos comportamientos y navegaci\u00f3n entre componentes. Sin embargo, por lo general, no tiene datos ni ejecuta l\u00f3gica de negocio.</li> <li>Para estas labores de obtener datos o ejecutar l\u00f3gica de negocio, el c\u00f3digo frontend necesita invocar endpoints de la segunda capa, el backend. Al igual que antes, el backend, puede estar desarrollado en muchas tecnolog\u00edas, en este tutorial se puede elegir entre Java-Springboot o Nodejs. Lo importante de esta capa es que es necesario exponer unos endpoints que sean invocados por la capa de frontend. T\u00edpicamente estos endpoints son operaciones API Rest que veremos m\u00e1s adelante.</li> <li>Por \u00faltimo, el servidor backend / capa backend, necesitar\u00e1 leer y guardar datos de alg\u00fan sitio. Esto se hace utilizando la tercera capa, la capa de datos. Normalmente esta capa de datos ser\u00e1 una BBDD instalada en alg\u00fan servidor externo, aunque a veces como es el caso del tutorial de Springboot, podemos embeber el servidor en memoria de backend. Pero por norma general, esta capa es externa.</li> </ul> <p>As\u00ed pues el flujo normal de una aplicaci\u00f3n ser\u00eda el siguiente:</p> <ul> <li>El usuario abre el navegador y solicita una web mediante una URL</li> <li>El servidor frontend, le sirve los recursos (p\u00e1ginas web, javascript, im\u00e1genes, ...) y se cargan en el navegador</li> <li>El navegador renderiza las p\u00e1ginas web, ejecuta los procesos javascript y realiza las navegaciones</li> <li>Si en alg\u00fan momento se requiere invocar una operaci\u00f3n, el navegador lanzar\u00e1 una petici\u00f3n contra una URL del backend</li> <li>El backend estar\u00e1 escuchando las peticiones y las ejecutar\u00e1 en el momento que le invoquen devulviendo un resultado al navegador</li> <li>Si hiciera falta leer o guardar datos, el backend lo realizar\u00e1 lanzando consultas SQL contra la BBDD</li> </ul> <p>Dicho esto, por lo general necesitaremos un m\u00ednimo de dos proyectos para desarrollar una aplicaci\u00f3n: </p> <ul> <li> <p>Por un lado tendremos un proyecto Frontend que se ejecutar\u00e1 en un servidor web de ficheros est\u00e1ticos, tipo Apache. Este proyecto ser\u00e1 c\u00f3digo javascript, css y html, que se renderizar\u00e1 en el navegador Web y que realizar\u00e1 ciertas operaciones sencillas y validaciones en local y llamadas a nuestro servidor backend para ejecutar las operaciones de negocio.</p> </li> <li> <p>Por otro lado tendremos un proyecto Backend que se ejecutar\u00e1 en un servidor de aplicaciones, tipo Tomcat o Node. Este proyecto tendr\u00e1 la l\u00f3gica de negocio de las operaciones, el acceso a los datos de la BBDD y cualquier integraci\u00f3n con servicios de terceros. La forma de exponer estas operaciones de negocio ser\u00e1 mediante endpoints de acceso, en concreto llamadas tipo REST.</p> </li> </ul> <p>Pueden haber otros tipos de proyectos dentro de la aplicaci\u00f3n, sobretodo si est\u00e1n basados en microservicios o tienen componentes batch, pero estos proyectos no vamos a verlos en el tutorial.</p> <p>A partir de ahora, para que sea m\u00e1s sencillo acceder al tutorial, diferenciaremos las tecnolog\u00edas en el men\u00fa mediante los siguientes colores:</p> <ul> <li>\ud83d\udd35 Frontend</li> <li>\ud83d\udfe2 Backend</li> </ul> <p>Consejo</p> <p>Como norma cada uno de los proyectos que componen la aplicaci\u00f3n, deber\u00eda estar conectado a un repositorio de c\u00f3digo diferente para poder evolucionar y trabajar con cada uno de ellos de forma aislada sin afectar a los dem\u00e1s. As\u00ed adem\u00e1s podemos tener equipos aislados que trabajen con cada uno de los proyectos por separado.</p> <p>Info</p> <p>Durante todo el tutorial, voy a intentar separar la construcci\u00f3n del proyecto Frontend de la construcci\u00f3n del proyecto Backend. Elige una tecnolog\u00eda para cada una de las capas y utiliza siempre la misma en todos los apartados del tutorial.</p>"},{"location":"usecases/#diseno-de-bd","title":"Dise\u00f1o de BD","text":"<p>Para el proyecto que vamos a crear vamos a modelizar y gestionar 3 entidades: <code>CATEGORY</code>, <code>AUTHOR</code> y <code>GAME</code>.</p> <p>La entidad <code>CATEGORY</code> estar\u00e1 compuesta por los siguientes campos:</p> <ul> <li>id (lo mismo que en <code>GAME</code>)</li> <li>name</li> </ul> <p>La entidad <code>AUTHOR</code> estar\u00e1 compuesta por los siguientes campos:</p> <ul> <li>id (lo mismo que en <code>GAME</code>)</li> <li>name</li> <li>nationality</li> </ul> <p>Para la entidad <code>GAME</code>, Ernesto nos ha comentado que la informaci\u00f3n que est\u00e1 guardando en sus fichas es la siguiente:</p> <ul> <li>id (este dato no estaba originalmente en las fichas pero nos ser\u00e1 muy util para indexar y realizar b\u00fasquedas)</li> <li>title</li> <li>age</li> <li>category</li> <li>author</li> </ul> <p>Comenzaremos con un caso b\u00e1sico que cumpla las siguientes premisas: un juego pertenece a una categor\u00eda y ha sido creado por un \u00fanico autor. </p> <p>Modelando este contexto quedar\u00eda algo similar a esto:</p> <p></p>"},{"location":"usecases/#diseno-de-pantallas","title":"Dise\u00f1o de pantallas","text":"<p>Deber\u00edamos construir tres pantallas de mantenimiento CRUD (Create, Read, Update, Delete) y una pantalla de Login general para activar las acciones de administrador. M\u00e1s o menos las pantallas deber\u00edan quedar as\u00ed:</p>"},{"location":"usecases/#listado-de-categorias","title":"Listado de categor\u00edas","text":""},{"location":"usecases/#edicion-de-categoria","title":"Edici\u00f3n de categor\u00eda","text":""},{"location":"usecases/#listado-de-autores","title":"Listado de autores","text":""},{"location":"usecases/#edicion-de-autor","title":"Edici\u00f3n de autor","text":""},{"location":"usecases/#listado-de-juegos","title":"Listado de juegos","text":""},{"location":"usecases/#edicion-de-juego","title":"Edici\u00f3n de juego","text":""},{"location":"usecases/#diseno-funcional","title":"Dise\u00f1o funcional","text":"<p>Por \u00faltimo vamos a definir un poco la funcionalidad b\u00e1sica que Ernesto necesita para iniciar su negocio.</p>"},{"location":"usecases/#aspectos-generales","title":"Aspectos generales","text":"<ul> <li>El sistema tan solo tendr\u00e1 dos roles:   ** <code>usuario b\u00e1sico</code> es el usuario an\u00f3nimo que accede a la web sin registrar. Solo tiene permisos para mostrar listados   ** <code>usuario administrador</code> es el usuario que se registra en la aplicaci\u00f3n. Puede realizar las operaciones de alta, edici\u00f3n y borrado</li> </ul> <p>Por defecto cuando entras en la aplicaci\u00f3n tendr\u00e1s los privilegios de un <code>usuario b\u00e1sico</code> hasta que el usuario haga un login correcto con el usuario / password <code>admin</code> / <code>admin</code>. En ese momento pasara a ser un <code>usuario administrador</code> y podr\u00e1 realizar operaciones de alta, baja y modificaci\u00f3n.</p> <p>La estructura general de la aplicaci\u00f3n ser\u00e1:</p> <ul> <li>Una cabecer\u00e1 superior que contendr\u00e1:</li> <li>el logo y el nombre de la tienda</li> <li>un enlace a cada uno de los CRUD del sistema</li> <li>un bot\u00f3n de <code>Sign in</code></li> <li>Zona de trabajo, donde cargaremos las pantallas que el usuario vaya abriendo</li> </ul> <p>Al pulsar sobre la funcionalidad de <code>Sign in</code> aparecer\u00e1 una ventana modal que preguntar\u00e1 usuario y password. Esto realizar\u00e1 una llamada al backend, donde se validar\u00e1 si el usuario es correcto. </p> <ul> <li>En caso de ser correcto, devolver\u00e1 un token jwt de acceso, que el cliente web deber\u00e1 guardar en <code>sessionStorage</code> para futuras peticiones</li> <li>En caso de no ser correcto, devolver\u00e1 un error de Usuario y/o password incorrectos</li> </ul> <p>Todas las operaciones del backend que permitan crear, modificar o borrar datos, deber\u00e1n estar securizadas para que no puedan ser accedidas sin haberse autenticado previamente.</p>"},{"location":"usecases/#crud-de-categorias","title":"CRUD de Categor\u00edas","text":"<p>Al acceder a esta pantalla se mostrar\u00e1 un listado de las categor\u00edas que tenemos en la BD. La tabla no tiene filtros, puesto que tiene muy pocos registros. Tampoco estar\u00e1 paginada.</p> <p>En la tabla debe aparecer:</p> <ul> <li>identificador de la categor\u00eda</li> <li>nombre de la categor\u00eda</li> <li>bot\u00f3n de editar (solo en el caso de que el usuario tenga permisos)</li> <li>bot\u00f3n de borrar (solo en el caso de que el usuario tenga permisos)</li> </ul> <p>Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevas categor\u00edas (solo en el caso de que el usuario tenga permisos).</p> <p>Crear</p> <p>Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con dos inputs:</p> <ul> <li>Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de <code>Identificador</code></li> <li>Nombre. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de <code>Nombre</code></li> </ul> <p>Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD.</p> <p>Editar</p> <p>Al pulsar el icono de editar se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de <code>Crear</code> pero con los dos campos rellenados con los datos de BD.</p> <p>Borrar</p> <p>Si el usuario pulsa el bot\u00f3n de borrar, se deber\u00e1 comprobar si esa categor\u00eda tiene alg\u00fan <code>Juego</code> asociado. En caso de tenerlo se le informar\u00e1 al usuario de que dicha categor\u00eda no se puede eliminar por tener asociado un juego. En caso de no estar asociada, se le preguntar\u00e1 al usuario mediante un mensaje de confirmaci\u00f3n si desea eliminar la categor\u00eda. Solo en caso de que la respuesta sea afirmativa, se lanzar\u00e1 el borrado f\u00edsico de la categor\u00eda en BD.</p>"},{"location":"usecases/#crud-de-autores","title":"CRUD de Autores","text":"<p>Al acceder a esta pantalla se mostrar\u00e1 un listado de los autores que tenemos en la BD. La tabla no tiene filtros pero deber\u00e1 estar paginada en servidor.</p> <p>En la tabla debe aparecer:</p> <ul> <li>identificador del autor</li> <li>nombre del autor</li> <li>nacionalidad del autor</li> <li>bot\u00f3n de editar (solo en el caso de que el usuario tenga permisos)</li> <li>bot\u00f3n de borrar (solo en el caso de que el usuario tenga permisos)</li> </ul> <p>Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevos autores (solo en el caso de que el usuario tenga permisos).</p> <p>Crear</p> <p>Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con tres inputs:</p> <ul> <li>Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de <code>Identificador</code></li> <li>Nombre. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de <code>Nombre</code></li> <li>Nacionalidad. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de <code>Nacionalidad</code></li> </ul> <p>Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. </p> <p>Editar</p> <p>Al pulsar el icono de editar se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de <code>Crear</code> pero con los tres campos rellenados con los datos de BD.</p> <p>Borrar</p> <p>Si el usuario pulsa el bot\u00f3n de borrar, se deber\u00e1 comprobar si ese autor tiene alg\u00fan <code>Juego</code> asociado. En caso de tenerlo se le informar\u00e1 al usuario de que dicho autor no se puede eliminar por tener asociado un juego. En caso de no estar asociado, se le preguntar\u00e1 al usuario mediante un mensaje de confirmaci\u00f3n si desea eliminar el autor. Solo en caso de que la respuesta sea afirmativa, se lanzar\u00e1 el borrado f\u00edsico de la categor\u00eda en BD.</p>"},{"location":"usecases/#crud-de-juegos","title":"CRUD de Juegos","text":"<p>Al acceder a esta pantalla se mostrar\u00e1 un listado de los juegos disponibles en el cat\u00e1logo de la BD. Esta tabla debe contener filtros en la parte superior, pero no debe estar paginada.</p> <p>Se debe poder filtrar por:</p> <ul> <li>nombre del juego. Donde el usuario podr\u00e1 poner cualquier texto y el filtrado ser\u00e1 todos aquellos juegos que <code>contengan</code> el texto buscado</li> <li>categor\u00eda del juego. Donde aparecer\u00e1 un desplegable que el usuario seleccionar de entre todas las categor\u00edas de juego que existan en la BD.</li> </ul> <p>Dos botones permitir\u00e1n realizar el filtrado de juegos (lanzando una nueva consulta a BD) o limpiar los filtros seleccionados (lanzando una consulta con los filtros vac\u00edos).</p> <p>En la tabla debe aparecer a modo de fichas. No hace falta que sea exactamente igual a la maqueta, no es un requisito determinar un ancho general de ficha por lo que pueden caber 2,3 o x fichas en una misma fila, depender\u00e1 del programador. Pero todas las fichas deben tener el mismo ancho:</p> <ul> <li>Un espacio destinado a una foto (de momento no pondremos nada en ese espacio)</li> <li>Una columna con la siguiente informaci\u00f3n:<ul> <li>T\u00edtulo del juego, resaltado de alguna forma</li> <li>Edad recomendada</li> <li>Categor\u00eda del juego, mostraremos su nombre</li> <li>Autor del juego, mostraremos su nombre</li> <li>Nacionalidad del juego, mostraremos la nacionalidad del autor del juego</li> </ul> </li> </ul> <p>Los juegos no se pueden eliminar, pero si se puede editar si el usuario pulsa en alguna de las fichas (solo en el caso de que el usuario tenga permisos).</p> <p>Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevos juegos (solo en el caso de que el usuario tenga permisos).</p> <p>Crear</p> <p>Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con cinco inputs:</p> <ul> <li>Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de <code>Identificador</code></li> <li>T\u00edtulo. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de <code>T\u00edtulo</code></li> <li>Edad. Este input es obligatorio, es de tipo num\u00e9rico de 0 a 99, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de <code>Edad</code></li> <li>Categor\u00eda. Este input es obligatorio, ser\u00e1 un campo seleccionable donde aparecer\u00e1n todas las categor\u00edas de la BD, aparecer\u00e1 vac\u00edo por defecto. Con el placeholder de <code>Categor\u00eda</code></li> <li>Autor. Este input es obligatorio, ser\u00e1 un campo seleccionable donde aparecer\u00e1n todos los autores de la BD, aparecer\u00e1 vac\u00edo por defecto. Con el placeholder de <code>Autor</code></li> </ul> <p>Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. </p> <p>Editar</p> <p>Al pulsar en una de las fichas con un click simple, se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de <code>Crear</code> pero con los cinco campos rellenados con los datos de BD.</p>"},{"location":"appendix/git/","title":"Tutorial b\u00e1sico de Git","text":"<p>Cada vez se tiende m\u00e1s a utilizar repositorios de c\u00f3digo Git y, aunque no sea objeto de este tutorial Springboot-Angular, queremos hacer un resumen muy b\u00e1sico y sencillo de como utilizar Git.</p> <p>En el mercado existen multitud de herramientas para gestionar repositorios Git, podemos utilizar cualquiera de ellas, aunque desde devonfw se recomienda utilizar Git SCM. Adem\u00e1s, existen tambi\u00e9n multitud de servidores de c\u00f3digo que implementan repositorios Git, como podr\u00edan ser GitHub, GitLab, Bitbucket, etc. Todos ellos trabajan de la misma forma, as\u00ed que este resumen servir\u00e1 para todos ellos.</p> <p>Info</p> <p>Este anexo muestra un resumen muy sencillo y b\u00e1sico de los comandos m\u00e1s comunes que se utilizan en Git. Para ver detalles m\u00e1s avanzados o un tutorial completo te recomiendo que leas la guia de Atlassian.</p>"},{"location":"appendix/git/#funcionamiento-basico","title":"Funcionamiento b\u00e1sico","text":"<p>Existen dos conceptos en Git que debes tener muy claros: las ramas y los repositorios. Vamos a ver como funciona cada uno de ellos.</p>"},{"location":"appendix/git/#ramas","title":"Ramas","text":"<p>Por un lado tenemos las <code>ramas</code> de Git. El repositorio puede tener tantas ramas como se quiera, pero por lo general debe existir una rama maestra a menudo llamada develop o master, y luego muchas ramas con cada una de las funcionalidades desarrolladas.</p> <p></p> <p>Las ramas siempre se deben crear a partir de una rama (en el ejemplo llamaremos develop), con una foto concreta y determinada de esa rama. Esta rama deber\u00e1 tener un nombre que describa lo que va a contener esa rama (en el ejemplo feature/xxx). Y por lo general, esa rama se <code>mergear\u00e1</code> con otra rama del repositorio, que puede ser la rama de origen o cualquier otra (en el ejemplo ser\u00e1 con la rama origen develop).</p> <p>As\u00ed pues, podemos tener algo as\u00ed:</p> <p></p> <p>Las acciones de crear ramas y mergear ramas est\u00e1n explicadas m\u00e1s abajo. En este punto solo es necesario que seas conocedor de:</p> <ul> <li>existen ramas maestras --&gt; que contienen el c\u00f3digo completo de la aplicaci\u00f3n</li> <li>existen ramas de desarrollo --&gt; que generalmente se crean de una rama maestra en un punto temporal concreto</li> <li>en alg\u00fan momento esas ramas de desarrollo se deben mergear en una rama maestra</li> <li>ojo cuidado, cuando hay varias personas en el equipo trabajando, habr\u00e1n varias ramas de desarrollo que nazcan de diferentes puntos temporales y que habr\u00e1 que tener en cuenta para posibles conflictos. Recuerda que no est\u00e1s solo programando, hay m\u00e1s gente modificando el c\u00f3digo.</li> </ul>"},{"location":"appendix/git/#repositorios","title":"Repositorios","text":"<p>El otro concepto que debe queda claro, es el de repositorios. Por defecto, en Git, se trabaja con el repositorio local, en el que puedes crear ramas, modificar c\u00f3digo, mergear, etc. pero todos esos cambios que se hagan, ser\u00e1n todos en local, nadie m\u00e1s tendr\u00e1 acceso.</p> <p>Tambi\u00e9n existe el repositorio remoto, tambi\u00e9n llamado <code>origin</code>. Este repositorio es el que todos los integrantes del equipo utilizan como referencia. Existen acciones de Git que permite sincronizar los repositorios.</p> <p></p> <p>En este punto solo es necesario que seas conocedor de:</p> <ul> <li>Los cambios que realices en local (en tu repositorio local) solo ser\u00e1n visibles por ti. Puedes crear ramas y borrarlas, pero solo tu las ver\u00e1s.</li> <li>Los cambios que se suban al repositorio remoto ser\u00e1n visibles para todos. Pueden haber ramas protegidas para que no se puedan modificar desde el equipo, t\u00edpicamente las ramas maestras. Estas ramas solo pueden modificarse previa validaci\u00f3n y <code>pull request</code> o <code>merge request</code> (depende de la aplicaci\u00f3n usada para Git).</li> <li>Existen acciones que permiten subir tus cambios de local a remoto. Recuerda que pueden existir ramas protegidas.</li> <li>Existen acciones que permiten actualizar tus ramas locales con los cambios remotos.</li> <li>Recuerda que no trabajas solo, es posible que tu repositorio local no est\u00e9 sincronizado, tus compa\u00f1eros han podido subir c\u00f3digo y deber\u00edas sincronizarte frecuentemente.</li> </ul>"},{"location":"appendix/git/#acciones-mas-tipicas","title":"Acciones m\u00e1s t\u00edpicas","text":"<p>En la Gu\u00eda r\u00e1pida puedes ver m\u00e1s detalle de estas acciones pero por lo general:</p> <ul> <li>Lo primero es descargarse una copia del repositorio con todas sus ramas. Se descargar\u00eda de remoto a local. A partir de este momento se trabaja en local.</li> <li>Cada nueva funcionalidad deber\u00eda tener su rama asociada, por tanto, lo l\u00f3gico es crear una rama de desarrollo (t\u00edpicamente feature/xxx) a partir de una rama maestra (t\u00edpicamente develop o master).</li> <li>Se trabajar\u00eda de forma local con esa rama. Es buena pr\u00e1ctica que si llevas mucho tiempo con la rama creada, de vez en cuando, sincronices tu repositorio local con lo que exista en el repositorio remoto. Adem\u00e1s, como es posible que la rama maestra de la que part\u00eda haya cambiado, esos cambios deber\u00edas llevarlos tambi\u00e9n a tu rama en desarrollo. Con esto consigues que tu punto temporal sea m\u00e1s moderno y tengas menos conflictos. Recuerda que no est\u00e1s solo trabajando.</li> <li>Cuando lo tengas listo y antes de subir nada, deber\u00edas realizar una \u00faltima sincronizaci\u00f3n de remoto a local. Despu\u00e9s deber\u00edas hacer un merge de tus ramas locales de desarrollo con las ramas maestras locales de las que partieron, por los posibles cambios que alguien hubiera podido subir.</li> <li>Por \u00faltimo, una vez tengas todo actualizado, ya puedes subir el c\u00f3digo al repositorio remoto (tu rama de desarrollo), y solicitar un <code>pull request</code> o <code>merge request</code> contra la rama maestra que quieras modificar.</li> <li>Alguien, diferente a ti, debe revisar esa solicitud y aprobarla antes de que se realice todo el merge correcto en remoto. Y vuelta a empezar.</li> </ul>"},{"location":"appendix/git/#funcionamiento-avanzado","title":"Funcionamiento avanzado","text":"<p>A continuaci\u00f3n vamos a describir estos mismos conceptos y acciones que hemos visto, pero m\u00e1s en profundidad para que veas como trabaja internamente Git. No es necesario que leas este punto, aunque es recomendable.</p>"},{"location":"appendix/git/#estructuras-y-flujo-de-trabajo","title":"Estructuras y flujo de trabajo","text":"<p>Lo primero que debes conocer de Git es su funcionamiento b\u00e1sico de flujo de trabajo. Tu repositorio local est\u00e1 compuesto por tres \"estructuras\" que contienen los archivos y los cambios de los ficheros del repositorio. </p> <p></p> <ul> <li>Working directory - Contiene los archivos con los que est\u00e1s trabajando localmente.</li> <li>Staging Area - Es un \u00e1rea intermedia donde vamos a\u00f1adiendo ficheros para ir agrupando modificaciones.</li> <li>Local Repository - Es el repositorio local donde tendr\u00e9mos el registro de todos los commits que hemos realizado. Por defecto apunta a HEAD que es el \u00faltimo commit registrado.</li> </ul> <p>Existen operaciones que nos permiten a\u00f1adir o borrar ficheros dentro de cada una de las estructuras desde otra estructura.</p> <p></p> <p>As\u00ed pues, los comandos b\u00e1sicos dentro de nuestro repositorio local son los siguientes.</p>"},{"location":"appendix/git/#add-y-commmit","title":"add y commmit","text":"<p>Puedes registrar los cambios realizados en tu <code>working directory</code> y a\u00f1adirlos al <code>staging area</code> usando el comando</p> <p><pre><code>git add &lt;filename&gt;\n</code></pre>     o si quieres a\u00f1adir todos los ficheros modificados <pre><code>git add .\n</code></pre></p> <p>Este es el primer paso en el flujo de trabajo b\u00e1sico. Una vez tenemos los cambios registrados en el <code>staging area</code> podemos hacer un commit y persistirlos dentro del <code>local repository</code> mediante el comando</p> <pre><code>git commit -m \"&lt;Commit message&gt;\"\n</code></pre> <p>A partir de ese momento, los ficheros modificados y a\u00f1adidos al <code>local repository</code> se han persistido y se han a\u00f1adido a tu <code>HEAD</code>, aunque todav\u00eda siguen estando el local, no lo has enviado a ning\u00fan repositorio remoto.</p>"},{"location":"appendix/git/#reset","title":"reset","text":"<p>De la misma manera que se han a\u00f1adido ficheros a <code>staging area</code> o a <code>local repository</code>, podemos retirarlos de estas estructuras y volver a recuperar los ficheros que ten\u00edamos anteriormente en el <code>working directory</code>. Por ejemplo, si nos hemos equivocado al incluir ficheros en un commit o simplemente queremos deshacer los cambios que hemos realizado bastar\u00eda con lanzar el comando</p> <p><pre><code>git reset --hard\n</code></pre>     o si queremos volver a un commit concreto <pre><code>git reset &lt;COMMIT&gt;\n</code></pre></p>"},{"location":"appendix/git/#trabajo-con-ramas","title":"Trabajo con ramas","text":"<p>Para complicarlo todo un poco m\u00e1s, el trabajo con git siempre se realiza mediante ramas. Estas ramas nos sirven para desarrollar funcionalidades aisladas unas de otras y poder hacer mezclas de c\u00f3digo de unas ramas a otras. Las ramas m\u00e1s comunes dentro de git suelen ser:</p> <ul> <li>master Esta ser\u00e1 la rama que contenga el c\u00f3digo fuente que tenemos en <code>producci\u00f3n</code>.</li> <li>release Esta ser\u00e1 la rama que contenga el c\u00f3digo fuente de cada una de las entregas parciales, no tiene porqu\u00e9 coincidir con la rama <code>master</code>.</li> <li>develop Esta ser\u00e1 la rama que contenga el c\u00f3digo fuente estable que est\u00e1 actualmente en desarrollo.</li> <li>feature/xxxx Estas ser\u00e1nn la rama que contengan el c\u00f3digo fuente de desarrollo de cada una de las funcionalidades. Generalmente estas ramas las crea cada desarrollador, las mantiene en local, hasta que las sube a remoto para realizar un <code>merge</code> a la rama <code>develop</code>.</li> </ul> <p>Siempre que trabajes con ramas debes tener en cuenta que al empezar tu desarrollo debes partir de una versi\u00f3n actualizada de la rama <code>develop</code>, y al terminar tu desarrollo debes solicitar un <code>merge</code> contra <code>develop</code>, para que tu funcionalidad est\u00e9 incorporada en la rama de desarrollo.</p> <p></p>"},{"location":"appendix/git/#crear-ramas","title":"Crear ramas","text":"<p>Crear ramas en local es tan sencillo como ejecutar este comando:</p> <pre><code>git checkout -b &lt;NOMBRE_RAMA&gt;\n</code></pre> <p>Eso nos crear\u00e1 una rama con el nombre que le hayamos dicho y mover\u00e1 el <code>Working Directory</code> a dicha rama.</p>"},{"location":"appendix/git/#cambiar-de-rama","title":"Cambiar de rama","text":"<p>Para cambiar de una rama a otra en local tan solo debemos ejecutar el comando:</p> <pre><code>git checkout &lt;NOMBRE_RAMA&gt;\n</code></pre> <p>La rama debe existir, sino se quejar\u00e1 de que no encuentra la rama. Este comando nos mover\u00e1 el <code>Working Directory</code> a la rama que le hayamos indicado. Si tenemos cambios en el <code>Staging Area</code> que no hayan sido movidos al <code>Local Repository</code> NO nos permitir\u00e1 movernos a la rama ya que perder\u00edamos los cambios. Antes de poder movernos debemos <code>resetear</code> los cambios o bien <code>commitearlos</code>.</p>"},{"location":"appendix/git/#remote-repository","title":"Remote repository","text":"<p>Hasta aqu\u00ed es todo m\u00e1s o menos sencillo, trabajamos con nuestro repositorio local, creamos ramas, commiteamos o reseteamos cambios de c\u00f3digo, pero todo esto lo hacemos en local. Ahora necesitamos que esos cambios se distribuyan y puedan leerlos el resto de integrantes de nuestro equipo.</p> <p>Aqu\u00ed es donde entra en juego los repositorios remotos.</p> <p></p> <p>Aqu\u00ed debemos tener MUY en cuenta que el c\u00f3digo que vamos a publicar en remoto SOLO es posible publicarlo desde el <code>Local Repository</code>. Es decir que para poder subir c\u00f3digo a remote antes debemos a\u00f1adirlo a <code>Staging Area</code> y hacer un commit para persistirlo en el <code>Local Repository</code>.</p>"},{"location":"appendix/git/#clone","title":"clone","text":"<p>Antes de empezar a tocar c\u00f3digo del proyecto podemos crear un <code>Local Repository</code> vac\u00edo o bien bajarnos un proyecto que ya exista en un <code>Remote Repository</code>. Esta \u00faltima opci\u00f3n es la m\u00e1s normal.</p> <p>Para bajarnos un proyecto desde remoto tan solo hay que ejecutar el comando:</p> <pre><code>git clone &lt;REMOTE_URL&gt;\n</code></pre> <p>Esto te crear\u00e1 una carpeta con el nombre del proyecto y dentro se descargar\u00e1 la estructura completa del repositorio y te mover\u00e1 al <code>Working Directory</code> todo el c\u00f3digo de la rama por defecto para ese repositorio.</p>"},{"location":"appendix/git/#envio-de-cambios","title":"env\u00edo de cambios","text":"<p>El env\u00edo de datos a un <code>Remote Repository</code> tan solo es posible realizarlo desde <code>Local Repository</code> (por lo que antes deber\u00e1s commitear cambios all\u00ed), y se debe ejecutar el comando:</p> <pre><code>git push origin\n</code></pre>"},{"location":"appendix/git/#actualizar-y-fusionar","title":"actualizar y fusionar","text":"<p>En ocasiones (bastante habitual) ser\u00e1 necesario descargarse los cambios de un <code>Remote Repository</code> para poder trabajar con la \u00faltima versi\u00f3n. Para ello debemos ejecutar el comando:</p> <pre><code>git pull\n</code></pre> <p>El propio <code>git</code> realizar\u00e1 la fusi\u00f3n local del c\u00f3digo remoto con el c\u00f3digo de tu <code>Working Directory</code>. Pero en ocasiones, si se ha modificado el mismo fichero en remoto y en local, se puede producir un Conflicto. No pasa nada, tan solo tendr\u00e1s que abrir dicho fichero en conflicto y resolverlo manualmente dejando el c\u00f3digo mezclado correcto.</p> <p>Tambi\u00e9n es posible que el c\u00f3digo que queramos actualizar est\u00e9 en otra rama, si lo que necesitamos es fusionar el c\u00f3digo de otra rama con la rama actual, nos situaremos en la rama destino y ejecutaremos el comando:</p> <pre><code>git merge &lt;RAMA_ORIGEN&gt;\n</code></pre> <p>Esto har\u00e1 lo mismo que un pull en local y fusionar\u00e1 el c\u00f3digo de una rama en otra. Tambi\u00e9n es posible que se produzcan conflictos que deber\u00e1s resolver de forma manual.</p>"},{"location":"appendix/git/#merge-request","title":"Merge Request","text":"<p>Ya por \u00faltimo, como estamos trabajando con ramas, lo \u00fanico que hacemos es subir y bajar ramas, pero en alg\u00fan momento alguien debe fusionar el contenido de una rama en la rama <code>develop</code>, <code>release</code> o <code>master</code>, que son las ramas principales.</p> <p>Se podr\u00eda directamente usar el comando merge para eso, pero en la mayor\u00eda de los repositorios no esta permitido subir el c\u00f3digo de una rama principal, por lo que no podr\u00e1s hacer un merge y subirlo. Para eso existe otra opci\u00f3n que es la de <code>Merge Request</code>.</p> <p>Esta opci\u00f3n permite a un usuario solicitar que otro usuario verifique y valide que el c\u00f3digo de su rama es correcto y lo puede fusionar en <code>Remote Repository</code> con una rama principal. Al ser una operaci\u00f3n delicada, tan solo es posible ejecutarla a trav\u00e9s de la web del repositorio git. </p> <p></p> <p>Por lo general existir\u00e1 una opci\u00f3n / bot\u00f3n que permitir\u00e1 hacer un <code>Merge Request</code> con una rama origen y una rama destino (generalmente una de las principales). A esa petici\u00f3n se le asignar\u00e1 un validador y se enviar\u00e1. El usuario validador verificar\u00e1 si es correcto o no y validar\u00e1 o rechazar\u00e1 la petici\u00f3n. En caso de validarla se fusionar\u00e1 autom\u00e1ticamente en remoto y todos los usuarios podr\u00e1n descargar los nuevos cambios desde la rama.</p> <p>\u00a1Cuidado!</p> <p>Siempre antes de solicitar un <code>Merge Request</code> debes comprobar que tienes actualizada la rama comparandola con la rama remota que queremos mergear, en nuestro ejemplo ser\u00e1 <code>develop</code>. </p> <p>Para actualizarla tu rama hay que seguir tres pasos muy sencillos:</p> <ul> <li>Cambias a la rama <code>develop</code> y descargarnos los cambios del repositorio remoto (git pull)</li> <li>Cambias a tu rama y ejecutar un merge desde <code>develop</code> hacia nuestra rama (git merge develop)</li> <li>Subes tus cambios a remoto (git add, git commit y git push) y ya puedes solcitar el <code>Merge Request</code></li> </ul>"},{"location":"appendix/git/#guia-rapida","title":"Gu\u00eda r\u00e1pida","text":"<p>Los pasos b\u00e1sicos de utilizaci\u00f3n de git son sencillos.</p> <p></p> <ul> <li>Primero nos bajamos el repositorio o lo creamos en local mediante los comandos <pre><code>git clone\n    o \ngit init\n</code></pre></li> <li>Una vez estamos trabajando con nuestro repositorio local, cada vez que vayamos a comenzar una funcionalidad nueva, debemos crear una rama nueva siempre partiendo desde una rama maestra mediante el comando: (en nuestro ejemplo la rama maestra ser\u00e1 <code>develop</code>) <pre><code>git checkout -b &lt;rama&gt;\n</code></pre></li> <li>Cuando tengamos implementados los cambios que queremos realizar, hay que subirlos al staging y luego persistirlos en nuestro repositorio local. Esto lo hacemos con el comando <pre><code>git add .\ngit commit -m \"&lt;Commit message&gt;\"\n</code></pre></li> <li>Siempre antes de subir los cambios al repositorio remoto, hay que comprobar que tenemos actualizada nuestra rama comparandola con la rama remota que queremos mergear, en nuestro ejemplo ser\u00e1 <code>develop</code>. Por tanto tenemos que cambiar a la rama <code>develop</code>, descargarnos los cambios del repositorio remoto, volver a cambiar a nuestra rama y ejecutar un merge desde <code>develop</code> hacia nuestra rama, ejecutando estos comandos <pre><code>git checkout develop\ngit pull\ngit checkout &lt;rama&gt;\ngit merge develop\n</code></pre></li> <li>Ahora que ya tenemos actualizadas las ramas, tan solo nos basta subir nuestra rama a remoto, con el comando <pre><code>git push --set-upstream origin &lt;rama&gt;\n</code></pre></li> <li>Por \u00faltimo accedemos al cliente web del repositorio y solicitamos un <code>merge request</code> contra <code>develop</code>. Para que sea validado y aprobado por otro compa\u00f1ero del equipo.</li> <li>Si en alg\u00fan momento necesitamos modificar nuestro c\u00f3digo del <code>merge request</code> antes de que haya sido aprobado, nos basta con repetir los pasos anteriores <pre><code>git add .\ngit commit -m \"&lt;Commit message&gt;\"\ngit push origin\n</code></pre></li> <li>Una vez hayamos terminado el desarrollo y vayamos a empezar una nueva funcionalidad, volveremos al punto 2 de este listado y comenzaremos de nuevo los comando. Debemos recordad que tenemos que partir siempre de la rama <code>develop</code> y adem\u00e1s debe estar actualizada <code>git pull</code>.</li> </ul>"},{"location":"appendix/jpa/","title":"Funcionamiento Spring Data","text":"<p>Este anexo no pretende explicar el funcionamiento interno de Spring Data, simplemente conocer un poco como utilizarlo y algunos peque\u00f1os tips que pueden ser interesantes.</p>"},{"location":"appendix/jpa/#funcionamiento-basico","title":"Funcionamiento b\u00e1sico","text":"<p>Lo primero que deber\u00edas tener claro, es que hagas lo que hagas, al final todo termina lanzando una query nativa sobre la BBDD. Da igual que uses cualquier tipo de acelerador (luego veremos alguno), ya que al final Spring Data termina convirtiendo lo que hayas programado en una query nativa.</p> <p>Cuanta m\u00e1s informaci\u00f3n le proporciones a Spring Data, tendr\u00e1s m\u00e1s control sobre la query final, pero m\u00e1s dificil ser\u00e1 de mantener. Lo mejor es utilizar, siempre que se pueda, todos los automatismos y automagias posibles y dejar que Spring haga su faena. Habr\u00e1 ocasiones en que esto no nos sirva, en ese momento tendremos que decidir si queremos bajar el nivel de implementaci\u00f3n o queremos utilizar otra alternativa como procesos por streams.</p>"},{"location":"appendix/jpa/#derived-query-methods","title":"Derived Query Methods","text":"<p>Para la realizaci\u00f3n de consultas a la base de datos, Spring Data nos ofrece un sencillo mecanismo que consiste en crear definiciones de m\u00e9todos con una sintaxis especifica, para luego traducirlas autom\u00e1ticamente a consultas nativas, por parte de Spring Data.</p> <p>Esto es muy \u00fatil, ya que convierte a la aplicaci\u00f3n en agn\u00f3sticos de la tecnolog\u00eda de BBDD utilizada y podemos migrar con facilidad entre las muchas soluciones disponibles en el mercado, delegando esta tarea en Spring.</p> <p>Esta es la opci\u00f3n m\u00e1s indicada en la mayor\u00eda de los casos, siempre que puedas deber\u00edas utilizar esta forma de realizar las consultas. Como parte negativa, en algunos casos en consultas m\u00e1s complejas la definici\u00f3n de los m\u00e9todos puede extenderse demasiado dificultando la lectura del c\u00f3digo.</p> <p>De esto tenemos alg\u00fan ejemplo por el tutorial, en el repositorio de GameRepository.</p> <p>Siguiendo el ejemplo del tutorial, si tuvieramos que recuperar los <code>Game</code> por el nombre del juego, se podr\u00eda crear un m\u00e9todo en el <code>GameRepository</code> de esta forma:</p> <pre><code>List&lt;Game&gt; findByName(String name);\n</code></pre> <p>Spring Data entender\u00eda que quieres recuperar un listado de <code>Game</code> que est\u00e1n filtrados por su propiedad <code>Name</code> y generar\u00eda la consulta SQL de forma autom\u00e1tica, sin tener que implementar nada.</p> <p>Se pueden contruir muchos m\u00e9todos diferentes, te recomiendo que leas un peque\u00f1o tutorial de Baeldung y profundices con la documentaci\u00f3n oficial donde podr\u00e1s ver todas las opciones.</p>"},{"location":"appendix/jpa/#anotacion-query","title":"Anotaci\u00f3n @Query","text":"<p>Otra forma de realizar consultas, esta vez menos autom\u00e1tica y m\u00e1s cercana a SQL, es la anotaci\u00f3n @Query.</p> <p>Existen dos opciones a la hora de usar la anotaci\u00f3n <code>@Query</code>. Esta anotaci\u00f3n ya la hemos usado en el tutorial, dentro del GameRepository.</p> <p>En primer lugar tenemos las consultas JPQL. Estas guardan un parecido con el lenguaje SQL pero al igual que en el caso anterior, son traducidas por Spring Data a la consulta final nativa. Su uso no est\u00e1 recomendado ya que estamos a\u00f1adiendo un nivel de concreci\u00f3n y por tanto estamos aumentando la complejidad del c\u00f3digo. Aun as\u00ed, es otra forma de generar consultas.</p> <p>Por otra parte, tambi\u00e9n es posible generar consultas nativas directamente dentro de esta anotaci\u00f3n interactuando de forma directa con la base de datos. Esta pr\u00e1ctica es altamente desaconsejable ya que crea acoplamientos con la tecnolog\u00eda de la BBDD utilizada y es una fuente de errores.</p> <p>Puedes ver m\u00e1s informaci\u00f3n de esta anotaci\u00f3n desde este peque\u00f1o tutorial de Baeldung.</p>"},{"location":"appendix/jpa/#acelerando-las-consultas","title":"Acelerando las consultas","text":"<p>En muchas ocasiones necesitamos obtener informaci\u00f3n que no est\u00e1 en una \u00fanica tabla por motivos de dise\u00f1o de la base de datos. Debemos plasmar esta casu\u00edstica con cuidado a nuestro modelo relacional para obtener resultados \u00f3ptimos en cuanto al rendimiento.</p> <p>Para ilustrar el caso vamos a recuperar los objetos utilizados en el tutorial <code>Author</code>, <code>Gategory</code> y <code>Game</code>. Si recuerdas, tenemos que un <code>Game</code> tiene asociado un <code>Author</code> y tiene asociada una <code>Gategory</code>.</p> <p>Cuando utilizamos el m\u00e9todo de filtrado <code>find</code> que construimos en el <code>GameRepository</code>, vemos que Spring Data traduce la <code>@Query</code> que hab\u00edamos dise\u00f1ado en una query SQL para recuperar los juegos.</p> <pre><code>@Query(\"select g from Game g where (:title is null or g.title like '%'||:title||'%') and (:category is null or g.category.id = :category)\")\nList&lt;Game&gt; find(@Param(\"title\") String title, @Param(\"category\") Long category);\n</code></pre> <p>Esta <code>@Query</code> es la que utiliza Spring Data para traducir las propiedades a objetos de BBDD y mapear los resultados a objetos Java. Si tenemos activada la property <code>spring.jpa.show-sql=true</code> podremos ver las queries que est\u00e1 generando Spring Data. El resultado es el siguiente.</p> <pre><code>Hibernate: select game0_.id as id1_2_, game0_.age as age2_2_, game0_.author_id as author_i4_2_, game0_.category_id as category5_2_, game0_.title as title3_2_ from game game0_ where (? is null or game0_.title like ('%'||?||'%')) and (? is null or game0_.category_id=?)\nHibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_, author0_.nationality as national3_0_0_ from author author0_ where author0_.id=?\nHibernate: select category0_.id as id1_1_0_, category0_.name as name2_1_0_ from category category0_ where category0_.id=?\nHibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_, author0_.nationality as national3_0_0_ from author author0_ where author0_.id=?\nHibernate: select category0_.id as id1_1_0_, category0_.name as name2_1_0_ from category category0_ where category0_.id=?\nHibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_, author0_.nationality as national3_0_0_ from author author0_ where author0_.id=?\nHibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_, author0_.nationality as national3_0_0_ from author author0_ where author0_.id=?\nHibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_, author0_.nationality as national3_0_0_ from author author0_ where author0_.id=?\n</code></pre> <p>Si te fijas ha generado una query SQL para filtrar los <code>Game</code>, pero luego cuando ha intentado construir los objetos Java, ha tenido que lanzar una serie de queries para recuperar los diferentes <code>Author</code> y <code>Category</code> a trav\u00e9s de sus <code>id</code>. Obviamente Spring Data es muy lista y cachea los resultados obtenidos para no tener que recuperarlos n veces, pero aun as\u00ed, lanza unas cuantas consultas. Esto penaliza el rendimiento de nuestra operaci\u00f3n, ya que tiene que lanzar n queries a BBDD que, aunque son muy \u00f3ptimas, incrementan unos milisegundos el tiempo total.</p> <p>Para evitar esta circunstancia, disponemos de la anotaci\u00f3n denominada <code>@EnitityGraph</code> la cual proporciona directrices a Spring Data sobre la forma en la que deseamos realizar la consulta, permitiendo que realice agrupaciones y uniones de tablas en una \u00fanica query que, aun siendo mas compleja, en muchos casos el rendimiento es mucho mejor que realizar m\u00faltiples interacciones con la BBDD.</p> <p>Siguiendo el ejemplo anterior podr\u00edamos utilizar la anotaci\u00f3n de esta forma:</p> <pre><code>@Query(\"select g from Game g where (:title is null or g.title like '%'||:title||'%') and (:category is null or g.category.id = :category)\")\n@EntityGraph(attributePaths = {\"category\", \"author\"})\nList&lt;Game&gt; find(@Param(\"title\") String title, @Param(\"category\") Long category);\n</code></pre> <p>Donde le estamos diciendo a Spring Data que cuando realice la query, haga el cruce con las propiedades <code>category</code> y <code>author</code>, que a su vez son entidades y por tanto mapean dos tablas de BBDD. El resultado es el siguiente:</p> <pre><code>Hibernate: select game0_.id as id1_2_0_, category1_.id as id1_1_1_, author2_.id as id1_0_2_, game0_.age as age2_2_0_, game0_.author_id as author_i4_2_0_, game0_.category_id as category5_2_0_, game0_.title as title3_2_0_, category1_.name as name2_1_1_, author2_.name as name2_0_2_, author2_.nationality as national3_0_2_ from game game0_ left outer join category category1_ on game0_.category_id=category1_.id left outer join author author2_ on game0_.author_id=author2_.id where (? is null or game0_.title like ('%'||?||'%')) and (? is null or game0_.category_id=?)\n</code></pre> <p>Una \u00fanica query, que es m\u00e1s compleja que la anterior, ya que hace dos cruces con tablas de BBDD, pero que nos evita tener que lanzar n queries diferentes para recuperar <code>Author</code> y <code>Category</code>.</p> <p>Generalmente, el uso de <code>@EntityGraph</code> acelera mucho los resultados y es muy recomendable utilizarlo para realizar los cruces inline. Se puede utilizar tanto con <code>@Query</code> como con <code>Derived Query Methods</code>. Puedes leer m\u00e1s informaci\u00f3n en este peque\u00f1o tutorial de Baeldung.</p>"},{"location":"appendix/jpa/#alternativa-de-streams","title":"Alternativa de Streams","text":"<p>A partir de Java 8 disponemos de los Java Streams. Se trata de una herramienta que nos permite multitud de opciones relativas tratamiento y trasformaci\u00f3n de los datos manejados.</p> <p>En este apartado \u00fanicamente se menciona debido a que en muchas ocasiones cuando nos enfrentamos a consultas complejas, puede ser beneficioso evitar ofuscar las consultas y realizar las trasformaciones necesarias mediante los Streams.</p> <p>Un ejemplo de uso pr\u00e1ctico podr\u00eda ser, evitar usar la cl\u00e1usula <code>IN</code> de SQL en una determinada consulta que podr\u00eda penalizar notablemente el rendimiento de las consultas. En vez de eso se podr\u00eda utilizar el m\u00e9todo de JAVA <code>filter</code> sobre el conjunto de elementos para obtener el mismo resultado.</p> <p>Puedes leer m\u00e1s informaci\u00f3n en el tutorial de Baeldung.</p>"},{"location":"appendix/jpa/#specifications","title":"Specifications","text":"<p>En algunos casos puede ocurrir que con las herramientas descritas anteriormente no tengamos suficiente alcance, bien porque las definiciones de los m\u00e9todos se complican y alargan demasiado o debido a que la consulta es demasiado gen\u00e9rica como para realizarlo de este modo.</p> <p>Para este caso se dispone de las Specifications que nos proveen de una forma de escribir consultas reutilizables mediante una API que ofrece una forma fluida de crear y combinar consultas complejas.</p> <p>Un ejemplo de caso de uso podr\u00eda ser un CRUD de una determinada entidad que debe poder filtrar por todos los atributos de esta, donde el tipo de filtrado viene especificado en la propia consulta y no siempre es requerido. En este caso no podr\u00edamos construir una consulta basada en definir un determinado m\u00e9todo ya no conocemos de ante mano que filtros ni que atributos vamos a recibir y deberemos recurrir al uso de las Specifications.</p> <p>Puedes leer m\u00e1s informaci\u00f3n en el tutorial de Baeldung.</p>"},{"location":"appendix/rest/","title":"Breve detalle sobre REST","text":"<p>Antes de empezar vamos a hablar de operaciones REST. Estas operaciones son el punto de entrada a nuestra aplicaci\u00f3n y se pueden diferenciar dos claros elementos:</p> <ul> <li>Ruta hacia el recurso, lo que viene siendo la URL.</li> <li>Acci\u00f3n a realizar sobre el recurso, lo que viene siendo la operaci\u00f3n HTTP o el verbo.</li> </ul>"},{"location":"appendix/rest/#ruta-del-recurso","title":"Ruta del recurso","text":"<p>La ruta del recurso nos indica entre otras cosas, el endpoint y su posible jerarqu\u00eda sobre la que se va a realizar la operaci\u00f3n. Debe tener una ra\u00edz de recurso y si se requiere navegar por el recursos, la jerarqu\u00eda ir\u00e1 separada por barras. La URL nunca deber\u00eda tener verbos o acciones solamente recursos, identificadores o atributos.  Por ejemplo en nuestro caso de <code>Categor\u00edas</code>, ser\u00edan correctas las siguientes rutas:</p> <ul> <li> /category</li> <li> /category/3</li> <li> /category/?name=Dados</li> </ul> <p>Sin embargo, no ser\u00edan del todo correctas las rutas:</p> <ul> <li> /getCategory</li> <li> /findCategories</li> <li> /saveCategory</li> <li> /category/save</li> </ul> <p>A menudo, se integran datos identificadores o atributos de b\u00fasqueda dentro de la propia ruta. Podr\u00edamos definir la operaci\u00f3n <code>category/3</code> para referirse a la Categor\u00eda con ID = 3, o <code>category/?name=Dados</code> para referirse a las categor\u00edas con nombre = Dados. A veces, estos datos tambi\u00e9n pueden ir como atributos en la URL o en el cuerpo de la petici\u00f3n, aunque se recomienda que siempre que sean identificadores vayan determinados en la propia URL.</p> <p>Si el dominio categor\u00eda tuviera hijos o relaciones con alg\u00fan otro dominio se podr\u00eda a\u00f1adir esas jerarqu\u00eda a la URL. Por ejemplo podr\u00edamos tener <code>category/3/child/2</code> para referirnos al hijo de ID = 2 que tiene la Categor\u00eda de ID = 3, y as\u00ed sucesivamente.</p>"},{"location":"appendix/rest/#accion-sobre-el-recurso","title":"Acci\u00f3n sobre el recurso","text":"<p>La acci\u00f3n sobre el recurso se determina mediante la operaci\u00f3n o verbo HTTP que se utiliza en el endpoint. Los verbos m\u00e1s usados ser\u00edan:</p> <ul> <li>GET. Cuando se quiere recuperar un recursos.</li> <li>POST. Cuando se quiere crear un recurso. Aunque a menudo se utiliza para realizar otras acciones de b\u00fasqueda o validaci\u00f3n.</li> <li>PUT. Cuando se quiere actualizar o modificar un recurso. Aunque a menudo se utiliza una sola operaci\u00f3n para crear o actualizar. En ese caso se utilizar\u00eda solamente <code>POST</code>.</li> <li>DELETE. Cuando se quiere eliminar un recurso.</li> </ul> <p>De esta forma tendr\u00edamos:</p> <ul> <li><code>GET /category/3</code>. Realizar\u00eda un acceso para recuperar la categor\u00eda 3.</li> <li><code>POST o PUT /category/3</code>. Realizar\u00eda un acceso para crear o modificar la categor\u00eda 3. Los datos a modificar deber\u00edan ir en el body.</li> <li><code>DELETE /category/3</code>. Realizar\u00eda un acceso para borrar la categor\u00eda 3.</li> <li><code>GET /category/?name=Dados</code>. Realizar\u00eda un acceso para recuperar las categor\u00edas que tengan nombre = Dados.</li> </ul> <p>Excepciones a la regla</p> <p>A veces hay que ejecutar una operaci\u00f3n que no es 'estandar' en cuanto a verbos HTTP. Para ese caso, deberemos clarificar en la URL la acci\u00f3n que se debe realizar y si vamos a enviar datos deber\u00eda ser de tipo <code>POST</code> mientras que si simplemente se requiere una contestaci\u00f3n sin enviar datos ser\u00e1 de tipo <code>GET</code>. Por ejemplo <code>POST /category/3/validate</code> realizar\u00eda un acceso para ejecutar una validaci\u00f3n sobre los datos enviados en el body de la categor\u00eda 3.</p>"},{"location":"appendix/tdd/","title":"TDD (Test Driven Development)","text":"<p>Se trata de una pr\u00e1ctica de programaci\u00f3n que consiste en escribir primero las pruebas (generalmente unitarias), despu\u00e9s escribir el c\u00f3digo fuente que pase la prueba satisfactoriamente y, por \u00faltimo, refactorizar el c\u00f3digo escrito.</p> <p>Este ciclo se suele representar con la siguiente imagen:</p> <p></p> <p>Con esta pr\u00e1ctica se consigue entre otras cosas: un c\u00f3digo m\u00e1s robusto, m\u00e1s seguro, m\u00e1s mantenible y una mayor rapidez en el desarrollo.</p> <p>Los pasos que se siguen son:</p> <ol> <li> <p>Primero hay que escribir el test o los tests que cubran la funcionalidad que voy a implementar. Los test no solo deben probar los casos correctos, sino que deben probar los casos err\u00f3neos e incluso los casos en los que se provoca una excepci\u00f3n. Cuantos m\u00e1s test hagas, mejor probada y m\u00e1s robusta ser\u00e1 tu aplicaci\u00f3n.</p> <p>Adem\u00e1s, como efecto colateral, al escribir el test est\u00e1s pensando el dise\u00f1o de c\u00f3mo va a funcionar la aplicaci\u00f3n. En vez de liarte a programar como loco, te est\u00e1s forzando a pensar primero y ver cual es la mejor soluci\u00f3n. Por ejemplo para implementar una operaci\u00f3n de calculadora primero piensas en qu\u00e9 es lo que necesitar\u00e1s: una clase Calculadora con un m\u00e9todo que se llame Suma y que tenga dos par\u00e1metros.</p> </li> <li> <p>El segundo paso una vez tengo definido el test, que evidentemente fallar\u00e1 (e incluso a menudo ni siquiera compilar\u00e1), es implementar el c\u00f3digo necesario para que los tests funcionen. Aqu\u00ed muchas veces pecamos de querer implementar demasiadas cosas o pensando en que en un futuro necesitaremos modificar ciertas partes y lo dejamos ya preparado para ello. Hay que ir con mucho cuidado con las <code>optimizaciones prematuras</code>, a menudo no son necesarias y solo hacen que dificultar nuestro c\u00f3digo.</p> <p>Piensa en construir el m\u00ednimo c\u00f3digo que haga que tus tests funcionen correctamente. Adem\u00e1s, no es necesario que sea un c\u00f3digo demasiado purista y limpio.</p> </li> <li> <p>El \u00faltimo paso y a menudo el m\u00e1s olvidado es el <code>Refactor</code>. Una vez te has asegurado que tu c\u00f3digo funciona y que los tests funcionan correctamente (ojo no solo los tuyos sino todos los que ya existan en la aplicaci\u00f3n) llega el paso de sacarle brillo a tu c\u00f3digo.</p> <p>En este paso tienes que intentar mejorar tu c\u00f3digo, evitar duplicidades, evitar malos olores de programaci\u00f3n, eliminar posibles malos usos del lenguaje, etc. En definitiva que tu c\u00f3digo se lea y se entienda mejor.</p> </li> </ol> <p>Si seguimos estos pasos a la hora de programar, nuestra aplicaci\u00f3n estar\u00e1 muy bien testada. Cada vez que hagamos un cambio tendremos una certeza muy elevada, de forma r\u00e1pida y sencilla, de si la aplicaci\u00f3n sigue funcionando o hemos roto algo. Y lo mejor de todo, las implementaciones que hagamos estar\u00e1n bien pensadas y dise\u00f1adas y acotadas realmente a lo que necesitamos.</p>"},{"location":"appendix/springbatch/clean/","title":"Limpieza - Spring Batch","text":"<p>Ya tenemos todo configurado de los pasos anteriores asi que proseguimos con el \u00faltimo ejemplo.</p>"},{"location":"appendix/springbatch/clean/#caso-de-uso","title":"Caso de Uso","text":"<p>Este es un caso de uso nuevo para poner en pr\u00e1ctica el uso de <code>Tasklet</code>.</p>"},{"location":"appendix/springbatch/clean/#que-vamos-a-hacer","title":"\u00bfQu\u00e9 vamos a hacer?","text":"<p>Vamos a implementar un batch que limpie de ficheros un determinado directorio. Esta vez y dado que no necesitamos realizar ning\u00fan tipo de lectura ni trasformaci\u00f3n ni escritura y queremos hacerlo todo al mismo tiempo, es buen momento para utilizar un <code>Tasklet</code>.</p>"},{"location":"appendix/springbatch/clean/#como-lo-vamos-a-hacer","title":"\u00bfC\u00f3mo lo vamos a hacer?","text":"<p>A diferencia de los casos anteriores seguiremos el esquema de funcionamiento de tasklet de un proceso batch que hemos visto en la parte de introducci\u00f3n:</p> <p></p> <ul> <li>Tasklet: Eliminar\u00e1 todos los ficheros del directorio.</li> <li>Step: El paso que contiene el tasklet que van a realizar la funcionalidad.</li> <li>Job: La tarea que contiene los pasos definidos.</li> </ul>"},{"location":"appendix/springbatch/clean/#codigo","title":"C\u00f3digo","text":""},{"location":"appendix/springbatch/clean/#tasklet","title":"Tasklet","text":"<p>En primer lugar, vamos a crear <code>CleanTasklet</code> dentro del package <code>com.ccsw.tutorialbatch.tasklet</code>.</p> CleanTasklet.java <pre><code>import java.io.File;\n\npublic class CleanTasklet implements Tasklet, InitializingBean {\n\n    private Resource directory;\n\n    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {\n        File dir = directory.getFile();\n\n        File[] files = dir.listFiles();\n\n        for (File file : files) {\n            boolean deleted = file.delete();\n            if (!deleted) {\n                throw new UnexpectedJobExecutionException(\"Could not delete file \" + file.getPath());\n            }\n        }\n        return RepeatStatus.FINISHED;\n    }\n\n    public void setDirectoryResource(Resource directory) {\n\n        this.directory = directory;\n    }\n\n    public void afterPropertiesSet() throws Exception {\n\n        if (directory == null) {\n            throw new UnexpectedJobExecutionException(\"Directory must be set\");\n        }\n    }\n}\n</code></pre> <p>La implementaci\u00f3n de la interface <code>Tasklet</code> consiste en sobreescribir el m\u00e9todo <code>execute</code> de forma muy similar como lo hac\u00edamos en los <code>Processors</code>. En este m\u00e9todo emplazamos nuestra l\u00f3gica de negocio que b\u00e1sicamente consiste en borrar todos los ficheros que se encuentren en el directorio proporcionado como atributo.</p>"},{"location":"appendix/springbatch/clean/#step-y-job","title":"Step y Job","text":"<p>Posteriormente, como en el caso anterior, emplazamos la configuraci\u00f3n junto al resto de beans dentro del package <code>com.ccsw.tutorialbatch.config</code>.</p> CleanBatchConfiguration.java <pre><code>package com.ccsw.tutorialbatch.config;\n\nimport com.ccsw.tutorialbatch.tasklet.CleanTasklet;\nimport org.springframework.batch.core.Job;\nimport org.springframework.batch.core.Step;\nimport org.springframework.batch.core.job.builder.JobBuilder;\nimport org.springframework.batch.core.launch.support.RunIdIncrementer;\nimport org.springframework.batch.core.repository.JobRepository;\nimport org.springframework.batch.core.step.builder.StepBuilder;\nimport org.springframework.batch.core.step.tasklet.Tasklet;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.io.FileSystemResource;\nimport org.springframework.transaction.PlatformTransactionManager;\n\n@Configuration\npublic class CleanBatchConfiguration {\n\n    @Bean\n    public Tasklet taskletClean() {\n        CleanTasklet tasklet = new CleanTasklet();\n\n        tasklet.setDirectoryResource(new FileSystemResource(\"target/test-outputs\"));\n\n        return tasklet;\n    }\n\n    @Bean\n    public Step step1Clean(JobRepository jobRepository, PlatformTransactionManager transactionManager, Tasklet taskletClean) {\n        return new StepBuilder(\"step1Clean\", jobRepository)\n                .tasklet(taskletClean, transactionManager)\n                .build();\n    }\n\n    @Bean\n    public Job jobClean(JobRepository jobRepository, Step step1Clean) {\n        return new JobBuilder(\"jobClean\", jobRepository)\n                .incrementer(new RunIdIncrementer())\n                .start(step1Clean)\n                .build();\n    }\n\n}\n</code></pre> <ul> <li>Tasklet: El bean del <code>Tasklet</code> que hemos creado anteriormente.</li> <li>Step: La creaci\u00f3n del <code>Step</code> se realiza mediante \u00e9l <code>StepBuilder</code> al que \u00fanicamente le a\u00f1adimos el <code>Tasklet</code> que se va a ejecutar de forma at\u00f3mica.</li> <li>Job: Finalmente, debemos definir \u00e9l <code>Job</code> que ser\u00e1 lo que se ejecute al lanzar nuestro proceso. La creaci\u00f3n se hace mediante el builder correspondiente como en los casos anteriores.</li> </ul>"},{"location":"appendix/springbatch/clean/#pruebas","title":"Pruebas","text":"<p>Ahora ya tenemos varios <code>Jobs</code> en nuestro batch por lo que debemos especificar en el arranque cu\u00e1l queremos ejecutar.</p> <p>Como en el caso anterior pasamos como <code>VM option</code> la siguiente propiedad en el arranque de la aplicaci\u00f3n: <pre><code>-Dspring.batch.job.name=jobClean\n</code></pre></p> <p>Hecho esto y ejecutado el batch, podremos ver la traza de la ejecuci\u00f3n en nuestro <code>log</code> y que el fichero generado en el <code>target</code> del proyecto de la ejecuci\u00f3n del batch de autores ya no est\u00e1.</p> <pre><code>Job: [SimpleJob: [name=jobClean]] launched with the following parameters: [{'run.id':'{value=1, type=class java.lang.Long, identifying=true}'}]\nExecuting step: [step1Clean]\nStep: [step1Clean] executed in 9ms\nJob: [SimpleJob: [name=jobClean]] completed with the following parameters: [{'run.id':'{value=1, type=class java.lang.Long, identifying=true}'}] and the following status: [COMPLETED] in 23ms\n</code></pre>"},{"location":"appendix/springbatch/exercise/","title":"Ahora hazlo t\u00fa!","text":"<p>Ahora vamos a ver si has comprendido bien el tutorial. \u00a1Vamos alla!</p>"},{"location":"appendix/springbatch/exercise/#exportacion-de-juegos-a-fichero","title":"Exportaci\u00f3n de juegos a fichero","text":""},{"location":"appendix/springbatch/exercise/#requisitos","title":"Requisitos","text":"<p>En este ejercicio vamos a simular la exportaci\u00f3n de datos desde una tabla de base de datos a fichero. </p> <p>El objetivo es que en funci\u00f3n del n\u00famero de stock de un determinado juego, generemos un fichero con su nombre y si el juego est\u00e1 disponible.</p> <p>Par ello debemos tener una tabla de juegos con los siguientes atributos:</p> <ul> <li>Identificador</li> <li>T\u00edtulo</li> <li>Edad recomendada</li> <li>Stock</li> </ul> <p>El proceso batch debe consultar los registros y convertirlos a la siguiente estructura:</p> <ul> <li>T\u00edtulo: T\u00edtulo del juego (el mismo que en la tabla de BBDD).</li> <li>Disponibilidad: Si el stock es mayor que cero estar\u00e1 disponible y si es cero debera aparecer que no est\u00e1 disponible.</li> </ul> <p>Una vez realizada la conversion, se debe escribir dicha informaci\u00f3n a fichero y guardarlo en el <code>target</code> del proyecto.</p>"},{"location":"appendix/springbatch/exercise/#consejos","title":"Consejos","text":"<p>Para empezar te dar\u00e9 unos consejos:</p> <ul> <li>Recuerda crear la tabla de la BBDD y sus datos.</li> <li>Intenta re-aprovechar lo que hemos aprendido en los ejemplos.</li> <li>Consulta la documentaci\u00f3n para utilizar un <code>Reader</code> apropiado para la lectura desde BBDD.</li> <li>Date cuenta de que el <code>Processor</code> que necesitas es algo m\u00e1s complejo esta vez y necesitaras m\u00e1s de un modelo diferente.</li> </ul>"},{"location":"appendix/springbatch/exercise/#ya-has-terminado","title":"\u00bfYa has terminado?","text":"<p>Si has llegado a este punto es porque ya tienes terminado el tutorial. Por favor no te olvides de subir los proyectos a alg\u00fan repositorio Github propio (puedes revisar el anexo Tutorial b\u00e1sico de Git) y av\u00edsarnos para que podamos echarle un ojo y darte sugerencias y feedback .</p>"},{"location":"appendix/springbatch/filetodb/","title":"Categor\u00eda - Spring Batch","text":"<p>Al igual que el tutorial b\u00e1sico de Spring Boot, debemos configurar el entorno y crear el proyecto.</p> <p>Para la configuraci\u00f3n del entorno nos remitimos a la gu\u00eda de instalaci\u00f3n donde se detalla el proceso de configuraci\u00f3n del Entorno de desarrollo</p> <p>Todos los pasos son exactamente iguales, lo \u00fanico que va a variar es la creaci\u00f3n del proyecto desde Spring Initializr:</p> <ul> <li>Tipo de proyecto: Maven</li> <li>Lenguage: Java</li> <li>Versi\u00f3n Spring boot: 3.2.2 (o alguna similar)</li> <li>Group: com.ccsw</li> <li>ArtifactId: tutorial-batch</li> <li>Versi\u00f3n Java: 17 (o similar)</li> <li>Dependencias: Spring Batch, H2 Database</li> </ul> <p></p> <p>Esto nos generar\u00e1 un proyecto que ya vendr\u00e1 configurado con Spring Batch y H2 para crear una BBDD en memoria de ejemplo con la que trabajaremos durante el tutorial.</p> <p>Esta parte de tutorial es una ampliaci\u00f3n de la parte de backend con Spring Boot, por tanto, no se ve a enfocar en las partes b\u00e1sicas aprendidas previamente, sino que se va a explicar el funcionamiento de los procesos batch.</p>"},{"location":"appendix/springbatch/filetodb/#caso-de-uso","title":"Caso de Uso","text":"<p>En este ejemplo no podemos seguir los mismos casos de uso que de los ejemplos del tutorial de <code>Spring Boot</code>, ya que sus requisitos no son v\u00e1lidos para implementarse como un proceso batch por lo que vamos a mantener las mismas entidades pero imaginar casos de uso diferentes.</p>"},{"location":"appendix/springbatch/filetodb/#que-vamos-a-hacer","title":"\u00bfQu\u00e9 vamos a hacer?","text":"<p>Vamos a implementar un batch para leer un fichero de <code>Categorias</code> e insertar los registros le\u00eddos en Base de Datos.</p>"},{"location":"appendix/springbatch/filetodb/#como-lo-vamos-a-hacer","title":"\u00bfC\u00f3mo lo vamos a hacer?","text":"<p>Seguiremos el esquema de funcionamiento habitual de un proceso batch que hemos visto en la parte de introducci\u00f3n:</p> <p></p> <ul> <li>ItemReader: Se va a leer de un fichero y convertir los registros le\u00eddos al modelo de <code>Category</code>.</li> <li>ItemProcessor: Va a procesar todos los registros convirtiendo los textos a may\u00fasculas.</li> <li>ItemWriter: Va a insertar los registros en la BBDD.</li> <li>Step: El paso que contiene los elementos que van a realizar la funcionalidad.</li> <li>Job: La tarea que contiene los pasos definidos.</li> </ul>"},{"location":"appendix/springbatch/filetodb/#codigo","title":"C\u00f3digo","text":""},{"location":"appendix/springbatch/filetodb/#modelo","title":"Modelo","text":"<p>En primer lugar, vamos a crear el modelo dentro del package <code>com.ccsw.tutorialbatch.model</code>. En este caso no trabajamos con entidades, ya que ahora son simples estructuras de datos.</p> Category.java <pre><code>package com.ccsw.tutorialbatch.model;\n\npublic class Category {\n\n    private String name;\n    private String type;\n    private String characteristics;\n\n    public Category() {\n    }\n\n    public Category(String name, String type, String characteristics) {\n        this.name = name;\n        this.type = type;\n        this.characteristics = characteristics;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public String getCharacteristics() {\n        return characteristics;\n    }\n\n    public void setCharacteristics(String characteristics) {\n        this.characteristics = characteristics;\n    }\n\n    @Override\n    public String toString() {\n        return \"Category [name=\" + getName() + \", type=\" + getType() + \", characteristics=\" + getCharacteristics() + \"]\";\n    }\n\n}\n</code></pre>"},{"location":"appendix/springbatch/filetodb/#reader","title":"Reader","text":"<p>Ahora, emplazamos \u00e9l <code>Reader</code> en la clase donde posteriormente a\u00f1adiremos la configuraci\u00f3n junto al resto de beans, dentro del package <code>com.ccsw.tutorialbatch.config</code>.</p> CategoryBatchConfiguration.java <pre><code>package com.ccsw.tutorialbatch.config;\n\n...\n\n@Configuration\npublic class CategoryBatchConfiguration {\n\n    @Bean\n    public ItemReader&lt;Category&gt; readerCategory() {\n        return new FlatFileItemReaderBuilder&lt;Category&gt;().name(\"categoryItemReader\")\n                .resource(new ClassPathResource(\"category-list.csv\"))\n                .delimited()\n                .names(new String[] { \"name\", \"type\", \"characteristics\" })\n                .fieldSetMapper(new BeanWrapperFieldSetMapper&lt;&gt;() {{\n                    setTargetType(Category.class);\n                }})\n                .build();\n    }\n\n}\n</code></pre> <p>Para la ingesta de datos vamos a hacer uso de <code>FlatFileItemReader</code> que nos proporciona Spring Batch. Como se puede observar se le proporciona el fichero a leer y el mapeo a la clase que deseamos. Aqu\u00ed el cat\u00e1logo de Readers que proporciona <code>Spring Batch</code>.</p>"},{"location":"appendix/springbatch/filetodb/#processor","title":"Processor","text":"<p>Posteriormente, emplazamos \u00e9l <code>Processor</code> dentro del package <code>com.ccsw.tutorialbatch.processor</code>.</p> CategoryItemProcessor.java <pre><code>package com.ccsw.tutorialbatch.processor;\n\nimport com.ccsw.tutorialbatch.model.Category;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.batch.item.ItemProcessor;\n\npublic class CategoryItemProcessor implements ItemProcessor&lt;Category, Category&gt; {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(CategoryItemProcessor.class);\n\n    @Override\n    public Category process(final Category category) {\n        String name = category.getName().toUpperCase();\n        String type = category.getType().toUpperCase();\n        String characteristics = category.getCharacteristics().toUpperCase();\n\n        Category transformedCategory = new Category(name, type, characteristics);\n        LOGGER.info(\"Converting ( {} ) into ( {} )\", category, transformedCategory);\n\n        return transformedCategory;\n    }\n}\n</code></pre> <p>Hemos implementado un <code>Processor</code> personalizado, esta clase implementa <code>ItemProcessor</code> donde especificamos de qu\u00e9 clase a qu\u00e9 clase se va a realizar la trasformaci\u00f3n. </p> <p>En nuestro caso, va a ser de <code>Category</code> a <code>Category</code> donde \u00fanicamente vamos a realizar una trasformaci\u00f3n de pasar los datos le\u00eddos a may\u00fasculas, ya que el <code>Reader</code> que veremos m\u00e1s adelante ya nos habr\u00e1 trasformado los datos del fichero al modelo deseado. Las trasformaciones en s\u00ed se especifican sobreescribiendo el m\u00e9todo <code>process</code>.</p>"},{"location":"appendix/springbatch/filetodb/#writer","title":"Writer","text":"<p>Posteriormente, a\u00f1adimos el writer a la clase de configuraci\u00f3n <code>CategoryBatchConfiguration</code> donde ya hab\u00edamos a\u00f1adido <code>Reader</code>.</p> CategoryBatchConfiguration.java <pre><code>package com.ccsw.tutorialbatch.config;\n\n...\n\n@Configuration\npublic class CategoryBatchConfiguration {\n\n    ...\n\n    @Bean\n    public ItemWriter&lt;Category&gt; writerCategory(DataSource dataSource) {\n        return new JdbcBatchItemWriterBuilder&lt;Category&gt;()\n                .itemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider&lt;&gt;())\n                .sql(\"INSERT INTO category (name, type, characteristics) VALUES (:name, :type, :characteristics)\")\n                .dataSource(dataSource)\n                .build();\n    }\n\n}\n</code></pre> <p>Para la parte de escritura usaremos <code>JdbcBatchItemWriter</code> que nos ayuda a lanzar inserciones en la base de datos de forma sencilla. \u00c9l <code>DataSource</code> se inicializa autom\u00e1ticamente con la instancia de H2 que se carga al arrancar el Batch. Aqu\u00ed el cat\u00e1logo de Writers que proporciona <code>Spring Batch</code>.</p>"},{"location":"appendix/springbatch/filetodb/#step-y-job","title":"Step y Job","text":"<p>Ahora ya podemos a\u00f1adir la configuraci\u00f3n del <code>Step</code> y del <code>Job</code> dentro de la clase de configuraci\u00f3n. La clase completa deber\u00eda quedar de esta forma:</p> CategoryBatchConfiguration.java <pre><code>package com.ccsw.tutorialbatch.config;\n\n\nimport com.ccsw.tutorialbatch.model.Category;\nimport com.ccsw.tutorialbatch.processor.CategoryItemProcessor;\nimport com.ccsw.tutorialbatch.listener.JobCategoryCompletionNotificationListener;\nimport org.springframework.batch.core.Job;\nimport org.springframework.batch.core.Step;\nimport org.springframework.batch.core.job.builder.JobBuilder;\nimport org.springframework.batch.core.launch.support.RunIdIncrementer;\nimport org.springframework.batch.core.repository.JobRepository;\nimport org.springframework.batch.core.step.builder.StepBuilder;\nimport org.springframework.batch.item.ItemProcessor;\nimport org.springframework.batch.item.ItemReader;\nimport org.springframework.batch.item.ItemWriter;\nimport org.springframework.batch.item.database.BeanPropertyItemSqlParameterSourceProvider;\nimport org.springframework.batch.item.database.builder.JdbcBatchItemWriterBuilder;\nimport org.springframework.batch.item.file.builder.FlatFileItemReaderBuilder;\nimport org.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.io.ClassPathResource;\nimport org.springframework.transaction.PlatformTransactionManager;\n\nimport javax.sql.DataSource;\n\n@Configuration\npublic class CategoryBatchConfiguration {\n\n    @Bean\n    public ItemReader&lt;Category&gt; readerCategory() {\n        return new FlatFileItemReaderBuilder&lt;Category&gt;().name(\"categoryItemReader\")\n                .resource(new ClassPathResource(\"category-list.csv\"))\n                .delimited()\n                .names(new String[] { \"name\", \"type\", \"characteristics\" })\n                .fieldSetMapper(new BeanWrapperFieldSetMapper&lt;&gt;() {{\n                    setTargetType(Category.class);\n                }})\n                .build();\n    }\n\n    @Bean\n    public ItemProcessor&lt;Category, Category&gt; processorCategory() {\n\n        return new CategoryItemProcessor();\n    }\n\n    @Bean\n    public ItemWriter&lt;Category&gt; writerCategory(DataSource dataSource) {\n        return new JdbcBatchItemWriterBuilder&lt;Category&gt;()\n                .itemSqlParameterSourceProvider(new BeanPropertyItemSqlParameterSourceProvider&lt;&gt;())\n                .sql(\"INSERT INTO category (name, type, characteristics) VALUES (:name, :type, :characteristics)\")\n                .dataSource(dataSource)\n                .build();\n    }\n\n    @Bean\n    public Step step1Category(JobRepository jobRepository, PlatformTransactionManager transactionManager, ItemReader&lt;Category&gt; readerCategory, ItemProcessor&lt;Category, Category&gt; processorCategory, ItemWriter&lt;Category&gt; writerCategory) {\n        return new StepBuilder(\"step1Category\", jobRepository)\n                .&lt;Category, Category&gt; chunk(10, transactionManager)\n                .reader(readerCategory)\n                .processor(processorCategory)\n                .writer(writerCategory)\n                .build();\n    }\n\n    @Bean\n    public Job jobCategory(JobRepository jobRepository, JobCategoryCompletionNotificationListener listener, Step step1Category) {\n        return new JobBuilder(\"jobCategory\", jobRepository)\n                .incrementer(new RunIdIncrementer())\n                .listener(listener)\n                .flow(step1Category)\n                .end()\n                .build();\n    }\n\n}\n</code></pre> <ul> <li>ItemReader: El bean del <code>Reader</code> que hemos creado anteriormente.</li> <li>ItemProcessor: El bean del <code>Processor</code> que hemos creado anteriormente.</li> <li>ItemWriter: El bean del <code>Writer</code> que hemos creado anteriormente.</li> <li>Step: La creaci\u00f3n del <code>Step</code> se realiza mediante \u00e9l <code>StepBuilder</code> al que le definimos el tama\u00f1o del <code>chunk</code> que es el n\u00famero de elementos procesados por lote y le asignamos los tres beans creados previamente. En este caso solo vamos a tener un \u00fanico <code>Step</code> pero podr\u00edamos tener todos los que quisi\u00e9ramos.</li> <li>Job: Finalmente, debemos definir \u00e9l <code>Job</code> que ser\u00e1 lo que se ejecute al lanzar nuestro proceso. La creaci\u00f3n se hace mediante el builder correspondiente como en el caso anterior. Se asigna el identificador de <code>Job</code>, el conjunto de steps, en este caso solo tenemos uno y finalmente el listener que es opcional y se crea en el siguiente paso.</li> </ul>"},{"location":"appendix/springbatch/filetodb/#listener","title":"Listener","text":"<p>Ahora, para verificar que nuestro proceso se ha ejecutado correctamente vamos a a\u00f1adir un <code>Listener</code> que al final de la ejecuci\u00f3n consultar\u00e1 que los datos se han insertado correctamente. Emplazamos \u00e9l <code>Listener</code> dentro del package <code>com.ccsw.tutorialbatch.listener</code>.</p> JobCategoryCompletionNotificationListener.java <pre><code>package com.ccsw.tutorialbatch.listener;\n\n\nimport com.ccsw.tutorialbatch.model.Category;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.batch.core.BatchStatus;\nimport org.springframework.batch.core.JobExecution;\nimport org.springframework.batch.core.JobExecutionListener;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class JobCategoryCompletionNotificationListener implements JobExecutionListener {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(JobCategoryCompletionNotificationListener.class);\n\n    private final JdbcTemplate jdbcTemplate;\n\n    @Autowired\n    public JobCategoryCompletionNotificationListener(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    @Override\n    public void afterJob(JobExecution jobExecution) {\n        if (jobExecution.getStatus() == BatchStatus.COMPLETED) {\n            LOGGER.info(\"!!! JOB FINISHED! Time to verify the results\");\n\n            String query = \"SELECT name, type, characteristics FROM category\";\n            jdbcTemplate.query(query, (rs, row) -&gt; new Category(rs.getString(1), rs.getString(2), rs.getString(3)))\n                .forEach(category -&gt; LOGGER.info(\"Found &lt; {} &gt; in the database.\", category));\n        }\n    }\n}\n</code></pre> <p>Para el listener implementamos la interface <code>JobExecutionListener</code> y sobreescribimos el m\u00e9todo <code>afterJob</code> que se ejecutara justo al terminar nuestro <code>Job</code> lanzando una consulta y mostrando el resultado.</p>"},{"location":"appendix/springbatch/filetodb/#base-de-datos-y-fichero-carga","title":"Base de Datos y Fichero Carga","text":"<p>Finalmente, debemos crear el fichero de inicializaci\u00f3n de base de datos con la tabla de categor\u00edas y crear el fichero que leeremos con los datos de las categor\u00edas que deseamos insertar.</p> schema-all.sqlcategory-list.csv <pre><code>DROP TABLE category IF EXISTS;\n\nCREATE TABLE category  (\ncategory_id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,\nname VARCHAR(20),\ntype VARCHAR(20),\ncharacteristics VARCHAR(30)\n);\n</code></pre> <pre><code>Eurogames,Mechanics,Hard\nAmeritrash,Thematic,Mid\nFamiliar,Fillers,Easy\n</code></pre>"},{"location":"appendix/springbatch/filetodb/#pruebas","title":"Pruebas","text":"<p>Ahora si arrancamos la aplicaci\u00f3n como cualquier aplicaci\u00f3n <code>Spring Boot</code>, podremos observar la traza de la ejecuci\u00f3n en nuestro <code>log</code> y comprobar que la ejecuci\u00f3n ha sido correcta y los registros se han insertado.</p> <pre><code>Job: [FlowJob: [name=jobCategory]] launched with the following parameters: [{'run.id':'{value=1, type=class java.lang.Long, identifying=true}'}]\nExecuting step: [step1Category]\nConverting ( Category [name=Eurogames, type=Mechanics, characteristics=Hard] ) into ( Category [name=EUROGAMES, type=MECHANICS, characteristics=HARD] )\nConverting ( Category [name=Ameritrash, type=Thematic, characteristics=Mid] ) into ( Category [name=AMERITRASH, type=THEMATIC, characteristics=MID] )\nConverting ( Category [name=Familiar, type=Fillers, characteristics=Easy] ) into ( Category [name=FAMILIAR, type=FILLERS, characteristics=EASY] )\nStep: [step1Category] executed in 55ms\n!!! JOB FINISHED! Time to verify the results\nFound &lt; Category [name=EUROGAMES, type=MECHANICS, characteristics=HARD] &gt; in the database.\nFound &lt; Category [name=AMERITRASH, type=THEMATIC, characteristics=MID] &gt; in the database.\nFound &lt; Category [name=FAMILIAR, type=FILLERS, characteristics=EASY] &gt; in the database.\nJob: [FlowJob: [name=jobCategory]] completed with the following parameters: [{'run.id':'{value=1, type=class java.lang.Long, identifying=true}'}] and the following status: [COMPLETED] in 73ms\n</code></pre>"},{"location":"appendix/springbatch/filetofile/","title":"Autor - Spring Batch","text":"<p>Ya tenemos todo configurado del paso anterior asi que proseguimos con el siguiente ejemplo.</p>"},{"location":"appendix/springbatch/filetofile/#caso-de-uso","title":"Caso de Uso","text":"<p>En este caso tambi\u00e9n debemos plantear requisitos diferentes para la parte de Autores.</p>"},{"location":"appendix/springbatch/filetofile/#que-vamos-a-hacer","title":"\u00bfQu\u00e9 vamos a hacer?","text":"<p>Vamos a implementar un batch para leer un fichero de <code>Autores</code> trasformar la nacionalidad del autor a c\u00f3digo de region y general un fichero con los datos trasformados.</p>"},{"location":"appendix/springbatch/filetofile/#como-lo-vamos-a-hacer","title":"\u00bfC\u00f3mo lo vamos a hacer?","text":"<p>Al igual que en el caso anterior seguiremos el esquema de funcionamiento habitual de un proceso batch que hemos visto en la parte de introducci\u00f3n:</p> <p></p> <ul> <li>ItemReader: Se va a leer de un fichero y convertir los registros le\u00eddos al modelo de <code>Author</code>.</li> <li>ItemProcessor: Va a procesar todos los registros convirtiendo el c\u00f3digo de nacionalidad al formato xx_XX.</li> <li>ItemWriter: Va a escribir los registros en un fichero.</li> <li>Step: El paso que contiene los elementos que van a realizar la funcionalidad.</li> <li>Job: La tarea que contiene los pasos definidos.</li> </ul>"},{"location":"appendix/springbatch/filetofile/#codigo","title":"C\u00f3digo","text":""},{"location":"appendix/springbatch/filetofile/#modelo","title":"Modelo","text":"<p>En primer lugar, vamos a crear el modelo dentro del package <code>com.ccsw.tutorialbatch.model</code> de la misma forma que en el ejemplo anterior.</p> Author.java <pre><code>package com.ccsw.tutorialbatch.model;\n\npublic class Author {\n\n    private String name;\n    private String nationality;\n\n    public Author() {\n    }\n\n    public Author(String name, String nationality) {\n        this.name = name;\n        this.nationality = nationality;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getNationality() {\n        return nationality;\n    }\n\n    public void setNationality(String nationality) {\n        this.nationality = nationality;\n    }\n\n    @Override\n    public String toString() {\n        return \"Author [name=\" + getName() + \", nationality=\" + getNationality() + \"]\";\n    }\n\n}\n</code></pre>"},{"location":"appendix/springbatch/filetofile/#reader","title":"Reader","text":"<p>Ahora, como en el caso anterior, emplazamos \u00e9l <code>Reader</code> en la clase donde posteriormente a\u00f1adiremos la configuraci\u00f3n junto al resto de beans, dentro del package <code>com.ccsw.tutorialbatch.config</code>.</p> AuthorBatchConfiguration.java <pre><code>package com.ccsw.tutorialbatch.config;\n\n...\n\n@Configuration\npublic class AuthorBatchConfiguration {\n\n    @Bean\n    public ItemReader&lt;Author&gt; readerAuthor() {\n        return new FlatFileItemReaderBuilder&lt;Author&gt;().name(\"authorItemReader\")\n                .resource(new ClassPathResource(\"author-list.csv\"))\n                .delimited()\n                .names(new String[] { \"name\", \"nationality\" })\n                .fieldSetMapper(new BeanWrapperFieldSetMapper&lt;&gt;() {{\n                    setTargetType(Author.class);\n                }})\n                .build();\n    }\n</code></pre> <p>Para la ingesta de datos vamos a hacer uso de este <code>FlatFileItemReader</code> que nos proporciona Spring Batch. Como se puede observar se le proporciona el fichero a leer y el mapeo a la clase que deseamos. Aqu\u00ed el cat\u00e1logo de Readers que proporciona <code>Spring Batch</code>.</p>"},{"location":"appendix/springbatch/filetofile/#processor","title":"Processor","text":"<p>Posteriormente, emplazamos \u00e9l <code>Processor</code> dentro del package <code>com.ccsw.tutorialbatch.processor</code>.</p> AuthorItemProcessor.java <pre><code>package com.ccsw.tutorialbatch.processor;\n\n\nimport com.ccsw.tutorialbatch.model.Author;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.batch.item.ItemProcessor;\n\n\npublic class AuthorItemProcessor implements ItemProcessor&lt;Author, Author&gt; {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(AuthorItemProcessor.class);\n\n    @Override\n    public Author process(final Author author) {\n        String name = author.getName();\n        String nationality = author.getNationality().toLowerCase() + \"_\" + author.getNationality().toUpperCase();\n\n        Author transformedAuthor = new Author(name, nationality);\n        LOGGER.info(\"Converting ( {} ) into ( {} )\", author, transformedAuthor);\n\n        return transformedAuthor;\n    }\n}\n</code></pre> <p>De la misma forma que en el caso anterior hemos implementado un <code>Processor</code> personalizado, esta clase implementa <code>ItemProcessor</code> donde especificamos de qu\u00e9 clase a qu\u00e9 clase se va a realizar la trasformaci\u00f3n. </p> <p>En nuestro caso, va a ser de <code>Author</code> a <code>Author</code> donde vamos a implementar la l\u00f3gica requerida para este caso de uso.</p>"},{"location":"appendix/springbatch/filetofile/#writer","title":"Writer","text":"<p>Posteriormente, a\u00f1adimos el writer a la clase de configuraci\u00f3n <code>AuthorBatchConfiguration</code> donde ya hab\u00edamos a\u00f1adido <code>Reader</code>.</p> AuthorBatchConfiguration.java <pre><code>package com.ccsw.tutorialbatch.config;\n\n...\n\n@Configuration\npublic class AuthorBatchConfiguration {\n\n    ...\n\n    @Bean\n    public ItemWriter&lt;Author&gt; writerAuthor() {\n        return  new FlatFileItemWriterBuilder&lt;Author&gt;().name(\"writerAuthor\")\n                .resource(new FileSystemResource(\"target/test-outputs/author-output.txt\"))\n                .lineAggregator(new PassThroughLineAggregator&lt;&gt;())\n                .build();\n    }\n\n}\n</code></pre> <p>A diferencia del ejemplo anterior utilizamos <code>FlatFileItemWriter</code> diferente que en este caso nos ayuda a crear un fichero con los datos deseados. Aqu\u00ed el cat\u00e1logo de Writers que proporciona <code>Spring Batch</code>.</p>"},{"location":"appendix/springbatch/filetofile/#step-y-job","title":"Step y Job","text":"<p>Ahora ya podemos a\u00f1adir la configuraci\u00f3n del <code>Step</code> y del <code>Job</code> dentro de la clase de configuraci\u00f3n. La clase completa deber\u00eda quedar de esta forma:</p> AuthorBatchConfiguration.java <pre><code>package com.ccsw.tutorialbatch.config;\n\n\nimport com.ccsw.tutorialbatch.model.Author;\nimport com.ccsw.tutorialbatch.processor.AuthorItemProcessor;\nimport org.springframework.batch.core.Job;\nimport org.springframework.batch.core.Step;\nimport org.springframework.batch.core.job.builder.JobBuilder;\nimport org.springframework.batch.core.launch.support.RunIdIncrementer;\nimport org.springframework.batch.core.repository.JobRepository;\nimport org.springframework.batch.core.step.builder.StepBuilder;\nimport org.springframework.batch.item.ItemProcessor;\nimport org.springframework.batch.item.ItemReader;\nimport org.springframework.batch.item.ItemWriter;\nimport org.springframework.batch.item.file.FlatFileItemReader;\nimport org.springframework.batch.item.file.FlatFileItemWriter;\nimport org.springframework.batch.item.file.builder.FlatFileItemReaderBuilder;\nimport org.springframework.batch.item.file.builder.FlatFileItemWriterBuilder;\nimport org.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper;\nimport org.springframework.batch.item.file.transform.PassThroughLineAggregator;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.io.ClassPathResource;\nimport org.springframework.core.io.FileSystemResource;\nimport org.springframework.transaction.PlatformTransactionManager;\n\n@Configuration\npublic class AuthorBatchConfiguration {\n\n    @Bean\n    public ItemReader&lt;Author&gt; readerAuthor() {\n        return new FlatFileItemReaderBuilder&lt;Author&gt;().name(\"authorItemReader\")\n                .resource(new ClassPathResource(\"author-list.csv\"))\n                .delimited()\n                .names(new String[] { \"name\", \"nationality\" })\n                .fieldSetMapper(new BeanWrapperFieldSetMapper&lt;&gt;() {{\n                    setTargetType(Author.class);\n                }})\n                .build();\n    }\n\n    @Bean\n    public ItemProcessor&lt;Author, Author&gt; processorAuthor() {\n\n        return new AuthorItemProcessor();\n    }\n\n    @Bean\n    public ItemWriter&lt;Author&gt; writerAuthor() {\n        return  new FlatFileItemWriterBuilder&lt;Author&gt;().name(\"writerAuthor\")\n                .resource(new FileSystemResource(\"target/test-outputs/author-output.txt\"))\n                .lineAggregator(new PassThroughLineAggregator&lt;&gt;())\n                .build();\n    }\n\n    @Bean\n    public Step step1Author(JobRepository jobRepository, PlatformTransactionManager transactionManager, ItemReader&lt;Author&gt; readerAuthor, ItemProcessor&lt;Author, Author&gt; processorAuthor, ItemWriter&lt;Author&gt; writerAuthor) {\n        return new StepBuilder(\"step1Author\", jobRepository)\n                .&lt;Author, Author&gt; chunk(10, transactionManager)\n                .reader(readerAuthor)\n                .processor(processorAuthor)\n                .writer(writerAuthor)\n                .build();\n    }\n\n    @Bean\n    public Job jobAuthor(JobRepository jobRepository, Step step1Author) {\n        return new JobBuilder(\"jobAuthor\", jobRepository)\n                .incrementer(new RunIdIncrementer())\n                .flow(step1Author)\n                .end()\n                .build();\n    }\n\n}\n</code></pre> <ul> <li>ItemReader: El bean del <code>Reader</code> que hemos creado anteriormente.</li> <li>ItemProcessor: El bean del <code>Processor</code> que hemos creado anteriormente.</li> <li>ItemWriter: El bean del <code>Writer</code> que hemos creado anteriormente.</li> <li>Step: La creaci\u00f3n del <code>Step</code> se realiza mediante \u00e9l <code>StepBuilder</code> al que le definimos el tama\u00f1o del <code>chunk</code> que es el n\u00famero de elementos procesados por lote y le asignamos los tres beans creados previamente. En este caso solo vamos a tener un \u00fanico <code>Step</code> pero podr\u00edamos tener todos los que quisi\u00e9ramos.</li> <li>Job: Finalmente, debemos definir \u00e9l <code>Job</code> que ser\u00e1 lo que se ejecute al lanzar nuestro proceso. La creaci\u00f3n se hace mediante el builder correspondiente como en el caso anterior. Se asigna el identificador de <code>Job</code>, el conjunto de steps, en este caso solo tenemos uno. En este caso no necesitamos un listener, ya que para verificar el resultado podemos ver el archivo generado.</li> </ul>"},{"location":"appendix/springbatch/filetofile/#fichero-carga","title":"Fichero Carga","text":"<p>Finalmente, debemos crear el fichero que leeremos con los datos de los autores que deseamos procesar.</p> author-list.csv <pre><code>Alan R. Moon,US\nVital Lacerda,PT\nSimone Luciani,IT\nPerepau Llistosella,ES\nMichael Kiesling,DE\nPhil Walker-Harding,US\n</code></pre>"},{"location":"appendix/springbatch/filetofile/#pruebas","title":"Pruebas","text":"<p>Ahora ya tenemos dos <code>Jobs</code> en nuestro batch por lo que debemos especificar en el arranque cual queremos ejecutar.</p> <p>Esto se realiza pasando una <code>VM option</code> en el arranque de la aplicaci\u00f3n: <pre><code>-Dspring.batch.job.name=jobAuthor\n</code></pre> \u00f3 <pre><code>-Dspring.batch.job.name=jobCtegory\n</code></pre></p> <p>Hecho esto y ejecutado el batch, podremos ver la traza de la ejecuci\u00f3n en nuestro <code>log</code> y el fichero generado en el <code>target</code> del proyecto:</p> <pre><code>Job: [FlowJob: [name=jobAuthor]] launched with the following parameters: [{'run.id':'{value=1, type=class java.lang.Long, identifying=true}'}]\nExecuting step: [step1Author]\nConverting ( Author [name=Alan R. Moon, nationality=US] ) into ( Author [name=Alan R. Moon, nationality=us_US] )\nConverting ( Author [name=Vital Lacerda, nationality=PT] ) into ( Author [name=Vital Lacerda, nationality=pt_PT] )\nConverting ( Author [name=Simone Luciani, nationality=IT] ) into ( Author [name=Simone Luciani, nationality=it_IT] )\nConverting ( Author [name=Perepau Llistosella, nationality=ES] ) into ( Author [name=Perepau Llistosella, nationality=es_ES] )\nConverting ( Author [name=Michael Kiesling, nationality=DE] ) into ( Author [name=Michael Kiesling, nationality=de_DE] )\nConverting ( Author [name=Phil Walker-Harding, nationality=US] ) into ( Author [name=Phil Walker-Harding, nationality=us_US] )\nStep: [step1Author] executed in 50ms\nJob: [FlowJob: [name=jobAuthor]] completed with the following parameters: [{'run.id':'{value=1, type=class java.lang.Long, identifying=true}'}] and the following status: [COMPLETED] in 67ms\n</code></pre> author-output.txt <pre><code>Author [name=Alan R. Moon, nationality=us_US]\nAuthor [name=Vital Lacerda, nationality=pt_PT]\nAuthor [name=Simone Luciani, nationality=it_IT]\nAuthor [name=Perepau Llistosella, nationality=es_ES]\nAuthor [name=Michael Kiesling, nationality=de_DE]\nAuthor [name=Phil Walker-Harding, nationality=us_US]\n</code></pre>"},{"location":"appendix/springbatch/intro/","title":"Introducci\u00f3n Batch - Spring Batch","text":""},{"location":"appendix/springbatch/intro/#que-son-los-procesos-batch","title":"Que son los procesos batch?","text":"<p>El proceso batch o procesamiento por lotes es un proceso por el cual un sistema realiza procesos, muchas veces de forma simult\u00e1nea, de forma continuada y secuencial. </p> <p>Normalmente, este tipo de procesos se dividen en peque\u00f1as partes que se realizan de forma cont\u00ednua consiguiendo un mejor rendimiento.</p>"},{"location":"appendix/springbatch/intro/#spring-batch","title":"Spring Batch","text":"<p>Existente multiples soluciones para implementar procesos batch, en nuestro caso vamos a utilizar la soluci\u00f3n que nos ofrece Spring Framework y que est\u00e1 incluido dentro del m\u00f3dulo Spring Batch. </p> <p>Spring Batch es framework de procesos batch ligero y completo dise\u00f1ado para permitir el desarrollo de aplicaciones por lotes robustas, vitales para las operaciones diarias de los sistemas empresariales.</p> <p>Proporciona funciones reutilizables que son esenciales en el procesamiento de grandes vol\u00famenes de registros, incluyendo trazabilidad, gesti\u00f3n de transacciones, estad\u00edsticas de procesamiento de trabajos, reinicio de trabajos, omisi\u00f3n y gesti\u00f3n de recursos. Tambi\u00e9n proporciona servicios y funcionalidades m\u00e1s avanzadas que permitir\u00e1n realizar procesos batch de gran volumen y alto rendimiento mediante t\u00e9cnicas de optimizaci\u00f3n y partici\u00f3n.</p>"},{"location":"appendix/springbatch/intro/#estructura","title":"Estructura","text":"<ul> <li>JobLauncher: Esta pieza es la encargada de la gesti\u00f3n de ejecuciones de los distintos Jobs que componen nuestro sistema. En nuestro ejemplo no vamos a utilizarla, ya que lanzaremos los procesos manualmente para simplificar el c\u00f3digo, pero pod\u00e9is consultar el detalle en la documentaci\u00f3n.</li> <li>JobRepository: Se trata del repositorio que almacena informaci\u00f3n sobre cada Job y los datos de su ejecuci\u00f3n necesario para mantener la trazabilidad del sistema. Para m\u00e1s informaci\u00f3n consultar la documentaci\u00f3n.</li> <li>Job: Se trata de la entidad principal de un proceso batch y es un bloque que contiene uno o varios steps que conforman el proceso a ejecutar.</li> <li>Step: Un <code>Step</code>, como su nombre indica, es un paso en la ejecuci\u00f3n de un <code>Job</code> el cual contiene la l\u00f3gica de negocio de un determinado caso de uso. Un <code>Step</code> habitualmente est\u00e1 formado por un <code>ItemReader</code>, <code>ItemProcessor</code> y <code>ItemWriter</code> o por un <code>Tasklet</code>. La primera opci\u00f3n es relativa a la ejecuci\u00f3n normal de un batch donde asociamos el tama\u00f1o del lote y el procesado es en funci\u00f3n de esta configuraci\u00f3n. Esta es la opci\u00f3n que deber\u00edamos usar en la mayor\u00eda de los casos, mientras que la opci\u00f3n de <code>Tasklet</code> esta reservada para cuando necesitamos realizar operaciones de forma at\u00f3mica. </li> <li>ItemReader: Se trata de la ingesta de datos para un determinado <code>Step</code>. Se puede realizar de forma manual o con los Readers que proporciona <code>Spring Batch</code>.</li> <li>ItemProcessor: En esta pieza se realizan todas las trasformaciones de datos que contenga nuestra l\u00f3gica de negocio.</li> <li>ItemWriter: Es la producci\u00f3n de datos por determinado <code>Step</code>. Se puede realizar de forma manual o con los Writers que proporciona <code>Spring Batch</code>.</li> <li>Tasklet: En los casos que no deseemos realizar ingestas, trasformaci\u00f3n y producci\u00f3n de datos para realizar funcionalidades de forma at\u00f3mica tenemos disponibles los <code>Tasklet</code>.</li> </ul>"},{"location":"appendix/springbatch/intro/#contexto-de-la-aplicacion","title":"Contexto de la aplicaci\u00f3n","text":"<p>Llegados a este punto, \u00bfqu\u00e9 es lo que vamos a hacer en los siguientes pasos?. Bas\u00e1ndonos en el ejemplo del tutorial y en el Contexto de la aplicaci\u00f3n vamos a reinventar nuestros requisitos para poder resolver las problem\u00e1ticas con procesos batch.</p> <p>Ya deber\u00edamos tener claros los conceptos y los actores que compondr\u00e1n nuestro sistema, as\u00ed que, all\u00e1 vamos!!!</p>"},{"location":"appendix/springbatch/summary/","title":"Resumen Batch - Spring Batch","text":""},{"location":"appendix/springbatch/summary/#que-hemos-hecho","title":"\u00bfQu\u00e9 hemos hecho?","text":"<p>Llegados a este punto, ya has podido ver que los procesos batch tienen una filosof\u00eda muy diferente a una aplicaci\u00f3n Spring Boot corriente, ya que el objetivo de los procesos est\u00e1 enfocado en procesado de datos y realizaci\u00f3n de tareas recurrentes.</p> <p>En definitiva, lo que hemos implementado ha sido:</p> <ul> <li> <p>Lectura de fichero y persistencia en BBDD: Este ha sido el primer ejemplo donde hemos visto la estructura b\u00e1sica de un batch y hemos hecho uso de las herramientas que nos proporciona para realizar tareas complejas de forma sencilla.</p> </li> <li> <p>Lectura de fichero y persistencia en fichero: Ejemplo similar al anterior para ilustrar la existencia de otro <code>Writer</code> y su utilizaci\u00f3n.</p> </li> <li> <p>Limpieza: Puesta en escena de la utilizaci\u00f3n de <code>Tasklet</code> que nos permite realizar operaciones at\u00f3micas que no requieran lectura, procesado y escritura para abarcar todo el espectro de posibles requisitos para implementar un proceso.</p> </li> </ul>"},{"location":"appendix/springbatch/summary/#consideraciones","title":"Consideraciones","text":"<p>En estos ejemplos hemos realizado la implementaci\u00f3n lo m\u00e1s sencilla posible de un proceso batch con <code>Spring Batch</code> y aunque no dista mucho de una implementaci\u00f3n para un proyecto real, aqu\u00ed un par de consideraciones a tener en cuenta:</p> <ul> <li> <p>Estructura: A diferencia de Spring Boot no existe un convenio unificado de organizaci\u00f3n de clases y paquetes por lo que se puede ver de muchas formas diferentes. Aqu\u00ed lo importante es que si se utiliza en un determinado proyecto, se debe respetar su estructura por homogeneidad y mantenibilidad del mismo.</p> </li> <li> <p>Ejecuci\u00f3n: La ejecuci\u00f3n de los procesos normalmente se delega en herramientas externas para su programaci\u00f3n y ejecuci\u00f3n. Esto var\u00eda mucho en funci\u00f3n de la arquitectura que tenga implementada un determinado cliente.</p> </li> </ul> <p>Y como siempre, para tener la informaci\u00f3n m\u00e1s actualizada, acude a la documentaci\u00f3n oficial de Spring Batch.</p>"},{"location":"appendix/springbatch/summary/#siguientes-pasos","title":"Siguientes pasos","text":"<p>Ahora te propongo hacer un peque\u00f1o ejercicio para poner aprueba si los conceptos se han consolidado. Puedes realizarlo en el punto Ahora hazlo t\u00fa!</p>"},{"location":"appendix/springcloud/basic/","title":"Listado simple - Spring Boot","text":"<p>A diferencia del tutorial b\u00e1sico de Spring Boot, donde constru\u00edamos una aplicaci\u00f3n monol\u00edtica, ahora vamos a construir multiples servicios por lo que necesitamos crear proyectos separados.</p> <p>Para la creaci\u00f3n de proyecto nos remitimos a la gu\u00eda de instalaci\u00f3n donde se detalla el proceso de creaci\u00f3n de nuevo proyecto Entorno de desarrollo</p> <p>Todos los pasos son exactamente iguales, lo \u00fanico que va a variar es el nombre de nuestro proyecto, que en este caso se va a llamar <code>tutorial-category</code>. El campo que debemos modificar es <code>artifact</code> en Spring Initilizr, el resto de campos se cambiaran autom\u00e1ticamente.</p>"},{"location":"appendix/springcloud/basic/#estructurar-el-codigo-y-buenas-practicas","title":"Estructurar el c\u00f3digo y buenas pr\u00e1cticas","text":"<p>Esta parte de tutorial es una ampliaci\u00f3n de la parte de backend con Spring Boot, por tanto, no se ve a enfocar en las partes b\u00e1sicas aprendidas previamente, sino que se va a explicar el funcionamiento de los micro servicios aplicados al mismo caso de uso. </p> <p>Para cualquier duda sobre la estructura del c\u00f3digo y buenas pr\u00e1cticas, consultar el apartado de Estructura y buenas pr\u00e1cticas, ya que aplican a este caso en el mismo modo.</p>"},{"location":"appendix/springcloud/basic/#codigo","title":"C\u00f3digo","text":"<p>Dado de vamos a implementar el micro servicio Spring Boot de <code>Categor\u00edas</code>, vamos a respetar la misma estructura del Listado simple de la version monol\u00edtica.</p>"},{"location":"appendix/springcloud/basic/#entity-y-dto","title":"Entity y Dto","text":"<p>En primer lugar, vamos a crear la entidad y el DTO dentro del package <code>com.ccsw.tutorialcategory.category.model</code>. Ojo al package que lo hemos renombrado con respecto al listado monol\u00edtico.</p> Category.javaCategoryDto.java <pre><code>package com.ccsw.tutorialcategory.category.model;\n\nimport jakarta.persistence.*;\n\n/**\n * @author ccsw\n *\n */\n@Entity\n@Table(name = \"category\")\npublic class Category {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\", nullable = false)\n    private Long id;\n\n    @Column(name = \"name\", nullable = false)\n    private String name;\n\n    /**\n     * @return id\n     */\n    public Long getId() {\n\n        return this.id;\n    }\n\n    /**\n     * @param id new value of {@link #getId}.\n     */\n    public void setId(Long id) {\n\n        this.id = id;\n    }\n\n    /**\n     * @return name\n     */\n    public String getName() {\n\n        return this.name;\n    }\n\n    /**\n     * @param name new value of {@link #getName}.\n     */\n    public void setName(String name) {\n\n        this.name = name;\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorialcategory.category.model;\n\n/**\n * @author ccsw\n *\n */\npublic class CategoryDto {\n\n    private Long id;\n\n    private String name;\n\n    /**\n     * @return id\n     */\n    public Long getId() {\n\n        return this.id;\n    }\n\n    /**\n     * @param id new value of {@link #getId}.\n     */\n    public void setId(Long id) {\n\n        this.id = id;\n    }\n\n    /**\n     * @return name\n     */\n    public String getName() {\n\n        return this.name;\n    }\n\n    /**\n     * @param name new value of {@link #getName}.\n     */\n    public void setName(String name) {\n\n        this.name = name;\n    }\n\n}\n</code></pre>"},{"location":"appendix/springcloud/basic/#repository-service-y-controller","title":"Repository, Service y Controller","text":"<p>Posteriormente, emplazamos el resto de clases dentro del package <code>com.ccsw.tutorialcategory.category</code>.</p> CategoryRepository.javaCategoryService.javaCategoryServiceImpl.javaCategoryController.java <pre><code>package com.ccsw.tutorialcategory.category;\n\nimport com.ccsw.tutorialcategory.category.model.Category;\nimport org.springframework.data.repository.CrudRepository;\n\n/**\n * @author ccsw\n *\n */\npublic interface CategoryRepository extends CrudRepository&lt;Category, Long&gt; {\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorialcategory.category;\n\n\nimport com.ccsw.tutorialcategory.category.model.Category;\nimport com.ccsw.tutorialcategory.category.model.CategoryDto;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\npublic interface CategoryService {\n\n    /**\n     * Recupera una {@link Category} a partir de su ID\n     *\n     * @param id PK de la entidad\n     * @return {@link Category}\n     */\n    Category get(Long id);\n\n    /**\n     * M\u00e9todo para recuperar todas las {@link Category}\n     *\n     * @return {@link List} de {@link Category}\n     */\n    List&lt;Category&gt; findAll();\n\n    /**\n     * M\u00e9todo para crear o actualizar una {@link Category}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    void save(Long id, CategoryDto dto);\n\n    /**\n     * M\u00e9todo para borrar una {@link Category}\n     *\n     * @param id PK de la entidad\n     */\n    void delete(Long id) throws Exception;\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorialcategory.category;\n\nimport com.ccsw.tutorialcategory.category.model.Category;\nimport com.ccsw.tutorialcategory.category.model.CategoryDto;\nimport jakarta.transaction.Transactional;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Service\n@Transactional\npublic class CategoryServiceImpl implements CategoryService {\n\n    @Autowired\n    CategoryRepository categoryRepository;\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Category get(Long id) {\n\n        return this.categoryRepository.findById(id).orElse(null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public List&lt;Category&gt; findAll() {\n\n        return (List&lt;Category&gt;) this.categoryRepository.findAll();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void save(Long id, CategoryDto dto) {\n\n        Category category;\n\n        if (id == null) {\n            category = new Category();\n        } else {\n            category = this.get(id);\n        }\n\n        category.setName(dto.getName());\n\n        this.categoryRepository.save(category);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void delete(Long id) throws Exception {\n\n        if(this.get(id) == null){\n            throw new Exception(\"Not exists\");\n        }\n\n        this.categoryRepository.deleteById(id);\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorialcategory.category;\n\nimport com.ccsw.tutorialcategory.category.model.Category;\nimport com.ccsw.tutorialcategory.category.model.CategoryDto;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport org.modelmapper.ModelMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * @author ccsw\n *\n */\n@Tag(name = \"Category\", description = \"API of Category\")\n@RequestMapping(value = \"/category\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class CategoryController {\n\n    @Autowired\n    CategoryService categoryService;\n\n    @Autowired\n    ModelMapper mapper;\n\n    /**\n     * M\u00e9todo para recuperar todas las {@link Category}\n     *\n     * @return {@link List} de {@link CategoryDto}\n     */\n    @Operation(summary = \"Find\", description = \"Method that return a list of Categories\"\n    )\n    @RequestMapping(path = \"\", method = RequestMethod.GET)\n    public List&lt;CategoryDto&gt; findAll() {\n\n        List&lt;Category&gt; categories = this.categoryService.findAll();\n\n        return categories.stream().map(e -&gt; mapper.map(e, CategoryDto.class)).collect(Collectors.toList());\n    }\n\n    /**\n     * M\u00e9todo para crear o actualizar una {@link Category}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    @Operation(summary = \"Save or Update\", description = \"Method that saves or updates a Category\"\n    )\n    @RequestMapping(path = { \"\", \"/{id}\" }, method = RequestMethod.PUT)\n    public void save(@PathVariable(name = \"id\", required = false) Long id, @RequestBody CategoryDto dto) {\n\n        this.categoryService.save(id, dto);\n    }\n\n    /**\n     * M\u00e9todo para borrar una {@link Category}\n     *\n     * @param id PK de la entidad\n     */\n    @Operation(summary = \"Delete\", description = \"Method that deletes a Category\")\n    @RequestMapping(path = \"/{id}\", method = RequestMethod.DELETE)\n    public void delete(@PathVariable(\"id\") Long id) throws Exception {\n\n        this.categoryService.delete(id);\n    }\n\n}\n</code></pre>"},{"location":"appendix/springcloud/basic/#sql-y-configuracion","title":"SQL y Configuraci\u00f3n","text":"<p>Finalmente, debemos crear el mismo fichero de inicializaci\u00f3n de base de datos con solo los datos de categor\u00edas y modificar ligeramente la configuraci\u00f3n inicial para a\u00f1adir un puerto manualmente. Esto es necesario ya que vamos a levantar varios servicios simult\u00e1neamente y necesitaremos levantarlos en puertos diferentes para que no colisionen entre ellos.</p> data.sqlapplication.properties <pre><code>INSERT INTO category(name) VALUES ('Eurogames');\nINSERT INTO category(name) VALUES ('Ameritrash');\nINSERT INTO category(name) VALUES ('Familiar');\n</code></pre> <pre><code>server.port=8091\n\n#Database\nspring.datasource.url=jdbc:h2:mem:testdb\nspring.datasource.username=sa\nspring.datasource.password=sa\nspring.datasource.driver-class-name=org.h2.Driver\n\nspring.jpa.database-platform=org.hibernate.dialect.H2Dialect\nspring.jpa.defer-datasource-initialization=true\nspring.jpa.show-sql=true\n\nspring.h2.console.enabled=true\n</code></pre>"},{"location":"appendix/springcloud/basic/#pruebas","title":"Pruebas","text":"<p>Ahora si arrancamos la aplicaci\u00f3n server y abrimos el Postman podemos realizar las mismas pruebas del apartado de Listado simple pero esta vez apuntado al puerto <code>8091</code>.</p>"},{"location":"appendix/springcloud/basic/#siguientes-pasos","title":"Siguientes pasos","text":"<p>Con esto ya tendr\u00edamos nuestro primer servicio separado. Podr\u00edamos conectar el frontend a este servicio, pero a medida que nuestra aplicaci\u00f3n creciera en n\u00famero de servicios ser\u00eda un poco engorroso todo, as\u00ed que todav\u00eda no lo vamos a conectar hasta que no tengamos toda la infraestructura.</p> <p>Vamos a convertir en micro servicio el siguiente listado.</p>"},{"location":"appendix/springcloud/filtered/","title":"Listado filtrado - Spring Boot","text":"<p>Al igual que en los caos anteriores vamos a crear un nuevo proyecto que contendr\u00e1 un nuevo micro servicio.</p> <p>Para la creaci\u00f3n de proyecto nos remitimos a la gu\u00eda de instalaci\u00f3n donde se detalla el proceso de creaci\u00f3n de nuevo proyecto Entorno de desarrollo</p> <p>Todos los pasos son exactamente iguales, lo \u00fanico que va a variar, es el nombre de nuestro proyecto, que en este caso se va a llamar <code>tutorial-game</code>. El campo que debemos modificar es <code>artifact</code> en Spring Initilizr, el resto de campos se cambiaran autom\u00e1ticamente.</p>"},{"location":"appendix/springcloud/filtered/#codigo","title":"C\u00f3digo","text":"<p>Dado de vamos a implementar el micro servicio Spring Boot de <code>Juegos</code>, vamos a respetar la misma estructura del Listado filtrado de la version monol\u00edtica.</p>"},{"location":"appendix/springcloud/filtered/#criteria","title":"Criteria","text":"<p>En primer lugar, vamos a a\u00f1adir la clase que necesitamos para realizar el filtrado y vimos en la version monol\u00edtica del tutorial en el package <code>com.ccsw.tutorialgame.common.criteria</code>.</p> SearchCriteria.java <pre><code>package com.ccsw.tutorialgame.common.criteria;\n\npublic class SearchCriteria {\n\n    private String key;\n    private String operation;\n    private Object value;\n\n    public SearchCriteria(String key, String operation, Object value) {\n\n        this.key = key;\n        this.operation = operation;\n        this.value = value;\n    }\n\n    public String getKey() {\n        return key;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public String getOperation() {\n        return operation;\n    }\n\n    public void setOperation(String operation) {\n        this.operation = operation;\n    }\n\n    public Object getValue() {\n        return value;\n    }\n\n    public void setValue(Object value) {\n        this.value = value;\n    }\n\n}\n</code></pre>"},{"location":"appendix/springcloud/filtered/#entity-y-dto","title":"Entity y Dto","text":"<p>Seguimos con la entidad y el DTO dentro del package <code>com.ccsw.tutorialgame.game.model</code>. En este punto, f\u00edjate que nuestro modelo de <code>Entity</code> no tiene relaci\u00f3n con la tabla <code>Author</code> ni <code>Category</code> ya que estos dos objetos no pertenecen a nuestro dominio y se gestionan desde otro micro servicio. Lo que tendremos ahora ser\u00e1 el identificador del registro que hace referencia a esos objetos. Ya no usaremos <code>@JoinColumn</code> porque en nuestro modelo no existen esas tablas relacionadas.</p> <p>Sin embargo el Dto si que utiliza relaciones, ya que son relaciones de negocio (en el <code>Service</code>) y no son relaciones de dominio (en BBDD o <code>Repository</code>)</p> Game.javaGameDto.java <pre><code>package com.ccsw.tutorialgame.game.model;\n\nimport jakarta.persistence.*;\n\n\n/**\n * @author ccsw\n *\n */\n@Entity\n@Table(name = \"game\")\npublic class Game {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\", nullable = false)\n    private Long id;\n\n    @Column(name = \"title\", nullable = false)\n    private String title;\n\n    @Column(name = \"age\", nullable = false)\n    private String age;\n\n    @Column(name = \"category_id\", nullable = false)\n    private Long idCategory;\n\n    @Column(name = \"author_id\", nullable = false)\n    private Long idAuthor;\n\n    /**\n     * @return id\n     */\n    public Long getId() {\n\n        return this.id;\n    }\n\n    /**\n     * @param id new value of {@link #getId}.\n     */\n    public void setId(Long id) {\n\n        this.id = id;\n    }\n\n    /**\n     * @return title\n     */\n    public String getTitle() {\n\n        return this.title;\n    }\n\n    /**\n     * @param title new value of {@link #getTitle}.\n     */\n    public void setTitle(String title) {\n\n        this.title = title;\n    }\n\n    /**\n     * @return age\n     */\n    public String getAge() {\n\n        return this.age;\n    }\n\n    /**\n     * @param age new value of {@link #getAge}.\n     */\n    public void setAge(String age) {\n\n        this.age = age;\n    }\n\n    /**\n     * @return idCategory\n     */\n    public Long getIdCategory() {\n\n        return this.idCategory;\n    }\n\n    /**\n     * @param idCategory new value of {@link #getIdCategory}.\n     */\n    public void setIdCategory(Long idCategory) {\n\n        this.idCategory = idCategory;\n    }\n\n    /**\n     * @return idAuthor\n     */\n    public Long getIdAuthor() {\n\n        return this.idAuthor;\n    }\n\n    /**\n     * @param idAuthor new value of {@link #getIdAuthor}.\n     */\n    public void setIdAuthor(Long idAuthor) {\n\n        this.idAuthor = idAuthor;\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorialgame.game.model;\n\n\nimport com.ccsw.tutorialgame.author.model.AuthorDto;\nimport com.ccsw.tutorialgame.category.model.CategoryDto;\n\n/**\n * @author ccsw\n *\n */\npublic class GameDto {\n\n    private Long id;\n\n    private String title;\n\n    private String age;\n\n    private Long idCategory;\n\n    private Long idAuthor;\n\n    /**\n     * @return id\n     */\n    public Long getId() {\n\n        return this.id;\n    }\n\n    /**\n     * @param id new value of {@link #getId}.\n     */\n    public void setId(Long id) {\n\n        this.id = id;\n    }\n\n    /**\n     * @return title\n     */\n    public String getTitle() {\n\n        return this.title;\n    }\n\n    /**\n     * @param title new value of {@link #getTitle}.\n     */\n    public void setTitle(String title) {\n\n        this.title = title;\n    }\n\n    /**\n     * @return age\n     */\n    public String getAge() {\n\n        return this.age;\n    }\n\n    /**\n     * @param age new value of {@link #getAge}.\n     */\n    public void setAge(String age) {\n\n        this.age = age;\n    }\n\n    /**\n     * @return idCategory\n     */\n    public Long getIdCategory() {\n\n        return this.idCategory;\n    }\n\n    /**\n     * @param idCategory new value of {@link #getIdCategory}.\n     */\n    public void setIdCategory(Long idCategory) {\n\n        this.idCategory = idCategory;\n    }\n\n    /**\n     * @return idAuthor\n     */\n    public Long getIdAuthor() {\n\n        return this.idAuthor;\n    }\n\n    /**\n     * @param idAuthor new value of {@link #getIdAuthor}.\n     */\n    public void setIdAuthor(Long idAuthor) {\n\n        this.idAuthor = idAuthor;\n    }\n\n}\n</code></pre>"},{"location":"appendix/springcloud/filtered/#repository-service-controller","title":"Repository, Service, Controller","text":"<p>Posteriormente, emplazamos el resto de clases dentro del package <code>com.ccsw.tutorialgame.game</code>.</p> GameRepository.javaGameService.javaGameSpecification.javaGameServiceImpl.javaGameController.java <pre><code>package com.ccsw.tutorialgame.game;\n\nimport com.ccsw.tutorialgame.game.model.Game;\nimport org.springframework.data.jpa.repository.JpaSpecificationExecutor;\nimport org.springframework.data.repository.CrudRepository;\n\n/**\n * @author ccsw\n *\n */\npublic interface GameRepository extends CrudRepository&lt;Game, Long&gt;, JpaSpecificationExecutor&lt;Game&gt; {\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorialgame.game;\n\nimport com.ccsw.tutorialgame.game.model.Game;\nimport com.ccsw.tutorialgame.game.model.GameDto;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\npublic interface GameService {\n\n    /**\n     * Recupera los juegos filtrando opcionalmente por t\u00edtulo y/o categor\u00eda\n     *\n     * @param title t\u00edtulo del juego\n     * @param idCategory PK de la categor\u00eda\n     * @return {@link List} de {@link Game}\n     */\n    List&lt;Game&gt; find(String title, Long idCategory);\n\n    /**\n     * Guarda o modifica un juego, dependiendo de si el identificador est\u00e1 o no informado\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    void save(Long id, GameDto dto);\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorialgame.game;\n\nimport com.ccsw.tutorialgame.common.criteria.SearchCriteria;\nimport com.ccsw.tutorialgame.game.model.Game;\nimport jakarta.persistence.criteria.*;\nimport org.springframework.data.jpa.domain.Specification;\n\n\npublic class GameSpecification implements Specification&lt;Game&gt; {\n\n    private static final long serialVersionUID = 1L;\n\n    private final SearchCriteria criteria;\n\n    public GameSpecification(SearchCriteria criteria) {\n\n        this.criteria = criteria;\n    }\n\n    @Override\n    public Predicate toPredicate(Root&lt;Game&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder builder) {\n        if (criteria.getOperation().equalsIgnoreCase(\":\") &amp;&amp; criteria.getValue() != null) {\n            Path&lt;String&gt; path = getPath(root);\n            if (path.getJavaType() == String.class) {\n                return builder.like(path, \"%\" + criteria.getValue() + \"%\");\n            } else {\n                return builder.equal(path, criteria.getValue());\n            }\n        }\n        return null;\n    }\n\n    private Path&lt;String&gt; getPath(Root&lt;Game&gt; root) {\n        String key = criteria.getKey();\n        String[] split = key.split(\"[.]\", 0);\n\n        Path&lt;String&gt; expression = root.get(split[0]);\n        for (int i = 1; i &lt; split.length; i++) {\n            expression = expression.get(split[i]);\n        }\n\n        return expression;\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorialgame.game;\n\nimport com.ccsw.tutorialgame.common.criteria.SearchCriteria;\nimport com.ccsw.tutorialgame.game.model.Game;\nimport com.ccsw.tutorialgame.game.model.GameDto;\nimport jakarta.transaction.Transactional;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.jpa.domain.Specification;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Service\n@Transactional\npublic class GameServiceImpl implements GameService {\n\n    @Autowired\n    GameRepository gameRepository;\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public List&lt;Game&gt; find(String title, Long idCategory) {\n\n        GameSpecification titleSpec = new GameSpecification(new SearchCriteria(\"title\", \":\", title));\n        GameSpecification categorySpec = new GameSpecification(new SearchCriteria(\"idCategory\", \":\", idCategory));\n\n        Specification&lt;Game&gt; spec = Specification.where(titleSpec).and(categorySpec);\n\n        return this.gameRepository.findAll(spec);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void save(Long id, GameDto dto) {\n\n        Game game;\n\n        if (id == null) {\n            game = new Game();\n        } else {\n            game = this.gameRepository.findById(id).orElse(null);\n        }\n\n        BeanUtils.copyProperties(dto, game, \"id\");\n\n        game.setIdAuthor(dto.getIdAuthor());\n        game.setIdCategory(dto.getIdCategory());\n\n        this.gameRepository.save(game);\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorialgame.game;\n\nimport com.ccsw.tutorialgame.game.model.Game;\nimport com.ccsw.tutorialgame.game.model.GameDto;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport org.modelmapper.ModelMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * @author ccsw\n *\n */\n@Tag(name = \"Game\", description = \"API of Game\")\n@RequestMapping(value = \"/game\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class GameController {\n\n    @Autowired\n    GameService gameService;\n\n    @Autowired\n    ModelMapper mapper;\n\n    /**\n     * M\u00e9todo para recuperar una lista de {@link Game}\n     *\n     * @param title t\u00edtulo del juego\n     * @param idCategory PK de la categor\u00eda\n     * @return {@link List} de {@link GameDto}\n     */\n    @Operation(summary = \"Find\", description = \"Method that return a filtered list of Games\")\n    @RequestMapping(path = \"\", method = RequestMethod.GET)\n    public List&lt;GameDto&gt; find(@RequestParam(value = \"title\", required = false) String title,\n                              @RequestParam(value = \"idCategory\", required = false) Long idCategory) {\n\n        List&lt;Game&gt; game = this.gameService.find(title, idCategory);\n\n        return game.stream().map(e -&gt; mapper.map(e, GameDto.class)).collect(Collectors.toList());\n    }\n\n    /**\n     * M\u00e9todo para crear o actualizar un {@link Game}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    @Operation(summary = \"Save or Update\", description = \"Method that saves or updates a Game\")\n    @RequestMapping(path = { \"\", \"/{id}\" }, method = RequestMethod.PUT)\n    public void save(@PathVariable(name = \"id\", required = false) Long id, @RequestBody GameDto dto) {\n\n        gameService.save(id, dto);\n    }\n\n}\n</code></pre>"},{"location":"appendix/springcloud/filtered/#sql-y-configuracion","title":"SQL y Configuraci\u00f3n","text":"<p>Finalmente, debemos crear el script de inicializaci\u00f3n de base de datos con solo los datos de juegos y modificar ligeramente la configuraci\u00f3n inicial para a\u00f1adir un puerto manualmente para poder tener multiples micro servicios funcionando simult\u00e1neamente.</p> data.sqlapplication.properties <pre><code>INSERT INTO game(title, age, category_id, author_id) VALUES ('On Mars', '14', 1, 2);\nINSERT INTO game(title, age, category_id, author_id) VALUES ('Aventureros al tren', '8', 3, 1);\nINSERT INTO game(title, age, category_id, author_id) VALUES ('1920: Wall Street', '12', 1, 4);\nINSERT INTO game(title, age, category_id, author_id) VALUES ('Barrage', '14', 1, 3);\nINSERT INTO game(title, age, category_id, author_id) VALUES ('Los viajes de Marco Polo', '12', 1, 3);\nINSERT INTO game(title, age, category_id, author_id) VALUES ('Azul', '8', 3, 5);\n</code></pre> <pre><code>server.port=8093\n\n#Database\nspring.datasource.url=jdbc:h2:mem:testdb\nspring.datasource.username=sa\nspring.datasource.password=sa\nspring.datasource.driver-class-name=org.h2.Driver\n\nspring.jpa.database-platform=org.hibernate.dialect.H2Dialect\nspring.jpa.defer-datasource-initialization=true\nspring.jpa.show-sql=true\n\nspring.h2.console.enabled=true\n</code></pre>"},{"location":"appendix/springcloud/filtered/#pruebas","title":"Pruebas","text":"<p>Ahora si arrancamos la aplicaci\u00f3n server y abrimos el Postman podemos realizar las mismas pruebas del apartado de Listado filtrado pero esta vez apuntado al puerto <code>8093</code>.</p> <p>F\u00edjate que cuando probemos el listado de juegos, devolver\u00e1 identificadores en <code>idAuthor</code> y <code>idCategory</code>, y no objetos como funcionaba hasta ahora en la aplicaci\u00f3n monol\u00edtica. As\u00ed que las pruebas que realices para insertar tambi\u00e9n deben utilizar esas propiedades y NO objetos.</p>"},{"location":"appendix/springcloud/filtered/#siguientes-pasos","title":"Siguientes pasos","text":"<p>En este punto ya tenemos un micro servicio de categor\u00edas en el puerto <code>8091</code>, un micro servicio de autores en el puerto <code>8092</code> y un \u00faltimo micro servicio de juegos en el puerto <code>8093</code>. </p> <p>Si ahora fueramos a conectarlo con el frontend tendr\u00edamos dos problemas:</p> <ul> <li>Por un lado, el frontend debe recordar la IP y el puerto en el que se encuentra cada servicio. Adem\u00e1s, este podr\u00eda cambiar si lo desplegamos en nube o lo movemos de servidor, y el frontend deber\u00eda ser capaz de refrescarse para actualizar la informaci\u00f3n.</li> <li>Por otro lado, como hemos comentado, se ha cambiado el contrato del endpoint de juegos. Ahora ya no devuelve la informaci\u00f3n de <code>author</code> y <code>category</code> sino que devuelve su ID. Esto obliga al frontend a tener que hacer dos llamadas extra para completar la informaci\u00f3n. Estar\u00edamos llevando l\u00f3gica de negocio al frontend y esto no nos convence.</li> </ul> <p>Para poder solverntar ambos problemas, necesitamos conectar todos nuestros micro servicios con una infraestructura que nos ayudar\u00e1 a gestionar todo el ecosistema de micro servicios. Vamos all\u00e1 con el \u00faltimo punto.</p>"},{"location":"appendix/springcloud/infra/","title":"Infraestructura - Spring Cloud","text":"<p>Creados los tres micro servicios que compondr\u00e1n nuestro aplicativo, ya podemos empezar con la creaci\u00f3n de las piezas de infraestructura que ser\u00e1n las encargadas de realizar la orquestaci\u00f3n.</p>"},{"location":"appendix/springcloud/infra/#service-discovery-eureka","title":"Service Discovery - Eureka","text":"<p>Para esta pieza hay muchas aplicaciones de mercado, incluso los propios proveedores de cloud tiene la suya propia, pero en este caso, vamos a utilizar la que ofrece Spring Cloud, as\u00ed que vamos a crear un proyecto de una forma similar a la que estamos acostumbrados.</p>"},{"location":"appendix/springcloud/infra/#crear-el-servicio","title":"Crear el servicio","text":"<p>Volviendo una vez m\u00e1s a Spring Initializr seleccionaremos los siguientes datos:</p> <ul> <li>Tipo de proyecto: Maven</li> <li>Lenguage: Java</li> <li>Versi\u00f3n Spring boot: 3.0.4 (o alguna similar)</li> <li>Group: com.ccsw</li> <li>ArtifactId: tutorial-eureka</li> <li>Versi\u00f3n Java: 19</li> <li>Dependencias: Eureka Server</li> </ul> <p></p> <p>Es importante que a\u00f1adamos la dependencia de <code>Eureka Server</code> para que sea capaz de ejecutar el proyecto como si fuera un servidor Eureka.</p>"},{"location":"appendix/springcloud/infra/#configurar-el-servicio","title":"Configurar el servicio","text":"<p>Importamos el proyecto dentro del IDE y ya solo nos queda activar el servidor y configurarlo.</p> <p>En primer lugar, a\u00f1adimos la anotaci\u00f3n que habilita el servidor de Eureka.</p> TutorialEurekaApplication.java <pre><code>package com.ccsw.tutorialeureka;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;\n\n@SpringBootApplication\n@EnableEurekaServer\npublic class TutorialEurekaApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(TutorialEurekaApplication.class, args);\n    }\n\n}\n</code></pre> <p>Ahora debemos a\u00f1adir las configuraciones necesarias. En primer lugar para facilitar la visualizaci\u00f3n de las propiedades vamos a renombrar nuestro fichero <code>application.properties</code> a <code>application.yml</code>.  Hecho esto, a\u00f1adimos la configuraci\u00f3n de puerto que ya conocemos y a\u00f1adimos directivas sobre que Eureka no se registre a s\u00ed mismo dentro del cat\u00e1logo de servicios.</p> application.yml <pre><code>server:\n  port: 8761\neureka:\n  client:\n    registerWithEureka: false\n    fetchRegistry: false\n</code></pre>"},{"location":"appendix/springcloud/infra/#probar-el-servicio","title":"Probar el servicio","text":"<p>Hechas estas sencillas configuraciones y arrancando el proyecto, nos dirigimos a la <code>http://localhost/8761</code> donde podemos ver la interfaz de Eureka y si miramos con detenimiento, vemos que el cat\u00e1logo de servicios aparece vac\u00edo, ya que a\u00fan no se ha registrado ninguno de ellos.</p>"},{"location":"appendix/springcloud/infra/#micro-servicios","title":"Micro servicios","text":"<p>Ahora que ya tenemos disponible Eureka, ya podemos proceder a registrar nuestros micro servicios dentro del cat\u00e1logo. Para ello vamos a realizar las mismas modificaciones sobre los tres micro servicios. Recuerda que hay que realizarlo sobre los tres para que se registren todos.</p>"},{"location":"appendix/springcloud/infra/#configurar-micro-servicios","title":"Configurar micro servicios","text":"<p>Para este fin debemos a\u00f1adir una nueva dependencia dentro del <code>pom.xml</code> y modificar la configuraci\u00f3n del proyecto.</p> pom.xmlapplication.properties <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;3.0.4&lt;/version&gt;\n        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;/parent&gt;\n    &lt;groupId&gt;com.ccsw&lt;/groupId&gt;\n    &lt;artifactId&gt;tutorial-XXX&lt;/artifactId&gt; &lt;!-- Cada proyecto tiene su configaci\u00f3n propia, NO modificar --&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;tutorial-XXX&lt;/name&gt; &lt;!-- Cada proyecto tiene su configaci\u00f3n propia, NO modificar --&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n    &lt;properties&gt;\n        &lt;java.version&gt;19&lt;/java.version&gt;\n        &lt;spring-cloud.version&gt;2022.0.1&lt;/spring-cloud.version&gt;\n    &lt;/properties&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springdoc&lt;/groupId&gt;\n            &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;\n            &lt;version&gt;2.0.3&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;\n            &lt;version&gt;8.0.0.Final&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;net.sf.dozer&lt;/groupId&gt;\n            &lt;artifactId&gt;dozer&lt;/artifactId&gt;\n            &lt;version&gt;5.5.1&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n            &lt;artifactId&gt;h2&lt;/artifactId&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;\n                &lt;version&gt;${spring-cloud.version}&lt;/version&gt;\n                &lt;type&gt;pom&lt;/type&gt;\n                &lt;scope&gt;import&lt;/scope&gt;\n            &lt;/dependency&gt;\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <pre><code>spring.application.name=spring-cloud-eureka-client-XXX\nserver.port=809X\n\n#Database\nspring.datasource.url=jdbc:h2:mem:testdb\nspring.datasource.username=sa\nspring.datasource.password=sa\nspring.datasource.driver-class-name=org.h2.Driver\n\nspring.jpa.database-platform=org.hibernate.dialect.H2Dialect\nspring.jpa.defer-datasource-initialization=true\nspring.jpa.show-sql=true\n\nspring.h2.console.enabled=true\n\n#Eureka\neureka.client.serviceUrl.defaultZone=${EUREKA_URI:http://localhost:8761/eureka}\neureka.instance.preferIpAddress=true\n</code></pre> <p>Como podemos observar, lo que hemos hecho, es a\u00f1adir la dependencia de Eureka Client y le hemos comunicado a cada micro servicio donde tenemos arrancado Eureka. De este modo al arrancar cada micro servicio, este se registrar\u00e1 autom\u00e1ticamente dentro de Eureka.</p> <p>Para poder diferenciar cada micro servicio, estos tienen su configuraci\u00f3n de nombre y puerto (mantenemos el puerto que hab\u00edamos configurado en pasos previos):</p> <ul> <li>Categor\u00edas: <code>spring.application.name=spring-cloud-eureka-client-category</code></li> <li>Autores: <code>spring.application.name=spring-cloud-eureka-client-author</code></li> <li>Juegos: <code>spring.application.name=spring-cloud-eureka-client-game</code></li> </ul> <p>Nombres en vez de rutas</p> <p>Estos nombres ser\u00e1n por los que vamos a identificar cada micro servicio dentro de Eureka que ser\u00e1 quien conozca las rutas de los mismos, asi cuando queramos realizar redirecciones a estos no necesitaremos conocerlas rutas ni los puertos de los mismos, con proporcionar los nombres tendremos la informaci\u00f3n completa de como llegar a ellos.</p>"},{"location":"appendix/springcloud/infra/#probar-micro-servicios","title":"Probar micro servicios","text":"<p>Hechas estas configuraciones y arrancados los micro servicios, volvemos a dirigirnos a Eureka en <code>http://localhost/8761</code> donde podemos ver que estos aparecen en el listado de servicios registrados.</p>"},{"location":"appendix/springcloud/infra/#gateway","title":"Gateway","text":"<p>Para esta pieza, de nuevo, hay muchas implementaciones y aplicaciones de mercado, pero nosotros vamos a utilizar la de Spring Cloud, as\u00ed que vamos a crear un nuevo proyecto de una forma similar a la de Eureka.</p>"},{"location":"appendix/springcloud/infra/#crear-el-servicio_1","title":"Crear el servicio","text":"<p>Volviendo una vez m\u00e1s a Spring Initializr seleccionaremos los siguientes datos:</p> <ul> <li>Tipo de proyecto: Maven</li> <li>Lenguage: Java</li> <li>Versi\u00f3n Spring boot: 3.0.4 (o alguna similar)</li> <li>Group: com.ccsw</li> <li>ArtifactId: tutorial-gateway</li> <li>Versi\u00f3n Java: 19</li> <li>Dependencias: Gateway, Eureka Client</li> </ul> <p></p> <p>Ojo con las dependencias de <code>Gateway</code> y de <code>Eureka Client</code> que debemos a\u00f1adir.</p>"},{"location":"appendix/springcloud/infra/#configurar-el-servicio_1","title":"Configurar el servicio","text":"<p>De nuevo lo importamos en nuestro IDE y pasamos a a\u00f1adir las configuraciones pertinentes.</p> <p>Al igual que en el caso de Eureka vamos a renombrar nuestro fichero <code>application.properties</code> a <code>application.yml</code>.</p> application.yml <pre><code>server:\n  port: 8080\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8761/eureka\nspring:\n  application:\n    name: spring-cloud-eureka-client-gateway\n  cloud:\n    gateway:\n      default-filters:\n        - DedupeResponseHeader=Access-Control-Allow-Credentials Access-Control-Allow-Origin\n      globalcors:\n        corsConfigurations:\n          '[/**]':\n             allowedOrigins: \"*\"\n             allowedMethods: \"*\"\n             allowedHeaders: \"*\"\n      routes:\n        - id: category\n          uri: lb://SPRING-CLOUD-EUREKA-CLIENT-CATEGORY\n          predicates:\n            - Path=/category/**\n        - id: author\n          uri: lb://SPRING-CLOUD-EUREKA-CLIENT-AUTHOR\n          predicates:\n            - Path=/author/**\n        - id: game\n          uri: lb://SPRING-CLOUD-EUREKA-CLIENT-GAME\n          predicates:\n            - Path=/game/**\n</code></pre> <p>Lo que hemos hecho aqu\u00ed es configurar el puerto como <code>8080</code> ya que el <code>Gateway</code> va a ser nuestro punto de acceso y el encargado de redirigir cada petici\u00f3n al micro servicio correcto.</p> <p>Posteriormente hemos configurado el cliente de Eureka para que el Gateway establezca comunicaci\u00f3n con Eureka que hemos configurado previamente para, en primer lugar, registrarse como un cliente y seguidamente obtener informaci\u00f3n del cat\u00e1logo de servicios existentes.</p> <p>El paso siguiente es darle un nombre a la aplicaci\u00f3n para que se registre en Eureka y a\u00f1adir configuraci\u00f3n de CORS para que cuando realicemos las llamadas desde navegador pueda realizar la redirecci\u00f3n correctamente.</p> <p>Finalmente a\u00f1adimos las directrices de redirecci\u00f3n al Gateway indic\u00e1ndole los nombres de los micro servicios con los que estos se han registrado en Eureka junto a los predicados que incluyen las rutas parciales que queremos que sean redirigidas a cada micro servicio.</p> <p>Con esto nos queda la siguiente configuraci\u00f3n:</p> <ul> <li>Las rutas que incluyan en su path <code>category</code> redirigir\u00e1n al micro servicio de <code>Categorias</code></li> <li>Las rutas que incluyan en su path <code>author</code> redirigir\u00e1n al micro servicio de <code>Autores</code></li> <li>Las rutas que incluyan en su path <code>game</code> redirigir\u00e1n al micro servicio de <code>Juegos</code></li> </ul>"},{"location":"appendix/springcloud/infra/#probar-el-servicio_1","title":"Probar el servicio","text":"<p>Hechas esto y arrancado el proyecto, volvemos a dirigirnos a Eureka en <code>http://localhost/8761</code> donde podemos ver que el Gateway se ha registrado correctamente junto al resto de clientes.</p> <p></p>"},{"location":"appendix/springcloud/infra/#feign-client","title":"Feign Client","text":"<p>El \u00faltimo paso es la implementaci\u00f3n de la comunicaci\u00f3n entre los micro servicios, en este caso necesitamos que nuestro micro servicio de <code>Game</code> obtenga datos de <code>Category</code> y <code>Author</code> para poder servir informaci\u00f3n completa de los <code>Game</code> ya que en su modelo solo posee los identificadores. Si record\u00e1is, est\u00e1bamos respondiendo solamente con los <code>id</code>.</p>"},{"location":"appendix/springcloud/infra/#configurar-el-servicio_2","title":"Configurar el servicio","text":"<p>Para la comunicaci\u00f3n entre los distintos servicios, Spring Cloud nos prove de <code>Feign Clients</code> que ofrecen una interfaz muy sencilla de comunicaci\u00f3n y que utiliza a la perfecci\u00f3n la infraestructura que ya hemos construido.</p> <p>En primer lugar debemos a\u00f1adir la dependencia necesaria dentro de nuestro pom.xml del micro servicio de <code>Game</code>.</p> pom.xml <pre><code>...\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n            &lt;artifactId&gt;h2&lt;/artifactId&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;/dependency&gt;\n...\n</code></pre> <p>El siguiente paso es habilitar el uso de los <code>Feign Clients</code> mediante la anotaci\u00f3n de SpringCloud.</p> TutorialGameApplication.java <pre><code>package com.ccsw.tutorialgame;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.openfeign.EnableFeignClients;\n\n@SpringBootApplication\n@EnableFeignClients\npublic class TutorialGameApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(TutorialGameApplication.class, args);\n    }\n\n}\n</code></pre>"},{"location":"appendix/springcloud/infra/#configurar-los-clientes","title":"Configurar los clientes","text":"<p>Realizadas las configuraciones ya podemos realizar los cambios necesarios en nuestro c\u00f3digo para implementar la comunicaci\u00f3n. En primer lugar vamos a crear los clientes de <code>Categor\u00edas</code> y <code>Autores</code>.</p> CategoryClient.javaAuthorClient.java <pre><code>package com.ccsw.tutorialgame.category;\n\nimport com.ccsw.tutorialgame.category.model.CategoryDto;\nimport org.springframework.cloud.openfeign.FeignClient;\nimport org.springframework.web.bind.annotation.GetMapping;\n\nimport java.util.List;\n\n@FeignClient(value = \"SPRING-CLOUD-EUREKA-CLIENT-CATEGORY\", url = \"http://localhost:8080\")\npublic interface CategoryClient {\n\n    @GetMapping(value = \"/category\")\n    List&lt;CategoryDto&gt; findAll();\n}\n</code></pre> <pre><code>package com.ccsw.tutorialgame.author;\n\nimport com.ccsw.tutorialgame.author.model.AuthorDto;\nimport org.springframework.cloud.openfeign.FeignClient;\nimport org.springframework.web.bind.annotation.GetMapping;\n\nimport java.util.List;\n\n@FeignClient(value = \"SPRING-CLOUD-EUREKA-CLIENT-AUTHOR\", url = \"http://localhost:8080\")\npublic interface AuthorClient {\n\n    @GetMapping(value = \"/author\")\n    List&lt;AuthorDto&gt; findAll();\n}\n</code></pre> <p>Lo que hacemos aqu\u00ed es crear una simple interfaz donde a\u00f1adimos la configuraci\u00f3n del <code>Feign Client</code> con la url del Gateway a trav\u00e9s del cual vamos a realizar todas las comunicaciones y creamos un m\u00e9todo abstracto con la anotaci\u00f3n pertinente para hacer referencia al endpoint de obtenci\u00f3n del listado.</p>"},{"location":"appendix/springcloud/infra/#invocar-los-clientes","title":"Invocar los clientes","text":"<p>Con esto ya podemos inyectar estas interfaces dentro de nuestro controlador para obtener todos los datos necesarios que completaran la informaci\u00f3n de la <code>Category</code> y <code>Author</code> de cada <code>Game</code>.</p> <p>Adem\u00e1s, vamos a cambiar el Dto de respuesta, para que en vez de devolver ids, devuelva los objetos correspondientes, que son los que est\u00e1 esperando nuestro frontend. Para ello, primero crearemos los Dtos que necesitamos. Los crearemos en:</p> <ul> <li><code>com.ccsw.tutorialgame.category.model</code></li> <li><code>com.ccsw.tutorialgame.author.model</code></li> </ul> CategoryDto.javaAuthorDto.java <pre><code>package com.ccsw.tutorialgame.category.model;\n\n/**\n * @author ccsw\n *\n */\npublic class CategoryDto {\n\n    private Long id;\n\n    private String name;\n\n    /**\n     * @return id\n     */\n    public Long getId() {\n\n        return this.id;\n    }\n\n    /**\n     * @param id new value of {@link #getId}.\n     */\n    public void setId(Long id) {\n\n        this.id = id;\n    }\n\n    /**\n     * @return name\n     */\n    public String getName() {\n\n        return this.name;\n    }\n\n    /**\n     * @param name new value of {@link #getName}.\n     */\n    public void setName(String name) {\n\n        this.name = name;\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorialgame.author.model;\n\n/**\n * @author ccsw\n *\n */\npublic class AuthorDto {\n\n    private Long id;\n\n    private String name;\n\n    private String nationality;\n\n    /**\n     * @return id\n     */\n    public Long getId() {\n\n        return this.id;\n    }\n\n    /**\n     * @param id new value of {@link #getId}.\n     */\n    public void setId(Long id) {\n\n        this.id = id;\n    }\n\n    /**\n     * @return name\n     */\n    public String getName() {\n\n        return this.name;\n    }\n\n    /**\n     * @param name new value of {@link #getName}.\n     */\n    public void setName(String name) {\n\n        this.name = name;\n    }\n\n    /**\n     * @return nationality\n     */\n    public String getNationality() {\n\n        return this.nationality;\n    }\n\n    /**\n     * @param nationality new value of {@link #getNationality}.\n     */\n    public void setNationality(String nationality) {\n\n        this.nationality = nationality;\n    }\n\n}\n</code></pre> <p>Adem\u00e1s, modificaremos nuestro <code>GameDto</code> para hacer uso de esos objetos.</p> GameDto.java <pre><code>package com.ccsw.tutorialgame.game.model;\n\n\nimport com.ccsw.tutorialgame.author.model.AuthorDto;\nimport com.ccsw.tutorialgame.category.model.CategoryDto;\n\n/**\n * @author ccsw\n *\n */\npublic class GameDto {\n\n    private Long id;\n\n    private String title;\n\n    private String age;\n\n    private CategoryDto category;\n\n    private AuthorDto author;\n\n    /**\n     * @return id\n     */\n    public Long getId() {\n\n        return this.id;\n    }\n\n    /**\n     * @param id new value of {@link #getId}.\n     */\n    public void setId(Long id) {\n\n        this.id = id;\n    }\n\n    /**\n     * @return title\n     */\n    public String getTitle() {\n\n        return this.title;\n    }\n\n    /**\n     * @param title new value of {@link #getTitle}.\n     */\n    public void setTitle(String title) {\n\n        this.title = title;\n    }\n\n    /**\n     * @return age\n     */\n    public String getAge() {\n\n        return this.age;\n    }\n\n    /**\n     * @param age new value of {@link #getAge}.\n     */\n    public void setAge(String age) {\n\n        this.age = age;\n    }\n\n    /**\n     * @return category\n     */\n    public CategoryDto getCategory() {\n\n        return this.category;\n    }\n\n    /**\n     * @param category new value of {@link #getCategory}.\n     */\n    public void setCategory(CategoryDto category) {\n\n        this.category = category;\n    }\n\n    /**\n     * @return author\n     */\n    public AuthorDto getAuthor() {\n\n        return this.author;\n    }\n\n    /**\n     * @param author new value of {@link #getAuthor}.\n     */\n    public void setAuthor(AuthorDto author) {\n\n        this.author = author;\n    }\n\n}\n</code></pre> <p>Y por \u00faltimo implementaremos el c\u00f3digo necesario para transformar los <code>ids</code> en objetos dto.  Aqu\u00ed lo que haremos ser\u00e1 recuperar todos los autores y categor\u00edas, haciendo uso de los <code>Feign Client</code>, y cuando ejecutemos el mapeo de los juegos, ir sustituyendo sus valores por los dtos correspondientes.</p> GameController.java <pre><code>package com.ccsw.tutorialgame.game;\n\nimport com.ccsw.tutorialgame.author.AuthorClient;\nimport com.ccsw.tutorialgame.author.model.AuthorDto;\nimport com.ccsw.tutorialgame.category.CategoryClient;\nimport com.ccsw.tutorialgame.category.model.CategoryDto;\nimport com.ccsw.tutorialgame.game.model.Game;\nimport com.ccsw.tutorialgame.game.model.GameDto;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * @author ccsw\n *\n */\n@Tag(name = \"Game\", description = \"API of Game\")\n@RequestMapping(value = \"/game\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class GameController {\n\n    @Autowired\n    GameService gameService;\n\n    @Autowired\n    CategoryClient categoryClient;\n\n    @Autowired\n    AuthorClient authorClient;\n\n    /**\n     * M\u00e9todo para recuperar una lista de {@link Game}\n     *\n     * @param title t\u00edtulo del juego\n     * @param idCategory PK de la categor\u00eda\n     * @return {@link List} de {@link GameDto}\n     */\n    @Operation(summary = \"Find\", description = \"Method that return a filtered list of Games\")\n    @RequestMapping(path = \"\", method = RequestMethod.GET)\n    public List&lt;GameDto&gt; find(@RequestParam(value = \"title\", required = false) String title,\n                              @RequestParam(value = \"idCategory\", required = false) Long idCategory) {\n\n        List&lt;CategoryDto&gt; categories = categoryClient.findAll();\n        List&lt;AuthorDto&gt; authors = authorClient.findAll();\n\n        return gameService.find(title, idCategory).stream().map(game -&gt; {\n            GameDto gameDto = new GameDto();\n\n            gameDto.setId(game.getId());\n            gameDto.setTitle(game.getTitle());\n            gameDto.setAge(game.getAge());\n            gameDto.setCategory(categories.stream().filter(category -&gt; category.getId().equals(game.getIdCategory())).findFirst().orElse(null));\n            gameDto.setAuthor(authors.stream().filter(author -&gt; author.getId().equals(game.getIdAuthor())).findFirst().orElse(null));\n\n            return gameDto;\n        }).collect(Collectors.toList());\n    }\n\n    /**\n     * M\u00e9todo para crear o actualizar un {@link Game}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    @Operation(summary = \"Save or Update\", description = \"Method that saves or updates a Game\")\n    @RequestMapping(path = { \"\", \"/{id}\" }, method = RequestMethod.PUT)\n    public void save(@PathVariable(name = \"id\", required = false) Long id, @RequestBody GameDto dto) {\n\n        gameService.save(id, dto);\n    }\n\n}\n</code></pre> <p>Con todo esto, ya tenemos construido nuestro aplicativo de micro servicios con la arquitectura Spring Cloud. Podemos proceder a realizar las mismas pruebas tanto manuales como a trav\u00e9s de los frontales.</p> <p>Escalado</p> <p>Una de las principales ventajas de las arquitecturas de micro servicios, es la posibilidad de escalar partes de los aplicativos sin tener que escalar el sistema completo. Para confirmar que esto es asi, podemos levantar multiples instancias de cada servicio en puertos diferentes y veremos que esto se refleja en Eureka y el Gateway balancear\u00e1 autom\u00e1ticamente entre las distintas instancias.</p>"},{"location":"appendix/springcloud/intro/","title":"Introducci\u00f3n Micro Servicios - Spring Cloud","text":""},{"location":"appendix/springcloud/intro/#que-son-los-micro-servicios","title":"Que son los micro servicios?","text":"<p>Pues como su nombre indica, son servicios peque\u00f1itos </p> <p>Aunque si nos vamos a una definici\u00f3n m\u00e1s t\u00e9cnica (seg\u00fan ChatGPT):</p> <p>Los micro servicios son una arquitectura de software en la que una aplicaci\u00f3n est\u00e1 compuesta por peque\u00f1os servicios independientes que se comunican entre s\u00ed a trav\u00e9s de interfaces bien definidas. Cada servicio se enfoca en realizar una tarea espec\u00edfica dentro de la aplicaci\u00f3n y se ejecuta de manera aut\u00f3noma.</p> <p>Cada micro servicio es responsable de un dominio del negocio y puede ser desarrollado, probado, implementado y escalado de manera independiente. Esto permite una mayor flexibilidad y agilidad en el desarrollo y la implementaci\u00f3n de aplicaciones, ya que los cambios en un servicio no afectan a otros servicios.</p> <p>Adem\u00e1s, los micro servicios son escalables y resistentes a fallos, ya que si un servicio falla, los dem\u00e1s servicios pueden seguir funcionando. Tambi\u00e9n permiten la utilizaci\u00f3n de diferentes tecnolog\u00edas para cada servicio, lo que ayuda a optimizar el rendimiento y la eficiencia en la aplicaci\u00f3n en general.</p>"},{"location":"appendix/springcloud/intro/#spring-cloud","title":"Spring Cloud","text":"<p>Existente multiples soluciones para implementar micro servicios, en nuestro caso vamos a utilizar la soluci\u00f3n que nos ofrece Spring Framework y que est\u00e1 incluido dentro del m\u00f3dulo Spring Cloud. </p> <p>Esta soluci\u00f3n nace hace ya varios a\u00f1os como parte de la infraestructura de Netflix para dar soluci\u00f3n a sus propias necesidades. Con el tiempo este c\u00f3digo opensource ha sido adquirido por Spring Framework y se ha incluido dentro de su ecosistema, evolucionandolo con nuevas funcionalidades. Todo ello ha sido publicado bajo el m\u00f3dulo de Spring Cloud.</p>"},{"location":"appendix/springcloud/intro/#contexto-de-la-aplicacion","title":"Contexto de la aplicaci\u00f3n","text":"<p>Llegados a este punto, \u00bfqu\u00e9 es lo que vamos a hacer en los siguientes puntos?.  Pues vamos a coger nuestra aplicaci\u00f3n monol\u00edtica que ya tenemos implementada durante todo el tutorial, y vamos a proceder a trocearla e implementarla con una metodolog\u00eda de micro servicios.</p> <p>Pero, adem\u00e1s de trocear la aplicaci\u00f3n en peque\u00f1os servicios, nos va a hacer falta una serie de servicios / utilidades para conectar todo el ecosistema. Nos har\u00e1 falta una infraestructura.</p>"},{"location":"appendix/springcloud/intro/#infraestructura","title":"Infraestructura","text":"<p>A diferencia de una aplicaci\u00f3n monol\u00edtica, en un enfoque de micro servicios, ya no basta \u00fanicamente con la aplicaci\u00f3n desplegada en su servidor, sino que ser\u00e1n necesarios varios actores que se responsabilizar\u00e1n de darle consistencia al sistema, permitir la comunicaci\u00f3n entre ellos, y ayudar\u00e1n a solventar ciertos problemas que nos surgir\u00e1n al trocear nuestras aplicaciones.</p> <p>Las principales piezas que vamos a utilizar para la implementaci\u00f3n de nuestra infraestructura, ser\u00e1n:</p> <ul> <li>Service Discovery / Eureka Server: Como vamos a tener varios servicios distribuidos por nuestra red, necesitaremos conocer donde est\u00e1 funcionando cada uno de ellos, su IP, su puerto e incluso sus m\u00e9tricas de acceso (localizaci\u00f3n, zona, estado de carga, etc.). Vamos a necesitar un <code>Service Discovery</code> que no es m\u00e1s que un cat\u00e1logo de todos los servicios que componen el ecosistema al cual cada servicio debe informar de forma proactiva, de su localizaci\u00f3n y disponibilidad.</li> <li>Client-side Service Discovery / Eureka Client: Como hemos mencionado en el punto anterior, todos los servicios del ecosistema (incluidos nuestros micro servicios) deben conectarse con el <code>Service Discovery</code> e informar peri\u00f3dicamente a este cat\u00e1logo de su estado y sus m\u00e9tricas para que en caso de perdida de servicio, el resto de elementos lo sepan y puedan tomar decisiones al respecto. Tambi\u00e9n nos servir\u00e1 para que cada elemento pueda guardar en local una cach\u00e9 del cat\u00e1logo publicado, que se ir\u00e1 refrescando cada vez que lance un <code>health check</code>.</li> <li>Edge Server / Gateway / Proxy: Se trata de un servicio que har\u00e1 de intermediario entre el mundo exterior y el mundo de microservicios. Adem\u00e1s permitir\u00e1 hacer redirecci\u00f3n y balanceo entre todos los elementos registrados en el <code>Service Discovery</code>. Es altamente configurable (rutas, redirecciones, carga, etc.) y es una pieza fundamental para unificar todas las llamadas en un \u00fanico punto del ecosistema.</li> <li>Feign Client: Esta utilidad que provee directamente Spring Cloud nos permite comunicarnos entre los diferentes micro servicios de Spring, de una forma muy sencilla y sin tener que estar gestionando llamadas API Rest.</li> </ul>"},{"location":"appendix/springcloud/intro/#diagrama-de-la-arquitectura","title":"Diagrama de la arquitectura","text":"<p>Con las piezas identificadas anteriormente y con el Contexto de la aplicaci\u00f3n en mente, lo que vamos a hacer en los siguientes puntos es trocear el sistema y generar la siguiente arquitectura:</p> <p></p> <p>Ya deber\u00edamos tener claros los conceptos y los actores que compondr\u00e1n nuestro sistema, as\u00ed que, all\u00e1 vamos!!!</p>"},{"location":"appendix/springcloud/paginated/","title":"Listado paginado - Spring Boot","text":"<p>Al igual que en el caso anterior vamos a crear un nuevo proyecto que contendr\u00e1 un nuevo micro servicio.</p> <p>Para la creaci\u00f3n de proyecto nos remitimos a la gu\u00eda de instalaci\u00f3n donde se detalla el proceso de creaci\u00f3n de nuevo proyecto Entorno de desarrollo</p> <p>Todos los pasos son exactamente iguales, lo \u00fanico que va a variar, es el nombre de nuestro proyecto, que en este caso se va a llamar <code>tutorial-author</code>. El campo que debemos modificar es <code>artifact</code> en Spring Initilizr, el resto de campos se cambiaran autom\u00e1ticamente.</p>"},{"location":"appendix/springcloud/paginated/#codigo","title":"C\u00f3digo","text":"<p>Dado de vamos a implementar el micro servicio Spring Boot de <code>Autores</code>, vamos a respetar la misma estructura del Listado paginado de la version monol\u00edtica.</p>"},{"location":"appendix/springcloud/paginated/#paginacion","title":"Paginaci\u00f3n","text":"<p>En primer lugar, vamos a a\u00f1adir la clase que necesitamos para realizar la paginaci\u00f3n y vimos en la version monol\u00edtica del tutorial en el package <code>com.ccsw.tutorialauthor.common.pagination</code>. Ojo al package que lo hemos renombrado con respecto al listado monol\u00edtico.</p> PageableRequest.java <pre><code>package com.ccsw.tutorialauthor.common.pagination;\n\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport org.springframework.data.domain.*;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class PageableRequest implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private int pageNumber;\n\n    private int pageSize;\n\n    private List&lt;SortRequest&gt; sort;\n\n    public PageableRequest() {\n\n        sort = new ArrayList&lt;&gt;();\n    }\n\n    public PageableRequest(int pageNumber, int pageSize) {\n\n        this();\n        this.pageNumber = pageNumber;\n        this.pageSize = pageSize;\n    }\n\n    public PageableRequest(int pageNumber, int pageSize, List&lt;SortRequest&gt; sort) {\n\n        this();\n        this.pageNumber = pageNumber;\n        this.pageSize = pageSize;\n        this.sort = sort;\n    }\n\n    public int getPageNumber() {\n        return pageNumber;\n    }\n\n    public void setPageNumber(int pageNumber) {\n        this.pageNumber = pageNumber;\n    }\n\n    public int getPageSize() {\n        return pageSize;\n    }\n\n    public void setPageSize(int pageSize) {\n        this.pageSize = pageSize;\n    }\n\n    public List&lt;SortRequest&gt; getSort() {\n        return sort;\n    }\n\n    public void setSort(List&lt;SortRequest&gt; sort) {\n        this.sort = sort;\n    }\n\n    @JsonIgnore\n    public Pageable getPageable() {\n\n        return PageRequest.of(this.pageNumber, this.pageSize, Sort.by(sort.stream().map(e -&gt; new Sort.Order(e.getDirection(), e.getProperty())).collect(Collectors.toList())));\n    }\n\n    public static class SortRequest implements Serializable {\n\n        private static final long serialVersionUID = 1L;\n\n        private String property;\n\n        private Sort.Direction direction;\n\n        protected String getProperty() {\n            return property;\n        }\n\n        protected void setProperty(String property) {\n            this.property = property;\n        }\n\n        protected Sort.Direction getDirection() {\n            return direction;\n        }\n\n        protected void setDirection(Sort.Direction direction) {\n            this.direction = direction;\n        }\n    }\n\n}\n</code></pre>"},{"location":"appendix/springcloud/paginated/#entity-y-dto","title":"Entity y Dto","text":"<p>Seguimos con la entidad y los DTOs dentro del package <code>com.ccsw.tutorialauthor.author.model</code>.</p> Author.javaAuthorDto.javaAuthorSearchDto.java <pre><code>package com.ccsw.tutorialauthor.author.model;\n\nimport jakarta.persistence.*;\n\n/**\n * @author ccsw\n *\n */\n@Entity\n@Table(name = \"author\")\npublic class Author {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\", nullable = false)\n    private Long id;\n\n    @Column(name = \"name\", nullable = false)\n    private String name;\n\n    @Column(name = \"nationality\")\n    private String nationality;\n\n    /**\n     * @return id\n     */\n    public Long getId() {\n\n        return this.id;\n    }\n\n    /**\n     * @param id new value of {@link #getId}.\n     */\n    public void setId(Long id) {\n\n        this.id = id;\n    }\n\n    /**\n     * @return name\n     */\n    public String getName() {\n\n        return this.name;\n    }\n\n    /**\n     * @param name new value of {@link #getName}.\n     */\n    public void setName(String name) {\n\n        this.name = name;\n    }\n\n    /**\n     * @return nationality\n     */\n    public String getNationality() {\n\n        return this.nationality;\n    }\n\n    /**\n     * @param nationality new value of {@link #getNationality}.\n     */\n    public void setNationality(String nationality) {\n\n        this.nationality = nationality;\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorialauthor.author.model;\n\n/**\n * @author ccsw\n *\n */\npublic class AuthorDto {\n\n    private Long id;\n\n    private String name;\n\n    private String nationality;\n\n    /**\n     * @return id\n     */\n    public Long getId() {\n\n        return this.id;\n    }\n\n    /**\n     * @param id new value of {@link #getId}.\n     */\n    public void setId(Long id) {\n\n        this.id = id;\n    }\n\n    /**\n     * @return name\n     */\n    public String getName() {\n\n        return this.name;\n    }\n\n    /**\n     * @param name new value of {@link #getName}.\n     */\n    public void setName(String name) {\n\n        this.name = name;\n    }\n\n    /**\n     * @return nationality\n     */\n    public String getNationality() {\n\n        return this.nationality;\n    }\n\n    /**\n     * @param nationality new value of {@link #getNationality}.\n     */\n    public void setNationality(String nationality) {\n\n        this.nationality = nationality;\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorialauthor.author.model;\n\nimport com.ccsw.tutorialauthor.common.pagination.PageableRequest;\n\n/**\n * @author ccsw\n *\n */\npublic class AuthorSearchDto {\n\n    private PageableRequest pageable;\n\n    public PageableRequest getPageable() {\n        return pageable;\n    }\n\n    public void setPageable(PageableRequest pageable) {\n        this.pageable = pageable;\n    }\n}\n</code></pre>"},{"location":"appendix/springcloud/paginated/#repository-service-y-controller","title":"Repository, Service y Controller","text":"<p>Posteriormente, emplazamos el resto de clases dentro del package <code>com.ccsw.tutorialauthor.author</code>.</p> AuthorRepository.javaAuthorService.javaAuthorServiceImpl.javaAuthorController.java <pre><code>package com.ccsw.tutorialauthor.author;\n\nimport com.ccsw.tutorialauthor.author.model.Author;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.repository.CrudRepository;\n\n/**\n * @author ccsw\n *\n */\npublic interface AuthorRepository extends CrudRepository&lt;Author, Long&gt; {\n\n    /**\n     * M\u00e9todo para recuperar un listado paginado de {@link Author}\n     *\n     * @param pageable pageable\n     * @return {@link Page} de {@link Author}\n     */\n    Page&lt;Author&gt; findAll(Pageable pageable);\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorialauthor.author;\n\nimport com.ccsw.tutorialauthor.author.model.Author;\nimport com.ccsw.tutorialauthor.author.model.AuthorDto;\nimport com.ccsw.tutorialauthor.author.model.AuthorSearchDto;\nimport org.springframework.data.domain.Page;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\npublic interface AuthorService {\n\n    /**\n     * Recupera un {@link Author} a trav\u00e9s de su ID\n     *\n     * @param id PK de la entidad\n     * @return {@link Author}\n     */\n    Author get(Long id);\n\n    /**\n     * M\u00e9todo para recuperar un listado paginado de {@link Author}\n     *\n     * @param dto dto de b\u00fasqueda\n     * @return {@link Page} de {@link Author}\n     */\n    Page&lt;Author&gt; findPage(AuthorSearchDto dto);\n\n    /**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    void save(Long id, AuthorDto dto);\n\n    /**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     */\n    void delete(Long id) throws Exception;\n\n    /**\n     * Recupera un listado de autores {@link Author}\n     *\n     * @return {@link List} de {@link Author}\n     */\n    List&lt;Author&gt; findAll();\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorialauthor.author;\n\nimport com.ccsw.tutorialauthor.author.model.Author;\nimport com.ccsw.tutorialauthor.author.model.AuthorDto;\nimport com.ccsw.tutorialauthor.author.model.AuthorSearchDto;\nimport jakarta.transaction.Transactional;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.domain.Page;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Service\n@Transactional\npublic class AuthorServiceImpl implements AuthorService {\n\n    @Autowired\n    AuthorRepository authorRepository;\n\n    /**\n     * {@inheritDoc}\n     * @return\n     */\n    @Override\n    public Author get(Long id) {\n\n        return this.authorRepository.findById(id).orElse(null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Page&lt;Author&gt; findPage(AuthorSearchDto dto) {\n\n        return this.authorRepository.findAll(dto.getPageable().getPageable());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void save(Long id, AuthorDto data) {\n\n        Author author;\n\n        if (id == null) {\n            author = new Author();\n        } else {\n            author = this.get(id);\n        }\n\n        BeanUtils.copyProperties(data, author, \"id\");\n\n        this.authorRepository.save(author);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void delete(Long id) throws Exception {\n\n        if(this.get(id) == null){\n            throw new Exception(\"Not exists\");\n        }\n\n        this.authorRepository.deleteById(id);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public List&lt;Author&gt; findAll() {\n\n        return (List&lt;Author&gt;) this.authorRepository.findAll();\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorialauthor.author;\n\nimport com.ccsw.tutorialauthor.author.model.Author;\nimport com.ccsw.tutorialauthor.author.model.AuthorDto;\nimport com.ccsw.tutorialauthor.author.model.AuthorSearchDto;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport org.modelmapper.ModelMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.PageImpl;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * @author ccsw\n *\n */\n@Tag(name = \"Author\", description = \"API of Author\")\n@RequestMapping(value = \"/author\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class AuthorController {\n\n    @Autowired\n    AuthorService authorService;\n\n    @Autowired\n    ModelMapper mapper;\n\n    /**\n     * M\u00e9todo para recuperar un listado paginado de {@link Author}\n     *\n     * @param dto dto de b\u00fasqueda\n     * @return {@link Page} de {@link AuthorDto}\n     */\n    @Operation(summary = \"Find Page\", description = \"Method that return a page of Authors\")\n    @RequestMapping(path = \"\", method = RequestMethod.POST)\n    public Page&lt;AuthorDto&gt; findPage(@RequestBody AuthorSearchDto dto) {\n\n        Page&lt;Author&gt; page = this.authorService.findPage(dto);\n\n        return new PageImpl&lt;&gt;(page.getContent().stream().map(e -&gt; mapper.map(e, AuthorDto.class)).collect(Collectors.toList()), page.getPageable(), page.getTotalElements());\n    }\n\n    /**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    @Operation(summary = \"Save or Update\", description = \"Method that saves or updates a Author\")\n    @RequestMapping(path = { \"\", \"/{id}\" }, method = RequestMethod.PUT)\n    public void save(@PathVariable(name = \"id\", required = false) Long id, @RequestBody AuthorDto dto) {\n\n        this.authorService.save(id, dto);\n    }\n\n    /**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     */\n    @Operation(summary = \"Delete\", description = \"Method that deletes a Author\")\n    @RequestMapping(path = \"/{id}\", method = RequestMethod.DELETE)\n    public void delete(@PathVariable(\"id\") Long id) throws Exception {\n\n        this.authorService.delete(id);\n    }\n\n    /**\n     * Recupera un listado de autores {@link Author}\n     *\n     * @return {@link List} de {@link AuthorDto}\n     */\n    @Operation(summary = \"Find\", description = \"Method that return a list of Authors\")\n    @RequestMapping(path = \"\", method = RequestMethod.GET)\n    public List&lt;AuthorDto&gt; findAll() {\n\n        List&lt;Author&gt; authors = this.authorService.findAll();\n\n        return authors.stream().map(e -&gt; mapper.map(e, AuthorDto.class)).collect(Collectors.toList());\n    }\n\n}\n</code></pre>"},{"location":"appendix/springcloud/paginated/#sql-y-configuracion","title":"SQL y Configuraci\u00f3n","text":"<p>Finalmente, debemos crear el script de inicializaci\u00f3n de base de datos con solo los datos de author y modificar ligeramente la configuraci\u00f3n inicial para a\u00f1adir un puerto manualmente para poder tener multiples micro servicios funcionando simult\u00e1neamente.</p> data.sqlapplication.properties <pre><code>INSERT INTO author(name, nationality) VALUES ('Alan R. Moon', 'US');\nINSERT INTO author(name, nationality) VALUES ('Vital Lacerda', 'PT');\nINSERT INTO author(name, nationality) VALUES ('Simone Luciani', 'IT');\nINSERT INTO author(name, nationality) VALUES ('Perepau Llistosella', 'ES');\nINSERT INTO author(name, nationality) VALUES ('Michael Kiesling', 'DE');\nINSERT INTO author(name, nationality) VALUES ('Phil Walker-Harding', 'US');\n</code></pre> <pre><code>server.port=8092\n\n#Database\nspring.datasource.url=jdbc:h2:mem:testdb\nspring.datasource.username=sa\nspring.datasource.password=sa\nspring.datasource.driver-class-name=org.h2.Driver\n\nspring.jpa.database-platform=org.hibernate.dialect.H2Dialect\nspring.jpa.defer-datasource-initialization=true\nspring.jpa.show-sql=true\n\nspring.h2.console.enabled=true\n</code></pre>"},{"location":"appendix/springcloud/paginated/#pruebas","title":"Pruebas","text":"<p>Ahora si arrancamos la aplicaci\u00f3n server y abrimos el Postman podemos realizar las mismas pruebas del apartado de Listado paginado pero esta vez apuntado al puerto <code>8092</code>.</p>"},{"location":"appendix/springcloud/paginated/#siguientes-pasos","title":"Siguientes pasos","text":"<p>En este punto ya tenemos un micro servicio de categor\u00edas en el puerto <code>8091</code> y un micro servicio de autores en el puerto <code>8092</code>. Al igual que antes, con estos datos ya podr\u00edamos conectar el frontend a estos servicios, pero vamos a esperar un poquito m\u00e1s a tener toda la infraestructura, para que sea m\u00e1s sencillo.</p> <p>Vamos a convertir en micro servicio el \u00faltimo listado.</p>"},{"location":"appendix/springcloud/summary/","title":"Resumen Micro Servicios - Spring Cloud","text":""},{"location":"appendix/springcloud/summary/#que-hemos-hecho","title":"\u00bfQu\u00e9 hemos hecho?","text":"<p>Llegados a este punto, ya has podido comprobar que implementar una aplicaci\u00f3n orientada a micro servicios es bastante similar a una aplicaci\u00f3n monol\u00edtica, con la salvedad de que tienes que tener en cuenta la distribuci\u00f3n de estos, y por tanto su gesti\u00f3n y coordinaci\u00f3n.</p> <p>En definitiva, lo que hemos implementado ha sido:</p> <ul> <li> <p>Service Discovery: Que ayudar\u00e1 a tener un cat\u00e1logo de todos las piezas de mi infraestructura, su IP, su puerto y ciertas m\u00e9tricas que ayuden luego en la elecci\u00f3n de servicio.</p> </li> <li> <p>Gateway: Que centraliza las peticiones en un \u00fanico punto y permite hacer de balanceo de carga, seguridad, etc. Ser\u00e1 el punto de entrada a nuestro ecosistema.</p> </li> <li> <p>Micro servicio Category: Contiene las operaciones sobre el \u00e1mbito funcional de categor\u00edas, guarda y recupera informaci\u00f3n de ese \u00e1mbito funcional.</p> </li> <li> <p>Micro servicio Author: Contiene las operaciones sobre el \u00e1mbito funcional de autores, guarda y recupera informaci\u00f3n de ese \u00e1mbito funcional.</p> </li> <li> <p>Micro servicio Game: Contiene las operaciones sobre el \u00e1mbito funcional de autores, guarda y recupera informaci\u00f3n de ese \u00e1mbito funcional. Adem\u00e1s, realiza llamadas entre los otros dos micro servicios para nutrir de m\u00e1s informaci\u00f3n sus endpoints.</p> </li> </ul> <p>El diagrama de nuestra aplicaci\u00f3n ahora es as\u00ed:</p> <p></p>"},{"location":"appendix/springcloud/summary/#siguientes-pasos","title":"Siguientes pasos","text":"<p>Bueno, el siguiente paso m\u00e1s evidente, ser\u00e1 ver que si conectas el frontend sigue funcionando exactamente igual que lo estaba haciendo antes.</p> <p>Ahora te propongo hacer el mismo ejercicio con los otros dos m\u00f3dulos <code>Cliente</code> y <code>Pr\u00e9stamo</code> que has tenido que implementar en el punto Ahora hazlo tu!.</p> <p>Ten en cuenta que <code>Cliente</code> no depende de nadie, pero <code>Pr\u00e9stamo</code> si que depende de <code>Cliente</code> y de <code>Game</code>. A ver como solucionas los cruces y sobre todo los filtros </p>"},{"location":"appendix/springcloud/summary/#mas-formacion-mas-informacion","title":"M\u00e1s formaci\u00f3n, m\u00e1s informaci\u00f3n","text":"<p>Pues ya estar\u00eda todo, ahora solo te puedo dar la enhorabuena y pasar algo de informaci\u00f3n extra / cursos / formaciones por si quieres seguir aprendiendo.</p> <p>Por un lado tienes el itinerario avanzado de Springboot donde se puede m\u00e1s detalle de micro servicios.</p> <p>Por otro lado tambi\u00e9n tienes los itinerarios de Cloud ya que no todo va a ser micro servicios con Spring Cloud, tambi\u00e9n existen micro servicios con otras tecnolog\u00edas, aunque el concepto es muy similar.</p>"},{"location":"cleancode/angular/","title":"Estructura y Buenas pr\u00e1cticas - Angular","text":"<p>Nota</p> <p>Antes de empezar y para puntualizar, Angular se considera un framework SPA Single-page application.</p> <p>En esta parte vamos a explicar los fundamentos de un proyecto en Angular y las recomendaciones existentes.</p>"},{"location":"cleancode/angular/#estructura-y-funcionamiento","title":"Estructura y funcionamiento","text":""},{"location":"cleancode/angular/#ciclo-de-vida-de-angular","title":"Ciclo de vida de Angular","text":"<p>El comportamiento de ciclo de vida de un componente Angular pasa por diferentes etapas que podemos ver en el esquema que mostramos a continuaci\u00f3n:</p> <p></p> <p>Es importante tenerlo claro para saber que m\u00e9todos podemos utilizar para realizar operaciones con el componente.</p>"},{"location":"cleancode/angular/#carpetas-creadas-por-angular","title":"Carpetas creadas por Angular","text":"<p>Al crear una aplicaci\u00f3n Angular, tendremos los siguientes directorios:</p> <ul> <li>node_modules: Todos los m\u00f3dulos de librer\u00edas usadas por el proyecto.</li> <li>\\src\\app: Contiene todo el c\u00f3digo asociado al proyecto.<ul> <li>\\src\\assets: Normalmente la carpeta usada para los recursos.</li> <li>\\src\\environments: Aqu\u00ed ir\u00e1n los ficheros relacionados con los entornos de desarrollos.</li> </ul> </li> </ul> <p>Otros ficheros importantes de un proyecto de Angular</p> <p>Otros archivos que debemos tener en cuenta dentro del proyecto son:</p> <ul> <li>angular.json: Configuraci\u00f3n del propio CLI. La madre de todos los configuradores</li> <li>package.json: Dependencias de librer\u00edas y scripts</li> </ul>"},{"location":"cleancode/angular/#estructura-de-modulos","title":"Estructura de m\u00f3dulos","text":"<p>Existe m\u00faltiples consensos al respecto de como estructurar un proyecto en Angular, pero al final, depende de los requisitos del proyecto. Una sugerencia de como hacerlo es la siguiente:</p> <pre><code>- src\\app\n    - core              /* Componentes y utilidades comunes */ \n        - header        /* Estructura del header */ \n        - footer        /* Estructura del footer */ \n  - domain1       /* M\u00f3dulo con los componentes del dominio1 */\n      - services        /* Servicios con operaciones del dominio1 */ \n      - models          /* Modelos de datos del dominio1 */ \n      - component1      /* Componente1 del dominio1 */ \n      - componentX      /* ComponenteX del dominio1 */ \n  - domainX       /* As\u00ed para el resto de dominios de la aplicaci\u00f3n */\n</code></pre> <p>Recordar, que esto es una sugerencia para una estructura de carpetas y componentes. No existe un estandar.</p> <p>ATENCI\u00d3N: Componentes gen\u00e9ricos</p> <p>Debemos tener en cuenta que a la hora de programar un componente <code>core</code>, lo ideal es pensar que sea un componente plug &amp; play, es decir que si lo copias y lo llevas a otro proyecto funcione sin la necesidad de adaptarlo.</p>"},{"location":"cleancode/angular/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":"<p>A continuaci\u00f3n veremos un listado de buenas pr\u00e1cticas de Angular y de c\u00f3digo limpio que deber\u00edamos intentar seguir en nuestro desarrollo.</p>"},{"location":"cleancode/angular/#estructura-de-archivos","title":"Estructura de archivos","text":"<p>Antes de empezar con un proyecto lo ideal, es pararse y pensar en los requerimientos de una buena estructura, en un futuro lo agradecer\u00e1s.</p>"},{"location":"cleancode/angular/#nombres-claros","title":"Nombres claros","text":"<p>Utilizar la S de los principios S.O.L.I.D para los nombres de variables, m\u00e9todos y dem\u00e1s c\u00f3digo.</p> <p>El efecto que produce este principio son clases con nombres muy descriptivos y por tanto largos.</p> <p>Tambi\u00e9n se recomienta utilizar <code>kebab-case</code> para los nombres de ficheros. Ej. hero-button.component.ts</p>"},{"location":"cleancode/angular/#organiza-tu-codigo","title":"Organiza tu c\u00f3digo","text":"<p>Intenta organizar tu c\u00f3digo fuente:</p> <ul> <li>Lo m\u00e1s importante debe ir arriba.</li> <li>Primero propiedades, despu\u00e9s m\u00e9todos.</li> <li>Un Item para un archivo: cada archivo deber\u00eda contener solamente un componente, al igual que los servicios.</li> <li>Solo una responsabilidad: Cada clase o modulo deber\u00eda tener solamente una responsabilidad.</li> <li>El nombre correcto: las propiedades y m\u00e9todos deber\u00edan usar el sistema de camel case (ej: getUserByName), al contrario, las clases (componentes, servicios, etc) deben usar upper camel case (ej: UserComponent).</li> <li>Los componentes y servicios deben tener su respectivo sufijo: UserComponent, UserService.</li> <li>Imports: los archivos externos van primero.</li> </ul>"},{"location":"cleancode/angular/#usar-linters-prettier-eslint","title":"Usar linters Prettier &amp; ESLint","text":"<p>Un linter es una herramienta que nos ayuda a seguir las buenas pr\u00e1cticas o gu\u00edas de estilo de nuestro c\u00f3digo fuente. En este caso, para JavaScript, proveeremos de unos muy famosos. Una de las m\u00e1s famosas es la combinaci\u00f3n de  Angular app to ESLint with Prettier, AirBnB Styleguide Recordar que a\u00f1adir este tipo de configuraci\u00f3n es opcional, pero necesaria para tener un buen c\u00f3digo de calidad.</p>"},{"location":"cleancode/angular/#git-hooks","title":"Git Hooks","text":"<p>Los Git Hooks son scripts de shell que se ejecutan autom\u00e1ticamente antes o despu\u00e9s de que Git ejecute un comando importante como Commit o Push. Para hacer uso de el es tan sencillo como:</p> <p>npm install husky --save-dev</p> <p>Y a\u00f1adir en el fichero lo siguiente:</p> <pre><code>// package.json\n{\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"npm test\",\n      \"pre-push\": \"npm test\",\n      \"...\": \"...\"\n    }\n  }\n}\n</code></pre> <p>Usar husky para el preformateo de c\u00f3digo antes de subirlo</p> <p>Es una buena pr\u00e1ctica que todo el equipo use el mismo est\u00e1ndar de formateo de codigo, con husky se puede solucionar.</p>"},{"location":"cleancode/angular/#utilizar-banana-in-the-box","title":"Utilizar Banana in the Box","text":"<p>Como el nombre sugiere banana in the box se debe a la forma que tiene lo siguiente: [{}] Esto es una forma muy sencilla de trabajar los cambios en la forma de Two ways binding. Es decir, el padre informa de un valor u objeto y el hijo lo manipula y actualiza el estado/valor al padre inmediatamente. La forma de implementarlo es sencillo</p> <p>Padre: HTML:</p> <p><code>&lt;my-input [(text)]=\"text\"&gt;&lt;/my-input&gt;</code></p> <p>Hijo</p> <pre><code>@Input() value: string;\n@Output() valueChange = new EventEmitter&lt;string&gt;();\nupdateValue(value){\n    this.value = value;\n    this.valueChange.emit(value);\n}\n</code></pre> <p>Prefijo Change</p> <p>Destacar que el prefijo 'Change' es necesario incluirlo en el Hijo para que funcione</p>"},{"location":"cleancode/angular/#correcto-uso-de-los-servicios","title":"Correcto uso de los servicios","text":"<p>Una buena practica es aconsejable no declarar los servicios en el provides, sino usar un decorador que forma parte de las ultimas versiones de Angular</p> <pre><code>@Injectable({\n  providedIn: 'root',\n})\nexport class HeroService {\n  constructor() { }\n}\n</code></pre>"},{"location":"cleancode/angular/#lazy-load","title":"Lazy Load","text":"<p>Lazy Load es un patr\u00f3n de dise\u00f1o que consiste en retrasar la carga o inicializaci\u00f3n</p> <p>desde el app-routing.module.ts</p> <p>A\u00f1adiremos un codigo parecido a este <pre><code>  {\n    path: 'customers',\n    loadChildren: () =&gt; import('./customers/customers.module').then(m =&gt; m.CustomersModule)\n  },\n</code></pre></p> <p>Con esto veremos que el m\u00f3dulo se cargar\u00e1 seg\u00fan se necesite.</p>"},{"location":"cleancode/nodejs/","title":"Estructura y Buenas pr\u00e1cticas - Nodejs","text":""},{"location":"cleancode/nodejs/#estructura-y-funcionamiento","title":"Estructura y funcionamiento","text":"<p>En los proyectos Nodejs no existe nada estandarizado y oficial que hable sobre estructura de proyectos y nomenclatura de Nodejs. Tan solo existen algunas sugerencias y buenas pr\u00e1cticas a la hora de desarrollar que te recomiendo que utilices en la medida de lo posible.</p> <p>Tip</p> <p>Piensa que el c\u00f3digo fuente que escribes hoy, es como un libro que se leer\u00e1 durante a\u00f1os. Alguien tendr\u00e1 que coger tu c\u00f3digo y leerlo en unos meses o a\u00f1os para hacer alguna modificaci\u00f3n y, como buenos desarrolladores que somos, tenemos la obligaci\u00f3n de facilitarle en todo lo posible la comprensi\u00f3n de ese c\u00f3digo fuente. Quiz\u00e1 esa persona futura podr\u00edas ser tu en unos meses y quedar\u00eda muy mal que no entendieras ni tu propio c\u00f3digo </p>"},{"location":"cleancode/nodejs/#estructura-en-capas","title":"Estructura en capas","text":"<p>Todos los proyectos para crear una Rest API con node y express est\u00e1n divididos en capas. Como m\u00ednimo estar\u00e1 la capa de rutas, controlador y modelo. En nuestro caso vamos a a\u00f1adir una capa mas de servicios para quitarle trabajo al controlador y desacoplarlo de la capa de datos. As\u00ed si en el futuro queremos cambiar nuestra base de datos no romperemos tanto \ud83d\ude0a</p> <p>Rutas</p> <p>En nuestro proyecto una ruta ser\u00e1 una secci\u00f3n de c\u00f3digo express que asociar\u00e1 un verbo http, una ruta o patr\u00f3n de url y una funci\u00f3n perteneciente al controlador para manejar esa petici\u00f3n.</p> <p>Controladores</p> <p>En nuestros controladores tendremos los m\u00e9todos que obtendr\u00e1n las solicitudes de las rutas, se comunicar\u00e1n con la capa de servicio y convertir\u00e1n estas solicitudes en respuestas http.</p> <p>Servicio</p> <p>Nuestra capa de servicio incluir\u00e1 toda la l\u00f3gica de negocio de nuestra aplicaci\u00f3n. Para realizar sus operaciones puede realizar llamadas tanto a otras clases dentro de esta capa, como a clases de la capa inferior.</p> <p>Modelo</p> <p>Como su nombre indica esta capa representa los modelos de datos de nuestra aplicaci\u00f3n. En nuestro caso, al usar un ODM, solo tendremos modelos de datos definidos seg\u00fan sus requisitos.</p>"},{"location":"cleancode/nodejs/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":""},{"location":"cleancode/nodejs/#accesos-entre-capas","title":"Accesos entre capas","text":"<p>En base a la divisi\u00f3n por capas que hemos comentado arriba, y el resto de entidades implicadas, hay una serie de reglas important\u00edsimas que debes seguir muy de cerca:</p> <ul> <li> <p>Un <code>Controlador</code></p> <ul> <li>NO debe contener l\u00f3gica en su clase. Solo est\u00e1 permitido que ejecute l\u00f3gica a trav\u00e9s de una llamada al objeto de la capa L\u00f3gica.</li> <li>NO puede ejecutar directamente operaciones de la capa Acceso a Datos, siempre debe pasar por la capa de servicios.</li> <li>Debemos seguir una coherencia entre todas las URL de las operaciones. Por ejemplo, si elegimos save para guardar, usemos esa palabra en todas las operaciones que sean de ese tipo. Evitad utilizar diferentes palabras save, guardar, persistir, actualizar para la misma acci\u00f3n.</li> </ul> </li> <li> <p>Un <code>Servicio</code></p> <ul> <li>NO puede llamar a objetos de la capa Controlador.</li> <li>NO debe llamar a Acceso a Datos que NO sean de su \u00e1mbito / competencia.</li> <li>Si es necesario puede llamar a otros Servicios para recuperar cierta informaci\u00f3n que no sea de su \u00e1mbito / competencia.</li> <li>Es un buen lugar para implementar la l\u00f3gica de negocio.</li> </ul> </li> </ul>"},{"location":"cleancode/nodejs/#usar-linters-prettier-eslint-se-recomienda-encarecidamente","title":"Usar linters Prettier &amp; ESLint (Se recomienda encarecidamente)","text":"<p>Un linter es una herramienta que nos ayuda a seguir las buenas pr\u00e1cticas o gu\u00edas de estilo de nuestro c\u00f3digo fuente. En este caso, para JavaScript, proveeremos de unos muy famosos. Una de las m\u00e1s famosas es la combinaci\u00f3n de Angular app to ESLint with Prettier, AirBnB Styleguide Recordar que a\u00f1adir este tipo de configuraci\u00f3n es opcional, pero necesaria para tener un buen c\u00f3digo de calidad.</p>"},{"location":"cleancode/react/","title":"Estructura y Buenas pr\u00e1cticas - React","text":"<p>Nota</p> <p>Antes de empezar y para puntualizar, React se considera un framework SPA Single-page application.</p> <p>Aqu\u00ed tenemos que puntualizar que React por s\u00ed mismo es una librer\u00eda y no un framework, puesto que se ocupa de las interfaces de usuario. Sin embargo, diversos a\u00f1adidos pueden convertir a React en un producto equiparable en caracter\u00edsticas a un framework.</p> <p>En esta parte vamos a explicar los fundamentos de un proyecto en React y las recomendaciones existentes.</p>"},{"location":"cleancode/react/#estructura-y-funcionamiento","title":"Estructura y funcionamiento","text":""},{"location":"cleancode/react/#como-funciona-react","title":"Como funciona React","text":"<p>React es una herramienta para crear interfaces de usuario de una manera \u00e1gil y vers\u00e1til, en lugar de manipular el DOM del navegador directamente, React crea un DOM virtual en la memoria, d\u00f3nde realiza toda la manipulaci\u00f3n necesaria antes de realizar los cambios en el DOM del navegador.  Estas interfaces de usuario denominadas componentes pueden definirse como clases o funciones independiente y reutilizables con unos par\u00e1metros de entrada que devuelven elementos de react. En ese tutorial solo utilizaremos componentes de tipo funci\u00f3n.</p> <p>Por si no te suena, un componente web es una forma de crear un bloque de c\u00f3digo encapsulado y de responsabilidad \u00fanica que puede reutilizarse en cualquier pagina mediante nuevas etiquetas html. </p> <p>Nota</p> <p>Desde la versi\u00f3n 16.8 se introdujo en React el concepto de hooks. Esto permiti\u00f3 usar el estado y otras caracter\u00edsticas de React sin necesidad de escribir una clase.</p>"},{"location":"cleancode/react/#ciclo-de-vida-de-un-componente-en-react","title":"Ciclo de vida de un componente en React","text":"<p>El comportamiento de ciclo de vida de un componente React pasa por diferentes etapas que podemos ver en el esquema que mostramos a continuaci\u00f3n:</p> <p></p> <p>Es importante tenerlo claro para saber que m\u00e9todos podemos utilizar para realizar operaciones con el componente.</p>"},{"location":"cleancode/react/#carpetas-creadas-por-react","title":"Carpetas creadas por React","text":"<p>Al crear una aplicaci\u00f3n React, tendremos los siguientes directorios:</p> <ul> <li>node_modules: Todos los m\u00f3dulos de librer\u00edas usadas por el proyecto.</li> <li>\\src\\app: Contiene todo el c\u00f3digo asociado al proyecto.<ul> <li>\\src\\assets: Normalmente la carpeta usada para los recursos.</li> </ul> </li> </ul> <p>Otros ficheros importantes de un proyecto de React</p> <p>Otros archivos que debemos tener en cuenta dentro del proyecto son:</p> <ul> <li>package.json: Dependencias de librer\u00edas y scripts</li> </ul>"},{"location":"cleancode/react/#estructura-de-nuestro-proyecto","title":"Estructura de nuestro proyecto","text":"<p>Existe m\u00faltiples consensos al respecto de c\u00f3mo estructurar un proyecto en React, pero al final, depende de los requisitos del proyecto. Una sugerencia de c\u00f3mo hacerlo es la siguiente:</p> <pre><code>- src\\\n    - components         /* Componentes comunes */ \n  - context            /* Carpeta para almacenar el contexto de la aplicaci\u00f3n */ \n  - pages              /* Carpeta para componentes asociados a rutas del navegador */\n      - components     /* Componentes propios de cada p\u00e1gina */ \n  - redux              /* Para todo aquello relacionado con el estado de nuestra aplicaci\u00f3n */\n  - types              /* Carpeta para los tipos de datos de typescript */\n</code></pre> <p>Recordad, que \u00e9sto es una sugerencia para una estructura de carpetas y componentes. No existe un est\u00e1ndar.</p>"},{"location":"cleancode/react/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":"<p>A continuaci\u00f3n, veremos un listado de buenas pr\u00e1cticas de React y de c\u00f3digo limpio que deber\u00edamos intentar seguir en nuestro desarrollo.</p>"},{"location":"cleancode/react/#estructura-de-archivos","title":"Estructura de archivos","text":"<p>Antes de empezar con un proyecto lo ideal, es pararse y pensar en los requerimientos de una buena estructura, en un futuro lo agradecer\u00e1s.</p>"},{"location":"cleancode/react/#nombres-claros","title":"Nombres claros","text":"<p>Utilizar la S de los principios S.O.L.I.D para los nombres de variables, m\u00e9todos y dem\u00e1s c\u00f3digo.</p> <p>El efecto que produce este principio son clases con nombres muy descriptivos y por tanto largos.</p>"},{"location":"cleancode/react/#organiza-tu-codigo","title":"Organiza tu c\u00f3digo","text":"<p>Intenta organizar tu c\u00f3digo fuente:</p> <ul> <li>Lo m\u00e1s importante debe ir arriba.</li> <li>Primero propiedades, despu\u00e9s m\u00e9todos.</li> <li>Un Item para un archivo: cada archivo deber\u00eda contener solamente un componente, al igual que los servicios.</li> <li>Solo una responsabilidad: Cada clase o modulo deber\u00eda tener solamente una responsabilidad.</li> <li>El nombre correcto: las propiedades y m\u00e9todos deber\u00edan usar el sistema de camel case (ej: getUserByName), al contrario, las clases (componentes, servicios, etc) deben usar upper camel case (ej: UserComponent).</li> <li>Los componentes y servicios deben tener su respectivo sufijo: UserComponent, UserService.</li> <li>Imports: los archivos externos van primero.</li> </ul>"},{"location":"cleancode/react/#usar-linters-prettier-eslint","title":"Usar linters Prettier &amp; ESLint","text":"<p>Un linter es una herramienta que nos ayuda a seguir las buenas pr\u00e1cticas o gu\u00edas de estilo de nuestro c\u00f3digo fuente. En este caso, para JavaScript, proveeremos de unos muy famosos. Recordar que a\u00f1adir este tipo de configuraci\u00f3n es opcional, pero necesaria para tener un buen c\u00f3digo de calidad.</p>"},{"location":"cleancode/react/#usa-el-estado-correctamente","title":"Usa el estado correctamente","text":"<p>La primera regla del hook useState es usarlo solo localmente. El estado global de nuestra aplicaci\u00f3n debe de entrar a nuestro componente a trav\u00e9s de las props as\u00ed como las mutaciones de este solo deben realizarse mediante alguna herramienta de gesti\u00f3n de estados como redux. Por otro lado, es preferible no abusar de los hooks y solo usarlos cuando sea realmente necesario ya que pueden reducir el rendimiento de nuestra aplicaci\u00f3n.</p>"},{"location":"cleancode/react/#reutiliza-codigo-y-componentes","title":"Reutiliza c\u00f3digo y componentes","text":"<p>Siempre que sea posible deberemos de reutilizar c\u00f3digo mediante funciones compartidas o bien si este c\u00f3digo implica almacenamiento de estado u otras caracter\u00edsticas similares mediante custom Hooks.</p>"},{"location":"cleancode/react/#usa-ts-en-lugar-de-js","title":"Usa TS en lugar de JS","text":"<p>Ya hemos creado nuestro proyecto incluyendo typescript pero esto no viene por defecto en un proyecto React como si pasa con Angular. Nuestra recomendaci\u00f3n es que siempre que puedas a\u00f1adas typescript a tus proyectos React, no solo se gana calidad en el c\u00f3digo, sino que eliminamos la probabilidad de usar un componente incorrectamente y ganamos tiempo de desarrollo.</p>"},{"location":"cleancode/springboot/","title":"Estructura y Buenas pr\u00e1cticas - Spring Boot","text":""},{"location":"cleancode/springboot/#estructura-y-funcionamiento","title":"Estructura y funcionamiento","text":"<p>En Springboot no existe nada estandarizado y oficial que hable sobre estructura de proyectos y nomenclatura. Tan solo existen algunas sugerencias y buenas pr\u00e1cticas a la hora de desarrollar que te recomiendo que utilices en la medida de lo posible.</p> <p>Tip</p> <p>Piensa que el c\u00f3digo fuente que escribes hoy, es como un libro que se leer\u00e1 durante a\u00f1os. Alguien tendr\u00e1 que coger tu c\u00f3digo y leerlo en unos meses o a\u00f1os para hacer alguna modificaci\u00f3n y, como buenos desarrolladores que somos, tenemos la obligaci\u00f3n de facilitarle en todo lo posible la comprensi\u00f3n de ese c\u00f3digo fuente. Quiz\u00e1 esa persona futura podr\u00edas ser tu en unos meses y quedar\u00eda muy mal que no entendieras ni tu propio c\u00f3digo </p>"},{"location":"cleancode/springboot/#estructura-en-capas","title":"Estructura en capas","text":"<p>Todos los proyectos web que construimos basados en Springboot se caracterizan por estar divididos en tres capas (a menos que utilicemos DDD para desarrollar que entonces existen infinitas capas ).</p> <p></p> <ul> <li>Controlador. Es la capa m\u00e1s alta, la que tiene acceso directo con el cliente. En esta capa es donde se exponen las operaciones que queremos publicar y que el cliente puede consumir. Para realizar sus operaciones lo m\u00e1s normal es que realice llamadas a las clases de la capa inmediatamente inferior.</li> <li>L\u00f3gica. Tambi\u00e9n llamada capa de <code>Servicios</code>. Es la capa intermedia que da soporte a las operaciones que est\u00e1n expuestas y ejecutan toda la l\u00f3gica de negocio de la aplicaci\u00f3n. Para realizar sus operaciones puede realizar llamadas tanto a otras clases dentro de esta capa, como a clases de la capa inferior.</li> <li>Acceso a Datos. Como su nombre indica, es la capa que accede a datos. T\u00edpicamente es la capa que ejecuta las consultas contra BBDD, pero esto no tiene por qu\u00e9 ser obligadamente as\u00ed. Tambi\u00e9n entrar\u00edan en esa capa aquellas clases que consumen datos externos, por ejemplo de un servidor externo. Las clases de esta capa deben ser nodos <code>finales</code>, no pueden llamar a ninguna otra clase para ejecutar sus operaciones, ni siquiera de su misma capa.</li> </ul>"},{"location":"cleancode/springboot/#estructura-de-proyecto","title":"Estructura de proyecto","text":"<p>En proyectos medianos o grandes, estructurar los directorios del proyecto en base a la estructura anteriormente descrita ser\u00eda muy complejo, ya que en cada uno de los niveles tendr\u00edamos muchas clases. As\u00ed que lo normal es diferenciar por \u00e1mbito funcional y dentro de cada <code>package</code> realizar la separaci\u00f3n en <code>Controlador</code>, <code>L\u00f3gica</code> y <code>Acceso a datos</code>.</p> <p>Tened en cuenta en un mismo \u00e1mbito funcional puede tener varios controladores o varios servicios de l\u00f3gica uno por cada entidad que estemos tratando. Siempre que se pueda, agruparemos entidades que intervengan dentro de una misma funcionalidad. </p> <p>En nuestro caso del tutorial, tendremos tres \u00e1mbitos funcionales <code>Categor\u00eda</code>, <code>Autor</code>, y <code>Juego</code> que diferenciaremos cada uno con su propia estructura.</p>"},{"location":"cleancode/springboot/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":""},{"location":"cleancode/springboot/#nomenclatura-de-las-clases","title":"Nomenclatura de las clases","text":"<p><code>@TODO: En construcci\u00f3n</code></p>"},{"location":"cleancode/springboot/#accesos-entre-capas","title":"Accesos entre capas","text":"<p>En base a la divisi\u00f3n por capas que hemos comentado arriba, y el resto de entidades implicadas, hay una serie de reglas important\u00edsimas que debes seguir muy de cerca:</p> <ul> <li>Un <code>Controlador</code><ul> <li>NO debe contener l\u00f3gica en su clase. Solo est\u00e1 permitido que ejecute l\u00f3gica a trav\u00e9s de una llamada al objeto de la capa <code>L\u00f3gica</code>.</li> <li>NO puede ejecutar directamente operaciones de la capa <code>Acceso a Datos</code>, siempre debe pasar por la capa <code>L\u00f3gica</code>.</li> <li>NO debe enviar ni recibir del cliente objetos de tipo <code>Entity</code>.</li> <li>Es un buen lugar para realizar las conversiones de datos entre <code>Entity</code> y <code>Dto</code>.</li> <li>En teor\u00eda cada operaci\u00f3n deber\u00eda tener su propio Dto, aunque los podemos reutilizar entre operaciones similares.</li> <li>Debemos seguir una coherencia entre todas las URL de las operaciones. Por ejemplo si elegimos <code>save</code> para guardar, usemos esa palabra en todas las operaciones que sean de ese tipo. Evitad utilizar diferentes palabras <code>save</code>, <code>guardar</code>, <code>persistir</code>, <code>actualizar</code> para la misma acci\u00f3n.</li> </ul> </li> <li>Un <code>Servicio</code><ul> <li>NO puede llamar a objetos de la la capa <code>Controlador</code>.</li> <li>NO puede ejecutar directamente queries contra la BBDD, siempre debe pasar por la capa <code>Acceso a Datos</code>.</li> <li>NO debe llamar a <code>Acceso a Datos</code> que NO sean de su \u00e1mbito / competencia.</li> <li>Si es necesario puede llamar a otros <code>Servicios</code> para recuperar cierta informaci\u00f3n que no sea de su \u00e1mbito / competencia.</li> <li>Debe trabajar en la medida de lo posible con objetos de tipo <code>Entity</code>.</li> <li>Es un buen lugar para implementar la l\u00f3gica de negocio.</li> </ul> </li> <li>Un <code>Acceso a Datos</code><ul> <li>NO puede llamar a ninguna otra capa. Ni <code>Controlador</code>, ni <code>Servicios</code>, ni <code>Acceso a Datos</code>.</li> <li>NO debe contener l\u00f3gica en su clase.</li> <li>Esta capa solo debe resolver el dato que se le ha solicitado y devolverlo a la capa de <code>Servicios</code>.</li> </ul> </li> </ul>"},{"location":"cleancode/vuejs/","title":"Estructura y Buenas pr\u00e1cticas - Vue.js","text":"<p>Nota</p> <p>Antes de empezar y para puntualizar, Vue.js es un framework progresivo para construir interfaces de usuario. A diferencia de otros frameworks monol\u00edticos, Vue.js est\u00e1 dise\u00f1ado desde cero para ser utilizado incrementalmente. La librer\u00eda central est\u00e1 enfocada solo en la capa de visualizaci\u00f3n, y es f\u00e1cil de utilizar e integrar con otras librer\u00edas o proyectos existentes. Por otro lado, Vue.js tambi\u00e9n es perfectamente capaz de impulsar sofisticadas Single-Page Applications cuando se utiliza en combinaci\u00f3n con herramientas modernas y librer\u00edas de apoyo.</p> <p>En esta parte vamos a explicar los fundamentos de un proyecto en Vue.js y las recomendaciones existentes.</p>"},{"location":"cleancode/vuejs/#estructura-y-funcionamiento","title":"Estructura y funcionamiento","text":""},{"location":"cleancode/vuejs/#ciclos-de-vida-de-un-componente","title":"Ciclos de vida de un componente","text":"<p>Vue.js cuenta con un conjunto de ciclos de vida que permiten a los desarrolladores controlar y personalizar el comportamiento de sus componentes en diferentes momentos. Estos ciclos de vida se pueden agrupar en tres fases principales: creaci\u00f3n, actualizaci\u00f3n y eliminaci\u00f3n.</p> <p>A continuaci\u00f3n, te explicar\u00e9 cada uno de los ciclos de vida disponibles en Vue.js junto con la Options API:</p> <ol> <li> <p>beforeCreate: Este ciclo de vida se ejecuta inmediatamente despu\u00e9s de que se haya creado una instancia de componente, pero antes de que se haya creado su DOM. En este punto, a\u00fan no es posible acceder a las propiedades del componente y a\u00fan no se han establecido las observaciones reactivas.</p> </li> <li> <p>created: Este ciclo de vida se ejecuta despu\u00e9s de que se haya creado una instancia de componente y se hayan establecido las observaciones reactivas. En este punto, el componente ya puede acceder a sus propiedades y m\u00e9todos.</p> </li> <li> <p>beforeMount: Este ciclo de vida se ejecuta justo antes de que el componente se monte en el DOM. En este punto, el componente ya est\u00e1 preparado para ser renderizado, pero a\u00fan no se ha agregado al \u00e1rbol de elementos del DOM.</p> </li> <li> <p>mounted: Este ciclo de vida se ejecuta despu\u00e9s de que el componente se ha montado en el DOM. En este punto, el componente ya est\u00e1 en el \u00e1rbol de elementos del DOM y se puede acceder a sus elementos hijos y a los elementos del DOM que lo rodean.</p> </li> <li> <p>beforeUpdate: Este ciclo de vida se ejecuta justo antes de que el componente se actualice en respuesta a un cambio en sus propiedades o estado. En este punto, el componente a\u00fan no se ha actualizado en el DOM.</p> </li> <li> <p>updated: Este ciclo de vida se ejecuta despu\u00e9s de que el componente se haya actualizado en el DOM en respuesta a un cambio en sus propiedades o estado. En este punto, el componente ya se ha actualizado en el DOM y se puede acceder a sus elementos hijos y a los elementos del DOM que lo rodean.</p> </li> <li> <p>beforeUnmount: Este ciclo de vida se ejecuta justo antes de que el componente se elimine del DOM. En este punto, el componente a\u00fan est\u00e1 en el \u00e1rbol de elementos del DOM.</p> </li> <li> <p>unmounted: Este ciclo de vida se ejecuta despu\u00e9s de que el componente se haya eliminado del DOM. En este punto, el componente ya no est\u00e1 en el \u00e1rbol de elementos del DOM y no se puede acceder a sus elementos hijos.</p> </li> <li> <p>errorCaptured: Este ciclo de vida se ejecuta cuando se produce un error en cualquier descendiente del componente y se captura en el componente actual. Esto permite que el componente maneje el error de forma personalizada en lugar de propagarse hacia arriba en la cadena de componentes.</p> </li> <li> <p>activated: Este ciclo de vida se ejecuta cuando un componente que se encuentra en un \u00e1rbol de componentes inactivo (por ejemplo, un componente en una pesta\u00f1a inactiva) se activa.</p> </li> <li> <p>deactivated: Este ciclo de vida se ejecuta cuando un componente que se encuentra en un \u00e1rbol de componentes activo (por ejemplo, un componente en una pesta\u00f1a activa) se desactiva y se vuelve inactivo.</p> </li> <li> <p>renderTracked: Este ciclo de vida se ejecuta cuando se observa una dependencia en el proceso de renderizado del componente. Esto se utiliza principalmente para fines de depuraci\u00f3n. </p> </li> <li> <p>renderTriggered: Este ciclo de vida se ejecuta cuando se desencadena un nuevo renderizado del componente. Esto se utiliza principalmente para fines de depuraci\u00f3n. </p> </li> <li> <p>serverPrefetch: Este ciclo de vida se utiliza en el contexto de renderizado del lado del servidor (SSR). Se ejecuta cuando el componente se preprocesa en el servidor antes de enviarse al cliente. En este punto, el componente a\u00fan no se ha montado en el DOM y no se pueden realizar operaciones que dependan del DOM. Esto se utiliza principalmente para cargar datos de forma as\u00edncrona antes de que se renderice el componente en el servidor. </p> </li> </ol> <p>Os dejo un peque\u00f1o esquema de los ciclos de vida mas importantes y en que momento se ejecutan:</p> <p></p> <p>Es importante tenerlo claro para saber que m\u00e9todos podemos utilizar para realizar operaciones con el componente.</p>"},{"location":"cleancode/vuejs/#carpetas-creadas-por-vuejs","title":"Carpetas creadas por Vue.js","text":"<ul> <li>node_modules: Todos los m\u00f3dulos de librer\u00edas usadas por el proyecto.</li> <li>public: Contiene iconos y archivos accesibles por todos los usuarios.</li> <li>.quasar: Contiene configuraci\u00f3n propia de Quasar.</li> <li>\\src: Contiene todo el c\u00f3digo asociado al proyecto.<ul> <li>\\src\\assets: Normalmente la carpeta usada para los recursos.</li> <li>\\src\\components: Aqu\u00ed ir\u00e1n los diferentes componentes que iremos creando para la aplicaci\u00f3n.</li> <li>\\src\\router: Es la carpeta donde el scafolding nos mete el router con sus diferentes rutas.</li> <li>\\src\\layouts: Aqu\u00ed iran las diferentes vistas de la aplicaci\u00f3n.</li> </ul> </li> </ul> <p>Otros ficheros importantes de un proyecto de Vue.js</p> <p>Otros archivos que debemos tener en cuenta dentro del proyecto son:</p> <ul> <li>quasar.d.ts: Configurador de la conexi\u00f3n entre la librer\u00eda y Vue</li> <li>package.json: Dependencias de librer\u00edas y scripts</li> <li>quasar.config.js: Configurador del CLI de Quasar</li> <li>\\src\\App.vue: Punto de entrada a nuestra aplicaci\u00f3n</li> </ul>"},{"location":"cleancode/vuejs/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":"<p>A continuaci\u00f3n veremos un listado de buenas pr\u00e1cticas de Vue.js y de c\u00f3digo limpio que deber\u00edamos intentar seguir en nuestro desarrollo.</p>"},{"location":"cleancode/vuejs/#estructura-de-archivos","title":"Estructura de archivos","text":"<p>Antes de empezar con un proyecto lo ideal, es pararse y pensar en los requerimientos de una buena estructura, en un futuro lo agradecer\u00e1s.</p>"},{"location":"cleancode/vuejs/#nombres-claros","title":"Nombres claros","text":"<p>Determinar una manera de nombrar a los componentes (UpperCamelCase, lowerCamelCase, kebab-case, snake_case, ...) y continuarla para todos los archivos, nombres descriptivos de los componentes y en una ruta acorde (si es un componente que forma parte de una pantalla, se ubicar\u00e1 dentro de la carpeta de esa pantalla pero si se usa en m\u00e1s de una pantalla, se ubicar\u00e1 en una carpeta externa a cualquier pantalla llamada common), componentes de m\u00e1ximo 350 l\u00edneas y componentes con finalidad \u00fanica (recibe los datos necesarios para realizar las tareas b\u00e1sicas de ese componente).</p>"},{"location":"cleancode/vuejs/#organiza-tu-codigo","title":"Organiza tu c\u00f3digo","text":"<p>El c\u00f3digo debe estar ordenado dentro de los componente siguiendo un orden de importancia similar a este:</p> <ol> <li>Importaciones de las diferentes librer\u00edas o componentes usados.</li> <li>Importaciones de funciones de otros archivos (como utils).</li> <li>Variables o constantes usadas para almacenar la informaci\u00f3n necesaria en este componente.</li> <li>Funciones necesarias para el resto del c\u00f3digo.</li> <li>Variables computadas, watchers, etc.</li> <li>C\u00f3digo HTML del componente.</li> </ol>"},{"location":"cleancode/vuejs/#consejos-varios","title":"Consejos varios","text":"<p>Modificaciones entre componentes</p> <p>A la hora de crear un componente b\u00e1sico (como un input propio) que necesite modificar su propio valor (algo que un componente hijo no debe hacer, ya que la variable estar\u00e1 en el padre), saber diferenciar entre v-model y modelValue (esta \u00faltima s\u00ed que permite modificar el valor en el padre mediante el evento update:modelValue sin tener que hacer nada m\u00e1s en el padre que pasarle el valor).</p> <p>Utiliza formateo y correcci\u00f3n de c\u00f3digo</p> <p>Si has seguido nuestro tutorial se habr\u00e1 instalado ESLint y Prettier. Si no, deber\u00edas instalarlo para generar c\u00f3digo de buena calidad. Adem\u00e1s de instalar alguna extensi\u00f3n en Visual Studio Code que te ayude a gestionar esas herramientas.</p> <p>Nomenclatura de funciones y variables</p> <p>El nombre de las funciones, al igual que los path de una API, deber\u00edan ser autoexplicativos y no tener que seguir la traza del c\u00f3digo para saber qu\u00e9 hace. Con un buen nombre para cada funci\u00f3n o variables de estado, evitas tener que a\u00f1adir comentarios para explicar qu\u00e9 hace o qu\u00e9 almacena cada una de ellas.       </p>"},{"location":"develop/basic/angular/","title":"Listado simple - Angular","text":"<p>Ahora que ya tenemos listo el proyecto frontend de Angular (en el puerto 4200), ya podemos empezar a codificar la soluci\u00f3n.</p>"},{"location":"develop/basic/angular/#primeros-pasos","title":"Primeros pasos","text":"<p>Antes de empezar</p> <p>Quiero hacer hincapi\u00e9 que Angular tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. Tanto en la propia web de documentaci\u00f3n de Angular como en la web de componentes Angular Material puedes buscar casi cualquier ejemplo que necesites.</p> <p>Si abrimos el proyecto con el IDE que tengamos (Visual Studio Code en el caso del tutorial) podemos ver que en la carpeta <code>src/app</code> existen unos ficheros ya creados por defecto. Estos ficheros son:</p> <ul> <li><code>app.component.ts</code> \u2192 contiene el c\u00f3digo inicial del proyecto escrito en TypeScript.</li> <li><code>app.component.html</code> \u2192 contiene la plantilla inicial del proyecto escrita en HTML.</li> <li><code>app.component.scss</code> \u2192 contiene los estilos CSS privados de la plantilla inicial.</li> </ul> <p>Vamos a modificar este c\u00f3digo inicial para ver como funciona. Abrimos el fichero <code>app.component.ts</code> y modificamos la l\u00ednea donde se asigna un valor a la variable <code>title</code>.</p> app.component.ts <pre><code>...\ntitle = 'Tutorial de Angular';\n...\n</code></pre> <p>Ahora abrimos el fichero <code>app.component.html</code>, borramos todo el c\u00f3digo de la plantilla y a\u00f1adimos el siguiente c\u00f3digo:</p> app.component.html <pre><code>&lt;h1&gt;{{title}}&lt;/h1&gt;\n</code></pre> <p>Las llaves dobles permiten hacen un binding entre el c\u00f3digo del componente y la plantilla. Es decir, en este caso ir\u00e1 al c\u00f3digo TypeScript y buscar\u00e1 el valor de la variable <code>title</code>.</p> <p>Consejo</p> <p>El binding tambi\u00e9n nos sirve para ejecutar los m\u00e9todos de TypeScript desde el c\u00f3digo HTML. Adem\u00e1s si el valor que contiene la variable se modificara durante la ejecuci\u00f3n de alg\u00fan m\u00e9todo, autom\u00e1ticamente el c\u00f3digo HTML refrescar\u00eda el nuevo valor de la variable <code>title</code> </p> <p>Si abrimos el navegador y accedemos a <code>http://localhost:4200/</code> podremos ver el resultado del c\u00f3digo.</p>"},{"location":"develop/basic/angular/#layout-general","title":"Layout general","text":""},{"location":"develop/basic/angular/#crear-componente","title":"Crear componente","text":"<p>Lo primero que vamos a hacer es escoger un tema y una paleta de componentes para trabajar. Lo m\u00e1s c\u00f3modo es trabajar con <code>Material</code> que ya viene perfectamente integrado en Angular. Ejecutamos el comando y elegimos la paleta de colores que m\u00e1s nos guste o bien creamos una custom:</p> <pre><code>ng add @angular/material\n</code></pre> <p>Recuerda</p> <p>Al a\u00f1adir una nueva librer\u00eda tenemos que parar el servidor y volver a arrancarlo para que compile y precargue las nuevas dependencias.</p> <p>Una vez a\u00f1adida la dependencia, lo que queremos es crear una primera estructura inicial a la p\u00e1gina. Si te acuerdas cual era la estructura (y si no te acuerdas, vuelve a la secci\u00f3n <code>Contexto de la aplicaci\u00f3n</code> y lo revisas), ten\u00edamos una cabecera superior con un logo y t\u00edtulo y unas opciones de men\u00fa.</p> <p>Pues vamos a ello, crearemos esa estructura com\u00fan para toda la aplicaci\u00f3n. Este componente al ser algo core para toda la aplicaci\u00f3n deber\u00edamos crearlo dentro del m\u00f3dulo <code>core</code> como ya vimos anteriormente.</p> <p>Pero antes de todo, vamos a crear los m\u00f3dulos generales de la aplicaci\u00f3n, as\u00ed que ejecutamos en consola el comando que nos permite crear un m\u00f3dulo nuevo:</p> <pre><code>ng generate module core\n</code></pre> <p>Y a\u00f1adimos esos m\u00f3dulos al m\u00f3dulo padre de la aplicaci\u00f3n:</p> app.module.ts <pre><code>import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { CoreModule } from './core/core.module';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    CoreModule,\n    BrowserAnimationsModule,\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n</code></pre> <p>Y despu\u00e9s crearemos el componente header, dentro del m\u00f3dulo core. Para eso ejecutaremos el comando:</p> <pre><code>ng generate component core/header\n</code></pre>"},{"location":"develop/basic/angular/#codigo-de-la-pantalla","title":"C\u00f3digo de la pantalla","text":"<p>Esto nos crear\u00e1 una carpeta con los ficheros del componente, donde tendremos que copiar el siguiente contenido:</p> header.component.htmlheader.component.scss <pre><code>&lt;mat-toolbar&gt;\n    &lt;mat-toolbar-row&gt;\n        &lt;div class=\"header_container\"&gt;\n            &lt;div class=\"header_title\"&gt;              \n                &lt;mat-icon&gt;storefront&lt;/mat-icon&gt; Ludoteca Tan\n            &lt;/div&gt;\n\n            &lt;div class=\"header_separator\"&gt; | &lt;/div&gt;\n\n            &lt;div class=\"header_menu\"&gt;\n                &lt;div class=\"header_button\"&gt;\n                    &lt;a routerLink=\"/games\" routerLinkActive=\"active\"&gt;Cat\u00e1logo&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;div class=\"header_button\"&gt;\n                    &lt;a routerLink=\"/categories\" routerLinkActive=\"active\"&gt;Categor\u00edas&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;div class=\"header_button\"&gt;\n                    &lt;a routerLink=\"/authors\" routerLinkActive=\"active\"&gt;Autores&lt;/a&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n\n            &lt;div class=\"header_login\"&gt;\n                &lt;mat-icon&gt;account_circle&lt;/mat-icon&gt; Sign in\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/mat-toolbar-row&gt;\n&lt;/mat-toolbar&gt;\n</code></pre> <pre><code>.mat-toolbar {\n  background-color: blue;\n  color: white;\n}\n\n.header_container {\n    display: flex;\n    width: 100%;\n    .header_title {\n        .mat-icon {\n            vertical-align: sub;\n        }\n    }\n\n    .header_separator {\n        margin-left: 30px;\n        margin-right: 30px;\n    }\n\n    .header_menu {\n        flex-grow: 4;\n        display: flex;\n        flex-direction: row;\n\n        .header_button {\n            margin-left: 1em;\n            margin-right: 1em;\n            font-size: 16px;\n\n            a {\n              font-weight: lighter;\n              text-decoration: none;\n              cursor: pointer;\n              color: white;\n            }\n\n            a:hover {\n              color: grey;\n            }\n\n            a.active {\n              font-weight: normal;\n              text-decoration: underline;\n              color: lightyellow;\n            }\n\n        }\n    }\n\n    .header_login {\n      font-size: 16px;\n      cursor: pointer;\n      .mat-icon {\n          vertical-align: sub;\n      }\n  }\n}\n</code></pre> <p>Al utilizar etiquetas de material como <code>mat-toolbar</code> o <code>mat-icon</code> y <code>routerLink</code> necesitaremos importar las dependencias. Esto lo podemos hacer directamente en el m\u00f3dulo del que depende, es decir en el fichero <code>core.module.ts</code></p> core.module.ts <pre><code>import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatToolbarModule } from '@angular/material/toolbar';\nimport { HeaderComponent } from './header/header.component';\nimport { RouterModule } from '@angular/router';\n\n\n@NgModule({\n  declarations: [HeaderComponent],\n  imports: [\n    CommonModule,\n    RouterModule,\n    MatIconModule, \n    MatToolbarModule,\n  ],\n  exports: [\n    HeaderComponent\n  ]\n})\nexport class CoreModule { }\n</code></pre> <p>Adem\u00e1s de a\u00f1adir las dependencias, diremos que este m\u00f3dulo va a exportar el componente <code>HeaderComponent</code> para poder utilizarlo desde otras p\u00e1ginas.</p> <p>Ya por \u00faltimo solo nos queda modificar la p\u00e1gina general de la aplicaci\u00f3n <code>app.component.html</code> para a\u00f1adirle el componente <code>HeaderComponent</code>.</p> app.component.html <pre><code>&lt;div&gt;\n  &lt;app-header&gt;&lt;/app-header&gt;\n  &lt;div&gt;\n    &lt;router-outlet&gt;&lt;/router-outlet&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>Vamos al navegador y refrescamos la p\u00e1gina, deber\u00eda aparecer una barra superior (Header) con las opciones de men\u00fa. Algo similar a esto:</p> <p></p> <p>Recuerda</p> <p>Cuando se a\u00f1aden componentes a los ficheros <code>html</code>, siempre se deben utilizar los selectores definidos para el componente. En el caso anterior hemos a\u00f1adido <code>app-header</code> que es el mismo nombre selector que tiene el componente en el fichero <code>header.component.ts</code>. Adem\u00e1s, recuerda que para poder utilizar componentes de otros m\u00f3dulos, los debes exportar ya que de lo contrario tan solo podr\u00e1n utilizarse dentro del m\u00f3dulo donde se declaran.</p>"},{"location":"develop/basic/angular/#creando-un-listado-basico","title":"Creando un listado b\u00e1sico","text":""},{"location":"develop/basic/angular/#crear-componente_1","title":"Crear componente","text":"<p>Ya tenemos la estructura principal, ahora vamos a crear nuestra primera pantalla. Vamos a empezar por la de <code>Categor\u00edas</code> que es la m\u00e1s sencilla, ya que se trata de un listado, que muestra datos sin filtrar ni paginar.</p> <p>Como categor\u00edas es un dominio funcional de la aplicaci\u00f3n, vamos a crear un m\u00f3dulo que contenga toda la funcionalidad de ese dominio. Ejecutamos en consola:</p> <pre><code>ng generate module category\n</code></pre> <p>Y por tanto, al igual que hicimos anteriormente, hay que a\u00f1adir el m\u00f3dulo al fichero <code>app.module.ts</code></p> app.module.ts <pre><code>import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { CoreModule } from './core/core.module';\nimport { CategoryModule } from './category/category.module';\n\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    CoreModule,\n    CategoryModule,\n    BrowserAnimationsModule,\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n</code></pre> <p>Ahora todas las pantallas, componentes y servicios que creemos, referidos a este dominio funcional, deber\u00e1n ir dentro del modulo <code>cagegory</code>.</p> <p>Vamos a crear un primer componente que ser\u00e1 un listado de categor\u00edas. Para ello vamos a ejecutar el siguiente comando:</p> <pre><code>ng generate component category/category-list\n</code></pre> <p>Para terminar de configurar la aplicaci\u00f3n, vamos a a\u00f1adir la ruta del componente dentro del componente routing de Angular, para poder acceder a \u00e9l, para ello modificamos el fichero <code>app-routing.module.ts</code></p> app-routing.module.ts <pre><code>import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { CategoryListComponent } from './category/category-list/category-list.component';\n\nconst routes: Routes = [\n  { path: 'categories', component: CategoryListComponent },\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n</code></pre> <p>Si abrimos el navegador y accedemos a <code>http://localhost:4200/</code> podremos navegar mediante el men\u00fa <code>Categor\u00edas</code> el cual abrir\u00e1 el componente que acabamos de crear.</p>"},{"location":"develop/basic/angular/#codigo-de-la-pantalla_1","title":"C\u00f3digo de la pantalla","text":"<p>Ahora vamos a construir la pantalla. Para manejar la informaci\u00f3n del listado, necesitamos almacenar los datos en un objeto de tipo <code>model</code>. Para ello crearemos un fichero en <code>category\\model\\Category.ts</code> donde implementaremos la clase necesaria. Esta clase ser\u00e1 la que utilizaremos en el c\u00f3digo html y ts de nuestro componente.</p> Category.ts <pre><code>export class Category {\n    id: number;\n    name: string;\n}\n</code></pre> <p>Tambi\u00e9n, escribiremos el c\u00f3digo de la pantalla de listado.</p> category-list.component.htmlcategory-list.component.scsscategory-list.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1&gt;Listado de Categor\u00edas&lt;/h1&gt;\n\n    &lt;mat-table [dataSource]=\"dataSource\"&gt;\n        &lt;ng-container matColumnDef=\"id\"&gt;\n            &lt;mat-header-cell *matHeaderCellDef&gt; Identificador &lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.id}} &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n        &lt;ng-container matColumnDef=\"name\"&gt;\n            &lt;mat-header-cell *matHeaderCellDef&gt; Nombre categor\u00eda  &lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.name}} &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n        &lt;ng-container matColumnDef=\"action\"&gt;\n            &lt;mat-header-cell *matHeaderCellDef&gt;&lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt;\n                &lt;button mat-icon-button color=\"primary\"&gt;&lt;mat-icon&gt;edit&lt;/mat-icon&gt;&lt;/button&gt;\n                &lt;button mat-icon-button color=\"accent\"&gt;&lt;mat-icon&gt;clear&lt;/mat-icon&gt;&lt;/button&gt;\n            &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n        &lt;mat-header-row *matHeaderRowDef=\"displayedColumns; sticky: true\"&gt;&lt;/mat-header-row&gt;\n        &lt;mat-row *matRowDef=\"let row; columns: displayedColumns;\"&gt;&lt;/mat-row&gt;\n    &lt;/mat-table&gt;\n\n    &lt;div class=\"buttons\"&gt;\n        &lt;button mat-flat-button color=\"primary\"&gt;Nueva categor\u00eda&lt;/button&gt;\n    &lt;/div&gt;   \n&lt;/div&gt;\n</code></pre> <pre><code>.container {\n  margin: 20px;\n\n  mat-table {\n    margin-top: 10px;\n    margin-bottom: 20px;\n\n    .mat-header-row {\n      background-color:#f5f5f5;\n\n      .mat-header-cell {\n        text-transform: uppercase;\n        font-weight: bold;\n        color: #838383;\n      }      \n    }\n\n    .mat-column-id {\n      flex: 0 0 20%;\n      justify-content: center;\n    }\n\n    .mat-column-action {\n      flex: 0 0 10%;\n      justify-content: center;\n    }\n  }\n\n  .buttons {\n    text-align: right;\n  }\n}\n</code></pre> <pre><code>import { Component, OnInit } from '@angular/core';\nimport { MatTableDataSource } from '@angular/material/table';\nimport { Category } from '../model/Category';\n\n@Component({\n  selector: 'app-category-list',\n  templateUrl: './category-list.component.html',\n  styleUrls: ['./category-list.component.scss']\n})\nexport class CategoryListComponent implements OnInit {\n\n  dataSource = new MatTableDataSource&lt;Category&gt;();\n  displayedColumns: string[] = ['id', 'name', 'action'];\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n</code></pre> <p>El c\u00f3digo HTML es f\u00e1cil de seguir pero por si acaso:</p> <ul> <li>L\u00ednea 4: Creamos la tabla con la variable <code>dataSource</code> definida en el fichero .ts</li> <li>L\u00ednea 5: Definici\u00f3n de la primera columna, su cabecera y el dato que va a contener</li> <li>L\u00ednea 10: Definici\u00f3n de la segunda columna, su cabecera y el dato que va a contener</li> <li>L\u00ednea 15: Definici\u00f3n de la tercera columna, su cabecera vac\u00eda y los dos botones de acci\u00f3n</li> <li>L\u00ednea 23 y 24: Construcci\u00f3n de la cabecera y las filas</li> </ul> <p>Y ya por \u00faltimo, a\u00f1adimos los componentes que se han utilizado de Angular Material a las dependencias del m\u00f3dulo donde est\u00e1 definido el componente en este caso <code>category\\category.module.ts</code>:</p> category.module.ts <pre><code>import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { MatTableModule } from '@angular/material/table';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatButtonModule } from '@angular/material/button';\nimport { CategoryListComponent } from './category-list/category-list.component';\n\n@NgModule({\n  declarations: [CategoryListComponent],\n  imports: [\n    CommonModule,\n    MatTableModule,\n    MatIconModule, \n    MatButtonModule\n  ],\n})\nexport class CategoryModule { }\n</code></pre> <p>Si abrimos el navegador y accedemos a <code>http://localhost:4200/</code> y pulsamos en el men\u00fa de <code>Categor\u00edas</code> obtendremos una pantalla con un listado vac\u00edo (solo con cabeceras) y un bot\u00f3n de crear Nueva Categor\u00eda que aun no hace nada.</p>"},{"location":"develop/basic/angular/#anadiendo-datos","title":"A\u00f1adiendo datos","text":"<p>En este punto y para ver como responde el listado, vamos a a\u00f1adir datos. Si tuvieramos el backend implementado podr\u00edamos consultar los datos directamente de una operaci\u00f3n de negocio de backend, pero ahora mismo no lo tenemos implementado as\u00ed que para no bloquear el desarrollo vamos a mockear los datos.</p>"},{"location":"develop/basic/angular/#creando-un-servicio","title":"Creando un servicio","text":"<p>En angular, cualquier acceso a datos debe pasar por un <code>service</code>, as\u00ed que vamos a crearnos uno para todas las operaciones de categor\u00edas. Vamos a la consola y ejecutamos:</p> <pre><code>ng generate service category/category\n</code></pre> <p>Esto nos crear\u00e1 un servicio, que adem\u00e1s podemos utilizarlo inyect\u00e1ndolo en cualquier componente que lo necesite. </p>"},{"location":"develop/basic/angular/#implementando-un-servicio","title":"Implementando un servicio","text":"<p>Vamos a implementar una operaci\u00f3n de negocio que recupere el listado de categor\u00edas y lo vamos a hacer de forma reactiva (as\u00edncrona) para simular una petici\u00f3n a backend. Modificamos los siguientes ficheros:</p> category.service.tscategory-list.component.ts <pre><code>import { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { Category } from './model/Category';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class CategoryService {\n\n  constructor() { }\n\n  getCategories(): Observable&lt;Category[]&gt; {\n    return new Observable();\n  }\n}\n</code></pre> <pre><code>import { Component, OnInit } from '@angular/core';\nimport { MatTableDataSource } from '@angular/material/table';\nimport { Category } from '../model/Category';\nimport { CategoryService } from '../category.service';\n\n@Component({\n  selector: 'app-category-list',\n  templateUrl: './category-list.component.html',\n  styleUrls: ['./category-list.component.scss']\n})\nexport class CategoryListComponent implements OnInit {\n\n  dataSource = new MatTableDataSource&lt;Category&gt;();\n  displayedColumns: string[] = ['id', 'name', 'action'];\n\n  constructor(\n    private categoryService: CategoryService,\n  ) { }\n\n  ngOnInit(): void {\n    this.categoryService.getCategories().subscribe(\n      categories =&gt; this.dataSource.data = categories\n    );\n  }\n}\n</code></pre>"},{"location":"develop/basic/angular/#mockeando-datos","title":"Mockeando datos","text":"<p>Como hemos comentado anteriormente, el backend todav\u00eda no est\u00e1 implementado as\u00ed que vamos a mockear datos. Nos crearemos un fichero <code>mock-categories.ts</code> dentro de model, con datos ficticios y modificaremos el servicio para que devuelva esos datos. De esta forma, cuando tengamos implementada la operaci\u00f3n de negocio en backend, tan solo tenemos que sustuir el c\u00f3digo que devuelve datos est\u00e1ticos por una llamada http.</p> mock-categories.tscategory.service.ts <pre><code>import { Category } from \"./Category\";\n\nexport const CATEGORY_DATA: Category[] = [\n    { id: 1, name: 'Dados' },\n    { id: 2, name: 'Fichas' },\n    { id: 3, name: 'Cartas' },\n    { id: 4, name: 'Rol' },\n    { id: 5, name: 'Tableros' },\n    { id: 6, name: 'Tem\u00e1ticos' },\n    { id: 7, name: 'Europeos' },\n    { id: 8, name: 'Guerra' },\n    { id: 9, name: 'Abstractos' },\n]    \n</code></pre> <pre><code>import { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Category } from './model/Category';\nimport { CATEGORY_DATA } from './model/mock-categories';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class CategoryService {\n\n  constructor() { }\n\n  getCategories(): Observable&lt;Category[]&gt; {\n    return of(CATEGORY_DATA);\n  }\n}\n</code></pre> <p>Si ahora refrescamos la p\u00e1gina web, veremos que el listado ya tiene datos con los que vamos a interactuar.</p> <p></p>"},{"location":"develop/basic/angular/#simulando-las-otras-peticiones","title":"Simulando las otras peticiones","text":"<p>Para terminar, vamos a simular las otras dos peticiones, la de editar y la de borrar para cuando tengamos que utilizarlas. El servicio debe quedar m\u00e1s o menos as\u00ed:</p> category.service.ts <pre><code>import { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Category } from './model/Category';\nimport { CATEGORY_DATA } from './model/mock-categories';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class CategoryService {\n\n  constructor() { }\n\n  getCategories(): Observable&lt;Category[]&gt; {\n    return of(CATEGORY_DATA);\n  }\n\n  saveCategory(category: Category): Observable&lt;Category&gt; {\n    return of(null);\n  }\n\n  deleteCategory(idCategory : number): Observable&lt;any&gt; {\n    return of(null);\n  }  \n}\n</code></pre>"},{"location":"develop/basic/angular/#anadiendo-acciones-al-listado","title":"A\u00f1adiendo acciones al listado","text":""},{"location":"develop/basic/angular/#crear-componente_2","title":"Crear componente","text":"<p>Ahora nos queda a\u00f1adir las acciones al listado: crear, editar y eliminar. Empezaremos primero por las acciones de crear y editar, que ambas deber\u00edan abrir una ventana modal con un formulario para poder modificar datos de la entidad <code>Categor\u00eda</code>. Como siempre, para crear un componente usamos el asistente de Angular, esta vez al tratarse de una pantalla que solo vamos a utilizar dentro del dominio de categor\u00edas, tiene sentido que lo creemos dentro de ese m\u00f3dulo:</p> <pre><code>ng generate component category/category-edit\n</code></pre> <p>Ahora vamos a hacer que se abra al pulsar el bot\u00f3n <code>Nueva categor\u00eda</code>. Para eso, vamos al fichero <code>category-list.component.ts</code> y a\u00f1adimos un nuevo m\u00e9todo:</p> category-list.component.ts <pre><code>...\nimport { MatDialog } from '@angular/material/dialog';\nimport { CategoryEditComponent } from '../category-edit/category-edit.component';\n...\n  constructor(\n    private categoryService: CategoryService,\n    public dialog: MatDialog,\n  ) { }\n...\n  createCategory() {    \n    const dialogRef = this.dialog.open(CategoryEditComponent, {\n      data: {}\n    });\n\n    dialogRef.afterClosed().subscribe(result =&gt; {\n      this.ngOnInit();\n    });    \n  }  \n...\n</code></pre> <p>Para poder abrir un componente dentro de un dialogo necesitamos obtener en el constructor un MatDialog. De ah\u00ed que hayamos tenido que a\u00f1adirlo como import y en el constructor.</p> <p>Dentro del m\u00e9todo <code>createCategory</code> lo que hacemos es crear un dialogo con el componente <code>CategoryEditComponent</code> en su interior, pasarle unos datos de creaci\u00f3n, donde podemos poner estilos del dialog y un objeto <code>data</code> donde pondremos los datos que queremos pasar entre los componentes. Por \u00faltimo, nos suscribimos al evento <code>afterClosed</code> para ejecutar las acciones que creamos oportunas, en nuestro caso volveremos a cargar el listado inicial.</p> <p>Como hemos utilizado un <code>MatDialog</code> en el componente, necesitamos a\u00f1adirlo tambi\u00e9n al m\u00f3dulo, as\u00ed que abrimos el fichero <code>category.module.ts</code> y a\u00f1adimos:</p> category.module.ts <pre><code>...\nimport { MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';\n\n@NgModule({\n  declarations: [CategoryListComponent, CategoryEditComponent],\n  imports: [\n    ...\n    MatDialogModule\n  ],\n  providers: [\n    {\n      provide: MAT_DIALOG_DATA,\n      useValue: {},\n    },\n  ]\n})\nexport class CategoryModule { }\n</code></pre> <p>Y ya por \u00faltimo enlazamos el click en el bot\u00f3n con el m\u00e9todo que acabamos de crear para abrir el dialogo. Modificamos el fichero <code>category-list.component.html</code> y a\u00f1adimos el evento click:</p> category-list.component.html <pre><code>...\n    &lt;div class=\"buttons\"&gt;\n        &lt;button mat-flat-button color=\"primary\" (click)=\"createCategory()\"&gt;Nueva categor\u00eda&lt;/button&gt; \n    &lt;/div&gt;   \n&lt;/div&gt;\n</code></pre> <p>Si refrescamos el navegador y pulsamos el bot\u00f3n <code>Nueva categor\u00eda</code> veremos como se abre una ventana modal de tipo Dialog con el componente nuevo que hemos creado, aunque solo se leer\u00e1 <code>category-edit works!</code> que es el contenido por defecto del componente.</p>"},{"location":"develop/basic/angular/#codigo-del-dialogo","title":"C\u00f3digo del dialogo","text":"<p>Ahora vamos a darle forma al formulario de editar y crear. Para ello vamos al html, ts y css del componente y pegamos el siguiente contenido:</p> category-edit.component.htmlcategory-edit.component.scsscategory-edit.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1&gt;Crear categor\u00eda&lt;/h1&gt;\n\n    &lt;form&gt;\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;Identificador&lt;/mat-label&gt;\n            &lt;input type=\"text\" matInput placeholder=\"Identificador\" [(ngModel)]=\"category.id\" name=\"id\" disabled&gt;\n        &lt;/mat-form-field&gt;\n\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;Nombre&lt;/mat-label&gt;\n            &lt;input type=\"text\" matInput placeholder=\"Nombre de categor\u00eda\" [(ngModel)]=\"category.name\" name=\"name\" required&gt;\n            &lt;mat-error&gt;El nombre no puede estar vac\u00edo&lt;/mat-error&gt;\n        &lt;/mat-form-field&gt;\n    &lt;/form&gt;\n\n    &lt;div class=\"buttons\"&gt;\n        &lt;button mat-stroked-button (click)=\"onClose()\"&gt;Cerrar&lt;/button&gt;\n        &lt;button mat-flat-button color=\"primary\" (click)=\"onSave()\"&gt;Guardar&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <pre><code>.container {\n    min-width: 350px;\n    max-width: 500px;\n    padding: 20px;\n\n    form {\n        display: flex;\n        flex-direction: column;\n        margin-bottom:20px;\n    }\n\n    .buttons {\n      text-align: right;\n\n      button {\n          margin-left: 10px;\n      }\n    }\n}\n</code></pre> <pre><code>import { Component, OnInit } from '@angular/core';\nimport { MatDialogRef } from '@angular/material/dialog';\nimport { CategoryService } from '../category.service';\nimport { Category } from '../model/Category';\n\n@Component({\n  selector: 'app-category-edit',\n  templateUrl: './category-edit.component.html',\n  styleUrls: ['./category-edit.component.scss']\n})\nexport class CategoryEditComponent implements OnInit {\n\n  category : Category;\n\n  constructor(\n    public dialogRef: MatDialogRef&lt;CategoryEditComponent&gt;,\n    private categoryService: CategoryService\n  ) { }\n\n  ngOnInit(): void {\n    this.category = new Category();\n  }\n\n  onSave() {\n    this.categoryService.saveCategory(this.category).subscribe(result =&gt; {\n      this.dialogRef.close();\n    });    \n  }  \n\n  onClose() {\n    this.dialogRef.close();\n  }\n\n}\n</code></pre> <p>Si te fijas en el c\u00f3digo TypeScript, hemos a\u00f1adido en el m\u00e9todo <code>onSave</code> una llamada al servicio de <code>CategoryService</code> que aunque no realice ninguna operaci\u00f3n de momento, por lo menos lo dejamos preparado para conectar con el servidor.</p> <p>Adem\u00e1s, como siempre, al utilizar componentes <code>matInput</code>, <code>matForm</code>, <code>matError</code> hay que a\u00f1adirlos como dependencias en el m\u00f3dulo <code>category.module.ts</code>:</p> category.module.ts <pre><code>...\nimport { MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';\nimport { MatFormFieldModule } from '@angular/material/form-field';\nimport { MatInputModule } from '@angular/material/input';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\n\n@NgModule({\n  declarations: [CategoryListComponent, CategoryEditComponent],\n  imports: [\n    ...\n    MatDialogModule,\n    MatFormFieldModule,\n    MatInputModule,\n    FormsModule,\n    ReactiveFormsModule,\n  ],\n  providers: [\n    {\n      provide: MAT_DIALOG_DATA,\n      useValue: {},\n    },\n  ]\n})\nexport class CategoryModule { }\n</code></pre> <p>Ahora podemos navegar y abrir el cuadro de dialogo mediante el bot\u00f3n <code>Nueva categor\u00eda</code> para ver como queda nuestro formulario.</p>"},{"location":"develop/basic/angular/#utilizar-el-dialogo-para-editar","title":"Utilizar el dialogo para editar","text":"<p>El mismo componente que hemos utilizado para crear una nueva categor\u00eda, nos sirve tambi\u00e9n para editar una categor\u00eda existente. Tan solo tenemos que utilizar la funcionalidad que Angular nos proporciona y pasarle los datos a editar en la llamada de apertura del Dialog. Vamos a implementar funcionalidad sobre el icono <code>editar</code>, tendremos que modificar unos cuantos ficheros:</p> category-list.component.htmlcategory-list.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1&gt;Listado de Categor\u00edas&lt;/h1&gt;\n\n    &lt;mat-table [dataSource]=\"dataSource\"&gt; \n        &lt;ng-container matColumnDef=\"id\"&gt;\n            &lt;mat-header-cell *matHeaderCellDef&gt; Identificador &lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.id}} &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n        &lt;ng-container matColumnDef=\"name\"&gt;\n            &lt;mat-header-cell *matHeaderCellDef&gt; Nombre categor\u00eda  &lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.name}} &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n        &lt;ng-container matColumnDef=\"action\"&gt;\n            &lt;mat-header-cell *matHeaderCellDef&gt;&lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt;\n                &lt;button mat-icon-button color=\"primary\" (click)=\"editCategory(element)\"&gt;\n                    &lt;mat-icon&gt;edit&lt;/mat-icon&gt;\n                &lt;/button&gt;\n                &lt;button mat-icon-button color=\"accent\"&gt;&lt;mat-icon&gt;clear&lt;/mat-icon&gt;&lt;/button&gt;\n            &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n        &lt;mat-header-row *matHeaderRowDef=\"displayedColumns; sticky: true\"&gt;&lt;/mat-header-row&gt;\n        &lt;mat-row *matRowDef=\"let row; columns: displayedColumns;\"&gt;&lt;/mat-row&gt;\n    &lt;/mat-table&gt;\n\n    &lt;div class=\"buttons\"&gt;\n        &lt;button mat-flat-button color=\"primary\" (click)=\"createCategory()\"&gt;Nueva categor\u00eda&lt;/button&gt; \n    &lt;/div&gt;   \n&lt;/div&gt;\n</code></pre> <pre><code>export class CategoryListComponent implements OnInit {\n\n  dataSource = new MatTableDataSource&lt;Category&gt;();\n  displayedColumns: string[] = ['id', 'name', 'action'];\n\n  constructor(\n    private categoryService: CategoryService,\n    public dialog: MatDialog,\n  ) { }\n\n  ngOnInit(): void {\n    this.categoryService.getCategories().subscribe(\n      categories =&gt; this.dataSource.data = categories\n    );\n  }\n\n  createCategory() {    \n    const dialogRef = this.dialog.open(CategoryEditComponent, {\n      data: {}\n    });\n\n    dialogRef.afterClosed().subscribe(result =&gt; {\n      this.ngOnInit();\n    });    \n  }  \n\n  editCategory(category: Category) {\n    const dialogRef = this.dialog.open(CategoryEditComponent, {\n      data: { category: category }\n    });\n\n    dialogRef.afterClosed().subscribe(result =&gt; {\n      this.ngOnInit();\n    });\n  }\n}\n</code></pre> <p>Y los Dialog:</p> category-edit.component.htmlcategory-edit.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1 *ngIf=\"category.id == null\"&gt;Crear categor\u00eda&lt;/h1&gt;\n    &lt;h1 *ngIf=\"category.id != null\"&gt;Modificar categor\u00eda&lt;/h1&gt;\n\n    &lt;form&gt;\n        &lt;mat-form-field&gt;\n...\n</code></pre> <pre><code>import { Component, OnInit, Inject } from '@angular/core';\nimport { MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';\nimport { CategoryService } from '../category.service';\nimport { Category } from '../model/Category';\n\n@Component({\n  selector: 'app-category-edit',\n  templateUrl: './category-edit.component.html',\n  styleUrls: ['./category-edit.component.scss']\n})\nexport class CategoryEditComponent implements OnInit {\n\n  category : Category;\n\n  constructor(\n    public dialogRef: MatDialogRef&lt;CategoryEditComponent&gt;,\n    @Inject(MAT_DIALOG_DATA) public data: any,\n    private categoryService: CategoryService\n  ) { }\n\n  ngOnInit(): void {\n    if (this.data.category != null) {\n      this.category = this.data.category;\n    }\n    else {\n      this.category = new Category();\n    }\n  }\n\n  onSave() {\n    this.categoryService.saveCategory(this.category).subscribe(result =&gt; {\n      this.dialogRef.close();\n    });    \n  }  \n\n  onClose() {\n    this.dialogRef.close();\n  }\n\n}\n</code></pre> <p>Navegando ahora por la p\u00e1gina y pulsando en el icono de editar, se deber\u00eda abrir una ventana con los datos que hemos seleccionado, similar a esta imagen:</p> <p></p> <p>Si te fijas, al modificar los datos dentro de la ventana de di\u00e1logo se modifica tambi\u00e9n en el listado. Esto es porque estamos pasando el mismo objeto desde el listado a la ventana dialogo y al ser el listado y el formulario reactivos los dos, cualquier cambio sobre los datos se refresca directamente en la pantalla. </p> <p>Hay veces en la que este comportamiento nos interesa, pero en este caso no queremos que se modifique el listado. Para solucionarlo debemos hacer una copia del objeto, para que ambos modelos (formulario y listado) utilicen objetos diferentes. Es tan sencillo como modificar <code>category-edit.component.ts</code> y a\u00f1adirle una copia del dato</p> category-edit.component.ts <pre><code>    ...\n    ngOnInit(): void {\n      if (this.data.category != null) {\n        this.category = Object.assign({}, this.data.category);\n      }\n      else {\n        this.category = new Category();\n      }\n    }\n    ...\n</code></pre> <p>Cuidado</p> <p>Hay que tener mucho cuidado con el binding de los objetos. Hay veces que al modificar un objeto NO queremos que se modifique en todas sus instancias y tenemos que poner especial cuidado en esos aspectos.</p>"},{"location":"develop/basic/angular/#accion-de-borrado","title":"Acci\u00f3n de borrado","text":"<p>Por norma general, toda acci\u00f3n de borrado de un dato de pantalla requiere una confirmaci\u00f3n previa por parte del usuario. Es decir, para evitar que el dato se borre accidentalmente el usuario tendr\u00e1 que confirmar su acci\u00f3n. Por tanto vamos a crear un componente que nos permita pedir una confirmaci\u00f3n al usuario.</p> <p>Como esta pantalla de confirmaci\u00f3n va a ser algo com\u00fan a muchas acciones de borrado de nuestra aplicaci\u00f3n, vamos a crearla dentro del m\u00f3dulo <code>core</code>. Como siempre, ejecutamos el comando en consola:</p> <pre><code>ng generate component core/dialog-confirmation\n</code></pre> <p>E implementamos el c\u00f3digo que queremos que tenga el componente. Al ser un componente gen\u00e9rico vamos a aprovechar y leeremos las variables que le pasemos en <code>data</code>.</p> dialog-confirmation.component.htmldialog-confirmation.component.scssdialog-confirmation.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1&gt;{{title}}&lt;/h1&gt;\n    &lt;div [innerHTML]=\"description\" class=\"description\"&gt;&lt;/div&gt;\n\n    &lt;div class=\"buttons\"&gt;\n        &lt;button mat-stroked-button (click)=\"onNo()\"&gt;No&lt;/button&gt;\n        &lt;button mat-flat-button color=\"primary\" (click)=\"onYes()\"&gt;S\u00ed&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/div&gt;    \n</code></pre> <pre><code>.container {\n    min-width: 350px;\n    max-width: 500px;\n    padding: 20px;\n\n    .description {\n      margin-bottom: 20px;\n    }\n\n    .buttons {\n      text-align: right;\n\n      button {\n          margin-left: 10px;\n      }\n    }\n}    \n</code></pre> <pre><code>import { Component, OnInit, Inject } from '@angular/core';\nimport { MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';\n\n@Component({\n  selector: 'app-dialog-confirmation',\n  templateUrl: './dialog-confirmation.component.html',\n  styleUrls: ['./dialog-confirmation.component.scss']\n})\nexport class DialogConfirmationComponent implements OnInit {\n\n  title : string;\n  description : string;\n\n  constructor(\n    public dialogRef: MatDialogRef&lt;DialogConfirmationComponent&gt;,\n    @Inject(MAT_DIALOG_DATA) public data: any\n  ) { }\n\n  ngOnInit(): void {\n    this.title = this.data.title;\n    this.description = this.data.description;\n  }\n\n  onYes() {\n    this.dialogRef.close(true);\n  }\n\n  onNo() {\n    this.dialogRef.close(false);\n  }\n}\n</code></pre> <p>Recuerda</p> <p>Recuerda que los componentes utilizados en el di\u00e1logo de confirmaci\u00f3n se deben a\u00f1adir al m\u00f3dulo padre al que pertenecen, en este caso a <code>core.module.ts</code> <pre><code>imports: [\n  CommonModule,\n  RouterModule,\n  MatIconModule, \n  MatToolbarModule,\n  MatDialogModule,\n  MatButtonModule,\n],\nproviders: [\n  {\n    provide: MAT_DIALOG_DATA,\n    useValue: {},\n  },\n],\n</code></pre></p> <p>Ya por \u00faltimo, una vez tenemos el componente gen\u00e9rico de dialogo, vamos a utilizarlo en nuestro listado al pulsar el bot\u00f3n eliminar:</p> category-list.component.htmlcategory-list.component.ts <pre><code>    ...\n    &lt;ng-container matColumnDef=\"action\"&gt;\n        &lt;mat-header-cell *matHeaderCellDef&gt;&lt;/mat-header-cell&gt;\n        &lt;mat-cell *matCellDef=\"let element\"&gt;\n            &lt;button mat-icon-button color=\"primary\" (click)=\"editCategory(element)\"&gt;\n                &lt;mat-icon&gt;edit&lt;/mat-icon&gt;\n            &lt;/button&gt;\n            &lt;button mat-icon-button color=\"accent\" (click)=\"deleteCategory(element)\"&gt;\n                &lt;mat-icon&gt;clear&lt;/mat-icon&gt;\n            &lt;/button&gt;\n        &lt;/mat-cell&gt;\n    &lt;/ng-container&gt;\n    ...\n</code></pre> <pre><code>  ...\n  deleteCategory(category: Category) {    \n    const dialogRef = this.dialog.open(DialogConfirmationComponent, {\n      data: { title: \"Eliminar categor\u00eda\", description: \"Atenci\u00f3n si borra la categor\u00eda se perder\u00e1n sus datos.&lt;br&gt; \u00bfDesea eliminar la categor\u00eda?\" }\n    });\n\n    dialogRef.afterClosed().subscribe(result =&gt; {\n      if (result) {\n        this.categoryService.deleteCategory(category.id).subscribe(result =&gt; {\n          this.ngOnInit();\n        }); \n      }\n    });\n  }  \n  ...    \n</code></pre> <p>Aqu\u00ed tambi\u00e9n hemos realizado la llamada a <code>categoryService</code>, aunque no se realice ninguna acci\u00f3n, pero as\u00ed lo dejamos listo para enlazarlo.</p> <p>Llegados a este punto, ya solo nos queda enlazar las acciones de la pantalla con las operaciones de negocio del backend.</p>"},{"location":"develop/basic/angular/#conectar-con-backend","title":"Conectar con Backend","text":"<p>Antes de seguir</p> <p>Antes de seguir con este punto, debes implementar el c\u00f3digo de backend en la tecnolog\u00eda que quieras (Springboot o Nodejs). Si has empezado este cap\u00edtulo implementando el frontend, por favor accede a la secci\u00f3n correspondiente de backend para poder continuar con el tutorial. Una vez tengas implementadas todas las operaciones para este listado, puedes volver a este punto y continuar con Angular.</p> <p>El siguiente paso, como es obvio ser\u00e1 hacer que Angular llame directamente al servidor backend para leer y escribir datos y eliminar los datos mockeados en Angular.</p> <p>Manos a la obra!</p>"},{"location":"develop/basic/angular/#llamada-del-listado","title":"Llamada del listado","text":"<p>La idea es que el m\u00e9todo <code>getCategories()</code> de <code>category.service.ts</code> en lugar de devolver datos est\u00e1ticos, realice una llamada al servidor a la ruta <code>http://localhost:8080/category</code>.</p> <p>Abrimos el fichero y susituimos la l\u00ednea que antes devolv\u00eda los datos est\u00e1ticos por esto:</p> category.service.ts <pre><code>import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Category } from './model/Category';\n\n@Injectable({\nprovidedIn: 'root'\n})\nexport class CategoryService { \n\n    constructor(\n        private http: HttpClient\n    ) { }\n\n    getCategories(): Observable&lt;Category[]&gt; {\n        return this.http.get&lt;Category[]&gt;('http://localhost:8080/category');\n    }\n\n    saveCategory(category: Category): Observable&lt;Category&gt; {\n        return of(null);\n    }\n\n    deleteCategory(idCategory : number): Observable&lt;any&gt; {\n        return of(null);\n    }  \n}\n</code></pre> <p>Como hemos a\u00f1adido un componente nuevo <code>HttpClient</code> tenemos que a\u00f1adir la dependencia al m\u00f3dulo padre.</p> category.module.ts <pre><code>import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { MatTableModule } from '@angular/material/table';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatButtonModule } from '@angular/material/button';\nimport { CategoryListComponent } from './category-list/category-list.component';\nimport { CategoryEditComponent } from './category-edit/category-edit.component';\nimport { MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';\nimport { MatFormFieldModule } from '@angular/material/form-field';\nimport { MatInputModule } from '@angular/material/input';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { HttpClientModule } from '@angular/common/http';\n\n@NgModule({\n  declarations: [CategoryListComponent, CategoryEditComponent],\n  imports: [\n    CommonModule,\n    MatTableModule,\n    MatIconModule, \n    MatButtonModule,\n    MatDialogModule,\n    MatFormFieldModule,\n    MatInputModule,\n    FormsModule,\n    ReactiveFormsModule,\n    HttpClientModule,\n  ],\n  providers: [\n    {\n      provide: MAT_DIALOG_DATA,\n      useValue: {},\n    },\n  ]\n})\nexport class CategoryModule { }\n</code></pre> <p>Si ahora refrescas el navegador (recuerda tener arrancado tambi\u00e9n el servidor) y accedes a la pantalla de <code>Categor\u00edas</code> deber\u00eda aparecer el listado con los datos que vienen del servidor.</p> <p></p>"},{"location":"develop/basic/angular/#llamada-de-guardado-edicion","title":"Llamada de guardado / edici\u00f3n","text":"<p>Para la llamada de guardado har\u00edamos lo mismo, pero invocando la operaci\u00f3n de negocio <code>put</code>.</p> category.service.ts <pre><code>import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Category } from './model/Category';\n\n@Injectable({\nprovidedIn: 'root'\n})\nexport class CategoryService { \n\n    constructor(\n        private http: HttpClient\n    ) { }\n\n    getCategories(): Observable&lt;Category[]&gt; {\n        return this.http.get&lt;Category[]&gt;('http://localhost:8080/category');\n    }\n\n    saveCategory(category: Category): Observable&lt;Category&gt; {\n\n        let url = 'http://localhost:8080/category';\n        if (category.id != null) url += '/'+category.id;\n\n        return this.http.put&lt;Category&gt;(url, category);\n    }\n\n    deleteCategory(idCategory : number): Observable&lt;any&gt; {\n        return of(null);\n    }  \n\n} \n</code></pre> <p>Ahora podemos probar a modificar o a\u00f1adir una nueva categor\u00eda desde la pantalla y deber\u00eda aparecer los nuevos datos en el listado.</p>"},{"location":"develop/basic/angular/#llamada-de-borrado","title":"Llamada de borrado","text":"<p>Y ya por \u00faltimo, la llamada de borrado, deber\u00edamos cambiarla e invocar a la operaci\u00f3n de negocio <code>delete</code>.</p> category.service.ts <pre><code>import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Category } from './model/Category';\n\n@Injectable({\nprovidedIn: 'root'\n})\nexport class CategoryService { \n\n    constructor(\n        private http: HttpClient\n    ) { }\n\n    getCategories(): Observable&lt;Category[]&gt; {\n        return this.http.get&lt;Category[]&gt;('http://localhost:8080/category');\n    }\n\n    saveCategory(category: Category): Observable&lt;Category&gt; {\n\n        let url = 'http://localhost:8080/category';\n        if (category.id != null) url += '/'+category.id;\n\n        return this.http.put&lt;Category&gt;(url, category);\n    }\n\n    deleteCategory(idCategory : number): Observable&lt;any&gt; {\n        return this.http.delete('http://localhost:8080/category/'+idCategory);\n    }  \n\n} \n</code></pre> <p>Ahora podemos probar a modificar o a\u00f1adir una nueva categor\u00eda desde la pantalla y deber\u00eda aparecer los nuevos datos en el listado.</p> <p>Como ves, es bastante sencillo conectar server y client.</p>"},{"location":"develop/basic/angular/#depuracion","title":"Depuraci\u00f3n","text":"<p>Una parte muy importante del desarrollo es tener la capacidad de depurar nuestro c\u00f3digo, en este apartado vamos a explicar como se realiza <code>debug</code> en Front.</p> <p>Esta parte se puede realizar con nuestro navegador favorito, en este caso vamos a utilizar Chrome.</p> <p>El primer paso es abrir las herramientas del desarrollador del navegador presionando <code>F12</code>.</p> <p></p> <p>En esta herramienta tenemos varias partes importantes:</p> <ul> <li>Elements: Inspector de los elementos del DOM de nuestra aplicaci\u00f3n que nos ayuda identificar el c\u00f3digo generado.</li> <li>Console: Consola donde podemos ver mensajes importantes que nos ayudan a identificar posibles problemas.</li> <li>Source: El navegador de ficheros que componen nuestra aplicaci\u00f3n.</li> <li>Network: El registro de peticiones que realiza nuestra aplicaci\u00f3n.</li> </ul> <p>Identificados los elementos importantes, vamos a depurar la operaci\u00f3n de crear categor\u00eda.</p> <p>Para ello nos dirigimos a la pesta\u00f1a de <code>Source</code>, en el \u00e1rbol de carpetas nos dirigimos a la ruta donde est\u00e1 localizado el c\u00f3digo de nuestra aplicaci\u00f3n <code>webpack://src/app</code>.</p> <p>Dentro de esta carpeta est\u00e9 localizado todo el c\u00f3digo fuente de la aplicaci\u00f3n, en nuestro caso vamos a localizar componente <code>category-edit.component</code> que crea una nueva categor\u00eda.</p> <p>Dentro del fichero ya podemos a\u00f1adir puntos de ruptura (breakpoint), en nuestro caso queremos comprobar que el nombre introducido se captura bien y se env\u00eda al service correctamente.</p> <p>Colocamos el breakpoint en la l\u00ednea de invocaci\u00f3n del service (click sobre el n\u00famero de la l\u00ednea) y desde la interfaz creamos una nueva categor\u00eda.</p> <p>Hecho esto, podemos observar que a nivel de interfaz, la aplicaci\u00f3n se detiene y aparece un panel de manejo de los puntos de interrupci\u00f3n:</p> <p></p> <p>En cuanto a la herramienta del desarrollador nos lleva al punto exacto donde hemos a\u00f1adido el breakpoint y se para en este punto ofreci\u00e9ndonos la posibilidad de explorar el contenido de las variables del c\u00f3digo:</p> <p></p> <p>Aqu\u00ed podemos comprobar que efectivamente la variable <code>category</code> tiene el valor que hemos introducido por pantalla y se propaga correctamente hacia el service.</p> <p>Para continuar con la ejecuci\u00f3n basta con darle al bot\u00f3n de <code>play</code> del panel de manejo de interrupci\u00f3n o al que aparece dentro de la herramienta de desarrollo (parte superior derecha).</p> <p>Por \u00faltimo, vamos a revisar que la petici\u00f3n REST se ha realizado correctamente al backend, para ello nos dirigimos a la pesta\u00f1a <code>Network</code> y comprobamos las peticiones realizadas:</p> <p></p> <p>Aqu\u00ed podemos observar el registro de todas las peticiones y haciendo click sobre una de ellas, obtenemos el detalle de esta.</p> <ul> <li>Header: Informaci\u00f3n de las cabeceras enviadas (aqu\u00ed podemos ver que se ha hecho un PUT a la ruta correcta).</li> <li>Payload: El cuerpo de la petici\u00f3n (vemos el cuerpo del mensaje con el nombre enviado).</li> <li>Preview: Respuesta de la petici\u00f3n normalizada (vemos la respuesta con el identificador creado para la nueva categor\u00eda).</li> </ul>"},{"location":"develop/basic/nodejs/","title":"Listado simple - Nodejs","text":"<p>Ahora que ya tenemos listo el proyecto backend de nodejs (en el puerto 8080) ya podemos empezar a codificar la soluci\u00f3n.</p>"},{"location":"develop/basic/nodejs/#primeros-pasos","title":"Primeros pasos","text":"<p>Antes de empezar</p> <p>Quiero hacer hincapi\u00e9 en Node tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. Tanto en la web de node como de express encontrar\u00e1s informaci\u00f3n detallada del proceso que vamos a seguir.</p>"},{"location":"develop/basic/nodejs/#estructurar-el-codigo","title":"Estructurar el c\u00f3digo","text":"<p>La estructura de nuestro proyecto ser\u00e1 la siguiente:</p> <p></p> <p>Vamos a aplicar una separaci\u00f3n por capas. En primer lugar, tendremos una capa de rutas para reenviar las solicitudes admitidas y cualquier informaci\u00f3n codificada en las urls de solicitud a la siguiente capa de controladores. La capa de control procesar\u00e1 las peticiones de las rutas y se comunicar\u00e1 con la capa de servicios devolviendo la respuesta de esta mediante respuestas http. En la capa de servicio se ejecutar\u00e1 toda la l\u00f3gica de la petici\u00f3n y se comunicar\u00e1 con los modelos de base de datos</p> <p>En nuestro caso una ruta es una secci\u00f3n de c\u00f3digo Express que asocia un verbo HTTP (GET, POST, PUT, DELETE, etc.), una ruta/patr\u00f3n de URL y una funci\u00f3n que se llama para manejar ese patr\u00f3n.</p> <p>\u00a1Ahora s\u00ed, vamos a programar!</p>"},{"location":"develop/basic/nodejs/#capa-de-routes","title":"Capa de Routes","text":"<p>Lo primero de vamos a crear es la carpeta principal de nuestra aplicaci\u00f3n donde estar\u00e1n contenidos los distintos elementos de la misma. Para ello creamos una carpeta llamada <code>src</code> en la ra\u00edz de nuestra aplicaci\u00f3n.</p> <p>El primero elemento que vamos a crear va a ser el fichero de rutas para la categor\u00eda. Para ello creamos una carpeta llamada <code>routes</code> en la carpeta <code>src</code> y dentro de esta carpeta crearemos un archivo llamado <code>category.routes.js</code>:</p> category.routes.js <pre><code>import { Router } from 'express';\nimport { createCategory } from '../controllers/category.controller.js';\n\nconst categoryRouter = Router();\ncategoryRouter.put('/', createCategory);\n\nexport default categoryRouter;\n</code></pre> <p>En este archivo estamos creando una ruta de tipo PUT que llamara al m\u00e9todo <code>createCategory</code> de nuestro futuro controlador de categor\u00edas (aunque todav\u00eda no lo hemos creado y por tanto fallar\u00e1).</p> <p>Ahora en nuestro archivo <code>index.js</code> vamos a a\u00f1adir lo siguiente justo despu\u00e9s de declarar la constante app:</p> index.js <pre><code>...\nimport categoryRouter from './src/routes/category.routes.js';\n...\n\n...\napp.use(cors({\n    origin: '*'\n}));\n\napp.use(express.json());\napp.use('/category', categoryRouter);\n\n...\n</code></pre> <p>De este modo estamos asociando la url <code>http://localhost:8080/category</code> a nuestro router. Tambi\u00e9n usaremos <code>express.json()</code> para parsear las peticiones entrantes a formato json.</p>"},{"location":"develop/basic/nodejs/#capa-de-controller","title":"Capa de Controller","text":"<p>Lo siguiente ser\u00e1 crear el m\u00e9todo createCategory en nuestro controller. Para ello lo primero ser\u00e1 crear una carpeta <code>controllers</code> en la carpeta <code>src</code> de nuestro proyecto y dentro de esta un archivo llamado <code>category.controller.js</code>:</p> category.controller.js <pre><code>export const createCategory = async (req, res) =&gt; {\n    console.log(req.body);\n    res.status(200).json(1);\n}\n</code></pre> <p>Hemos creado la funci\u00f3n <code>createCategory</code> que recibir\u00e1 una request y una response. Estos par\u00e1metros vienen de la ruta de express y son la request y response de la petici\u00f3n HTTP. De momento simplemente vamos a hacer un <code>console.log</code> de <code>req.body</code> para ver el body de la petici\u00f3n y vamos a hacer una response 200 para indicar que todo ha ido correctamente.</p> <p>Si arrancamos el servidor y hacemos una petici\u00f3n <code>PUT</code> con Postman a <code>http://localhost:8080/category</code> con un body que pongamos formado correctamente podremos ver la salida que hemos programado en nuestro controller y en la consola de node podemos ver el contenido de <code>req.body</code>.</p> <p></p> <p></p>"},{"location":"develop/basic/nodejs/#capa-de-modelo","title":"Capa de Modelo","text":"<p>Ahora para que los datos que pasemos en el body los podamos guardar en BBDD necesitaremos un modelo y un esquema para la entidad <code>Category</code>. Vamos a crear una carpeta llamada <code>schemas</code> en la carpeta <code>src</code> de nuestro proyecto. Un schema no es m\u00e1s que un modelo de BBDD que especifica que campos estar\u00e1n presentes y cu\u00e1les ser\u00e1n sus tipos. Dentro de la carpeta de schemas creamos un archivo con el nombre <code>category.schema.js</code>:</p> category.schema.js <pre><code>import mongoose from \"mongoose\";\nconst { Schema, model } = mongoose;\nimport normalize from 'normalize-mongoose';\n\nconst categorySchema = new Schema({\n    name: {\n        type: String,\n        require: true\n    }\n});\ncategorySchema.plugin(normalize);\nconst CategoryModel = model('Category', categorySchema);\n\nexport default CategoryModel;\n</code></pre> <p>En este archivo estamos definiendo nuestro schema indicando sus propiedades y tipos, en nuestro caso \u00fanicamente <code>name</code>. Adem\u00e1s del tipo tambi\u00e9n indicaremos que el campo es obligatorio con la validation require para indicar que ese campo es obligatorio. Si quieres conocer otras validaciones aqu\u00ed tienes m\u00e1s info. Aparte de definir nuestro schema tambi\u00e9n lo estamos transformado en un modelo para poder trabajar con \u00e9l. En el constructor de model le pasamos el nombre del modelo y el schema que vamos a utilizar.</p>"},{"location":"develop/basic/nodejs/#capa-de-servicio","title":"Capa de Servicio","text":"<p>Como hemos visto en nuestra estructura la capa controller no puede comunicarse con la capa modelo, debe de haber una capa intermedia, para ello vamos a crear una carpeta <code>services</code> en la carpeta <code>src</code> de nuestro proyecto y dentro un archivo <code>category.service.js</code>:</p> category.service.js <pre><code>import CategoryModel from '../schemas/category.schema.js';\n\nexport const createCategory = async function(name) {\n    try {\n        const category = new CategoryModel({ name });\n        return await category.save();\n    } catch (e) {\n        throw Error('Error creating category');\n    }\n}\n</code></pre> <p>Hemos importado el modelo de categor\u00eda para poder realizar acciones sobre la BBDD y hemos creado una funci\u00f3n que recoger\u00e1 el nombre de la categor\u00eda y crear\u00e1 una nueva categor\u00eda con \u00e9l. Llamamos al m\u00e9todo save para guardar nuestra categor\u00eda y devolvemos el resultado. Ahora en nuestro m\u00e9todo del controller solo tenemos que llamar al servicio pas\u00e1ndole los par\u00e1metros que nos llegan en la petici\u00f3n:</p> category.controller.js <pre><code>import * as CategoryService from '../services/category.service.js';\n\nexport const createCategory = async (req, res) =&gt; {\n    const { name } = req.body;\n    try {\n        const category = await CategoryService.createCategory(name);\n        res.status(200).json({\n            category\n        });\n    } catch (err) {\n        res.status(400).json({\n            msg: err.toString()\n        });\n    }\n}\n</code></pre> <p>Si todo ha ido correctamente llamaremos al m\u00e9todo de respuesta con el c\u00f3digo 200 y la categor\u00eda creada. En caso contrario mandaremos un c\u00f3digo de error. Si ahora de nuevo vamos a postman y volvemos a lanzar nuestra petici\u00f3n podemos ver como nos devuelve una nueva categor\u00eda:</p> <p></p>"},{"location":"develop/basic/nodejs/#resto-de-operaciones","title":"Resto de Operaciones","text":""},{"location":"develop/basic/nodejs/#recuperacion-categorias","title":"Recuperaci\u00f3n categor\u00edas","text":"<p>Ahora que ya podemos crear categor\u00edas lo siguiente ser\u00e1 crear un endpoint para recuperar las categor\u00edas creadas en nuestra base de datos. Podemos empezar a\u00f1adiendo un nuevo m\u00e9todo en nuestro servicio:</p> category.service.js <pre><code>export const getCategories = async function () {\n    try {\n        return await CategoryModel.find().sort('name');\n    } catch (e) {\n        throw Error('Error fetching categories');\n    }\n}\n</code></pre> <p>Al igual que en el anterior m\u00e9todo haremos uso del modelo, pero esta vez para hacer un <code>find</code> y ordenando los resultados por el campo <code>name</code>. Al m\u00e9todo find se le pueden pasar <code>queries</code>, <code>projections</code> y <code>options</code>. Te dejo por aqu\u00ed m\u00e1s info. En nuestro caso simplemente queremos que nos devuelva todas las categor\u00edas por lo que no le pasaremos nada.</p> <p>Creamos tambi\u00e9n un m\u00e9todo en el controlador para recuperar las categor\u00edas y que har\u00e1 uso del servicio:</p> category.controller.js <pre><code>export const getCategories = async (req, res) =&gt; {\n    try {\n        const categories = await CategoryService.getCategories();\n        res.status(200).json(\n            categories\n        );\n    } catch (err) {\n        res.status(400).json({\n            msg: err.toString()\n        });\n    }\n}\n</code></pre> <p>Y ahora que ya tenemos el m\u00e9todo creado en el controlador lo siguiente ser\u00e1 relacionar este m\u00e9todo con una ruta. Para ello en nuestro archivo <code>category.routes.js</code> tendremos que a\u00f1adir una nueva l\u00ednea:</p> category.routes.js <pre><code>import { Router } from 'express';\nimport { createCategory, getCategories } from '../controllers/category.controller.js';\n\nconst categoryRouter = Router();\ncategoryRouter.put('/', createCategory);\ncategoryRouter.get('/', getCategories);\n\nexport default categoryRouter;\n</code></pre> <p>De este modo cuando hagamos una petici\u00f3n GET a <code>http://localhost:8080/category</code> nos devolver\u00e1 el listado de categor\u00edas existentes: </p> <p></p>"},{"location":"develop/basic/nodejs/#actualizar-categoria","title":"Actualizar categor\u00eda","text":"<p>Ahora vamos a por el m\u00e9todo para actualizar nuestras categor\u00edas. En el servicio creamos el siguiente m\u00e9todo:</p> category.service.js <pre><code>export const updateCategory = async (id, name) =&gt; {\n    try {\n        const category = await CategoryModel.findById(id);\n        if (!category) {\n            throw Error('There is no category with that Id');\n        }    \n        return await CategoryModel.findByIdAndUpdate(id, {name});\n    } catch (e) {\n        throw Error(e);\n    }\n}\n</code></pre> <p>A este m\u00e9todo le pasaremos de entrada el <code>id</code> y el <code>nombre</code>. Con ese <code>id</code> realizaremos una b\u00fasqueda para asegurarnos que esa categor\u00eda existe en nuestra base de datos. Si existe la categor\u00eda haremos una petici\u00f3n con <code>findByIdAndUpdate</code> donde el primer par\u00e1metro es el <code>id</code> y el segundo es el resto de los campos de nuestra entidad. </p> <p>En el controlador creamos el m\u00e9todo correspondiente:</p> category.controller.js <pre><code>export const updateCategory = async (req, res) =&gt; {\n    const categoryId = req.params.id;\n    const { name } = req.body;\n    try {\n        await CategoryService.updateCategory(categoryId, name);\n        res.status(200).json(1);\n    } catch (err) {\n        res.status(400).json({\n            msg: err.toString()\n        });\n    }\n}\n</code></pre> <p>Aqu\u00ed recogeremos el par\u00e1metro <code>id</code> que nos vendr\u00e1 en la url, por ejemplo: <code>http://localhost:8080/category/1</code>. Esto lo hacemos con <code>req.params.id</code>. El <code>id</code> es el nombre de la variable que le daremos en el router como veremos m\u00e1s adelante.  Y una vez creado el m\u00e9todo en el controlador tendremos que a\u00f1adir la ruta en nuestro fichero de rutas correspondiente, pero como ya hemos dicho tendremos que indicar que nuestra ruta espera un par\u00e1metro id, lo haremos de la siguiente forma:</p> category.routes.js <pre><code>import { Router } from 'express';\nimport { createCategory, getCategories, updateCategory } from '../controllers/category.controller.js';\n\nconst categoryRouter = Router();\ncategoryRouter.put('/', createCategory);\ncategoryRouter.get('/', getCategories);\ncategoryRouter.put('/:id', updateCategory);\n\nexport default categoryRouter;\n</code></pre> <p>Y volvemos a probar en Postman:</p> <p></p> <p>Y si hacemos de nuevo un <code>GET</code> vemos como la categor\u00eda se ha modificado correctamente:</p> <p></p>"},{"location":"develop/basic/nodejs/#borrado-categoria","title":"Borrado categor\u00eda","text":"<p>Ya solo nos faltar\u00eda la operaci\u00f3n de <code>delete</code> para completar nuestro CRUD, en el servicio a\u00f1adimos un nuevo m\u00e9todo:</p> category.service.js <pre><code>export const deleteCategory = async (id) =&gt; {\n    try {\n        const category = await CategoryModel.findById(id);\n        if (!category) {\n            throw Error('There is no category with that Id');\n        }\n        return await CategoryModel.findByIdAndDelete(id);\n    } catch (e) {\n        throw Error('Error deleting category');\n    }\n}\n</code></pre> <p>Como vemos es muy parecido al update, recuperamos el <code>id</code> de los par\u00e1metros de la ruta y en este caso llamaremos al m\u00e9todo <code>findByIdAndDelete</code>. En nuestro controlador creamos el m\u00e9todo correspondiente:</p> category.controller.js <pre><code>export const deleteCategory = async (req, res) =&gt; {\n    const categoryId = req.params.id;\n    try {\n        const deletedCategory = await CategoryService.deleteCategory(categoryId);\n        res.status(200).json({\n            category: deletedCategory\n        });\n    } catch (err) {\n        res.status(400).json({\n            msg: err.toString()\n        });\n    }\n}\n</code></pre> <p>Y de nuevo a\u00f1adimos la ruta correspondiente al archivo de rutas:</p> category.routes.js <pre><code>import { Router } from 'express';\nimport { createCategory, getCategories, updateCategory, deleteCategory } from '../controllers/category.controller.js';\n\nconst categoryRouter = Router();\ncategoryRouter.put('/', createCategory);\ncategoryRouter.get('/', getCategories);\ncategoryRouter.put('/:id', updateCategory);\ncategoryRouter.delete('/:id', deleteCategory);\n\nexport default categoryRouter;\n</code></pre> <p>Y de nuevo, probamos en postman:</p> <p></p> <p>Hacemos un get para comprobar que se ha borrado de nuestra base de datos:</p> <p></p>"},{"location":"develop/basic/nodejs/#capa-de-middleware-validaciones","title":"Capa de Middleware (Validaciones)","text":"<p>Antes de pasar a nuestro siguiente CRUD vamos a ver en que consiste la <code>Capa de Middleware</code>.  Un <code>middleware</code> es un c\u00f3digo que se ejecuta antes de que una petici\u00f3n http llegue a nuestro manejador de rutas o antes de que el cliente reciba una respuesta. </p> <p>En nuestro caso vamos a crear un middleware para asegurarnos que todos los campos que necesitamos en nuestras entidades vienen en el body de la petici\u00f3n. Vamos a crear una carpeta <code>middlewares</code> en la carpeta <code>src</code> de nuestro proyecto y dentro crearemos el fichero <code>validateFields.js</code>:</p> validateFields.js <pre><code>import { response } from 'express';\nimport { validationResult } from 'express-validator';\n\nconst validateFields = (req, res = response, next) =&gt; {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n        return res.status(400).json({\n            errors: errors.mapped()\n        });\n    }\n    next();\n}\n\nexport default validateFields;\n</code></pre> <p>En este m\u00e9todo nos ayudaremos de la librer\u00eda <code>express-validator</code> para ver los errores que tenemos en nuestras rutas. Para ello llamaremos a la funci\u00f3n <code>validationResult</code> que nos devolver\u00e1 un array de errores que m\u00e1s tarde definiremos. Si el array no va vac\u00edo es porque se ha producido alg\u00fan error en las validaciones y ejecutara la response con un c\u00f3digo de error.</p> <p>Ahora definiremos las validaciones en nuestro archivo de rutas, deber\u00eda quedar de la siguiente manera:</p> category.routes.js <pre><code>import { Router } from 'express';\nimport { check } from 'express-validator';\nimport validateFields from '../middlewares/validateFields.js';\nimport { getCategories, createCategory, deleteCategory, updateCategory } from '../controllers/category.controller.js';\nconst categoryRouter = Router();\n\ncategoryRouter.put('/:id', [\n    check('name').not().isEmpty(),\n    validateFields\n], updateCategory);\n\ncategoryRouter.put('/', [\n    check('name').not().isEmpty(),\n    validateFields\n], createCategory);\n\ncategoryRouter.get('/', getCategories);\ncategoryRouter.delete('/:id', deleteCategory);\n\nexport default categoryRouter;\n</code></pre> <p>Aqu\u00ed nos ayudamos de nuevo de <code>express-validator</code> y de su m\u00e9todo <code>check</code>. Para las rutas en las que necesitemos validaciones, a\u00f1adimos un array como segundo par\u00e1metro. En este array vamos a\u00f1adiendo todas las validaciones que necesitemos. En nuestro caso solo queremos que el campo name no sea vac\u00edo, pero existen muchas m\u00e1s validaciones que puedes encontrar en la documentaci\u00f3n de express-validator. Importamos nuestro middleware y lo a\u00f1adimos en la \u00faltima posici\u00f3n de este array. </p> <p>De este modo no se realizar\u00e1n las peticiones que no pasen las validaciones:</p> <p></p> <p>Y con esto habremos terminado nuestro primer CRUD.</p>"},{"location":"develop/basic/nodejs/#depuracion","title":"Depuraci\u00f3n","text":"<p>Una parte muy importante del desarrollo es tener la capacidad de depurar nuestro c\u00f3digo, en este apartado vamos a explicar como se realiza <code>debug</code> en Backend.</p> <p>Esta parte se realiza con las herramientas incluidas dentro de nuestro IDE favorito, en este caso vamos a utilizar el Visual Estudio.</p> <p>Lo primero que debemos hacer es configurar el modo <code>Debug</code> de nuestro proyecto.</p> <p>Para ello nos dirigimos a la opci\u00f3n <code>Run and Debug</code> y creamos el fichero de launch necesario:</p> <p></p> <p>Esto nos crear\u00e1 el fichero necesario y ya podremos arrancar la aplicaci\u00f3n mediante esta herramienta presionando el bot\u00f3n <code>Launch Program</code> (seleccionamos tipo de aplicaci\u00f3n Node y el script de arranque que ser\u00e1 el que hemos utilizado en el desarrollo):</p> <p></p> <p>Arrancada la aplicaci\u00f3n de este modo, vamos a depurar la operaci\u00f3n de crear categor\u00eda.</p> <p>Para ello vamos a abrir nuestro fichero donde tenemos la implementaci\u00f3n del servicio de creaci\u00f3n de la capa de la l\u00f3gica de negocio <code>category.service.js</code>.</p> <p>Dentro del fichero ya podemos a\u00f1adir puntos de ruptura (breakpoint), en nuestro caso queremos comprobar que el nombre introducido se recibe correctamente.</p> <p>Colocamos el breakpoint en la primera l\u00ednea del m\u00e9todo (click sobre el n\u00famero de la l\u00ednea) y desde la interfaz/postman creamos una nueva categor\u00eda.</p> <p>Hecho esto, podemos observar que a nivel de interfaz/postman, la petici\u00f3n se queda esperando y el IDE mostrar\u00e1 un panel de manejo de los puntos de interrupci\u00f3n:</p> <p></p> <p>El IDE nos lleva al punto exacto donde hemos a\u00f1adido el breakpoint y se para en este punto ofreci\u00e9ndonos la posibilidad de explorar el contenido de las variables del c\u00f3digo:</p> <p></p> <p>Aqu\u00ed podemos comprobar que efectivamente la variable <code>name</code> tiene el valor que hemos introducido por pantalla/postman.</p> <p>Para continuar con la ejecuci\u00f3n basta con darle al bot\u00f3n de <code>play</code> del panel de manejo de los puntos de interrupci\u00f3n.</p>"},{"location":"develop/basic/react/","title":"Listado simple - React","text":"<p>Ahora que ya tenemos listo el proyecto frontend de React (en el puerto 5173), ya podemos empezar a codificar la soluci\u00f3n.</p>"},{"location":"develop/basic/react/#primeros-pasos","title":"Primeros pasos","text":"<p>Antes de empezar</p> <p>Quiero hacer hincapi\u00e9 que React tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. Tanto en la propia web de documentaci\u00f3n de React como en la web de componentes Mui puedes buscar casi cualquier ejemplo que necesites.</p> <p>Si abrimos el proyecto con el IDE que tengamos (Visual Studio Code en el caso del tutorial) podemos ver que en la carpeta <code>src</code> existen unos ficheros ya creados por defecto. Estos ficheros son:</p> <ul> <li><code>main.tsx</code> \u2192 contiene el componente principal del proyecto.</li> <li><code>index.css</code> \u2192 contiene los estilos CSS globales de la aplicaci\u00f3n.</li> <li><code>APP.tsx</code> \u2192 contiene el componente inicial del proyecto </li> <li><code>APP.css</code> \u2192 contiene los estilos para el componente APP.</li> </ul> <p>Aunque <code>main.tsx</code> y <code>App.tsx</code> puedan parecer lo mismo <code>main.tsx</code> se suele dejar tal y como esta ya que lo \u00fanico que hace es asociar el div con id \u201croot\u201d del archivo <code>index.html</code> de la ra\u00edz de nuestro proyecto para que sea el nodo principal de React. En el archivo <code>App.tsx</code> es donde realmente empezamos a desarrollar c\u00f3digo.</p> <p>Si abrimos <code>main.tsx</code> podemos ver que se esta usando <code>&lt;App /&gt;</code> como una etiqueta html. El nombre con que exportemos nuestros componentes ser\u00e1 el nombre de la etiqueta html utilizado para renderizar los componentes.</p> <p>Vamos a modificar este c\u00f3digo inicial para ver c\u00f3mo funciona. Abrimos el fichero <code>App.tsx</code> y vamos a dejarlo de esta manera:</p> <p><pre><code>import { useState } from 'react'\nimport './App.css'\n\nfunction App() {\n  const [count, setCount] = useState(0)\n  const probando = \"probando 123\";\n\n  return (\n    &lt;&gt;\n      &lt;p&gt;{probando}&lt;/p&gt;\n      &lt;div className=\"card\"&gt;\n        &lt;button onClick={() =&gt; setCount((count) =&gt; count + 1)}&gt;\n          count is {count}\n        &lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/&gt;\n  )\n}\n\nexport default App\n</code></pre> En los componentes React siempre se suele seguir el mismo orden, primero introduciremos los imports necesarios, luego podemos declarar variables y funciones que no se vayan a modificar, despu\u00e9s creamos nuestra funci\u00f3n principal con el nombre del componente y dentro de esta lo primero que se suelen declarar son todas las variables, despu\u00e9s a\u00f1adiremos m\u00e9todos del componente y por \u00faltimo tenemos que llamar a return para devolver lo que queramos renderizar.</p> <p>Si ahora abrimos nuestro navegador veremos en pantalla el valor de la variable \"probando\" que hemos introducido mediante una expresi\u00f3n en un tag p de html y un bot\u00f3n que si pulsamos incrementar\u00e1 el valor de la cuenta en uno. Si refrescamos la pantalla el valor de la cuenta volver\u00e1 autom\u00e1ticamente a 0. Es hora de explicar como funciona un componente React y el hook useState.</p>"},{"location":"develop/basic/react/#jsx","title":"JSX","text":"<p>JSX significa Javascript XML. JSX nos permite escribir elementos HTML en JavaScript y colocarlos en el DOM. Con JSX puedes escribir expresiones dentro de llaves \u201c{}\u201d. Estas expresiones pueden ser variables, propiedades o cualquier expresi\u00f3n Javascript valida. JSX ejecutar\u00e1 esta expresi\u00f3n y devolver\u00e1 el resultado.</p> <p>Por ejemplo, si queremos mostrar un elemento de forma condicional lo podemos hacer de la siguiente manera: </p> <pre><code>        {\n          variableBooleana  &amp;&amp; &lt;p&gt;El valor es true&lt;/p&gt;\n        }\n</code></pre> <p>Tambi\u00e9n podemos usar el operador ternario para condiciones: </p> <pre><code>        {\n          variableBooleana  ? &lt;p&gt;El valor es true&lt;/p&gt; : &lt;p&gt;El valor es false&lt;/p&gt;\n        }\n</code></pre> <p>Y si lo que queremos es recorrer un array e ir representando los elementos lo podemos hacer de la siguiente manera:</p> <pre><code>        {\n          arrayNumerico.map(numero =&gt; &lt;p&gt;Mi valor es {numero}&lt;/p&gt;)\n        }\n</code></pre> <p>React solo puede devolver un elemento en su bloque return, es por eso por lo que algunas veces se rodea todo el c\u00f3digo con un elemento llamado Fragment \u201c&lt;&gt;\u201d. Estos fragment no soportan ni propiedades ni atributos y no tendr\u00e1n visibilidad en el dom.</p> <p>Dentro de una expresi\u00f3n podemos ver dos formas de llamar a una funci\u00f3n:</p> <pre><code>&lt;Button onClick={callToCancelar}&gt;Cancelar&lt;/Button&gt;\n&lt;Button onClick={() =&gt; callToCancelar('param1')}&gt;Cancelar&lt;/Button&gt;\n</code></pre> <p>En la primera se pasa una funci\u00f3n por referencia y Button es el responsable de los par\u00e1metros del evento. En la segunda tras hacer onClick se ejecuta la funci\u00f3n callToCancelar con los par\u00e1metros que nosotros queramos quitando esa responsabilidad a Button. En t\u00e9rminos de rendimiento es mejor la primera manera ya que en la segunda se vuelve a crear la funci\u00f3n en cada renderizado, pero hay veces que es necesario hacerlo as\u00ed para tomar control de los par\u00e1metros.</p>"},{"location":"develop/basic/react/#usestate-hook","title":"useState hook","text":"<p>Todo componente en React tiene una serie de variables. Algunas de estas son propiedades de entrada como podr\u00edan serlo disabled en un bot\u00f3n y que se trasmiten de componentes padres a hijos. </p> <p>Luego tenemos variables y constantes declaradas dentro del componente como por ejemplo la constante probando de nuestro ejemplo. Y finalmente tenemos unas variables especiales dentro de nuestro componente que corresponden al estado de este.</p> <p>Si modificamos el estado de un componente este autom\u00e1ticamente se volver\u00e1 a renderizar y producir\u00e1 una nueva representaci\u00f3n en pantalla.</p> <p>Como ya hemos comentado previamente los hooks aparecieron en la versi\u00f3n 16.8 de React. Antes de esto si quer\u00edamos acceder al estado de un componente solo pod\u00edamos acceder a este mediante componentes de clase, pero desde esta versi\u00f3n podemos hacer uso de estas funciones especiales para utilizar estas caracter\u00edsticas de React.</p> <p>M\u00e1s tarde veremos otras, pero de momento vamos a ver useState. </p> <pre><code>const [count, setCount] = useState(0)\n</code></pre> <p>En nuestro ejemplo tenemos una variable count que va mostrando su valor en el interior de un bot\u00f3n. Si pulsamos el bot\u00f3n ejecutara la funci\u00f3n <code>setCount</code> que actualiza el valor de nuestro contador. A esta funci\u00f3n se le puede pasar o bien el nuevo valor que tomar\u00e1 esta variable de estado o bien una funci\u00f3n cuyo primer par\u00e1metro es el valor actual de la variable. Siempre que se actualice la variable del estado de producir\u00e1 un nuevo renderizado del componente, eso lo pod\u00e9is comprobar escribiendo un <code>console.log</code> antes del return. En nuestro caso hemos inicializado nuestra variable de estado con el valor 0, pero puede inicializarse con un valor de cualquier tipo javascript. No existe limite en el n\u00famero de variables de estado por componente.</p> <p>Debemos tener en cuenta que si modificamos el estado de un componente que renderiza otros componentes, estos tambi\u00e9n se volver\u00e1n a renderizar al cambiar el estado del componente padre. Es por esto por lo que debemos tener cuidado a la hora de modificar estados y renderizar los hijos correctamente. </p> <p>Nota</p> <p>Para evitar el re-renderizado de los componentes hijos existe una funci\u00f3n especial en React llamada <code>memo</code> que evita este comportamiento si las props de los hijos no se ven modificadas. En este curso no cubriremos esta funcionalidad.</p> <p>Nota</p> <p>Por convenci\u00f3n todos los hooks empiezan con <code>use</code>. Si en alg\u00fan proyecto tienes que crear un custom hook es importante seguir esta nomenclatura.</p>"},{"location":"develop/basic/react/#libreria-de-componentes-y-resto-de-dependencias","title":"Librer\u00eda de componentes y resto de dependencias","text":"<p>Antes de continuar con nuestro curso vamos a instalar las dependencias necesarias para empezar a construir la base de nuestra aplicaci\u00f3n. Para ello ejecutamos lo siguiente en la consola en la ra\u00edz de nuestro proyecto:</p> <pre><code>npm i @mui/material @mui/icons-material react-router-dom react-redux @reduxjs/toolkit @emotion/react @emotion/styled\n</code></pre> <p>Como librer\u00eda de componentes vamos a utilizar Mui, anteriormente conocido como Material ui, es una librer\u00eda muy utilizada en los proyectos de React con una gran documentaci\u00f3n. Tambi\u00e9n necesitaremos las librer\u00edas de emotion necesarias para trabajar con Mui.</p> <p>Vamos a utilizar la librer\u00eda react router dom que nos permitir\u00e1 definir y usar rutas de navegaci\u00f3n en nuestra aplicaci\u00f3n.</p> <p>Vamos a instalar tambi\u00e9n react redux y redux toolkit para gestionar el estado global de nuestra aplicaci\u00f3n.</p>"},{"location":"develop/basic/react/#layout-general","title":"Layout general","text":""},{"location":"develop/basic/react/#crear-componente","title":"Crear componente","text":"<p>Lo primero que haremos ser\u00e1 borrar el contenido del archivo <code>App.css</code> y vamos a modificar <code>index.css</code> con el siguiente contenido:</p> <pre><code>:root {\n  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;\n}\n\nbody {\n  margin: 0;\n}\n\n@media (prefers-color-scheme: light) {\n  :root {\n    color: #213547;\n    background-color: #ffffff;\n  }\n}\n\n.container {\n  margin: 20px;\n}\n\n.newButton {\n  display: flex;\n  justify-content: flex-end;\n  margin-top: 20px;\n}\n</code></pre> <p>Ahora vamos a crear los distintos componentes que compondr\u00e1n nuestra aplicaci\u00f3n. Para ello dentro de la carpeta src vamos a crear una nueva carpeta llamada pages y dentro de esta crearemos tres carpetas relativas a nuestras paginas navegables: \u201cAuthor\u201d, \u201cCategory\u201d y \u201cGame\u201d. Dentro de estas a su vez crearemos un fichero llamado <code>Author.tsx</code>, <code>Category.tsx</code> y <code>Game.tsx</code> respectivamente, cuyo contenido ser\u00e1 una funci\u00f3n que tendr\u00e1 por nombre el mismo nombre que el fichero y que devolver\u00e1 un div cuyo contenido ser\u00e1 tambi\u00e9n el nombre del fichero: </p> <pre><code>export const Game = () =&gt; {\n  return (\n    &lt;div&gt;Game&lt;/div&gt;\n  )\n}\n</code></pre> <p>Ahora vamos a crear en la carpeta src otra carpeta cuyo nombre ser\u00e1 \u201ccomponents\u201d y dentro de esta un fichero llamado <code>Layout.tsx</code> cuyo contenido ser\u00e1 el siguiente:</p> <pre><code>import { useState } from \"react\";\nimport AppBar from \"@mui/material/AppBar\";\nimport Box from \"@mui/material/Box\";\nimport Toolbar from \"@mui/material/Toolbar\";\nimport IconButton from \"@mui/material/IconButton\";\nimport Typography from \"@mui/material/Typography\";\nimport Menu from \"@mui/material/Menu\";\nimport MenuIcon from \"@mui/icons-material/Menu\";\nimport Container from \"@mui/material/Container\";\nimport Button from \"@mui/material/Button\";\nimport MenuItem from \"@mui/material/MenuItem\";\nimport CasinoIcon from \"@mui/icons-material/Casino\";\nimport { useNavigate, Outlet } from \"react-router-dom\";\n\nconst pages = [\n  { name: \"Catalogo\", link: \"games\" },\n  { name: \"Categor\u00edas\", link: \"categories\" },\n  { name: \"Autores\", link: \"authors\" },\n];\n\nexport const Layout = () =&gt; {\n  const navigate = useNavigate();\n\n  const [anchorElNav, setAnchorElNav] = useState&lt;null | HTMLElement&gt;(\n    null\n  );\n\n  const handleOpenNavMenu = (event: React.MouseEvent&lt;HTMLElement&gt;) =&gt; {\n    setAnchorElNav(event.currentTarget);\n  };\n\n  const handleCloseNavMenu = (link: string) =&gt; {\n    navigate(`/${link}`);\n    setAnchorElNav(null);\n  };\n\n  return (\n    &lt;&gt;\n      &lt;AppBar position=\"static\"&gt;\n        &lt;Container maxWidth=\"xl\"&gt;\n          &lt;Toolbar disableGutters&gt;\n            &lt;CasinoIcon sx={{ display: { xs: \"none\", md: \"flex\" }, mr: 1 }} /&gt;\n            &lt;Typography\n              variant=\"h6\"\n              noWrap\n              component=\"a\"\n              href=\"/\"\n              sx={{\n                mr: 2,\n                display: { xs: \"none\", md: \"flex\" },\n                fontFamily: \"monospace\",\n                fontWeight: 700,\n                letterSpacing: \".3rem\",\n                color: \"inherit\",\n                textDecoration: \"none\",\n              }}\n            &gt;\n              Ludoteca Tan\n            &lt;/Typography&gt;\n\n            &lt;Box sx={{ flexGrow: 1, display: { xs: \"flex\", md: \"none\" } }}&gt;\n              &lt;IconButton\n                size=\"large\"\n                aria-label=\"account of current user\"\n                aria-controls=\"menu-appbar\"\n                aria-haspopup=\"true\"\n                onClick={handleOpenNavMenu}\n                color=\"inherit\"\n              &gt;\n                &lt;MenuIcon /&gt;\n              &lt;/IconButton&gt;\n              &lt;Menu\n                id=\"menu-appbar\"\n                anchorEl={anchorElNav}\n                anchorOrigin={{\n                  vertical: \"bottom\",\n                  horizontal: \"left\",\n                }}\n                keepMounted\n                transformOrigin={{\n                  vertical: \"top\",\n                  horizontal: \"left\",\n                }}\n                open={Boolean(anchorElNav)}\n                onClose={handleCloseNavMenu}\n                sx={{\n                  display: { xs: \"block\", md: \"none\" },\n                }}\n              &gt;\n                {pages.map((page) =&gt; (\n                  &lt;MenuItem\n                    key={page.name}\n                    onClick={() =&gt; handleCloseNavMenu(page.link)}\n                  &gt;\n                        &lt;Typography textAlign=\"center\"&gt;\n                        {page.name}\n                      &lt;/Typography&gt;\n                  &lt;/MenuItem&gt;\n                ))}\n              &lt;/Menu&gt;\n            &lt;/Box&gt;\n            &lt;CasinoIcon sx={{ display: { xs: \"flex\", md: \"none\" }, mr: 1 }} /&gt;\n            &lt;Typography\n              variant=\"h5\"\n              noWrap\n              component=\"a\"\n              href=\"\"\n              sx={{\n                mr: 2,\n                display: { xs: \"flex\", md: \"none\" },\n                flexGrow: 1,\n                fontFamily: \"monospace\",\n                fontWeight: 700,\n                letterSpacing: \".3rem\",\n                color: \"inherit\",\n                textDecoration: \"none\",\n              }}\n            &gt;\n              Ludoteca Tan\n            &lt;/Typography&gt;\n            &lt;Box sx={{ flexGrow: 1, display: { xs: \"none\", md: \"flex\" } }}&gt;\n              {pages.map((page) =&gt; (\n                &lt;Button\n                  key={page.name}\n                  onClick={() =&gt; handleCloseNavMenu(page.link)}\n                  sx={{ my: 2, color: \"white\", display: \"block\" }}\n                &gt;\n                  {page.name}\n                &lt;/Button&gt;\n              ))}\n            &lt;/Box&gt;\n          &lt;/Toolbar&gt;\n        &lt;/Container&gt;\n      &lt;/AppBar&gt;\n      &lt;Outlet /&gt;\n    &lt;/&gt;\n  );\n};\n</code></pre> <p>Aunque puede parecer complejo por su tama\u00f1o en realidad no es tanto, casi todo es c\u00f3digo cogido directamente de un ejemplo de layout de navegaci\u00f3n de un componente de MUI.</p> <p>Lo m\u00e1s destacable es un nuevo hook (en realidad es un custom hook de react router dom) llamado <code>useNavigate</code> que como su propio nombre indica navegara a la ruta correspondiente seg\u00fan el valor pulsado.</p> <p>Las etiquetas sx son para dar estilo a los componentes de MUI. Tambi\u00e9n se puede sobrescribir el estilo mediante hojas css pero es m\u00e1s complejo y requiere una configuraci\u00f3n inicial que no cubriremos en este tutorial.</p> <p>Si nos fijamos en la l\u00ednea 90 se introduce una expresi\u00f3n javascript en la cual se recorre el array de pages declarado al inicio del componente y para cada uno de los valores se llama a <code>MenuItem</code> que es otro componente React al que se le pasan las props key, onClick y aunque no lo veamos tambi\u00e9n la prop \u201cchildren\u201d.</p> <p>La prop children estar\u00e1 presente cuando pasemos elementos entre los tags de un elemento:</p> <p><pre><code>&lt;MenuItem &gt;     \n&lt;Typography&gt;I\u2019m a child&lt;/Typography&gt;\n &lt;/MenuItem&gt;\n</code></pre> El uso de la prop children no es muy recomendado y se prefiere que se pasen los elementos como una prop m\u00e1s.</p> <p>Siempre que rendericemos un array en react es recomendable usar una prop especial llamada \u201ckey\u201d, de hecho, si no la usamos la consola de desarrollo se nos llenar\u00e1 de warnings por no usarla. </p> <p>Esta key lo que permite a React es identificar cada elemento de formar m\u00e1s eficiente, as\u00ed si modificamos, a\u00f1adimos o eliminamos un elemento de un array no ser\u00e1 necesario volver a renderizar todo el array, solo se eliminar\u00e1 el elemento necesario.</p> <p>En la parte final del archivo tenemos una llamada al elemento <code>Outlet</code>. Este elemento es el que albergara el componente asociado a la ruta seleccionada.</p> <p>Por \u00faltimo, el archivo <code>App.tsx</code> se tiene que quedar de esta manera:</p> <p><pre><code>import { BrowserRouter, Routes, Route, Navigate } from \"react-router-dom\";\nimport { Game } from \"./pages/Game/Game\";\nimport { Author } from \"./pages/Author/Author\";\nimport { Category } from \"./pages/Category/Category\";\nimport { Layout } from \"./components/Layout\";\n\nfunction App() {\n  return (\n        &lt;BrowserRouter&gt;\n          &lt;Routes&gt;\n            &lt;Route element={&lt;Layout /&gt;}&gt;\n              &lt;Route index path=\"games\" element={&lt;Game /&gt;} /&gt;\n              &lt;Route path=\"categories\" element={&lt;Category /&gt;} /&gt;\n              &lt;Route path=\"authors\" element={&lt;Author /&gt;} /&gt;\n              &lt;Route path=\"*\" element={&lt;Navigate to=\"/games\" /&gt;} /&gt;\n            &lt;/Route&gt;\n          &lt;/Routes&gt;\n        &lt;/BrowserRouter&gt;\n  );\n}\n\nexport default App;\n</code></pre> De esta manera definimos cada una de nuestras rutas y las asociamos a una p\u00e1gina.</p> <p>Vamos a arrancar el proyecto de nuevo con npm run dev y navegamos a http://localhost:5173/.</p> <p>Ahora podemos ver como autom\u00e1ticamente nos lleva a http://localhost:5173/games debido al \u00faltimo route en el que redirigimos cualquier path que no coincida con los anteriores a <code>/games</code>. Si pulsamos sobre las distintas opciones del men\u00fa podemos ver c\u00f3mo va cambiando el outlet de nuestra aplicaci\u00f3n con los distintos div creados para cada uno de los componentes p\u00e1gina.</p>"},{"location":"develop/basic/react/#creando-un-listado-simple","title":"Creando un listado simple","text":""},{"location":"develop/basic/react/#pagina-categorias","title":"P\u00e1gina categor\u00edas","text":"<p>Ya tenemos la estructura principal, ahora vamos a crear nuestra primera pantalla. Vamos a empezar por la de categor\u00edas.</p> <p>Lo primero que vamos a hacer es crear una carpeta llamada <code>types</code> dentro de <code>src/</code>. Aqu\u00ed crearemos los tipos de typescript. Creamos un nuevo fichero llamado <code>Category.ts</code> cuyo contenido ser\u00e1 el siguiente:</p> <pre><code>export interface Category {\n  id: string;\n  name: string;\n}\n</code></pre> <p>Ahora vamos a crear un archivo de estilos que ser\u00e1 solo utilizado por el componente Category. Para ello dentro de la carpeta <code>src/pages/Category</code> vamos a crear un archivo llamado <code>Category.module.css</code>. Al llamar al archivo de esta manera React reconoce este archivo como un archivo \u00fanico para un componente y hace que sus reglas css sean m\u00e1s prioritarias, aunque por ejemplo exista una clase con el mismo nombre en el archivo <code>index.css</code>.</p> <p>El contenido de nuestro archivo css ser\u00e1 el siguiente:</p> <pre><code>.tableActions {\n    margin-right: 20px;\n    display: flex;\n    justify-content: flex-end;\n    align-content: flex-start;\n    gap: 19px;\n}\n</code></pre> <p>Y por \u00faltimo el contenido de nuestro fichero <code>src/pages/Category.tsx</code> quedar\u00eda as\u00ed:</p> <p><pre><code>import { useState } from \"react\";\nimport Table from \"@mui/material/Table\";\nimport TableBody from \"@mui/material/TableBody\";\nimport TableCell from \"@mui/material/TableCell\";\nimport TableContainer from \"@mui/material/TableContainer\";\nimport TableHead from \"@mui/material/TableHead\";\nimport TableRow from \"@mui/material/TableRow\";\nimport Paper from \"@mui/material/Paper\";\nimport Button from \"@mui/material/Button\";\nimport EditIcon from \"@mui/icons-material/Edit\";\nimport ClearIcon from \"@mui/icons-material/Clear\";\nimport IconButton from \"@mui/material/IconButton\";\nimport styles from \"./Category.module.css\";\nimport { Category as CategoryModel } from \"../../types/Category\";\n\nexport const Category = () =&gt; {\n  const data = [\n    {\n      id: \"1\",\n      name: \"Test 1\",\n    },\n    {\n      id: \"2\",\n      name: \"Test 2\",\n    },\n  ];\n\n  return (\n    &lt;div className=\"container\"&gt;\n      &lt;h1&gt;Listado de Categor\u00edas&lt;/h1&gt;\n      &lt;TableContainer component={Paper}&gt;\n        &lt;Table sx={{ minWidth: 650 }} aria-label=\"simple table\"&gt;\n          &lt;TableHead\n            sx={{\n              \"&amp; th\": {\n                backgroundColor: \"lightgrey\",\n              },\n            }}\n          &gt;\n            &lt;TableRow&gt;\n              &lt;TableCell&gt;Identificador&lt;/TableCell&gt;\n              &lt;TableCell&gt;Nombre categor\u00eda&lt;/TableCell&gt;\n              &lt;TableCell&gt;&lt;/TableCell&gt;\n            &lt;/TableRow&gt;\n          &lt;/TableHead&gt;\n          &lt;TableBody&gt;\n            {data.map((category: CategoryModel) =&gt; (\n              &lt;TableRow\n                key={category.id}\n                sx={{ \"&amp;:last-child td, &amp;:last-child th\": { border: 0 } }}\n              &gt;\n                &lt;TableCell component=\"th\" scope=\"row\"&gt;\n                  {category.id}\n                &lt;/TableCell&gt;\n                &lt;TableCell component=\"th\" scope=\"row\"&gt;\n                  {category.name}\n                &lt;/TableCell&gt;\n                &lt;TableCell&gt;\n                  &lt;div className={styles.tableActions}&gt;\n                    &lt;IconButton aria-label=\"update\" color=\"primary\"&gt;\n                      &lt;EditIcon /&gt;\n                    &lt;/IconButton&gt;\n                    &lt;IconButton aria-label=\"delete\" color=\"error\"&gt;\n                      &lt;ClearIcon /&gt;\n                    &lt;/IconButton&gt;\n                  &lt;/div&gt;\n                &lt;/TableCell&gt;\n              &lt;/TableRow&gt;\n            ))}\n          &lt;/TableBody&gt;\n        &lt;/Table&gt;\n      &lt;/TableContainer&gt;\n      &lt;div className=\"newButton\"&gt;\n        &lt;Button variant=\"contained\"&gt;Nueva categor\u00eda&lt;/Button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> De momento vamos a usar un listado mockeado para mostrar nuestras categorias. El c\u00f3digo JSX esta sacado pr\u00e1cticamente en su totalidad del ejemplo de una tabla de Mui y solo hemos modificado el nombre del array que tenemos que recorrer, sus atributos y hemos a\u00f1adido unos botones de acci\u00f3n para editar y borrar autores que de momento no hacen nada.</p> <p>Si abrimos un navegador (con el servidor arrancado npm run dev) y vamos a http://localhost:5173/categories podremos ver nuestro listado con los datos mockeados.</p> <p>Ahora vamos a crear un componente que se mostrar\u00e1 cuando pulsemos el bot\u00f3n de nueva categor\u00eda. En la carpeta <code>src/pages/category</code> vamos a crear una nueva carpeta llamada <code>components</code> y dentro de esta crearemos un nuevo fichero llamado <code>CreateCategory.tsx</code> que tendr\u00e1 el siguiente contenido:</p> <pre><code>import { useState } from \"react\";\nimport Button from \"@mui/material/Button\";\nimport TextField from \"@mui/material/TextField\";\nimport Dialog from \"@mui/material/Dialog\";\nimport DialogActions from \"@mui/material/DialogActions\";\nimport DialogContent from \"@mui/material/DialogContent\";\nimport DialogTitle from \"@mui/material/DialogTitle\";\nimport { Category } from \"../../../types/Category\";\n\ninterface Props {\n  category: Category | null;\n  closeModal: () =&gt; void;\n  create: (name: string) =&gt; void;\n}\n\nexport default function CreateCategory(props: Props) {\n  const [name, setName] = useState(props?.category?.name || \"\");\n\n  return (\n    &lt;div&gt;\n      &lt;Dialog open={true} onClose={props.closeModal}&gt;\n        &lt;DialogTitle&gt;\n          {props.category ? \"Actualizar Categor\u00eda\" : \"Crear Categor\u00eda\"}\n        &lt;/DialogTitle&gt;\n        &lt;DialogContent&gt;\n          {props.category &amp;&amp; (\n            &lt;TextField\n              margin=\"dense\"\n              disabled\n              id=\"id\"\n              label=\"Id\"\n              fullWidth\n              value={props.category.id}\n              variant=\"standard\"\n            /&gt;\n          )}\n          &lt;TextField\n            margin=\"dense\"\n            id=\"name\"\n            label=\"Nombre\"\n            fullWidth\n            variant=\"standard\"\n            onChange={(event) =&gt; setName(event.target.value)}\n            value={name}\n          /&gt;\n        &lt;/DialogContent&gt;\n        &lt;DialogActions&gt;\n          &lt;Button onClick={props.closeModal}&gt;Cancelar&lt;/Button&gt;\n          &lt;Button onClick={() =&gt; props.create(name)} disabled={!name}&gt;\n            {props.category ? \"Actualizar\" : \"Crear\"}\n          &lt;/Button&gt;\n        &lt;/DialogActions&gt;\n      &lt;/Dialog&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>Para este componente hemos definido una categor\u00eda como par\u00e1metro de entrada para poder reutilizar el componente en el caso de una edici\u00f3n y poder pasar la categor\u00eda a editar, en nuestro caso inicial al ser un alta esta categor\u00eda tendr\u00e1 el valor <code>null</code>. Tambi\u00e9n hemos definido dos funciones en los par\u00e1metros de entrada para controlar o bien el cerrado del modal o bien la creaci\u00f3n de un autor.</p> <p>Esta es la forma directa que tienen de comunicaci\u00f3n los componentes padre/hijo en React, el padre puede pasar datos de lectura o funciones a sus componentes hijos a las que estos llamaran para comunicarse con \u00e9l.</p> <p>As\u00ed en nuestro ejemplo el componente <code>CreateCategory</code> llamar\u00e1 a la funci\u00f3n <code>create</code> a la que pasar\u00e1 un nuevo objecto <code>Category</code> y ser\u00e1 el padre (nuestra p\u00e1gina <code>Category</code>) el que decidir\u00e1 qu\u00e9 hacer con esos datos al igual que ocurre con los eventos en los tags de html.</p> <p>En el estado de nuestro componente solo vamos a almacenar los datos introducidos en el formulario, en el caso de una edici\u00f3n el valor inicial del nombre de la categor\u00eda ser\u00e1 el que venga de entrada. </p> <p>Adem\u00e1s introducido unas expresiones que modificar\u00e1n la visualizaci\u00f3n del componente (titulo, id, texto de los botones, \u2026) dependiendo de si tenemos un autor de entrada o no.</p> <p>Ahora tenemos que a\u00f1adir nuestro nuevo componente en nuestra p\u00e1gina Category:</p> <p>Importamos el componente:</p> <pre><code>import CreateCategory from \"./components/CreateCategory\";\n</code></pre> <p>Creamos las funciones que le pasaremos al componente, dej\u00e1ndolas de momento vac\u00edas:</p> <pre><code>const createCategory = () =&gt; {\n\n  }\n\n  const handleCloseCreate = () =&gt; {\n\n  }\n</code></pre> <p>Y a\u00f1adimos en el c\u00f3digo JSX lo siguiente tras nuestro <code>button</code>:</p> <pre><code>      &lt;CreateCategory\n          create={createCategory}\n          category={null}\n          closeModal={handleCloseCreate}\n        /&gt;\n</code></pre> <p>Si ahora vamos a nuestro navegador, a la p\u00e1gina de categor\u00edas, podremos ver el formulario para crear una categor\u00eda, pero \u00e9sta fijo y no hay manera de cerrarlo. Vamos a cambiar este comportamiento mediante una variable booleana en el estado del componente que decidir\u00e1 cuando se muestra este. Adem\u00e1s, a\u00f1adiremos a nuestro bot\u00f3n el c\u00f3digo necesario para mostrar el componente y a\u00f1adiremos a la funci\u00f3n <code>handleCloseCreate</code> el c\u00f3digo para ocultarlo.</p> <p>A\u00f1adimos un nuevo estado:</p> <pre><code>const [openCreate, setOpenCreate] = useState(false);\n</code></pre> <p>Modificamos la function <code>handleCloseCreate</code>:</p> <pre><code>const handleCloseCreate = () =&gt; {\n    setOpenCreate(false);\n  };\n</code></pre> <p>Y por \u00faltimo modificamos el c\u00f3digo del return de la siguiente manera:</p> <pre><code>      &lt;div className=\"newButton\"&gt;\n        &lt;Button variant=\"contained\" onClick={() =&gt; setOpenCreate(true)}&gt;\n          Nueva categor\u00eda\n        &lt;/Button&gt;\n      &lt;/div&gt;\n      {openCreate &amp;&amp; (\n        &lt;CreateCategory\n          create={createCategory}\n          category={null}\n          closeModal={handleCloseCreate}\n        /&gt;\n      )}\n</code></pre> <p>Si probamos ahora vemos que ya se realiza la funcionalidad de abrir y cerrar nuestro formulario de manera correcta.</p> <p>Ahora vamos a a\u00f1adir la funcionalidad para que al pulsar el bot\u00f3n de edici\u00f3n pasemos la categor\u00eda a editar a nuestro formulario. Para esto vamos a necesitar una nueva variable en nuestro estado donde almacenaremos la categor\u00eda a editar:</p> <pre><code>const [categoryToUpdate, setCategoryToUpdate] =\n    useState&lt;CategoryModel | null&gt;(null);\n</code></pre> <p>Modificamos el c\u00f3digo de nuestro bot\u00f3n: </p> <pre><code>                    &lt;IconButton\n                      aria-label=\"update\"\n                      color=\"primary\"\n                      onClick={() =&gt; {\n                        setCategoryToUpdate(category);\n                        setOpenCreate(true);\n                      }}\n                    &gt;\n                      &lt;EditIcon /&gt;\n                    &lt;/IconButton&gt;\n</code></pre> <p>Y la entrada a nuestro componente:</p> <pre><code>      {openCreate &amp;&amp; (\n        &lt;CreateCategory\n          create={createCategory}\n          category={categoryToUpdate}\n          closeModal={handleCloseCreate}\n        /&gt;\n      )}\n</code></pre> <p>Si ahora hacemos una prueba en nuestro navegador y pulsamos el bot\u00f3n de editar vemos como nuestro formulario ya se carga correctamente pero hay un problema, si pulsamos el bot\u00f3n de editar, cerramos el formulario y le damos al boton de nueva categor\u00eda vemos que el formulario mantiene los datos anteriores. Vamos a solucionar este problema volviendo a dejar vacia la variable <code>categoryToUpdate</code> cuando se cierre el componente:</p> <p>Modificamos la funci\u00f3n <code>handleCloseCreate</code>:</p> <pre><code>const handleCloseCreate = () =&gt; {\n    setOpenCreate(false);\n    setCategoryToUpdate(null);\n  };\n</code></pre> <p>Y vemos que el funcionamiento ya es el correcto.</p> <p>Ahora vamos a darle funcionalidad al bot\u00f3n de borrado. Cuando pulsemos sobre este bot\u00f3n se nos debe mostrar un mensaje de alerta para confirmar nuestra decisi\u00f3n. Como este es un mensaje que vamos a reutilizar en el resto de la aplicaci\u00f3n vamos a crear un componente en la carpeta <code>src/components</code> llamado <code>ConfirmDialog.tsx</code> con el siguiente contenido: </p> <pre><code>import Button from \"@mui/material/Button\";\nimport DialogContentText from \"@mui/material/DialogContentText\";\nimport Dialog from \"@mui/material/Dialog\";\nimport DialogActions from \"@mui/material/DialogActions\";\nimport DialogContent from \"@mui/material/DialogContent\";\nimport DialogTitle from \"@mui/material/DialogTitle\";\n\ninterface Props {\n  closeModal: () =&gt; void;\n  confirm: () =&gt; void;\n  title: string;\n  text: string;\n}\n\nexport const ConfirmDialog = (props: Props) =&gt; {\n  return (\n    &lt;div&gt;\n      &lt;Dialog open={true} onClose={props.closeModal}&gt;\n        &lt;DialogTitle&gt;{props.title}&lt;/DialogTitle&gt;\n        &lt;DialogContent&gt;\n          &lt;DialogContentText&gt;{props.text}&lt;/DialogContentText&gt;\n        &lt;/DialogContent&gt;\n        &lt;DialogActions&gt;\n          &lt;Button onClick={props.closeModal}&gt;Cancelar&lt;/Button&gt;\n          &lt;Button onClick={() =&gt; props.confirm()}&gt;Confirmar&lt;/Button&gt;\n        &lt;/DialogActions&gt;\n      &lt;/Dialog&gt;\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Y vamos a a\u00f1adirlo a nuestra p\u00e1gina de categorias, pero al igual que paso con nuestro formulario de altas no queremos que este componente se muestre siempre, sino que estar\u00e1 condicionado al valor de una nueva variable en nuestro estado. En este caso vamos a almacenar el id de la categor\u00eda a borrar. </p> <p>Importamos nuestro nuevo componente:</p> <pre><code>import { ConfirmDialog } from \"../../components/ConfirmDialog\";\n</code></pre> <p>Creamos una nueva variable en el estado:</p> <pre><code>const [idToDelete, setIdToDelete] = useState(\"\");\n</code></pre> <p>Creamos una nueva funci\u00f3n:</p> <pre><code>const deleteCategory = () =&gt; {};\n</code></pre> <p>Modificamos el bot\u00f3n de borrado:</p> <pre><code>                      &lt;IconButton\n                        aria-label=\"delete\"\n                        color=\"error\"\n                        onClick={() =&gt; {\n                          setIdToDelete(category.id);\n                        }}\n                      &gt;\n                        &lt;ClearIcon /&gt;\n                      &lt;/IconButton&gt;\n</code></pre> <p>Y a\u00f1adimos el c\u00f3digo necesario en nuestro return para incluir el nuevo componente:</p> <pre><code>      {!!idToDelete &amp;&amp; (\n        &lt;ConfirmDialog\n          title=\"Eliminar categor\u00eda\"\n          text=\"Atenci\u00f3n si borra la categor\u00eda se perder\u00e1n sus datos. \u00bfDesea eliminar la categor\u00eda?\"\n          confirm={deleteCategory}\n          closeModal={() =&gt; setIdToDelete('')}\n        /&gt;\n      )}\n</code></pre>"},{"location":"develop/basic/react/#recuperando-datos","title":"Recuperando datos","text":"<p>Ya estamos preparados para llamar a nuestro back. Hay muchas maneras de recuperar datos del back en React. Si no queremos usar ninguna librer\u00eda externa podemos hacer uso del m\u00e9todo fetch, pero tendr\u00edamos que repetir mucho c\u00f3digo o bien construir interceptores, para el manejo de errores, construcci\u00f3n de middlewares,\u2026 adem\u00e1s, no es lo mas utilizado. Hoy en d\u00eda se opta por librer\u00edas como <code>Axios</code> o <code>Redux Toolkit query</code> que facilitan el uso de este m\u00e9todo.</p> <p>Nosotros vamos a utilizar una herramienta de redux llamada <code>Redux Toolkit Query</code>, pero primero vamos a explicar que es redux.</p>"},{"location":"develop/basic/react/#redux","title":"Redux","text":"<p>Redux es una librer\u00eda que implementa el patr\u00f3n de dise\u00f1o Flux y que nos permite crear un estado global. </p> <p>Nuestros componentes pueden realizar acciones asociadas a un reducer que modificar\u00e1n este estado global llamado generalmente <code>store</code> y a su vez estar\u00e1n subscritos a variables de este estado para estar atentos a posibles cambios.</p> <p></p> <p>Antes se sol\u00edan construir ficheros de actions, de reducers y un fichero de store, pero con redux toolkit se ha simplificado todo. Por un lado, podemos tener slices, que son ficheros que agrupan acciones, reducers y parte del estado y por otro lado podemos tener servicios donde declaramos llamadas a nuestra api y redux guarda las llamadas en nuestro estado global para que sean accesibles desde cualquier parte de nuestra aplicaci\u00f3n.</p> <p>Vamos a crear una carpeta llamada <code>redux</code> dentro de la carpeta <code>src</code> y a su vez dentro de <code>src/redux</code> vamos a crear dos carpetas: <code>features</code> donde crearemos nuestros slices y <code>services</code> donde crearemos las llamadas al api.</p> <p>Dentro de la carpeta <code>services</code> vamos a crear un fichero llamado <code>ludotecaApi.ts</code> con el siguiente contenido:</p> <pre><code>import { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\nimport { Category } from \"../../types/Category\";\n\nexport const ludotecaAPI = createApi({\n  reducerPath: \"ludotecaApi\",\n  baseQuery: fetchBaseQuery({\n    baseUrl: \"http://localhost:8080\",\n  }),\n  tagTypes: [\"Category\"],\n  endpoints: (builder) =&gt; ({\n    getCategories: builder.query&lt;Category[], null&gt;({\n      query: () =&gt; \"category\",\n      providesTags: [\"Category\"],\n    }),\n    createCategory: builder.mutation({\n      query: (payload) =&gt; ({\n        url: \"/category\",\n        method: \"PUT\",\n        body: payload,\n        headers: {\n          \"Content-type\": \"application/json; charset=UTF-8\",\n        },\n      }),\n      invalidatesTags: [\"Category\"],\n    }),\n    deleteCategory: builder.mutation({\n      query: (id: string) =&gt; ({\n        url: `/category/${id}`,\n        method: \"DELETE\",\n      }),\n      invalidatesTags: [\"Category\"],\n    }),\n    updateCategory: builder.mutation({\n      query: (payload: Category) =&gt; ({\n        url: `category/${payload.id}`,\n        method: \"PUT\",\n        body: payload,\n      }),\n      invalidatesTags: [\"Category\"],\n    }),\n  }),\n});\n\nexport const {\n    useGetCategoriesQuery,\n    useCreateCategoryMutation,\n    useDeleteCategoryMutation,\n    useUpdateCategoryMutation\n} = ludotecaAPI;\n</code></pre> <p>Con esto ya habr\u00edamos creado las acciones que llaman al back y almacenan el resultado en nuestro estado. Para configurar nuestra api le tenemos que dar un nombre, una url base, una series de tags y nuestros endpoints que pueden ser de tipo query para realizar consultas o <code>mutation</code>. Tambi\u00e9n exportamos los hooks que nos van a permitir hacer uso de estos endpoints. Si los endpoints los creamos de tipo <code>query</code>, cuando hacemos uso de estos hooks se realizar\u00e1 una consulta al back y recibiremos los datos de la consulta en nuestros par\u00e1metros del hook entre otras cosas. Si los creamos de tipo <code>mutation</code> lo que nos devolver\u00e1 el hook ser\u00e1 la acci\u00f3n que tenemos que llamar para realizar esta llamada.</p> <p>Los tags sirven para cachear el resultado, pero cuando llamamos a una <code>mutation</code> y pasamos informaci\u00f3n en <code>invalidateTags</code>, esto va a hacer que se vuelva a lanzar la query afectada por estos tags para actualizar su resultado, por eso hemos a\u00f1adido el <code>providesTags</code> en la query, para que desde nuestras p\u00e1ginas usemos los hooks exportados.</p> <p>Ahora vamos a crear dentro de la carpeta <code>src/redux</code> un fichero llamado <code>store.ts</code> con el siguiente contenido:</p> <pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport { setupListeners } from \"@reduxjs/toolkit/dist/query\";\nimport { ludotecaAPI } from \"./services/ludotecaApi\";\n\nexport const store = configureStore({\n  reducer: {\n    [ludotecaAPI.reducerPath]: ludotecaAPI.reducer,\n  },\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat([ludotecaAPI.middleware]),\n});\n\nsetupListeners(store.dispatch);\n\n// Infer the `RootState` and `AppDispatch` types from the store itself\nexport type RootState = ReturnType&lt;typeof store.getState&gt;;\n// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}\nexport type AppDispatch = typeof store.dispatch;\n</code></pre> <p>Aqu\u00ed b\u00e1sicamente creamos el store con nuestro <code>reducer</code>. Cabe destacar que podemos crear tantos <code>reducers</code> como queramos siempre que les demos distintos nombres.</p> <p>Ahora ya podr\u00edamos hacer uso de los hooks que vienen con redux llamados <code>useDispatch</code> para llamar a nuestras actions y <code>useSelect</code> para suscribirnos a los cambios en el estado, pero como estamos usando typescript tendr\u00edamos que tipar todos estos m\u00e9todos y variables que usamos en todos nuestros componentes resultando un c\u00f3digo un tanto sucio y repetitivo. Tambi\u00e9n podemos simplemente ignorar a typescript y deshabilitar las reglas para estos ficheros, pero vamos a hacerlo bien.</p> <p>Vamos a crear un fichero llamado <code>hooks.ts</code> dentro de la carpeta de redux y su contenido ser\u00e1 el siguiente:</p> <pre><code>import {  useDispatch, useSelector } from 'react-redux'\nimport type { TypedUseSelectorHook } from 'react-redux'\nimport type { RootState, AppDispatch } from './store'\n\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\ntype DispatchFunc = () =&gt; AppDispatch\nexport const useAppDispatch: DispatchFunc = useDispatch\nexport const useAppSelector: TypedUseSelectorHook&lt;RootState&gt; = useSelector\n</code></pre> <p>Estos ser\u00e1n los m\u00e9todos que usaremos en lugar de <code>useDispatch</code> y <code>useSelector</code>.</p> <p>Ahora vamos a modificar nuestro fichero <code>App.tsx</code> a\u00f1adiendo los imports necesarios y rodeando nuestro c\u00f3digo con el tag <code>provider</code>:</p> <pre><code>import { Provider } from \"react-redux\";\n\nimport { store } from \"./redux/store\";\n\n    &lt;Provider store={store}&gt;\n      &lt;BrowserRouter&gt;\n        &lt;Routes&gt;\n          &lt;Route element={&lt;Layout /&gt;}&gt;\n            &lt;Route index path=\"games\" element={&lt;Game /&gt;} /&gt;\n            &lt;Route path=\"categories\" element={&lt;Category /&gt;} /&gt;\n            &lt;Route path=\"authors\" element={&lt;Author /&gt;} /&gt;\n            &lt;Route path=\"*\" element={&lt;Navigate to=\"/games\" /&gt;} /&gt;\n          &lt;/Route&gt;\n        &lt;/Routes&gt;\n      &lt;/BrowserRouter&gt;\n    &lt;/Provider&gt;\n</code></pre> <p>Ahora ya podemos hacer uso de los m\u00e9todos de <code>redux</code> para modificar y leer el estado global de nuestra aplicaci\u00f3n.</p> <p>Volvemos a nuestro componente <code>Category</code> y vamos a importar los hooks de nuestra api para hacer uso de ellos:</p> <pre><code>import { useAppDispatch } from \"../../redux/hooks\";\nimport {\n  useCreateCategoryMutation,\n  useDeleteCategoryMutation,\n  useGetCategoriesQuery,\n  useUpdateCategoryMutation,\n} from \"../../redux/services/ludotecaApi\";\n</code></pre> <p>Eliminamos la variable mockeada data y a\u00f1adimos en su lugar lo siguiente: <pre><code>const dispatch = useAppDispatch();\n  const { data, error, isLoading } = useGetCategoriesQuery(null);\n\n  const [\n    deleteCategoryApi,\n    { isLoading: isLoadingDelete, error: errorDelete },\n  ] = useDeleteCategoryMutation();\n  const [createCategoryApi, { isLoading: isLoadingCreate }] =\n    useCreateCategoryMutation();\n\n  const [updateCategoryApi, { isLoading: isLoadingUpdate }] =\n    useUpdateCategoryMutation();\n</code></pre></p> <p>Como ya hemos dicho anteriormente, los <code>hooks</code> de la api de tipo query nos devolver\u00e1n datos mientras que los <code>hooks</code> de tipo <code>mutation</code> nos devuelven acciones que podemos lanzar con el m\u00e9todo <code>dispatch</code>. El resto de los par\u00e1metros nos dan informaci\u00f3n para saber el estado de la llamada, por ejemplo, para saber si esta cargando, si se ha producido un error, etc\u2026</p> <p>Tenemos que modificar el c\u00f3digo que recorre data ya que este valor ahora puede estar sin definir:</p> <pre><code>        &lt;TableBody&gt;\n            {data &amp;&amp;\n              data.map((category: CategoryModel) =&gt; (\n</code></pre> <p>Y ahora si tenemos datos en la base de datos y vamos a nuestro navegador podemos ver que ya se est\u00e1n representando estos datos en la tabla de categor\u00edas.</p> <p>Modificamos el m\u00e9todo <code>createCategory</code>:</p> <pre><code>const createCategory = (category: string) =&gt; {\n    setOpenCreate(false);\n    if (categoryToUpdate) {\n      updateCategoryApi({ id: categoryToUpdate.id, name: category })\n        .then(() =&gt; {\n          setCategoryToUpdate(null);\n        })\n        .catch((err) =&gt; console.log(err));\n    } else {\n      createCategoryApi({ name: category })\n        .then(() =&gt; {\n          setCategoryToUpdate(null);\n        })\n        .catch((err) =&gt; console.log(err));\n    }\n  };\n</code></pre> <p>Si tenemos almacenada alguna categor\u00eda para actualizar llamaremos a la acci\u00f3n para actualizar la categor\u00eda que recuperamos del hook y si no tenemos categor\u00eda almacenada llamaremos al m\u00e9todo para crear una categor\u00eda nueva. Estos m\u00e9todos nos devuelven una promesa que cuando resolvemos volvemos a poner el valor de la categor\u00eda a actualizar a <code>null</code>.</p> <p>Implementamos el m\u00e9todo para borrar categor\u00edas:</p> <pre><code>const deleteCategory = () =&gt; {\n    deleteCategoryApi(idToDelete)\n      .then(() =&gt; \n      setIdToDelete(''))\n      .catch((err) =&gt; console.log(err));\n  };\n</code></pre> <p>Ahora si probamos en nuestro navegador ya podremos realizar todas las funciones de la p\u00e1gina: listar, crear, actualizar y borrar, pero aun vamos a darle m\u00e1s funcionalidad. </p> <p>Vamos a crear una variable en el estado global de nuestra aplicaci\u00f3n para mostrar alertas de informaci\u00f3n o de error. Para ello creamos un nuevo fichero en la carpeta <code>src/redux/features</code> llamado <code>messageSlice.ts</code> cuyo contenido ser\u00e1 el siguiente:</p> <pre><code>import { createSlice } from '@reduxjs/toolkit'\nimport type {PayloadAction} from \"@reduxjs/toolkit\"\n\nexport const messageSlice = createSlice({\n  name: 'message',\n  initialState: {\n    text: '',\n    type: ''\n  },\n  reducers: {\n    deleteMessage: (state) =&gt; {\n        state.text = ''\n        state.type = ''\n    },\n    setMessage: (state, action : PayloadAction&lt;{text: string; type: string}&gt;) =&gt; {\n        state.text = action.payload.text;\n        state.type = action.payload.type;\n    },\n  },\n})\n\nexport const { deleteMessage, setMessage } = messageSlice.actions;\nexport default messageSlice.reducer;\n</code></pre> <p>Como ya hemos dicho anteriormente los <code>slices</code> son un concepto introducido en <code>Redux Toolkit</code> y no es ni m\u00e1s ni menos que un fichero que agrupa <code>reducers</code>, <code>actions</code> y <code>selectors</code>.</p> <p>En este fichero declaramos el nombre del selector (<code>message</code>) para despu\u00e9s poder recuperar los datos en un componente, declaramos el estado inicial de nuestro <code>slice</code>, creamos las funciones de los <code>reducers</code> y declaramos dos acciones.</p> <p>Los <code>reducers</code> son funciones puras que modifican el estado, en nuestro caso utilizamos un <code>reducer</code> para resetear el estado y otro para setear el texto y el tipo de mensaje. Con <code>Redux Toolkit</code> podemos acceder directamente al estado dentro de nuestros <code>reducers</code>. En los <code>reducers</code> que no usan esta herramienta lo que se hace es devolver un objeto que ser\u00e1 el nuevo estado.</p> <p>Las acciones son las que invocan a los <code>reducers</code>. Estas solo dicen que hacer, pero no como hacerlo. Con <code>Redux Toolkit</code> las acciones se generan autom\u00e1ticamente y solo tenemos que hacer un destructuring del objecto actions de nuestro <code>slice</code> para recuperarlas y exportarlas.</p> <p>Ahora vamos a modificar el fichero <code>src/redux/store.ts</code> para a\u00f1adir el nuevo <code>reducer</code>:</p> <pre><code>import { configureStore } from \"@reduxjs/toolkit\";\nimport { setupListeners } from \"@reduxjs/toolkit/dist/query\";\nimport { ludotecaAPI } from \"./services/ludotecaApi\";\nimport messageReducer from \"./features/messageSlice\";\n\nexport const store = configureStore({\n  reducer: {\n    messageReducer,\n    [ludotecaAPI.reducerPath]: ludotecaAPI.reducer,\n  },\n  middleware: (getDefaultMiddleware) =&gt;\n    getDefaultMiddleware().concat([ludotecaAPI.middleware]),\n});\n\nsetupListeners(store.dispatch);\n\n// Infer the `RootState` and `AppDispatch` types from the store itself\nexport type RootState = ReturnType&lt;typeof store.getState&gt;;\n// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}\nexport type AppDispatch = typeof store.dispatch;\n</code></pre> <p>Con esto ya podemos hacer uso de esta funcionalidad. Vamos a modificar el componente Layout para que pueda recibir mensajes y mostrarlos por pantalla.</p> <pre><code>import Alert from \"@mui/material/Alert\";\nimport { useAppDispatch, useAppSelector } from \"../redux/hooks\";\nimport { deleteMessage } from \"../redux/features/messageSlice\";\n\n  const dispatch = useAppDispatch();\n  const { text, type } = useAppSelector((state) =&gt; state.messageReducer);\n\n  useEffect(() =&gt; {\n    setTimeout(() =&gt; {\n      dispatch(deleteMessage());\n    }, 3000);\n  }, [text, type]);\n\n      {text &amp;&amp; (\n        &lt;Alert severity={type === \"error\" ? \"error\" : \"success\"}&gt;{text}&lt;/Alert&gt;\n      )}\n</code></pre> <p>Hemos a\u00f1adido c\u00f3digo para que el componente <code>layout</code> este subscrito a las variables <code>text</code> y <code>type</code> de nuestro contexto global. Si tenemos <code>text</code> se mostrar\u00e1 la alerta y adem\u00e1s hemos incluido un nuevo <code>hook</code> <code>useEffect</code> gracias al cual cuando el componente reciba un text llamar\u00e1 a una funci\u00f3n que pasados 3 segundos borrar\u00e1 el mensaje de nuestro estado ocultando as\u00ed el <code>Alert</code>.</p> <p>Pero antes de seguir adelante vamos a explicar que hace <code>useEffect</code> exactamente ya que es un <code>hook</code> de React muy utilizado.</p>"},{"location":"develop/basic/react/#useeffect","title":"useEffect","text":"<p>El ciclo de vida de los componentes en React permit\u00eda en los componentes de tipo clase poder ejecutar c\u00f3digo en diferentes fases de montaje, actualizaci\u00f3n y desmontaje. De esta forma, pod\u00edamos a\u00f1adir cierta funcionalidad en las distintas etapas de nuestro componente.</p> <p>Con los <code>hooks</code> tambi\u00e9n podremos acceder a ese ciclo de vida en nuestros componentes funcionales, aunque de una forma m\u00e1s clara y sencilla. Para ello usaremos <code>useEffect</code>, un <code>hook</code> que recibe como par\u00e1metro una funci\u00f3n que se ejecutar\u00e1 cada vez que se modifique el valor de las las dependencias que pasemos como segundo par\u00e1metro.</p> <p>Hay otros casos especiales de <code>useEffect</code>, por ejemplo, si hubi\u00e9semos dejado el array de dependencias de <code>useEffect</code> vac\u00edo, solo se llamar\u00eda a la funci\u00f3n la primera vez que se renderiza el componente. </p> <pre><code>useEffect(() =&gt; {\nconsole.log(\u2018Solo me muestro en el primer render\u2019);\n  }, []);\n</code></pre> <p>Y si queremos que solo se llame a la funci\u00f3n cuando se desmonta el componente lo que tenemos que hacer es devolver de <code>useEffect</code> una funci\u00f3n con el c\u00f3digo que queremos que se ejecute una vez que se desmonte:</p> <pre><code>useEffect(() =&gt; {\nreturn () =&gt; {\n        console.log(\u2018Me desmonto!!\u2019)\n}\n  }, []);\n</code></pre> <p>Dentro de la carpeta <code>src/types</code> vamos a crear un fichero llamado <code>appTypes.ts</code> que contendr\u00e1 todos aquellos tipos o interfaces auxiliares para construir nuestra aplicaci\u00f3n:</p> <pre><code>export interface BackError {\n  msg: string;\n}\n</code></pre> <p>Ahora ya podemos incluir en nuestra p\u00e1gina de categor\u00edas el c\u00f3digo para guardar los mensajes de informaci\u00f3n y error en el estado global, importamos lo necesario:</p> <pre><code>import { setMessage } from \"../../redux/features/messageSlice\";\nimport { BackError } from \"../../types/appTypes\";\n</code></pre> <p>A\u00f1adimos:</p> <pre><code>useEffect(() =&gt; {\n    if (errorDelete) {\n      if (\"status\" in errorDelete) {\n        dispatch(\n          setMessage({\n            text: (errorDelete?.data as BackError).msg,\n            type: \"error\",\n          })\n        );\n      }\n    }\n  }, [errorDelete, dispatch]);\n\n  useEffect(() =&gt; {\n    if (error) {\n      dispatch(setMessage({ text: \"Se ha producido un error\", type: \"error\" }));\n    }\n  }, [error]);\n</code></pre> <p>Y modificamos:</p> <pre><code>const createCategory = (category: string) =&gt; {\n    setOpenCreate(false);\n    if (categoryToUpdate) {\n      updateCategoryApi({ id: categoryToUpdate.id, name: category })\n        .then(() =&gt; {\n          dispatch(\n            setMessage({\n              text: \"Categor\u00eda actualizada correctamente\",\n              type: \"ok\",\n            })\n          );\n          setCategoryToUpdate(null);\n        })\n        .catch((err) =&gt; console.log(err));\n    } else {\n      createCategoryApi({ name: category })\n        .then(() =&gt; {\n          dispatch(\n            setMessage({ text: \"Categor\u00eda creada correctamente\", type: \"ok\" })\n          );\n          setCategoryToUpdate(null);\n        })\n        .catch((err) =&gt; console.log(err));\n    }\n  };\n\n  const deleteCategory = () =&gt; {\n    deleteCategoryApi(idToDelete)\n      .then(() =&gt; {\n        dispatch(\n          setMessage({\n            text: \"Categor\u00eda borrada correctamente\",\n            type: \"ok\",\n          })\n        );\n        setIdToDelete(\"\");\n      })\n      .catch((err) =&gt; console.log(err));\n  };\n</code></pre> <p>Si ahora probamos nuestra aplicaci\u00f3n al borrar, actualizar o crear una categor\u00eda nos deber\u00eda de mostrar un mensaje de informaci\u00f3n.</p> <p>Ya casi estamos terminando con nuestra p\u00e1gina de categor\u00edas, pero vamos a a\u00f1adir tambi\u00e9n un <code>loader</code> para cuando nuestra acciones est\u00e9n en estado de <code>loading</code>. Para esto vamos a hacer uso de otra de las maneras que tiene React de almacenar informaci\u00f3n global, el contexto.</p>"},{"location":"develop/basic/react/#context-api","title":"Context API","text":"<p>Una de las caracter\u00edsticas que llegaron en las \u00faltimas versiones de React fue el contexto, una forma de pasar datos que pueden considerarse globales a un \u00e1rbol de componentes sin la necesidad de utilizar <code>Redux</code>. El uso de contextos mediante la <code>Context API</code> es una soluci\u00f3n m\u00e1s ligera y sencilla que redux y que no est\u00e1 mal para aplicaciones que no son excesivamente grandes.</p> <p>En general cuando queramos usar estados globales que no sean demasiado grandes y no se haga demasiada escritura sobre ellos ser\u00e1 preferible usar <code>Context API</code> en lugar de <code>redux</code>.</p> <p>Vamos a crear un contexto para utilizar un <code>loader</code> en nuestra aplicaci\u00f3n. </p> <p>Lo primero ser\u00e1 crear una carpeta llamada <code>context</code> dentro de la carpeta <code>src</code> de nuestro proyecto y dentro de esta crearemos un nuevo fichero llamado <code>LoaderProvider.tsx</code> con el siguiente contenido:</p> <pre><code>import { createContext, useState } from \"react\";\nimport Backdrop from \"@mui/material/Backdrop\";\nimport CircularProgress from \"@mui/material/CircularProgress\";\n\nexport const LoaderContext = createContext({\n  loading: false,\n  showLoading: (_show: boolean) =&gt; {},\n});\n\ntype Props = {\n  children: JSX.Element;\n};\n\nexport const LoaderProvider = ({ children }: Props) =&gt; {\n  const showLoading = (show: boolean) =&gt; {\n    setState((prev) =&gt; ({\n      ...prev,\n      loading: show,\n    }));\n  };\n\n  const [state, setState] = useState({\n    loading: false,\n    showLoading,\n  });\n\n  return (\n    &lt;LoaderContext.Provider value={state}&gt;\n      &lt;Backdrop\n        sx={{ color: \"#fff\", zIndex: (theme) =&gt; theme.zIndex.drawer + 1 }}\n        open={state.loading}\n      &gt;\n        &lt;CircularProgress color=\"inherit\" /&gt;\n      &lt;/Backdrop&gt;\n\n      {children}\n    &lt;/LoaderContext.Provider&gt;\n  );\n};\n</code></pre> <p>Y ahora modificamos nuestro fichero <code>App.tsx</code> de la siguiente manera:</p> <pre><code>import { LoaderProvider } from \"./context/LoaderProvider\";\n    &lt;LoaderProvider&gt;\n      &lt;Provider store={store}&gt;\n        &lt;BrowserRouter&gt;\n          &lt;Routes&gt;\n            &lt;Route element={&lt;Layout /&gt;}&gt;\n              &lt;Route index path=\"games\" element={&lt;Game /&gt;} /&gt;\n              &lt;Route path=\"categories\" element={&lt;Category /&gt;} /&gt;\n              &lt;Route path=\"authors\" element={&lt;Author /&gt;} /&gt;\n              &lt;Route path=\"*\" element={&lt;Navigate to=\"/games\" /&gt;} /&gt;\n            &lt;/Route&gt;\n          &lt;/Routes&gt;\n        &lt;/BrowserRouter&gt;\n      &lt;/Provider&gt;\n    &lt;/LoaderProvider&gt;\n</code></pre> <p>Lo que hemos hecho ha sido envolver toda nuestra aplicaci\u00f3n dentro de nuestro <code>provider</code> de tal modo que esta el <code>children</code> en el fichero <code>LoaderProvider</code>, pero ahora y gracias a la funcionalidad de <code>createContext</code> la variable <code>loading</code> y el m\u00e9todo <code>showLoading</code> estar\u00e1n disponibles en todos los sitios de nuestra aplicaci\u00f3n.</p> <p>Ahora para hacer uso de esta funcionalidad nos vamos a nuestra pagina de <code>Categorias</code> e importamos lo siguiente:</p> <pre><code>import { useState, useEffect, useContext  } from \"react\";\n\nimport { LoaderContext } from \"../../context/LoaderProvider\";\n</code></pre> <p>Declaramos una nueva constante:</p> <pre><code>const loader = useContext(LoaderContext);\n</code></pre> <p>Podemos hace uso del m\u00e9todo <code>showLoading</code> donde queramos, en nuestro caso vamos a crear otro <code>useEffect</code> que estar\u00e1 pendiente de los cambios en cualquiera de los <code>loadings</code>:</p> <pre><code>useEffect(() =&gt; {\n    loader.showLoading(\n      isLoadingCreate || isLoading || isLoadingDelete || isLoadingUpdate\n    );\n  }, [isLoadingCreate, isLoading, isLoadingDelete, isLoadingUpdate]);\n</code></pre> <p>Probamos la aplicaci\u00f3n y vemos que cuando se carga el listado o realizamos cualquier llamada al back se muestra brevemente nuestro <code>loader</code>.</p>"},{"location":"develop/basic/springboot/","title":"Listado simple - Spring Boot","text":"<p>Ahora que ya tenemos listo el proyecto backend de Spring Boot (en el puerto 8080) ya podemos empezar a codificar la soluci\u00f3n.</p>"},{"location":"develop/basic/springboot/#primeros-pasos","title":"Primeros pasos","text":"<p>Antes de empezar</p> <p>Quiero hacer hincapi\u00e9 en Spring Boot tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. Tanto la propia web de Spring como en el portal de tutoriales de Baeldung puedes buscar casi cualquier ejemplo que necesites.</p>"},{"location":"develop/basic/springboot/#estructurar-el-codigo","title":"Estructurar el c\u00f3digo","text":"<p>Vamos a hacer un breve refresco de la estructura del c\u00f3digo que ya se ha visto en puntos anteriores.</p> <p>Las clases deben estar agrupadas por \u00e1mbito funcional, en nuestro caso como vamos a hacer la funcionalidad de <code>Categor\u00edas</code> pues deber\u00eda estar todo dentro de un package del tipo <code>com.ccsw.tutorial.category</code>.</p> <p>Adem\u00e1s, deber\u00edamos aplicar la separaci\u00f3n por capas como ya se vi\u00f3 en el esquema:</p> <p></p> <p>La primera capa, la de <code>Controlador</code>, se encargar\u00e1 de procesar las peticiones y transformar datos. Esta capa llamar\u00e1 a la capa de <code>L\u00f3gica</code> de negocio que ejecutar\u00e1 las operaciones, ayud\u00e1ndose de otros objetos de esa misma capa de <code>L\u00f3gica</code> o bien de llamadas a datos a trav\u00e9s de la capa de <code>Acceso a Datos</code></p> <p>Ahora s\u00ed, vamos a programar!.</p>"},{"location":"develop/basic/springboot/#capa-de-operaciones-controller","title":"Capa de operaciones: Controller","text":"<p>En esta capa es donde se definen las operaciones que pueden ser consumidas por los clientes. Se caracterizan por estar anotadas con las anotaciones @Controller o @RestController y por las anotaciones @RequestMapping que nos permiten definir las rutas de acceso.</p> <p>Recomendaci\u00f3n: Breve detalle REST</p> <p>Antes de continuar te recomiendo encarecidamente que leas el Anexo: Detalle REST donde se explica brevemente como estructurar los servicios REST que veremos a continuaci\u00f3n.</p>"},{"location":"develop/basic/springboot/#controller-de-ejemplo","title":"Controller de ejemplo","text":"<p>Vamos a crear una clase <code>CategoryController.java</code> dentro del package <code>com.ccsw.tutorial.category</code> para definir las rutas de las operaciones.</p> CategoryController.java <pre><code>package com.ccsw.tutorial.category;\n\nimport java.util.List;\n\nimport org.springframework.web.bind.annotation.CrossOrigin;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport io.swagger.v3.oas.annotations.tags.Tag;\n\n/**\n * @author ccsw\n * \n */\n@Tag(name = \"Category\", description = \"API of Category\")\n@RequestMapping(value = \"/category\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class CategoryController {\n\n    /**\n     * M\u00e9todo para probar el servicio\n     * \n     */\n    @RequestMapping(path = \"\", method = RequestMethod.GET)\n    public String prueba() {\n\n        return \"Probando el Controller\";\n    }\n\n}\n</code></pre> <p>Ahora si arrancamos la aplicaci\u00f3n server, abrimos el Postman y creamos una petici\u00f3n GET a la url http://localhost:8080/category nos responder\u00e1 con el mensaje que hemos programado.</p>"},{"location":"develop/basic/springboot/#implementar-operaciones","title":"Implementar operaciones","text":"<p>Ahora que ya tenemos un controlador y una operaci\u00f3n de negocio ficticia, vamos a borrarla y a\u00f1adir las operaciones reales que consumir\u00e1 nuestra pantalla. Deberemos a\u00f1adir una operaci\u00f3n para listar, una para actualizar, una para guardar y una para borrar. Aunque para hacerlo m\u00e1s c\u00f3modo, utilizaremos la misma operaci\u00f3n para guardar y para actualizar. Adem\u00e1s, no vamos a trabajar directamente con datos simples, sino que usaremos objetos para recibir informaci\u00f3n y para enviar informaci\u00f3n.</p> <p>Estos objetos t\u00edpicamente se denominan DTO (Data Transfer Object) y nos sirven justamente para encapsular informaci\u00f3n que queremos transportar. En realidad no son m\u00e1s que clases pojo sencillas con propiedades, getters y setters. </p> <p>Para nuestro ejemplo crearemos una clase <code>CategoryDto</code> dentro del package <code>com.ccsw.tutorial.category.model</code> con el siguiente contenido:</p> CategoryDto.java <pre><code>package com.ccsw.tutorial.category.model;\n\n/**\n * @author ccsw\n * \n */\npublic class CategoryDto {\n\n    private Long id;\n\n    private String name;\n\n    /**\n     * @return id\n     */\n    public Long getId() {\n\n        return this.id;\n    }\n\n    /**\n     * @param id new value of {@link #getId}.\n     */\n    public void setId(Long id) {\n\n        this.id = id;\n    }\n\n    /**\n     * @return name\n     */\n    public String getName() {\n\n        return this.name;\n    }\n\n    /**\n     * @param name new value of {@link #getName}.\n     */\n    public void setName(String name) {\n\n        this.name = name;\n    }\n\n}\n</code></pre> <p>A continuaci\u00f3n utilizaremos esta clase en nuestro Controller para implementar las tres operaciones de negocio.</p> CategoryController.java <pre><code>package com.ccsw.tutorial.category;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.springframework.web.bind.annotation.CrossOrigin;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.ccsw.tutorial.category.model.CategoryDto;\n\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\n\n/**\n * @author ccsw\n * \n */\n@Tag(name = \"Category\", description = \"API of Category\")\n@RequestMapping(value = \"/category\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class CategoryController {\n\n    private long SEQUENCE = 1;\n    private Map&lt;Long, CategoryDto&gt; categories = new HashMap&lt;Long, CategoryDto&gt;();\n\n    /**\n     * M\u00e9todo para recuperar todas las categorias\n     *\n     * @return {@link List} de {@link CategoryDto}\n     */\n    @Operation(summary = \"Find\", description = \"Method that return a list of Categories\")\n    @RequestMapping(path = \"\", method = RequestMethod.GET)\n    public List&lt;CategoryDto&gt; findAll() {\n\n        return new ArrayList&lt;CategoryDto&gt;(this.categories.values());\n    }\n\n    /**\n     * M\u00e9todo para crear o actualizar una categoria\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    @Operation(summary = \"Save or Update\", description = \"Method that saves or updates a Category\")\n    @RequestMapping(path = { \"\", \"/{id}\" }, method = RequestMethod.PUT)\n    public void save(@PathVariable(name = \"id\", required = false) Long id, @RequestBody CategoryDto dto) {\n\n        CategoryDto category;\n\n        if (id == null) {\n            category = new CategoryDto();\n            category.setId(this.SEQUENCE++);\n            this.categories.put(category.getId(), category);\n        } else {\n            category = this.categories.get(id);\n        }\n\n        category.setName(dto.getName());\n    }\n\n    /**\n     * M\u00e9todo para borrar una categoria\n     *\n     * @param id PK de la entidad\n     */\n    @Operation(summary = \"Delete\", description = \"Method that deletes a Category\")\n    @RequestMapping(path = \"/{id}\", method = RequestMethod.DELETE)\n    public void delete(@PathVariable(\"id\") Long id) {\n\n        this.categories.remove(id);\n    }\n}\n</code></pre> <p>Como todav\u00eda no tenemos acceso a BD, hemos creado una variable tipo HashMap y una variable Long, que simular\u00e1n una BD y una secuencia. Tambi\u00e9n hemos implementado tres operaciones GET, PUT y DELETE que realizan las acciones necesarias por nuestra pantalla. Ahora podr\u00edamos probarlo desde el Postman con cuatro ejemplo sencillos.</p> <p>F\u00edjate que el m\u00e9todo <code>save</code> tiene dos rutas. La ruta normal <code>category/</code> y la ruta informada <code>category/1</code>. Esto es porque hemos juntado la acci\u00f3n create y update en un mismo m\u00e9todo para facilitar el desarrollo. Es totalmente v\u00e1lido y funcional.</p> <p>Atenci\u00f3n</p> <p>Los datos que se reciben pueden venir informados como un par\u00e1metro en la URL Get, como una variable en el propio path o dentro del body de la petici\u00f3n. Cada uno de ellos se recupera con una anotaci\u00f3n especial: <code>@RequestParam</code>, <code>@PathVariable</code> y <code>@RequestBody</code> respectivamente.</p> <p>Como no tenemos ning\u00fan dato dado de alta, podemos probar en primer lugar a realizar una inserci\u00f3n de datos con el m\u00e9todo PUT.</p> <p>PUT /category nos sirve para insertar <code>Categor\u00edas</code> nuevas (si no tienen el id informado) o para actualizar <code>Categor\u00edas</code> (si tienen el id informado). F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no env\u00edas datos, te dar\u00e1 un error.</p> <p></p> <p></p> <p>GET /category nos devuelve un listado de <code>Categor\u00edas</code>, siempre que hayamos insertado algo antes.</p> <p></p> <p>DELETE /category nos sirve eliminar <code>Categor\u00edas</code>. F\u00edjate que el dato del ID que se env\u00eda est\u00e1 en el path.</p> <p></p> <p>Prueba a jugar borrando categor\u00edas que no existen o modificando categor\u00edas que no existen. Tal y como est\u00e1 programado, el borrado no dar\u00e1 error, pero la modificaci\u00f3n deber\u00eda dar un NullPointerException al no existir el dato a modificar.</p>"},{"location":"develop/basic/springboot/#documentacion-openapi","title":"Documentaci\u00f3n (OpenAPI)","text":"<p>Si te acuerdas, en el punto de <code>Entorno de desarrollo</code>, a\u00f1adimos el m\u00f3dulo de OpenAPI a nuestro proyecto, y en el desarrollo de nuestro <code>Controller</code> hemos anotado tanto la clase como los m\u00e9todos con sus correspondientes etiquetas <code>@Tag</code> y <code>@Operation</code>. </p> <p>Esto nos va a ayudar a generar documentaci\u00f3n autom\u00e1tica de nuestras APIs haciendo que nuestro c\u00f3digo sea m\u00e1s mantenible y nuestra documentaci\u00f3n mucho m\u00e1s fiable.</p> <p>Para ver el resultado, con el proyecto arrancado nos dirigimos a la ruta por defecto de OpenAPI: http://localhost:8080/swagger-ui/index.html</p> <p>Aqu\u00ed podemos observar el cat\u00e1logo de endpoints generados, ver los tipos de entrada y salida e incluso realizar peticiones a los mismos. Este ser\u00e1 el contrato de nuestros endpoints, que nos ayudar\u00e1 a integrarnos con el equipo frontend (en el caso del tutorial seguramente seremos nosotros mismos).</p>"},{"location":"develop/basic/springboot/#aspectos-importantes","title":"Aspectos importantes","text":"<p>Los aspectos importantes de la capa <code>Controller</code> son:</p> <ul> <li>La clase debe estar anotada con <code>@Controller</code> o <code>@RestController</code>. Mejor usar la \u00faltima anotaci\u00f3n, ya que est\u00e1s diciendo que las operaciones son de tipo Rest y no har\u00e1 falta configurar nada</li> <li>La ruta general al controlador se define con el <code>@RequestMapping</code> global de la clase, aunque tambi\u00e9n se puede obviar esta anotaci\u00f3n y a\u00f1adir a cada una de las operaciones la ruta ra\u00edz.</li> <li>Los m\u00e9todos que queramos exponer como operaciones deben ir anotados tambi\u00e9n con <code>@RequestMapping</code> con la info:<ul> <li><code>path</code> \u2192 Que nos permite definir un path para la operaci\u00f3n, siempre sum\u00e1ndole el path de la clase (si es que tuviera)</li> <li><code>method</code> \u2192 Que nos permite definir el verbo de http que vamos a atender. Podemos tener el mismo path con diferente method, sin problema. Por lo general utilizaremos:<ul> <li>GET \u2192 Generalmente se usa para recuperar informaci\u00f3n</li> <li>POST \u2192 Se utiliza para hacer update y filtrados complejos de informaci\u00f3n</li> <li>PUT \u2192 Se utiliza para hacer save de informaci\u00f3n</li> <li>DELETE \u2192 Se utiliza para hacer borrados de informaci\u00f3n</li> </ul> </li> </ul> </li> </ul>"},{"location":"develop/basic/springboot/#capa-de-servicio-service","title":"Capa de Servicio: Service","text":"<p>Pero en realidad la cosa no funciona as\u00ed. Hemos implementado parte de la l\u00f3gica de negocio (las operaciones/acciones de guardado, borrado y listado) dentro de lo que ser\u00eda la capa de operaciones o servicios al cliente. Esta capa no debe ejecutar l\u00f3gica de negocio, tan solo debe hacer transformaciones de datos y enrutar peticiones, toda la l\u00f3gica deber\u00eda ir en la capa de servicio.</p>"},{"location":"develop/basic/springboot/#implementar-servicios","title":"Implementar servicios","text":"<p>Pues vamos a arreglarlo. Vamos a crear un servicio y vamos a mover la l\u00f3gica de negocio al servicio.</p> CategoryService.javaCategoryServiceImpl.javaCategoryController.java <pre><code>package com.ccsw.tutorial.category;\n\nimport com.ccsw.tutorial.category.model.CategoryDto;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n * \n */\npublic interface CategoryService {\n\n    /**\n     * M\u00e9todo para recuperar todas las categor\u00edas\n     *\n     * @return {@link List} de {@link Category}\n     */\n    List&lt;CategoryDto&gt; findAll();\n\n    /**\n     * M\u00e9todo para crear o actualizar una categor\u00eda\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    void save(Long id, CategoryDto dto);\n\n    /**\n     * M\u00e9todo para borrar una categor\u00eda\n     *\n     * @param id PK de la entidad\n     */\n    void delete(Long id);\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.category;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.springframework.stereotype.Service;\n\nimport com.ccsw.tutorial.category.model.CategoryDto;\n\n/**\n * @author ccsw\n *\n */\n@Service\npublic class CategoryServiceImpl implements CategoryService {\n\n    private long SEQUENCE = 1;\n    private Map&lt;Long, CategoryDto&gt; categories = new HashMap&lt;Long, CategoryDto&gt;();\n\n    /**\n     * {@inheritDoc}\n     */\n    public List&lt;CategoryDto&gt; findAll() {\n\n        return new ArrayList&lt;CategoryDto&gt;(this.categories.values());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void save(Long id, CategoryDto dto) {\n\n        CategoryDto category;\n\n        if (id == null) {\n            category = new CategoryDto();\n            category.setId(this.SEQUENCE++);\n            this.categories.put(category.getId(), category);\n        } else {\n            category = this.categories.get(id);\n        }\n\n        category.setName(dto.getName());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void delete(Long id) {\n\n        this.categories.remove(id);\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.category;\n\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.CrossOrigin;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.ccsw.tutorial.category.model.CategoryDto;\n\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\n\n/**\n * @author ccsw\n * \n */\n@Tag(name = \"Category\", description = \"API of Category\")\n@RequestMapping(value = \"/category\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class CategoryController {\n\n    @Autowired\n    private CategoryService categoryService;\n\n    /**\n     * M\u00e9todo para recuperar todas las categorias\n     *\n     * @return {@link List} de {@link CategoryDto}\n     */\n    @Operation(summary = \"Find\", description = \"Method that return a list of Categories\")\n    @RequestMapping(path = \"\", method = RequestMethod.GET)\n    public List&lt;CategoryDto&gt; findAll() {\n\n        return this.categoryService.findAll();\n    }\n\n    /**\n     * M\u00e9todo para crear o actualizar una categoria\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    @Operation(summary = \"Save or Update\", description = \"Method that saves or updates a Category\")\n    @RequestMapping(path = { \"\", \"/{id}\" }, method = RequestMethod.PUT)\n    public void save(@PathVariable(name = \"id\", required = false) Long id, @RequestBody CategoryDto dto) {\n\n        this.categoryService.save(id, dto);\n    }\n\n    /**\n     * M\u00e9todo para borrar una categoria\n     *\n     * @param id PK de la entidad\n     */\n    @Operation(summary = \"Delete\", description = \"Method that deletes a Category\")\n    @RequestMapping(path = \"/{id}\", method = RequestMethod.DELETE)\n    public void delete(@PathVariable(\"id\") Long id) {\n\n        this.categoryService.delete(id);\n    }\n}\n</code></pre> <p>Ahora ya tenemos bien estructurado nuestro proyecto. Ya tenemos las dos capas necesarias Controladores y Servicios y cada uno se encarga de llevar a cabo su cometido de forma correcta.</p>"},{"location":"develop/basic/springboot/#aspectos-importantes_1","title":"Aspectos importantes","text":"<p>Los aspectos importantes de la capa <code>Service</code> son:</p> <ul> <li>Toda la l\u00f3gica de negocio, operaciones y dem\u00e1s debe estar implementada en los servicios. Los controladores simplemente invocan servicios y transforman ciertos datos.</li> <li>Es buena pr\u00e1ctica que la capa de servicios se implemente usando el patr\u00f3n fachada, esto quiere decir que necesitamos tener una Interface y al menos una implementaci\u00f3n de esa Interface. Y siempre debemos interactuar con la Interface. Esto nos permitir\u00e1 a futuro poder sustituir la implementaci\u00f3n por otra diferente sin que el resto del c\u00f3digo se vea afectado. Especialmente \u00fatil cuando queremos mockear comportamientos en tests.</li> <li>La capa de servicio puede invocar a otros servicios en sus operaciones, pero nunca debe invocar a un controlador.</li> <li>Para crear un servicio se debe anotar mediante <code>@Service</code> y adem\u00e1s debe implementar la Interface del servicio. Un error muy com\u00fan al arrancar un proyecto y ver que no funcionan las llamadas, es porqu\u00e9 no existe la anotaci\u00f3n <code>@Service</code> o porqu\u00e9 no se ha implementado la Interface.</li> <li>La forma de <code>inyectar</code> y utilizar componentes manejados por Spring Boot es mediante la anotaci\u00f3n <code>@Autowired</code>. NO intentes crear un objeto de CategoryServiceImpl, ni hacer un <code>new</code>, ya que no estar\u00e1 manejado por Springboot y dar\u00e1 fallos de NullPointer. Lo mejor es dejar que Spring Boot lo gestione y utilizar las inyecciones de dependencias.</li> </ul>"},{"location":"develop/basic/springboot/#capa-de-datos-repository","title":"Capa de Datos: Repository","text":"<p>Pero no siempre vamos a acceder a los datos mediante un HasMap en memoria. En algunas ocasiones queremos que nuestro proyecto acceda a un servicio de datos como puede ser una BBDD, un servicio externo, un acceso a disco, etc. Estos accesos se deben hacer desde la capa de acceso a datos, y en concreto para nuestro ejemplo, lo haremos a trav\u00e9s de un Repository para que acceda a una BBDD.</p> <p>Para el tutorial no necesitamos configurar una BBDD externa ni complicarnos demasiado. Vamos a utilizar una librer\u00eda muy \u00fatil llamada <code>H2</code> que nos permite levantar una BBDD en memoria persistiendo los datos en memoria o en disco, de hecho ya la configuramos en el apartado de <code>Entorno de desarrollo</code>.</p>"},{"location":"develop/basic/springboot/#implementar-entity","title":"Implementar Entity","text":"<p>Lo primero que haremos ser\u00e1 crear nuestra entity con la que vamos a persistir y recuperar informaci\u00f3n. Las entidades igual que los DTOs deber\u00edan estar agrupados dentro del package <code>model</code> de cada funcionalidad, as\u00ed que vamos a crear una nueva clase java.</p> Category.java <pre><code>package com.ccsw.tutorial.category.model;\n\nimport jakarta.persistence.*;\n\n/**\n * @author ccsw\n * \n */\n@Entity\n@Table(name = \"category\")\npublic class Category {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\", nullable = false)\n    private Long id;\n\n    @Column(name = \"name\", nullable = false)\n    private String name;\n\n    /**\n     * @return id\n     */\n    public Long getId() {\n\n        return this.id;\n    }\n\n    /**\n     * @param id new value of {@link #getId}.\n     */\n    public void setId(Long id) {\n\n        this.id = id;\n    }\n\n    /**\n     * @return name\n     */\n    public String getName() {\n\n        return this.name;\n    }\n\n    /**\n     * @param name new value of {@link #getName}.\n     */\n    public void setName(String name) {\n\n        this.name = name;\n    }\n\n}\n</code></pre> <p>Si te fijas, la Entity suele ser muy similar a un DTO, tiene unas propiedades y sus getters y setters. Pero a diferencia de los DTOs, esta clase tiene una serie de anotaciones que permiten a JPA hacer su magia y generar consultas SQL a la BBDD. En este ejemplo vemos 4 anotaciones importantes:</p> <ul> <li><code>@Entity</code> \u2192 Le indica a Springboot que se trata de una clase que implementa una Entidad de BBDD. Sin esta anotaci\u00f3n no es posible hacer queries.</li> <li><code>@Table</code> \u2192 Le indica a JPA el nombre y el schema de la tabla que representa esta clase. Por claridad se deber\u00eda poner siempre, aunque si el nombre de la tabla es igual al nombre de la clase no es necesaria la anotaci\u00f3n.</li> <li><code>@Id</code> y <code>@GeneratedValue</code> \u2192 Le indica a JPA que esta propiedad es la que mapea una Primary Key y adem\u00e1s que esta PK se genera con la estrategia que se le indique en la anotaci\u00f3n <code>@GeneratedValue</code>, que puede ser:<ul> <li>Generaci\u00f3n de PK por <code>Secuence</code>, la que utiliza Oracle, en este caso habr\u00e1 que indicarle un nombre de secuencia.</li> <li>Generaci\u00f3n de PK por <code>Indentity</code>, la que utiliza MySql o SQLServer, el auto-incremental. </li> <li>Generaci\u00f3n de PK por <code>Table</code>, en algunas BBDD se permite tener una tabla donde se almacenan como registros todas las secuencias.</li> <li>Generaci\u00f3n de PK <code>Auto</code>, elige la mejor estrategia en funci\u00f3n de la BBDD que hemos seleccionado.</li> </ul> </li> <li><code>@Column</code> \u2192 Le indica a JPA que esta propiedad mapea una columna de la tabla y le especifica el nombre de la columna. Al igual que la anotaci\u00f3nd de <code>Table</code>, esta anotaci\u00f3n no es necesaria aunque si es muy recomendable. Por claridad se deber\u00eda poner siempre, aunque si el nombre de la columna es igual al nombre de la propiedad no es necesaria la anotaci\u00f3n.</li> </ul> <p>Hay muchas otras anotaciones, pero estas son las b\u00e1sicas, ya ir\u00e1s aprendiendo otras.</p> <p>Consejo</p> <p>Para definir las PK de las tablas, intenta evitar una PK compuesta de m\u00e1s de una columna. La programaci\u00f3n se hace muy compleja y las magias que hace JPA en la oscuridad se complican mucho. Mi recomendaci\u00f3n es que siempre utilices una PK n\u00famerica, en la medida de lo posible, y si es necesario, crees \u00edndices compuestos de b\u00fasqueda o checks compuestos para evitar duplicidades.</p>"},{"location":"develop/basic/springboot/#juego-de-datos-de-bbdd","title":"Juego de datos de BBDD","text":"<p>Spring Boot autom\u00e1ticamente cuando arranque el proyecto escaner\u00e1 todas las <code>@Entity</code> y crear\u00e1 las estructuras de las tablas en la BBDD en memoria, gracias a las anotaciones que hemos puesto.  Adem\u00e1s de esto, lanzar\u00e1 los scripts de construcci\u00f3n de BBDD que tenemos en la carpeta <code>src/main/resources/</code>. As\u00ed que, teniendo clara la estructura de la <code>Entity</code> podemos configurar los ficheros con los juegos de datos que queramos, y para ello vamos a utilizar el fichero <code>data.sql</code> que creamos en su momento. </p> <p>Sabemos que la tabla se llamar\u00e1 <code>category</code> y que tendr\u00e1 dos columnas, una columna <code>id</code>, que ser\u00e1 la PK autom\u00e1tica, y una columna <code>name</code>. Podemos escribir el siguiente script para rellenar datos:</p> data.sql <pre><code>INSERT INTO category(name) VALUES ('Eurogames');\nINSERT INTO category(name) VALUES ('Ameritrash');\nINSERT INTO category(name) VALUES ('Familiar');\n</code></pre>"},{"location":"develop/basic/springboot/#implementar-repository","title":"Implementar Repository","text":"<p>Ahora que ya tenemos el juego de datos y la entidad implementada, vamos a ver como acceder a BBDD desde Java. Esto lo haremos con un <code>Repository</code>. Existen varias formas de utilizar los repositories, desde el todo autom\u00e1tico y magia de JPA hasta el repositorio manual en el que hay que codificar todo. En el tutorial voy a explicar varias formas de implementarlo para este CRUD y los siguientes CRUDs.</p> <p>Como ya se dijo en puntos anteriores, el acceso a datos se debe hacer siempre a trav\u00e9s de un <code>Repository</code>, as\u00ed que vamos a implementar uno. En esta capa, al igual que pasaba con los services, es recomendable utilizar el patr\u00f3n fachada, para poder sustituir implementaciones sin afectar al c\u00f3digo.</p> CategoryRepository.java <pre><code>package com.ccsw.tutorial.category;\n\nimport com.ccsw.tutorial.category.model.Category;\nimport org.springframework.data.repository.CrudRepository;\n\n/**\n * @author ccsw\n *\n */\npublic interface CategoryRepository extends CrudRepository&lt;Category, Long&gt; {\n\n}\n</code></pre> <p>\u00bfQu\u00e9 te parece?, sencillo, \u00bfno?. Spring ya tiene una implementaci\u00f3n por defecto de un CrudRepository, tan solo tenemos que crear una interface que extienda de la interface <code>CrudRepository</code> pas\u00e1ndole como tipos la <code>Entity</code> y el tipo de la Primary Key. Con eso Spring construye el resto y nos provee de los m\u00e9todos t\u00edpicos y necesarios para un CRUD.</p> <p>Ahora vamos a utilizarla en \u00e9l <code>Service</code>, pero hay un problema. \u00c9l <code>Repository</code> devuelve un objeto tipo <code>Category</code> y \u00e9l <code>Service</code> y <code>Controller</code> devuelven un objeto tipo <code>CategoryDto</code>. Esto es porque en cada capa se debe con un \u00e1mbito de modelos diferente. Podr\u00edamos hacer que todo el back trabajara con <code>Category</code> que son entidades de persistencia, pero no es lo correcto y nos podr\u00eda llevar a cometer errores, o modificar el objeto y que sin que nosotros lo orden\u00e1semos se persistiera ese cambio en BBDD.</p> <p>El \u00e1mbito de trabajo de las capas con el que solemos trabajar y est\u00e1 m\u00e1s extendido es el siguiente:</p> <p></p> <ul> <li>Los datos que vienen y van al cliente, deber\u00edan ser en la mayor\u00eda de los casos datos en formato json</li> <li>Al entrar en un <code>Controller</code> esos datos json se transforman en un DTO. Al salir del <code>Controller</code> hacia el cliente, esos DTOs se transforman en formato json. Estas conversiones son autom\u00e1ticas, las hace Springboot (en realidad las hace la librer\u00eda de jackson codehaus).</li> <li>Cuando un <code>Controller</code> ejecuta una llamada a un <code>Service</code>, generalmente le pasa sus datos en DTO, y el <code>Service</code> se encarga de transformar esto a una <code>Entity</code>. A la inversa, cuando un <code>Service</code> responde a un <code>Controller</code>, \u00e9l responde con una <code>Entity</code> y el <code>Controller</code> ya se encargar\u00e1 de transformarlo a DTO.</li> <li>Por \u00faltimo, para los <code>Repository</code>, siempre se trabaja de entrada y salida con objetos tipo <code>Entity</code></li> </ul> <p>Parece un l\u00edo, pero ya ver\u00e1s como es muy sencillo ahora que veremos el ejemplo. Una \u00faltima cosa, para hacer esas transformaciones, las podemos hacer a mano usando getters y setters o bien utilizar el objeto <code>DozerBeanMapper</code> que hemos configurado al principio.</p> <p>El c\u00f3digo deber\u00eda quedar as\u00ed:</p> CategoryServiceImpl.javaCategoryService.javaCategoryController.java <pre><code>package com.ccsw.tutorial.category;\n\nimport com.ccsw.tutorial.category.model.Category;\nimport com.ccsw.tutorial.category.model.CategoryDto;\nimport jakarta.transaction.Transactional;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Service\n@Transactional\npublic class CategoryServiceImpl implements CategoryService {\n\n    @Autowired\n    CategoryRepository categoryRepository;\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public List&lt;Category&gt; findAll() {\n\n          return (List&lt;Category&gt;) this.categoryRepository.findAll();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void save(Long id, CategoryDto dto) {\n\n          Category category;\n\n          if (id == null) {\n             category = new Category();\n          } else {\n             category = this.categoryRepository.findById(id).orElse(null);\n          }\n\n          category.setName(dto.getName());\n\n          this.categoryRepository.save(category);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void delete(Long id) throws Exception {\n\n          if(this.categoryRepository.findById(id).orElse(null) == null){\n             throw new Exception(\"Not exists\");\n          }\n\n          this.categoryRepository.deleteById(id);\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.category;\n\nimport com.ccsw.tutorial.category.model.Category;\nimport com.ccsw.tutorial.category.model.CategoryDto;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n * \n */\npublic interface CategoryService {\n\n    /**\n     * M\u00e9todo para recuperar todas las {@link Category}\n     *\n     * @return {@link List} de {@link Category}\n     */\n    List&lt;Category&gt; findAll();\n\n    /**\n     * M\u00e9todo para crear o actualizar una {@link Category}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    void save(Long id, CategoryDto dto);\n\n    /**\n     * M\u00e9todo para borrar una {@link Category}\n     *\n     * @param id PK de la entidad\n     */\n    void delete(Long id) throws Exception;\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.category;\n\nimport com.ccsw.tutorial.category.model.Category;\nimport com.ccsw.tutorial.category.model.CategoryDto;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport org.modelmapper.ModelMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * @author ccsw\n *\n */\n@Tag(name = \"Category\", description = \"API of Category\")\n@RequestMapping(value = \"/category\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class CategoryController {\n\n    @Autowired\n    CategoryService categoryService;\n\n    @Autowired\n    ModelMapper mapper;\n\n    /**\n     * M\u00e9todo para recuperar todas las {@link Category}\n     *\n     * @return {@link List} de {@link CategoryDto}\n     */\n    @Operation(summary = \"Find\", description = \"Method that return a list of Categories\"\n    )\n    @RequestMapping(path = \"\", method = RequestMethod.GET)\n    public List&lt;CategoryDto&gt; findAll() {\n\n        List&lt;Category&gt; categories = this.categoryService.findAll();\n\n        return categories.stream().map(e -&gt; mapper.map(e, CategoryDto.class)).collect(Collectors.toList());\n    }\n\n    /**\n     * M\u00e9todo para crear o actualizar una {@link Category}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    @Operation(summary = \"Save or Update\", description = \"Method that saves or updates a Category\"\n    )\n    @RequestMapping(path = { \"\", \"/{id}\" }, method = RequestMethod.PUT)\n    public void save(@PathVariable(name = \"id\", required = false) Long id, @RequestBody CategoryDto dto) {\n\n        this.categoryService.save(id, dto);\n    }\n\n    /**\n     * M\u00e9todo para borrar una {@link Category}\n     *\n     * @param id PK de la entidad\n     */\n    @Operation(summary = \"Delete\", description = \"Method that deletes a Category\")\n    @RequestMapping(path = \"/{id}\", method = RequestMethod.DELETE)\n    public void delete(@PathVariable(\"id\") Long id) throws Exception {\n\n        this.categoryService.delete(id);\n    }\n\n}\n</code></pre> <p>El <code>Service</code> no tiene nada raro, simplemente accede al <code>Repository</code> (siempre anotado como <code>@Autowired</code>) y recupera datos o los guarda. F\u00edjate en el caso especial del save que la \u00fanica diferencia es que en un caso tendr\u00e1 <code>id != null</code> y por tanto internamente har\u00e1 un update, y en otro caso tendr\u00e1 <code>id == null</code> y por tanto internamente har\u00e1 un save.</p> <p>En cuanto a la interface, lo \u00fanico que cambiamos fue los objetos de respuesta, que ahora pasan a ser de tipo <code>Category</code>. Los de entrada se mantienen como <code>CategoryDto</code>.</p> <p>Por \u00faltimo, en \u00e9l <code>Controller</code> se puede ver como se utiliza el conversor de <code>DozerBeanMapper</code> (siempre anotado como <code>@Autowired</code>), que permite traducir una lista a un tipo concreto, o un objeto \u00fanico a un tipo concreto. La forma de hacer estas conversiones siempre es por nombre de propiedad. Las propiedades del objeto destino se deben llamar igual que las propiedades del objeto origen. En caso contrario se quedar\u00e1n a null.</p> <p>Ojo con el mapeo</p> <p>Ojo a esta \u00faltima frase, debe quedar meridianamente claro. La forma de mapear de un objeto origen a un objeto destino siempre es a trav\u00e9s del nombre. Los getters del origen deben ser iguales a los getters del destino. Si hay una letra diferente o unas may\u00fasculas o min\u00fasculas diferentes NO realizar\u00e1 el mapeo y se quedar\u00e1 la propiedad a null.</p> <p>Para terminar, cuando queramos realizar un mapeo masivo de los diferentes registros, tenemos que itulizar la API Stream de Java, que nos proporciona una forma sencilla de realizar estas operativas, sobre colecciones de elementos, mediante el uso del m\u00e9todo intermedio <code>map</code> y el reductor por defecto para listas. Te recomiendo echarle un ojo a la teor\u00eda de Introducci\u00f3n a API Java Streams.</p> <p>BBDD</p> <p>Si quires ver el contenido de la base de datos puedes acceder a un IDE web autopublicado por H2 en la ruta <code>http://localhost:8080/h2-console</code></p>"},{"location":"develop/basic/springboot/#aspectos-importantes_2","title":"Aspectos importantes","text":"<p>Los aspectos importantes de la capa <code>Repository</code> son:</p> <ul> <li>Al igual que los <code>Service</code>, se debe utilizar el patr\u00f3n fachada, por lo que tendremos una Interface y posiblemente una implementaci\u00f3n.</li> <li>A menudo la implementaci\u00f3n la hace internamente Spring Boot, pero hay veces que podemos hacer una implementaci\u00f3n manual. Lo veremos en siguientes puntos.</li> <li>Los <code>Repository</code> trabajan siempre con <code>Entity</code> que no son m\u00e1s que mapeos de una tabla o de una vista que existe en BBDD.</li> <li>Los <code>Repository</code> no contienen l\u00f3gica de negocio, ni transformaciones, simplemente acceder a datos, persisten o devuelven informaci\u00f3n.</li> <li>Los <code>Repository</code> JAM\u00c1S deben llamar a otros <code>Repository</code> ni <code>Service</code>.</li> <li>Intenta que tus clases <code>Entity</code> sean lo m\u00e1s sencillas posible, sobre todo en cuanto a Primary Keys, se simplificar\u00e1 mucho el desarrollo.</li> </ul>"},{"location":"develop/basic/springboot/#capa-de-testing-tdd","title":"Capa de Testing: TDD","text":"<p>Por \u00faltimo y aunque no deber\u00eda ser lo \u00faltimo que se desarrolla sino todo lo contrario, deber\u00eda ser lo primero en desarrollar, tenemos la bater\u00eda de pruebas. Con fines did\u00e1cticos, he querido ense\u00f1arte un ciclo de desarrollo para ir recorriendo las diferentes capas de una aplicaci\u00f3n, pero en realidad, para realizar el desarrollo deber\u00eda aplicar TDD (Test Driven Development). Si quieres aprender las reglas b\u00e1sicas de como aplicar TDD al desarrollo diario, te recomiendo que leas el Anexo. TDD.</p> <p>En este caso, y sin que sirva de precedente, ya tenemos implementados los m\u00e9todos de la aplicaci\u00f3n, y ahora vamos a testearlos. Existen muchas formas de testing en funci\u00f3n del componente o la capa que se quiera testear. En realidad, a medida que vayas programando ir\u00e1s aprendiendo todas ellas, de momento realizaremos dos tipos de test simples que prueben las casu\u00edsticas de los m\u00e9todos.</p> <p>El enfoque que seguiremos en este tutorial ser\u00e1 realizar las pruebas mediante test unitarios y test de integraci\u00f3n.</p> <ul> <li>Test unitarios: Se trata de pruebas estrictamente relativas a la calidad est\u00e1tica del c\u00f3digo de una determinada operaci\u00f3n de la capa de la l\u00f3gica de negocio (Service). Estas pruebas no inicializan el contexto de Spring y deben simular todas las piezas ajenas a la funcionalidad testeada.</li> <li>Test de integraci\u00f3n: Se tratan de pruebas completas de un determinado endpoint que conlleva inicializar el contexto de Spring (base de datos incluida) y realizar una llama REST para comprobar el flujo completo de la API.</li> </ul> <p>Lo primero ser\u00e1 conocer que queremos probar y para ello nos vamos a hacer una lista:</p> <p>Test unitarios:</p> <ul> <li>Prueba de listado, debe probar la l\u00f3gica dentro de la operaci\u00f3n de negocio de consulta de <code>Categor\u00eda</code></li> <li>Prueba de creaci\u00f3n, debe probar la l\u00f3gica dentro de la operaci\u00f3n de negocio de creaci\u00f3n una nueva <code>Categor\u00eda</code></li> <li>Prueba de modificaci\u00f3n, debe probar la l\u00f3gica dentro de la operaci\u00f3n de negocio de modificaci\u00f3n una <code>Categor\u00eda</code> existente</li> <li>Prueba de borrado, debe probar la l\u00f3gica dentro de la operaci\u00f3n de negocio de borrado de una <code>Categor\u00eda</code> existente</li> </ul> <p>Test de integraci\u00f3n:</p> <ul> <li>Prueba de listado, debe recuperar los elementos de la tabla <code>Categor\u00eda</code></li> <li>Prueba de creaci\u00f3n, debe crear una nueva <code>Categor\u00eda</code></li> <li>Prueba de modificaci\u00f3n correcta, debe modificar una <code>Categor\u00eda</code> existente</li> <li>Prueba de modificaci\u00f3n incorrecta, debe dar error al modificar una <code>Categor\u00eda</code> que no existe</li> <li>Prueba de borrado correcta, debe borrar una <code>Categor\u00eda</code> existente</li> <li>Prueba de borrado incorrecta, debe dar error al borrar una <code>Categor\u00eda</code> que no existe</li> </ul> <p>Se podr\u00edan hacer muchos m\u00e1s tests, pero creo que con esos son suficientes para que entiendas como se comporta esta capa. Si te fijas, hay que probar tanto los resultados correctos como los resultados incorrectos. El usuario no siempre se va a comportar como nosotros pensamos.</p> <p>Pues vamos a ello.</p>"},{"location":"develop/basic/springboot/#pruebas-de-listado","title":"Pruebas de listado","text":"<p>Vamos a empezar haciendo una clase de test dentro de la carpeta <code>src/test/java</code>. No queremos que los test formen parte del c\u00f3digo productivo de la aplicaci\u00f3n, por eso utilizamos esa ruta que queda fuera del scope general de la aplicaci\u00f3n (main).</p> <p>Crearemos las clases (en la package <code>category</code>):</p> <ul> <li>Test unitarios: <code>com.ccsw.tutorial.category.CategoryTest</code></li> <li>Test de integraci\u00f3n: <code>com.ccsw.tutorial.category.CategoryIT</code> </li> </ul> CategoryTest.javaCategoryIT.java <pre><code>package com.ccsw.tutorial.category;\n\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\n@ExtendWith(MockitoExtension.class)\npublic class CategoryTest {\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.category;\n\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.web.client.TestRestTemplate;\nimport org.springframework.boot.test.web.server.LocalServerPort;\nimport org.springframework.test.annotation.DirtiesContext;\n\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\npublic class CategoryIT {\n\n    @LocalServerPort\n    private int port;\n\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n}\n</code></pre> <p>Estas clases son sencillas y tan solo tienen anotaciones espec\u00edficas de Spring Boot para cada tipo de test:</p> <ul> <li><code>@SpringBootTest</code>. Esta anotaci\u00f3n lo que hace es inicializar el contexto de Spring cada vez que se inician los test de jUnit. Aunque el contexto tarda unos segundos en arrancar, lo bueno que tiene es que solo se inicializa una vez y se lanzan todos los jUnits en bater\u00eda con el mismo contexto.</li> <li><code>@DirtiesContext</code>. Esta anotaci\u00f3n le indica a Spring que los test van a ser transaccionales, y por tanto cuando termine la ejecuci\u00f3n de cada uno de los test, autom\u00e1ticamente por la anotaci\u00f3n de arriba, Spring har\u00e1 un rearranque parcial del contexto y dejar\u00e1 el estado de la BBDD como estaba inicialmente.</li> <li><code>@ExtendWith</code>. Esta anotaci\u00f3n le indica a Spring que no debe inicializar el contexto, ya que se trata de test est\u00e1ticos que no lo requieren.</li> </ul> <p>Para las pruebas de integraci\u00f3n nos faltar\u00e1 configurar la aplicaci\u00f3n de test, al igual que hicimos con la aplicaci\u00f3n 'productiva'. Deberemos abrir el fichero <code>src/test/resources/application.properties</code> y a\u00f1adir la configuraci\u00f3n de la BBDD. Para este tutorial vamos a utilizar la misma BBDD que la aplicaci\u00f3n productiva, pero de normal la aplicaci\u00f3n se conectar\u00e1 a una BBDD, generalmente f\u00edsica, mientras que los test jUnit se conectar\u00e1n a otra BBDD, generalmente en memoria.</p> application.properties <pre><code>#Database\nspring.datasource.url=jdbc:h2:mem:testdb\nspring.datasource.username=sa\nspring.datasource.password=sa\nspring.datasource.driver-class-name=org.h2.Driver\n\nspring.jpa.database-platform=org.hibernate.dialect.H2Dialect\nspring.jpa.defer-datasource-initialization=true\n</code></pre> <p>Con todo esto ya podemos crear nuestro primer test. Iremos a las clases <code>CategoryIT</code> y <code>CategoryTest</code> donde a\u00f1adiremos un m\u00e9todo p\u00fablico. Los test siempre tienen que ser m\u00e9todos p\u00fablicos que devuelvan el tipo <code>void</code>.</p> CategoryTest.javaCategoryIT.java <pre><code>package com.ccsw.tutorial.category;\n\nimport com.ccsw.tutorial.category.model.Category;\nimport com.ccsw.tutorial.category.model.CategoryDto;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\n@ExtendWith(MockitoExtension.class)\npublic class CategoryTest {\n\n    @Mock\n    private CategoryRepository categoryRepository;\n\n    @InjectMocks\n    private CategoryServiceImpl categoryService;\n\n    @Test\n    public void findAllShouldReturnAllCategories() {\n\n          List&lt;Category&gt; list = new ArrayList&lt;&gt;();\n          list.add(mock(Category.class));\n\n          when(categoryRepository.findAll()).thenReturn(list);\n\n          List&lt;Category&gt; categories = categoryService.findAll();\n\n          assertNotNull(categories);\n          assertEquals(1, categories.size());\n    }\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.category;\n\nimport com.ccsw.tutorial.category.model.CategoryDto;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;    \nimport org.springframework.boot.test.web.client.TestRestTemplate;\nimport org.springframework.boot.test.web.server.LocalServerPort;\nimport org.springframework.core.ParameterizedTypeReference;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.test.annotation.DirtiesContext;\n\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.*;\n\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\npublic class CategoryIT {\n\n    public static final String LOCALHOST = \"http://localhost:\";\n    public static final String SERVICE_PATH = \"/category\";\n\n    @LocalServerPort\n    private int port;\n\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    ParameterizedTypeReference&lt;List&lt;CategoryDto&gt;&gt; responseType = new ParameterizedTypeReference&lt;List&lt;CategoryDto&gt;&gt;(){};\n\n    @Test\n    public void findAllShouldReturnAllCategories() {\n\n          ResponseEntity&lt;List&lt;CategoryDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.GET, null, responseType);\n\n          assertNotNull(response);\n          assertEquals(3, response.getBody().size());\n    }\n}\n</code></pre> <p>Es muy importante marcar cada m\u00e9todo de prueba con la anotaci\u00f3n <code>@Test</code>, en caso contrario no se ejecutar\u00e1. Lo que se debe hacer en cada m\u00e9todo que implementemos es probar una y solo una acci\u00f3n. </p> <p>En los ejemplos anteriores <code>(CategoryTest)</code>, por un lado hemos comprobado el m\u00e9todo <code>findAll()</code> el cual por debajo invoca una llamada al repository de categor\u00eda, la cual hemos simulado con una respuesta ficticia limit\u00e1ndonos \u00fanicamente a la l\u00f3gica contenida en la operaci\u00f3n de negocio.</p> <p>Mientras que por otro lado <code>(CategoryIT)</code>, hemos probado la llamando al m\u00e9todo <code>GET</code> del endpoint <code>http://localhost:XXXX/category</code> comprobando que realmente nos devuelve 3 resultados, que son los que hay en BBDD inicialmente.</p> <p>Muy importante: Nomenclatura de los tests</p> <p>La nomenclatura de los m\u00e9todos de test debe sigue una estructura determinada. Hay muchas formas de nombrar a los m\u00e9todos, pero nosotros solemos utilizar la estructura 'should', para indicar lo que va a hacer. En el ejemplo anterior el m\u00e9todo 'findAll' debe devolver 'AllCategories'. De esta forma sabemos cu\u00e1l es la intenci\u00f3n del test, y si por cualquier motivo diera un fallo, sabemos que es lo que NO est\u00e1 funcionando de nuestra aplicaci\u00f3n.</p> <p>Para comprobar que el test funciona, podemos darle bot\u00f3n derecho sobre la clase de <code>CategoryIT</code> y pulsar en <code>Run as</code> -&gt; <code>JUnit Test</code>. Si todo funciona correctamente, deber\u00e1 aparecer una pantalla de ejecuci\u00f3n y todos nuestros tests (en este caso solo uno) corriendo correctamente (en verde). El proceso es el mismo para la clase <code>CategoryTest</code>.</p> <p></p>"},{"location":"develop/basic/springboot/#pruebas-de-creacion","title":"Pruebas de creaci\u00f3n","text":"<p>Vamos con los siguientes test, los que probar\u00e1n una creaci\u00f3n de una nueva <code>Categor\u00eda</code>. A\u00f1adimos el siguiente m\u00e9todo a la clase de test:</p> CategoryTest.javaCategoryIT.java <pre><code>public static final String CATEGORY_NAME = \"CAT1\";\n\n@Test\npublic void saveNotExistsCategoryIdShouldInsert() {\n\n      CategoryDto categoryDto = new CategoryDto();\n      categoryDto.setName(CATEGORY_NAME);\n\n      ArgumentCaptor&lt;Category&gt; category = ArgumentCaptor.forClass(Category.class);\n\n      categoryService.save(null, categoryDto);\n\n      verify(categoryRepository).save(category.capture());\n\n      assertEquals(CATEGORY_NAME, category.getValue().getName());\n}\n</code></pre> <pre><code>public static final Long NEW_CATEGORY_ID = 4L;\npublic static final String NEW_CATEGORY_NAME = \"CAT4\";\n\n@Test\npublic void saveWithoutIdShouldCreateNewCategory() {\n\n      CategoryDto dto = new CategoryDto();\n      dto.setName(NEW_CATEGORY_NAME);\n\n      restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.PUT, new HttpEntity&lt;&gt;(dto), Void.class);\n\n      ResponseEntity&lt;List&lt;CategoryDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.GET, null, responseType);\n      assertNotNull(response);\n      assertEquals(4, response.getBody().size());\n\n      CategoryDto categorySearch = response.getBody().stream().filter(item -&gt; item.getId().equals(NEW_CATEGORY_ID)).findFirst().orElse(null);\n      assertNotNull(categorySearch);\n      assertEquals(NEW_CATEGORY_NAME, categorySearch.getName());\n}\n</code></pre> <p>En el primer caso, estamos construyendo un objeto <code>CategoryDto</code> para darle un nombre a la <code>Categor\u00eda</code> e invocamos a la operaci\u00f3n <code>save</code> pasandole un ID a nulo. Para identificar que el funcionamiento es el esperado, capturamos la categor\u00eda que se proporciona al repository al intentar realizar la acci\u00f3n ficticia de guardado y comprobamos que el valor es el que se proporciona en la invocaci\u00f3n.</p> <p>De forma similar en el segundo caso, estamos construyendo un objeto <code>CategoryDto</code> para darle un nombre a la <code>Categor\u00eda</code> e invocamos al m\u00e9todo <code>PUT</code> sin a\u00f1adir en la ruta referencia al identificador. Seguidamente, recuperamos de nuevo la lista de categor\u00edas y en este caso deber\u00eda tener 4 resultados. Hacemos un filtrado buscando la nueva <code>Categor\u00eda</code> que deber\u00eda tener un ID = 4 y deber\u00eda ser la que acabamos de crear. </p> <p>Si ejecutamos, veremos que ambos test ahora aparecen en verde.</p>"},{"location":"develop/basic/springboot/#pruebas-de-modificacion","title":"Pruebas de modificaci\u00f3n","text":"<p>Para este caso de prueba, vamos a realizar varios test, como hemos comentado anteriormente. Tenemos que probar que es lo que pasa cuando intentamos modificar un elemento que existe, pero tambi\u00e9n debemos probar que es lo que pasa cuando intentamos modificar un elemento que no existe.</p> <p>Empezamos con el sencillo, un test que pruebe una modificaci\u00f3n existente.</p> CategoryTest.javaCategoryIT.java <pre><code>public static final Long EXISTS_CATEGORY_ID = 1L;\n\n@Test\npublic void saveExistsCategoryIdShouldUpdate() {\n\n  CategoryDto categoryDto = new CategoryDto();\n  categoryDto.setName(CATEGORY_NAME);\n\n  Category category = mock(Category.class);\n  when(categoryRepository.findById(EXISTS_CATEGORY_ID)).thenReturn(Optional.of(category));\n\n  categoryService.save(EXISTS_CATEGORY_ID, categoryDto);\n\n  verify(categoryRepository).save(category);\n}\n</code></pre> <pre><code>public static final Long MODIFY_CATEGORY_ID = 3L;\n\n@Test\npublic void modifyWithExistIdShouldModifyCategory() {\n\n      CategoryDto dto = new CategoryDto();\n      dto.setName(NEW_CATEGORY_NAME);\n\n      restTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + MODIFY_CATEGORY_ID, HttpMethod.PUT, new HttpEntity&lt;&gt;(dto), Void.class);\n\n      ResponseEntity&lt;List&lt;CategoryDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.GET, null, responseType);\n      assertNotNull(response);\n      assertEquals(3, response.getBody().size());\n\n      CategoryDto categorySearch = response.getBody().stream().filter(item -&gt; item.getId().equals(MODIFY_CATEGORY_ID)).findFirst().orElse(null);\n      assertNotNull(categorySearch);\n      assertEquals(NEW_CATEGORY_NAME, categorySearch.getName());\n}\n</code></pre> <p>En el caso de los test unitarios, comprobamos la l\u00f3gica de la modificaci\u00f3n simulando que el repository nos devuelve una categor\u00eda que modificar y verificado que se invoca el guardado sobre la misma.</p> <p>En el caso de los test de integraci\u00f3n, la misma filosof\u00eda que en el test anterior, pero esta vez modificamos la <code>Categor\u00eda</code> de ID = 3. Luego la filtramos y vemos que realmente se ha modificado. Adem\u00e1s comprobamos que el listado de todas los registros sigue siendo 3 y no se ha creado un nuevo registro.</p> <p>En el siguiente test, probaremos un resultado err\u00f3neo.</p> CategoryIT.java <pre><code>@Test\npublic void modifyWithNotExistIdShouldInternalError() {\n\n      CategoryDto dto = new CategoryDto();\n      dto.setName(NEW_CATEGORY_NAME);\n\n      ResponseEntity&lt;?&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + NEW_CATEGORY_ID, HttpMethod.PUT, new HttpEntity&lt;&gt;(dto), Void.class);\n\n      assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());\n}\n</code></pre> <p>Intentamos modificar el ID = 4, que no deber\u00eda existir en BBDD y por tanto lo que se espera en el test es que lance un <code>500 Internal Server Error</code> al llamar al m\u00e9todo <code>PUT</code>.</p>"},{"location":"develop/basic/springboot/#pruebas-de-borrado","title":"Pruebas de borrado","text":"<p>Ya por \u00faltimo implementamos las pruebas de borrado.</p> CategoryTest.javaCategoryIT.java <pre><code>@Test\npublic void deleteExistsCategoryIdShouldDelete() throws Exception {\n\n      Category category = mock(Category.class);\n      when(categoryRepository.findById(EXISTS_CATEGORY_ID)).thenReturn(Optional.of(category));\n\n      categoryService.delete(EXISTS_CATEGORY_ID);\n\n      verify(categoryRepository).deleteById(EXISTS_CATEGORY_ID);\n}\n</code></pre> <pre><code>public static final Long DELETE_CATEGORY_ID = 2L;\n\n@Test\npublic void deleteWithExistsIdShouldDeleteCategory() {\n\n      restTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + DELETE_CATEGORY_ID, HttpMethod.DELETE, null, Void.class);\n\n      ResponseEntity&lt;List&lt;CategoryDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.GET, null, responseType);\n      assertNotNull(response);\n      assertEquals(2, response.getBody().size());\n}\n\n@Test\npublic void deleteWithNotExistsIdShouldInternalError() {\n\n      ResponseEntity&lt;?&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + NEW_CATEGORY_ID, HttpMethod.DELETE, null, Void.class);\n\n      assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());\n}\n</code></pre> <p>En cuanto al test unitario, se invoca a la operaci\u00f3n <code>delete</code> y se verifica que la operaci\u00f3n requerida del repository es invocado con el atributo correcto.    </p> <p>En lo relativo a las pruebas de integraci\u00f3n, en el primer test, se invoca el m\u00e9todo <code>DELETE</code> y posteriormente se comprueba que el listado tiene un tama\u00f1o de 2 (uno menos que el original). Mientras que en el segundo test, se comprueba que con ID no v\u00e1lido, devuelve un <code>500 Internal Server Error</code>.</p> <p>Con esto tendr\u00edamos m\u00e1s o menos probados los casos b\u00e1sicos de nuestra aplicaci\u00f3n y tendr\u00edamos una peque\u00f1a red de seguridad que nos ayudar\u00eda por si a futuro necesitamos hacer alg\u00fan cambio o evolutivo.</p>"},{"location":"develop/basic/springboot/#que-hemos-aprendido","title":"\u00bfQ\u00fae hemos aprendido?","text":"<p>Resumiendo un poco los pasos que hemos seguido:</p> <ul> <li>Hay que definir y agrupar por \u00e1mbito funcional, hemos creado el package <code>com.ccsw.tutorial.category</code> para aglutinar todas las clases.</li> <li>Lo primero que debemos empezar a construir siempre son los test, aunque en este cap\u00edtulo del tutorial lo hemos hecho al rev\u00e9s solo con fines did\u00e1cticos. En los siguientes cap\u00edtulos lo haremos de forma correcta, y esto nos ayudar\u00e1 a pensar y dise\u00f1ar que es lo que queremos implementar realmente.</li> <li>La implementaci\u00f3n de la aplicaci\u00f3n se deber\u00eda separar por capas:<ul> <li><code>Controller</code> \u2192 Maneja las peticiones de entrada del cliente y realiza transformaciones. No ejecuta directamente l\u00f3gica de negocio, para eso utiliza llamadas a la siguiente capa.</li> <li><code>Service</code> \u2192 Ejecuta la l\u00f3gica de negocio en sus m\u00e9todos o llamando a otros objetos de la misma capa. No ejecuta directamente accesos a datos, para eso utiliza la siguiente capa.</li> <li><code>Repository</code> \u2192 Realiza los accesos a datos de lectura y escritura. NUNCA debe llamar a otros objetos de la misma capa ni de capas anteriores.</li> </ul> </li> <li>Hay que tener en cuenta los objetos modelo que se mueven en cada capa. Generalmente son:<ul> <li><code>Json</code> \u2192 Los datos que vienen y van del cliente al <code>Controller</code>.</li> <li><code>DTO</code> \u2192 Los datos se mueven dentro del <code>Controller</code> y sirven para invocar llamadas. Tambi\u00e9n son los datos que devuelve un <code>Controller</code>.</li> <li><code>Entity</code> \u2192 Los datos que sirven para persistir y leer datos de una BBDD y que NUNCA deber\u00edan ir m\u00e1s all\u00e1 del <code>Controller</code>.</li> </ul> </li> </ul>"},{"location":"develop/basic/springboot/#depuracion","title":"Depuraci\u00f3n","text":"<p>Una parte muy importante del desarrollo es tener la capacidad de depurar nuestro c\u00f3digo, en este apartado vamos a explicar como se realiza <code>debug</code> en Backend.</p> <p>Esta parte se realiza con las herramientas incluidas dentro de nuestro IDE favorito, depender\u00e1 del que tengas instalado, se hace de una forma u otra.</p>"},{"location":"develop/basic/springboot/#intellij","title":"IntelliJ","text":"<p>En caso de que hayas elegido instalar IntelliJ, lo primero que debemos hacer es arrancar la aplicaci\u00f3n en modo <code>Debug</code>:</p> <p> </p> <p>o bien</p> <p> </p> <p>Arrancada la aplicaci\u00f3n en este modo, vamos a depurar la operaci\u00f3n de crear categor\u00eda.</p> <p>Para ello vamos a abrir nuestro fichero donde tenemos la implementaci\u00f3n del servicio de creaci\u00f3n de la capa de la l\u00f3gica de negocio <code>CategoryServiceImpl</code>.</p> <p>Dentro del fichero ya podemos a\u00f1adir puntos de ruptura (breakpoint), en nuestro caso queremos comprobar en el m\u00e9todo <code>save</code> que el nombre introducido se recibe correctamente.</p> <p>Colocamos el breakpoint en la primera l\u00ednea del m\u00e9todo <code>save</code> (click al lado del n\u00famero de la l\u00ednea):</p> <p> </p> <p>y desde la interfaz/postman creamos una nueva categor\u00eda para lanzar la petici\u00f3n y que se detenga la ejecuci\u00f3n en debug.</p> <p>Hecho esto, podemos observar que a nivel de interfaz/postman, la petici\u00f3n se queda esperando y el IDE pasa modo <code>Debug</code>. En la parte inferior del IDE podemos ver la pila de llamadas y las variables actuales en memoria:</p> <p> </p> <p>El IDE nos lleva al punto exacto donde hemos a\u00f1adido el breakpoint y se para en este punto ofreci\u00e9ndonos la posibilidad de explorar el contenido de las variables del c\u00f3digo:</p> <p> </p> <p>Aqu\u00ed podemos comprobar que efectivamente el atributo <code>name</code> de la variable <code>dto</code> tiene el valor que hemos introducido por pantalla/postman.</p> <p>Para continuar con la ejecuci\u00f3n basta con darle al bot\u00f3n de <code>play</code> de la barra de herramientas inferior-izquierda, o incluso navegar por las siguientes l\u00edneas de c\u00f3digo.</p> <p> </p>"},{"location":"develop/basic/springboot/#eclipse","title":"Eclipse","text":"<p>En caso de que hayas elegido instalar Eclipse, lo primero que debemos hacer es arrancar la aplicaci\u00f3n en modo <code>Debug</code>:</p> <p></p> <p>Arrancada la aplicaci\u00f3n en este modo, vamos a depurar la operaci\u00f3n de crear categor\u00eda.</p> <p>Para ello vamos a abrir nuestro fichero donde tenemos la implementaci\u00f3n del servicio de creaci\u00f3n de la capa de la l\u00f3gica de negocio <code>CategoryServiceImpl</code>.</p> <p>Dentro del fichero ya podemos a\u00f1adir puntos de ruptura (breakpoint), en nuestro caso queremos comprobar que el nombre introducido se recibe correctamente.</p> <p>Colocamos el breakpoint en la primera l\u00ednea del m\u00e9todo (click sobre el n\u00famero de la l\u00ednea) y desde la interfaz/postman creamos una nueva categor\u00eda.</p> <p>Hecho esto, podemos observar que a nivel de interfaz/postman, la petici\u00f3n se queda esperando y el IDE pasa modo <code>Debug</code> (la primera vez nos preguntar\u00e1 si queremos hacerlo, le decimos que si):</p> <p></p> <p>El IDE nos lleva al punto exacto donde hemos a\u00f1adido el breakpoint y se para en este punto ofreci\u00e9ndonos la posibilidad de explorar el contenido de las variables del c\u00f3digo:</p> <p></p> <p>Aqu\u00ed podemos comprobar que efectivamente el atributo <code>name</code> de la variable <code>dto</code> tiene el valor que hemos introducido por pantalla/postman.</p> <p>Para continuar con la ejecuci\u00f3n basta con darle al bot\u00f3n de <code>play</code> de la barra de herramientas superior.</p> <p>Nota: para volver al modo <code>Java</code> de Eclipse, presionamos el bot\u00f3n que se sit\u00faa a la izquierda del modo <code>Debug</code> en el que ha entrado el IDE autom\u00e1ticamente.</p>"},{"location":"develop/basic/vuejs/","title":"Listado simple - VUE","text":"<p>Ahora que ya tenemos listo el proyecto frontend de VUE, ya podemos empezar a codificar la soluci\u00f3n.</p>"},{"location":"develop/basic/vuejs/#primeros-pasos","title":"Primeros pasos","text":"<p>Antes de empezar</p> <p>Quiero hacer hincapi\u00e9 que VUE tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. En la propia web de documentaci\u00f3n de VUE puedes buscar casi cualquier ejemplo que necesites.</p> <p>Vamos a realizar una pantalla lo m\u00e1s parecida a la siguiente captura para empezar:</p> <p></p> <p>Lo primero que vamos a hacer es crear los componentes de las tres pr\u00f3ximas pantallas mediante el siguiente comando: </p> <pre><code>npx quasar new page CatalogPage CategoriesPage AuthorsPage\n</code></pre> <p>Y ahora vamos a crear las rutas que nos van a hacer llegar hasta ellos: </p> <pre><code>import { RouteRecordRaw } from 'vue-router';\nimport MainLayout from 'layouts/MainLayout.vue';\nimport IndexPage from 'pages/IndexPage.vue';\nimport CatalogPage from 'pages/CatalogPage.vue';\nimport CategoriesPage from 'pages/CategoriesPage.vue';\nimport AuthorsPage from 'pages/AuthorsPage.vue';\n\nconst routes: RouteRecordRaw[] = [\n  {\n    path: '/',\n    component: MainLayout,\n    children: [\n      { path: '', component: IndexPage },\n      { path: 'games', component: CatalogPage },\n      { path: 'categories', component: CategoriesPage },\n      { path: 'authors', component: AuthorsPage },\n    ],\n  },\n\n  // Always leave this as last one,\n  // but you can also remove it\n  // {\n  //   path: '/:catchAll(.*)*',\n  //   component: () =&gt; import('pages/ErrorNotFound.vue'),\n  // },\n];\n\nexport default routes;\n</code></pre> <p>Una vez realizado esto, vamos a ponerle dentro de cada uno de los archivos creados el nombre del archivo donde est\u00e1 el comentario para saber que lleva al lugar correcto:</p> <pre><code>&lt;template&gt;\n  &lt;q-page padding&gt; CatalogPage &lt;/q-page&gt;\n&lt;/template&gt;\n\n&lt;script lang=\"ts\"&gt;\nimport { defineComponent } from 'vue';\nexport default defineComponent({\n  name: 'CatalogPage',\n});\n&lt;/script&gt;\n</code></pre> <p>Por \u00faltimo, modificaremos el men\u00fa lateral para que lleve las opciones correctas y nos enlace a dichas pantallas (para esto, iremos al archivo <code>MainLayout.vue</code>):</p> <pre><code>const linksList = [\n  {\n    title: 'Cat\u00e1logo',\n    icon: 'list',\n    link: 'games',\n  },\n  {\n    title: 'Categor\u00edas',\n    icon: 'dashboard',\n    link: 'categories',\n  },\n  {\n    title: 'Autores',\n    icon: 'face',\n    link: 'authors',\n  },\n];\n</code></pre> <p>En caso de que no funcione correctamente, deber\u00eda solucionarse cambiando en el archivo <code>EssentialLink.vue</code> el prop <code>\u201chref\u201d</code> por el prop <code>\u201cto\u201d</code>:</p> <pre><code>&lt;template&gt;\n  &lt;q-item clickable tag=\"a\" :to=\"link\"&gt;\n    &lt;q-item-section v-if=\"icon\" avatar&gt;\n      &lt;q-icon :name=\"icon\" /&gt;\n    &lt;/q-item-section&gt;\n\n    &lt;q-item-section&gt;\n      &lt;q-item-label&gt;{{ title }}&lt;/q-item-label&gt;\n    &lt;/q-item-section&gt;\n  &lt;/q-item&gt;\n&lt;/template&gt;\n</code></pre>"},{"location":"develop/basic/vuejs/#codigo-de-la-pantalla","title":"C\u00f3digo de la pantalla","text":"<p>Para empezar, usaremos un componente de tabla de la librer\u00eda de Quasar. Este componente nos ayudar\u00e1 a mostrar los datos de los juegos en un futuro.</p> <pre><code>&lt;template&gt;\n  &lt;q-page padding&gt;\n    &lt;q-table\n      :rows=\"catalogData\"\n      :columns=\"columns\"\n      title=\"Cat\u00e1logo\"\n      row-key=\"id\"\n    /&gt;\n  &lt;/q-page&gt;\n&lt;/template&gt;\n</code></pre> <p>As\u00ed es como deber\u00eda quedar nuestro componente de tabla con todas las supuestas variables que m\u00e1s adelante le settearemos:</p> <pre><code>&lt;template&gt;\n  &lt;q-page padding&gt;\n    &lt;q-table\n      hide-bottom\n      :rows=\"catalogData\"\n      :columns=\"columns\"\n      v-model:pagination=\"pagination\"\n      title=\"Cat\u00e1logo\"\n      class=\"my-sticky-header-table\"\n      no-data-label=\"No hay resultados\"\n      row-key=\"id\"\n    /&gt;\n  &lt;/q-page&gt;\n&lt;/template&gt;\n</code></pre> <p>Y as\u00ed es como vamos a necesitar que est\u00e9, ya que no va a tener paginado. \u00bfPor qu\u00e9?</p> <ul> <li><code>hide-bottom</code> \u2192 hace que no se muestre la zona baja de la tabla que es donde est\u00e1 el paginado.</li> <li><code>v-model:pagination</code> \u2192 har\u00e1 que vengan los datos que vengan, se muestren todos de la misma manera.</li> <li><code>class</code> \u2192 esta clase har\u00e1 que, si haciendo scroll pierdes los header, estos te acompa\u00f1en y siempre sepas qu\u00e9 columna es la que est\u00e1s mirando.</li> <li><code>no-data-label</code> \u2192 un mensaje por si alg\u00fan d\u00eda no hay datos o tiene un fallo el back.</li> </ul> <p>Todo esto no hace falta aprend\u00e9rselo, est\u00e1 en la documentaci\u00f3n de este componente. Pero vamos a ir usando algunos props como estos para configurar correctamente la tabla.</p>"},{"location":"develop/basic/vuejs/#mockeando-datos","title":"Mockeando datos","text":"<p>Y esto va a hacer que podamos mostrar datos:</p> <p><pre><code>&lt;script lang=\"ts\"&gt;\nimport { defineComponent } from 'vue';\n\nconst columns = [\n  { name: 'id', align: 'left', label: 'ID', field: 'id', sortable: true },\n  {\n    name: 'name',\n    align: 'left',\n    label: 'Nombre',\n    field: 'name',\n    sortable: true,\n  },\n  { name: 'options', align: 'left', label: 'Options', field: 'options' },\n];\n\nconst data = [\n  { id: 1, name: 'Dados' },\n  { id: 2, name: 'Fichas' },\n  { id: 3, name: 'Cartas' },\n  { id: 4, name: 'Rol' },\n  { id: 5, name: 'Tableros' },\n  { id: 6, name: 'Tem\u00e1ticos' },\n  { id: 7, name: 'Europeos' },\n  { id: 8, name: 'Guerra' },\n  { id: 9, name: 'Abstractos' },\n];\n\nexport default defineComponent({\n  name: 'CatalogPage',\n\n  setup() {\n    const catalogData = ref(data);\n\n    return {\n      catalogData,\n      columns: columns,\n      pagination: {\n        page: 1,\n        rowsPerPage: 0, // 0 means all rows\n      },\n    };\n  },\n});\n&lt;/script&gt;\n</code></pre> Lo que estamos haciendo es settear unos datos, los nombres y estilos de las columnas, y los ajustes de la paginaci\u00f3n.</p>"},{"location":"develop/basic/vuejs/#anadir-editar-y-eliminar-filas","title":"A\u00f1adir, editar y eliminar filas","text":"<p>El c\u00f3digo final para esto, que m\u00e1s adelante explicaremos, es el siguiente:</p> <pre><code>&lt;template&gt;\n  &lt;q-page padding&gt;\n    &lt;q-table\n      hide-bottom\n      :rows=\"catalogData\"\n      :columns=\"columns\"\n      v-model:pagination=\"pagination\"\n      title=\"Cat\u00e1logo\"\n      class=\"my-sticky-header-table\"\n      no-data-label=\"No hay resultados\"\n      row-key=\"id\"\n    &gt;\n      &lt;template v-slot:top&gt;\n        &lt;q-btn flat round color=\"primary\" icon=\"add\" @click=\"showAdd = true\" /&gt;\n      &lt;/template&gt;\n      &lt;template v-slot:body=\"props\"&gt;\n        &lt;q-tr :props=\"props\"&gt;\n          &lt;q-td key=\"id\" :props=\"props\"&gt;{{ props.row.id }}&lt;/q-td&gt;\n          &lt;q-td key=\"name\" :props=\"props\"&gt;\n            {{ props.row.name }}\n            &lt;q-popup-edit\n              v-model=\"props.row.name\"\n              title=\"Cambiar nombre\"\n              v-slot=\"scope\"\n            &gt;\n              &lt;q-input\n                v-model=\"scope.value\"\n                dense\n                autofocus\n                counter\n                @keyup.enter=\"scope.set\"\n              &gt;\n                &lt;template v-slot:append&gt;\n                  &lt;q-icon name=\"edit\" /&gt;\n                &lt;/template&gt;\n              &lt;/q-input&gt;\n            &lt;/q-popup-edit&gt;\n          &lt;/q-td&gt;\n          &lt;q-td key=\"options\" :props=\"props\"&gt;\n            &lt;q-btn\n              flat\n              round\n              color=\"negative\"\n              icon=\"delete\"\n              @click=\"showDeleteDialog(props.row)\"\n            /&gt;\n          &lt;/q-td&gt;\n        &lt;/q-tr&gt;\n      &lt;/template&gt;\n    &lt;/q-table&gt;\n    &lt;q-dialog v-model=\"showDelete\" persistent&gt;\n      &lt;q-card&gt;\n        &lt;q-card-section class=\"row items-center\"&gt;\n          &lt;q-icon\n            name=\"delete\"\n            size=\"sm\"\n            color=\"negative\"\n            @click=\"showDelete = true\"\n          /&gt;\n          &lt;span class=\"q-ml-sm\"&gt;\n            \u00bfEst\u00e1s seguro de que quieres borrar este elemento?\n          &lt;/span&gt;\n        &lt;/q-card-section&gt;\n\n        &lt;q-card-actions align=\"right\"&gt;\n          &lt;q-btn flat label=\"Cancelar\" color=\"primary\" v-close-popup /&gt;\n          &lt;q-btn\n            flat\n            label=\"Confirmar\"\n            color=\"primary\"\n            v-close-popup\n            @click=\"deleteGame\"\n          /&gt;\n        &lt;/q-card-actions&gt;\n      &lt;/q-card&gt;\n    &lt;/q-dialog&gt;\n    &lt;q-dialog v-model=\"showAdd\"&gt;\n      &lt;q-card style=\"min-width: 350px\"&gt;\n        &lt;q-card-section&gt;\n          &lt;div class=\"text-h6\"&gt;Nombre del juego&lt;/div&gt;\n        &lt;/q-card-section&gt;\n\n        &lt;q-card-section class=\"q-pt-none\"&gt;\n          &lt;q-input dense v-model=\"nameToAdd\" autofocus @keyup.enter=\"addGame\" /&gt;\n        &lt;/q-card-section&gt;\n\n        &lt;q-card-actions align=\"right\" class=\"text-primary\"&gt;\n          &lt;q-btn flat label=\"Cancelar\" v-close-popup /&gt;\n          &lt;q-btn flat label=\"A\u00f1adir juego\" v-close-popup @click=\"addGame\" /&gt;\n        &lt;/q-card-actions&gt;\n      &lt;/q-card&gt;\n    &lt;/q-dialog&gt;\n  &lt;/q-page&gt;\n&lt;/template&gt;\n\n&lt;script lang=\"ts\"&gt;\nimport { ref } from 'vue';\nimport { defineComponent } from 'vue';\n\nconst columns = [\n  { name: 'id', align: 'left', label: 'ID', field: 'id', sortable: true },\n  {\n    name: 'name',\n    align: 'left',\n    label: 'Nombre',\n    field: 'name',\n    sortable: true,\n  },\n  { name: 'options', align: 'left', label: 'Options', field: 'options' },\n];\n\nconst data = [\n  { id: 1, name: 'Dados' },\n  { id: 2, name: 'Fichas' },\n  { id: 3, name: 'Cartas' },\n  { id: 4, name: 'Rol' },\n  { id: 5, name: 'Tableros' },\n  { id: 6, name: 'Tem\u00e1ticos' },\n  { id: 7, name: 'Europeos' },\n  { id: 8, name: 'Guerra' },\n  { id: 9, name: 'Abstractos' },\n];\n\nexport default defineComponent({\n  name: 'CatalogPage',\n\n  setup() {\n    const catalogData = ref(data);\n    const showDelete = ref(false);\n    const showAdd = ref(false);\n    const nameToAdd = ref('');\n    const selectedRow = ref({});\n\n    const deleteGame = () =&gt; {\n      catalogData.value.splice(\n        catalogData.value.findIndex((i) =&gt; i.id === selectedRow.value.id),\n        1\n      );\n      showDelete.value = false;\n    };\n\n    const showDeleteDialog = (item: any) =&gt; {\n      selectedRow.value = item;\n      showDelete.value = true;\n    };\n\n    const addGame = () =&gt; {\n      catalogData.value.push({\n        id: Math.max(...catalogData.value.map((o) =&gt; o.id)) + 1,\n        name: nameToAdd.value,\n      });\n      nameToAdd.value = '';\n      showAdd.value = false;\n    };\n\n    return {\n      catalogData,\n      columns: columns,\n      pagination: {\n        page: 1,\n        rowsPerPage: 0, // 0 means all rows\n      },\n      showDelete,\n      showAdd,\n      nameToAdd,\n      showDeleteDialog,\n      deleteGame,\n      addGame,\n    };\n  },\n});\n&lt;/script&gt;\n</code></pre>"},{"location":"develop/basic/vuejs/#anadir-fila","title":"A\u00f1adir fila","text":"<p>Para esto hemos necesitado el primer template dentro del componente tabla para mostrar un bot\u00f3n que har\u00e1 que se muestre un dialog para introducir el nombre del juego que es el \u00faltimo q-dialog mostrado en el componente. Tanto al pulsar en el bot\u00f3n como al pulsar Enter se ejecutar\u00e1 la funci\u00f3n para a\u00f1adirlo llamada addGame, que se encarga de a\u00f1adirlo poni\u00e9ndole un id superior a cualquiera de los ya creados, el nombre seleccionado almacenado en la variable nameToAdd y de dejar de mostrar el dialog una vez realizado el proceso.</p>"},{"location":"develop/basic/vuejs/#editar-fila","title":"Editar fila","text":"<p>Para esto hemos necesitado el segundo template de dentro del componente (a excepci\u00f3n del \u00faltimo q-td). Este hace que cuando sea la columna id simplemente muestre su valor, pero en cambio cuando sea la del nombre, en caso de que se pulse sobre esa casilla se muestre un dialog con un campo de texto con el valor de la casilla pulsada.</p>"},{"location":"develop/basic/vuejs/#borrar-fila","title":"Borrar fila","text":"<p>Por \u00faltimo, para el borrado hemos necesitado el q-td con la key de options para mostrar un bot\u00f3n para ejecutar la funci\u00f3n showDeleteDialog pas\u00e1ndole el item completo de la fila seleccionada, este hace que se muestre el dialog y se almacene el item seleccionado y por \u00faltimo el dialog se encarga de realizar la pregunta de confirmaci\u00f3n para su posterior borrado. En caso de confirmarlo, la funci\u00f3n deleteGame busca la posici\u00f3n del item seleccionado y lo borra. Una vez hecho eso, limpia el valor de fila seleccionada y deja de mostrar el dialog.</p>"},{"location":"develop/basic/vuejs/#conexion-con-backend","title":"Conexi\u00f3n con backend","text":"<p>Antes de nada, para poder realizar peticiones vamos a tener que instalar: <code>@vueuse/core</code>.</p>"},{"location":"develop/basic/vuejs/#recuperacion-de-datos","title":"Recuperaci\u00f3n de datos","text":"<p>Vamos a proceder a modificar lo m\u00ednimo e indispensable para que los datos mostrados no sean los mockeados y vengan del back mediante esta petici\u00f3n:</p> <pre><code>const { data } = useFetch('http://localhost:8080/game').get().json();\nwhenever(data, () =&gt; (catalogData.value = data.value));\n</code></pre> <p>Tambi\u00e9n tendremos que modificar los campos a mostrar, ya que ya no es name, si no title el nombre del juego. Y tambi\u00e9n habr\u00e1 que mostrar la edad, la categor\u00eda y el autor.</p>"},{"location":"develop/basic/vuejs/#edicion-de-una-fila","title":"Edici\u00f3n de una fila","text":"<p>Solo modificaremos los campos referidos al juego (de momento) para que sea lo m\u00e1s sencillo posible, es decir, solo se modificar\u00e1 el t\u00edtulo y la edad tal y como lo hab\u00edamos hecho antes con el <code>q-popup-edit</code>.</p>"},{"location":"develop/basic/vuejs/#creacion-de-una-nueva-fila","title":"Creaci\u00f3n de una nueva fila","text":"<p>Ya que no tenemos en el back de Node realizado el back necesario para poder borrar una fila, terminaremos con el a\u00f1adido de una nueva fila.</p> <p>Para esto, tendremos que modificar la funci\u00f3n para a\u00f1adir, adem\u00e1s de eliminar la variable <code>nameToAdd</code> y modificar el dialog. As\u00ed deber\u00eda quedar la funci\u00f3n:</p> <pre><code>const addGame = async () =&gt; {\n  const response = await useFetch('http://localhost:8080/game', {\n    method: 'PUT',\n    redirect: 'manual',\n    headers: {\n      accept: '*/*',\n      origin: window.origin,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(gameToAdd.value),\n  })\n    .put()\n    .json();\n\n  getGames();\n  gameToAdd.value = newGame;\n};\n</code></pre> <p>Y as\u00ed el dialog:</p> <pre><code>&lt;q-dialog v-model=\"showAdd\"&gt;\n      &lt;q-card style=\"width: 300px\" class=\"q-px-sm q-pb-md\"&gt;\n        &lt;q-card-section&gt;\n          &lt;div class=\"text-h6\"&gt;Nuevo juego&lt;/div&gt;\n        &lt;/q-card-section&gt;\n\n        &lt;q-item-label header&gt;T\u00edtulo&lt;/q-item-label&gt;\n        &lt;q-item dense&gt;\n          &lt;q-item-section avatar&gt;\n            &lt;q-icon name=\"sports_esports\" /&gt;\n          &lt;/q-item-section&gt;\n          &lt;q-item-section&gt;\n            &lt;q-input dense v-model=\"gameToAdd.title\" autofocus /&gt;\n          &lt;/q-item-section&gt;\n        &lt;/q-item&gt;\n\n        &lt;q-item-label header&gt;Edad&lt;/q-item-label&gt;\n        &lt;q-item dense&gt;\n          &lt;q-item-section avatar&gt;\n            &lt;q-icon name=\"cake\" /&gt;\n          &lt;/q-item-section&gt;\n          &lt;q-item-section&gt;\n            &lt;q-slider\n              color=\"teal\"\n              v-model=\"gameToAdd.age\"\n              :min=\"0\"\n              :max=\"100\"\n              :step=\"1\"\n              label\n              label-always\n            /&gt;\n          &lt;/q-item-section&gt;\n        &lt;/q-item&gt;\n\n        &lt;q-item-label header&gt;Categor\u00eda&lt;/q-item-label&gt;\n        &lt;q-item dense&gt;\n          &lt;q-item-section avatar&gt;\n            &lt;q-icon name=\"category\" /&gt;\n          &lt;/q-item-section&gt;\n          &lt;q-item-section&gt;\n            &lt;q-select\n              name=\"category\"\n              v-model=\"gameToAdd.category.id\"\n              :options=\"categories\"\n              filled\n              clearable\n              emit-value\n              map-options\n              option-disable=\"inactive\"\n              option-value=\"id\"\n              option-label=\"name\"\n              color=\"primary\"\n              label=\"Category\"\n            /&gt;\n          &lt;/q-item-section&gt;\n        &lt;/q-item&gt;\n\n        &lt;q-item-label header&gt;Autor&lt;/q-item-label&gt;\n        &lt;q-item dense&gt;\n          &lt;q-item-section avatar&gt;\n            &lt;q-icon name=\"face\" /&gt;\n          &lt;/q-item-section&gt;\n          &lt;q-item-section&gt;\n            &lt;q-select\n              name=\"author\"\n              v-model=\"gameToAdd.author.id\"\n              :options=\"authors\"\n              filled\n              clearable\n              emit-value\n              map-options\n              option-disable=\"inactive\"\n              option-value=\"id\"\n              option-label=\"name\"\n              color=\"primary\"\n              label=\"Author\"\n            /&gt;\n          &lt;/q-item-section&gt;\n        &lt;/q-item&gt;\n\n        &lt;q-card-actions align=\"right\" class=\"text-primary\"&gt;\n          &lt;q-btn flat label=\"Cancelar\" v-close-popup /&gt;\n          &lt;q-btn flat label=\"A\u00f1adir juego\" v-close-popup @click=\"addGame\" /&gt;\n        &lt;/q-card-actions&gt;\n      &lt;/q-card&gt;\n    &lt;/q-dialog&gt;\n</code></pre>"},{"location":"develop/basic/vuejs/#ultimo-paso","title":"\u00daltimo paso","text":"<p>Este resultado vamos a copiarlo y pegarlo en las pantallas de Categor\u00eda y Autor para que tengamos exactamente el mismo formato cambiando todo donde diga \u201cjuego\u201d o \u201cgame\u201d por su traducci\u00f3n a \u201ccategor\u00eda\u201d o \u201cautor\u201d.</p>"},{"location":"develop/basic/vuejs/#ejercicio","title":"Ejercicio","text":"<p>Al realizar el cambio descrito anteriormente podremos ver que no todo funciona, ya que el objeto que se env\u00eda para modificar no ser\u00eda correcto adem\u00e1s de que las tablas de Categor\u00eda y Autor s\u00ed que tienen una funci\u00f3n para poder borrar esas filas.</p> <p>El ejercicio se va a realizar en la pantalla de Categor\u00eda. Consta en, despu\u00e9s de haber realizado todos los cambios, hacer que a\u00f1ada, edite y borre las filas seg\u00fan sea necesario.</p> <p>El c\u00f3digo resultante deber\u00eda ser algo parecido al siguiente c\u00f3digo:</p> <pre><code>&lt;template&gt;\n  &lt;q-page padding&gt;\n    &lt;q-table\n      hide-bottom\n      :rows=\"categoriesData\"\n      :columns=\"columns\"\n      v-model:pagination=\"pagination\"\n      title=\"Cat\u00e1logo\"\n      class=\"my-sticky-header-table\"\n      no-data-label=\"No hay resultados\"\n      row-key=\"id\"\n    &gt;\n      &lt;template v-slot:top&gt;\n        &lt;q-btn flat round color=\"primary\" icon=\"add\" @click=\"showAdd = true\" /&gt;\n      &lt;/template&gt;\n      &lt;template v-slot:body=\"props\"&gt;\n        &lt;q-tr :props=\"props\"&gt;\n          &lt;q-td key=\"id\" :props=\"props\"&gt;{{ props.row.id }}&lt;/q-td&gt;\n          &lt;q-td key=\"name\" :props=\"props\"&gt;\n            {{ props.row.name }}\n            &lt;q-popup-edit\n              v-model=\"props.row.name\"\n              title=\"Cambiar nombre\"\n              v-slot=\"scope\"\n            &gt;\n              &lt;q-input\n                v-model=\"scope.value\"\n                dense\n                autofocus\n                counter\n                @keyup.enter=\"editRow(props, scope, 'name')\"\n              &gt;\n                &lt;template v-slot:append&gt;\n                  &lt;q-icon name=\"edit\" /&gt;\n                &lt;/template&gt;\n              &lt;/q-input&gt;\n            &lt;/q-popup-edit&gt;\n          &lt;/q-td&gt;\n          &lt;q-td key=\"options\" :props=\"props\"&gt;\n            &lt;q-btn\n              flat\n              round\n              color=\"negative\"\n              icon=\"delete\"\n              @click=\"showDeleteDialog(props.row)\"\n            /&gt;\n          &lt;/q-td&gt;\n        &lt;/q-tr&gt;\n      &lt;/template&gt;\n    &lt;/q-table&gt;\n    &lt;q-dialog v-model=\"showDelete\" persistent&gt;\n      &lt;q-card&gt;\n        &lt;q-card-section class=\"row items-center\"&gt;\n          &lt;q-icon\n            name=\"delete\"\n            size=\"sm\"\n            color=\"negative\"\n            @click=\"showDelete = true\"\n          /&gt;\n          &lt;span class=\"q-ml-sm\"&gt;\n            \u00bfEst\u00e1s seguro de que quieres borrar este elemento?\n          &lt;/span&gt;\n        &lt;/q-card-section&gt;\n\n        &lt;q-card-actions align=\"right\"&gt;\n          &lt;q-btn flat label=\"Cancelar\" color=\"primary\" v-close-popup /&gt;\n          &lt;q-btn\n            flat\n            label=\"Confirmar\"\n            color=\"primary\"\n            v-close-popup\n            @click=\"deleteCategory\"\n          /&gt;\n        &lt;/q-card-actions&gt;\n      &lt;/q-card&gt;\n    &lt;/q-dialog&gt;\n    &lt;q-dialog v-model=\"showAdd\"&gt;\n      &lt;q-card style=\"width: 300px\" class=\"q-px-sm q-pb-md\"&gt;\n        &lt;q-card-section&gt;\n          &lt;div class=\"text-h6\"&gt;Nueva categor\u00eda&lt;/div&gt;\n        &lt;/q-card-section&gt;\n\n        &lt;q-item-label header&gt;Nombre&lt;/q-item-label&gt;\n        &lt;q-item dense&gt;\n          &lt;q-item-section avatar&gt;\n            &lt;q-icon name=\"category\" /&gt;\n          &lt;/q-item-section&gt;\n          &lt;q-item-section&gt;\n            &lt;q-input\n              dense\n              v-model=\"categoryToAdd.name\"\n              autofocus\n              @keyup.enter=\"addCategory\"\n            /&gt;\n          &lt;/q-item-section&gt;\n        &lt;/q-item&gt;\n        &lt;q-card-actions align=\"right\" class=\"text-primary\"&gt;\n          &lt;q-btn flat label=\"Cancelar\" v-close-popup /&gt;\n          &lt;q-btn\n            flat\n            label=\"A\u00f1adir categor\u00eda\"\n            v-close-popup\n            @click=\"addCategory\"\n          /&gt;\n        &lt;/q-card-actions&gt;\n      &lt;/q-card&gt;\n    &lt;/q-dialog&gt;\n  &lt;/q-page&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport { ref } from 'vue';\nimport { useFetch, whenever } from '@vueuse/core';\n\nconst columns = [\n  { name: 'id', align: 'left', label: 'ID', field: 'id', sortable: true },\n  {\n    name: 'name',\n    align: 'left',\n    label: 'Nombre',\n    field: 'name',\n    sortable: true,\n  },\n  { name: 'options', align: 'left', label: 'Options', field: 'options' },\n];\nconst pagination = {\n  page: 1,\n  rowsPerPage: 0,\n};\nconst newCategory = {\n  name: '',\n  id: '',\n};\n\nconst categoriesData = ref([]);\nconst showDelete = ref(false);\nconst showAdd = ref(false);\nconst selectedRow = ref({});\nconst categoryToAdd = ref({ ...newCategory });\n\nconst getCategories = () =&gt; {\n  const { data } = useFetch('http://localhost:8080/category').get().json();\n  whenever(data, () =&gt; (categoriesData.value = data.value));\n};\ngetCategories();\n\nconst showDeleteDialog = (item: any) =&gt; {\n  selectedRow.value = item;\n  showDelete.value = true;\n};\n\nconst addCategory = async () =&gt; {\n  await useFetch('http://localhost:8080/category', {\n    method: 'PUT',\n    redirect: 'manual',\n    headers: {\n      accept: '*/*',\n      origin: window.origin,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(categoryToAdd.value),\n  })\n    .put()\n    .json();\n\n  getCategories();\n  categoryToAdd.value = newCategory;\n  showAdd.value = false;\n};\n\nconst editRow = (props: any, scope: any, field: any) =&gt; {\n  const row = {\n    name: props.row.name,\n  };\n  row[field] = scope.value;\n  scope.set();\n  editCategory(props.row.id, row);\n};\n\nconst editCategory = async (id: string, reqBody: any) =&gt; {\n  await useFetch(`http://localhost:8080/category/${id}`, {\n    method: 'PUT',\n    redirect: 'manual',\n    headers: {\n      accept: '*/*',\n      origin: window.origin,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(reqBody),\n  })\n    .put()\n    .json();\n\n  getCategories();\n};\n\nconst deleteCategory = async () =&gt; {\n  await useFetch(`http://localhost:8080/category/${selectedRow.value.id}`, {\n    method: 'DELETE',\n    redirect: 'manual',\n    headers: {\n      accept: '*/*',\n      origin: window.origin,\n      'Content-Type': 'application/json',\n    },\n  })\n    .delete()\n    .json();\n\n  getCategories();\n};\n&lt;/script&gt;\n</code></pre>"},{"location":"develop/basic/vuejs/#depuracion","title":"Depuraci\u00f3n","text":"<p>Una parte muy importante del desarrollo es tener la capacidad de depurar nuestro c\u00f3digo, en este apartado vamos a explicar como se realiza <code>debug</code> en Front.</p> <p>Esta parte se puede realizar con nuestro navegador favorito, en este caso vamos a utilizar Chrome.</p> <p>El primer paso es abrir las herramientas del desarrollador del navegador presionando <code>F12</code>.</p> <p></p> <p>En esta herramienta tenemos varias partes importantes:</p> <ul> <li>Elements: Inspector de los elementos del DOM de nuestra aplicaci\u00f3n que nos ayuda identificar el c\u00f3digo generado.</li> <li>Console: Consola donde podemos ver mensajes importantes que nos ayudan a identificar posibles problemas.</li> <li>Source: El navegador de ficheros que componen nuestra aplicaci\u00f3n.</li> <li>Network: El registro de peticiones que realiza nuestra aplicaci\u00f3n.</li> </ul> <p>Identificados los elementos importantes, vamos a depurar la operaci\u00f3n de crear categor\u00eda.</p> <p>Para ello nos dirigimos a la pesta\u00f1a de <code>Source</code>, en el \u00e1rbol de carpetas nos dirigimos a la ruta donde est\u00e1 localizado el c\u00f3digo de nuestra aplicaci\u00f3n <code>webpack://src/app</code>.</p> <p>Dentro de esta carpeta est\u00e9 localizado todo el c\u00f3digo fuente de la aplicaci\u00f3n, en nuestro caso vamos a localizar componente <code>category-edit.component</code> que crea una nueva categor\u00eda.</p> <p>Dentro del fichero ya podemos a\u00f1adir puntos de ruptura (breakpoint), en nuestro caso queremos comprobar que el nombre introducido se captura bien y se env\u00eda al service correctamente.</p> <p>Colocamos el breakpoint en la l\u00ednea de invocaci\u00f3n del service (click sobre el n\u00famero de la l\u00ednea) y desde la interfaz creamos una nueva categor\u00eda.</p> <p>Hecho esto, podemos observar que a nivel de interfaz, la aplicaci\u00f3n se detiene y aparece un panel de manejo de los puntos de interrupci\u00f3n:</p> <p></p> <p>En cuanto a la herramienta del desarrollador nos lleva al punto exacto donde hemos a\u00f1adido el breakpoint y se para en este punto ofreci\u00e9ndonos la posibilidad de explorar el contenido de las variables del c\u00f3digo:</p> <p></p> <p>Aqu\u00ed podemos comprobar que efectivamente la variable <code>category</code> tiene el valor que hemos introducido por pantalla y se propaga correctamente hacia el service.</p> <p>Para continuar con la ejecuci\u00f3n basta con darle al bot\u00f3n de <code>play</code> del panel de manejo de interrupci\u00f3n o al que aparece dentro de la herramienta de desarrollo (parte superior derecha).</p> <p>Por \u00faltimo, vamos a revisar que la petici\u00f3n REST se ha realizado correctamente al backend, para ello nos dirigimos a la pesta\u00f1a <code>Network</code> y comprobamos las peticiones realizadas:</p> <p></p> <p>Aqu\u00ed podemos observar el registro de todas las peticiones y haciendo click sobre una de ellas, obtenemos el detalle de esta.</p> <ul> <li>Header: Informaci\u00f3n de las cabeceras enviadas (aqu\u00ed podemos ver que se ha hecho un PUT a la ruta correcta).</li> <li>Payload: El cuerpo de la petici\u00f3n (vemos el cuerpo del mensaje con el nombre enviado).</li> <li>Preview: Respuesta de la petici\u00f3n normalizada (vemos la respuesta con el identificador creado para la nueva categor\u00eda).</li> </ul>"},{"location":"develop/basic/vuejsold/","title":"Listado simple - VUE","text":"<p>Ahora que ya tenemos listo el proyecto frontend de VUE, ya podemos empezar a codificar la soluci\u00f3n.</p>"},{"location":"develop/basic/vuejsold/#primeros-pasos","title":"Primeros pasos","text":"<p>Antes de empezar</p> <p>Quiero hacer hincapi\u00e9 que VUE tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. En la propia web de documentaci\u00f3n de VUE puedes buscar casi cualquier ejemplo que necesites.</p> <p>Si abrimos el proyecto con el IDE que tengamos (Visual Studio Code en el caso del tutorial) podemos ver que en la carpeta <code>src/</code> existen unos ficheros ya creados por defecto. Estos ficheros son:</p> <ul> <li><code>App.vue</code> \u2192 contiene el c\u00f3digo inicial del proyecto.</li> <li><code>main.ts</code> \u2192 es el punto de entrada a la aplicaci\u00f3n.</li> </ul> <p>Lo primero que vamos a hacer es instalar SASS para poder trabajar con este preprocesador CSS, para ello tendremos que irnos a la terminal, en la misma carpeta donde tenemos el proyecto y ejecutar el siguiente comando:</p> <pre><code>npm install -D sass\n</code></pre> <p>Con esto ya lo tendremos instalado y para usarlo es tan f\u00e1cil como poner la etiqueta style de esta manera:</p> <pre><code>&lt;style lang=\"scss\"&gt;&lt;/style&gt;  &lt;---&gt;  con Sass activado\n&lt;style&gt;&lt;/style&gt;  &lt;---&gt;  sin Sass, css normal\n</code></pre> <p>En los estilos tambi\u00e9n veremos la propiedad scoped en VUE, el atributo scoped se utiliza para limitar el \u00e1mbito de los estilos de un componente a los elementos del propio componente y no a los elementos hijos o padres, lo que ayuda a evitar conflictos de estilo entre los diferentes componentes de una aplicaci\u00f3n.</p> <p>Esto significa que los estilos definidos en una etiqueta <code>&lt;style scoped&gt;</code> solo se aplicar\u00e1n a los elementos dentro del componente actual, y no se propagar\u00e1n a otros componentes en la jerarqu\u00eda del DOM. De esta manera, se puede evitar que los estilos de un componente afecten a otros componentes en la aplicaci\u00f3n.</p> <pre><code>&lt;style scoped&gt;&lt;/style&gt;  &lt;---&gt;  Estos estilos solo afectar\u00e1n al componente donde se aplican\n&lt;style&gt;&lt;/style&gt;  &lt;---&gt;  Estos estilos son generales y afectan a toda la aplicaci\u00f3n.\n</code></pre> <p>Con estas cositas sobre los estilos en cabeza vamos lo primero a limpiar la aplicaci\u00f3n para poder empezar a trabajar desde cero.</p> <ul> <li>Entraremos en la carpeta <code>assets</code> y borraremos todos los archivos excepto <code>base.css</code>.</li> <li>Entraremos en la carpeta <code>components</code> y borraremos todos los archivos dejando solo la carpeta que usaremos m\u00e1s adelante.</li> <li>La carpeta <code>router</code> la dejaremos tal cual esta, sin tocar nada.</li> <li>Entraremos en la carpeta <code>views</code> y borraremos todos los archivos dejando solo la carpeta que usaremos m\u00e1s adelante.</li> </ul> <p>Con esto tenemos nuestra estructura preparada y quedar\u00eda tal que asi:</p> <p></p> <p>Vamos a a\u00f1adir unas l\u00edneas al <code>tsconfig.json</code> para que el typescript deje de marcarnos lo como error, lo dejaremos asi:</p> tsconfig.json <pre><code>{\n  \"extends\": \"@vue/tsconfig/tsconfig.web.json\",\n  \"include\": [\"env.d.ts\", \"src/**/*\", \"src/**/*.vue\"],\n  \"compilerOptions\": {\n    \"preserveValueImports\": false,\n    \"importsNotUsedAsValues\": \"remove\",\n    \"verbatimModuleSyntax\": true,\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"./src/*\"]\n    }\n  },\n\n  \"references\": [\n    {\n      \"path\": \"./tsconfig.node.json\"\n    }\n  ]\n}\n</code></pre> <p>Para que la aplicaci\u00f3n funcione de nuevo y poder empezar a trabajar faltar\u00eda hacer un par de cositas que os explico:</p> <ul> <li>En \u00e9l <code>base.css</code> no hace falta cambiar nada para que funcione, pero tenemos muchas cosas que seguramente no vamos a usar, este archivo lo conservamos solamente para trabajar en variables css todo el tema de los colores de nuestra web o algunas otras cositas como el ancho del menu o del header, etc\u2026 Lo primero vamos a eliminar todas las variables CSS y crearnos las nuestras propias con nuestro color primario y secundario tanto para botones y dem\u00e1s como para texto y tambi\u00e9n para el background principal. Tenemos que dejar nuestro archivo de esta manera:</li> </ul> base.css <pre><code>:root {\n  --primary: #2a6fa8;\n  --secondary: #12abdb;\n  --text-ligth: #2c3e50;\n  --text-dark: #fff;\n  --background-color: #fff;\n}\n\n*,\n*::before,\n*::after {\n  box-sizing: border-box;\n  margin: 0;\n  position: relative;\n  font-weight: normal;\n}\n\nbody {\n  min-height: 100vh;\n  color: var(--text-ligth);\n  background: var(--background-color);\n  line-height: 1.6;\n  font-family: Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu,\n    Cantarell, 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;\n  font-size: 16px;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n</code></pre> <ul> <li>Despu\u00e9s vamos a abrir el archivo <code>main.ts</code> y cambiaremos el import que hace del CSS por el base que es el que estamos usando, quedar\u00eda de esta manera:</li> </ul> main.ts <pre><code>import { createApp } from 'vue'\nimport App from './App.vue'\nimport router from './router'\n\nimport './assets/base.css'\n\nconst app = createApp(App)\n\napp.use(router)\n\napp.mount('#app')\n</code></pre> <ul> <li>Luego abriremos el archivo <code>App.vue</code> y lo dejaremos solo como la entrada a la aplicaci\u00f3n, esto ya son maneras de trabajar de cada uno, pero a m\u00ed me gusta hacerlo asi para tener si hiciera falta diferentes layouts, uno con header y men\u00fa, otro sin header y men\u00fa, otro de la parte de admin, etc\u2026 Lo dejaremos exactamente asi:</li> </ul> App.vue <pre><code>&lt;script setup lang=\"ts\"&gt;\nimport { RouterView } from 'vue-router'\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;RouterView /&gt;\n&lt;/template&gt;\n</code></pre> <ul> <li>Por \u00faltimo crearemos nuestro layout principal al que iremos a\u00f1adiendo luego toda nuestra aplicaci\u00f3n. Lo primero nos pondremos en <code>src</code> y crearemos una nueva carpeta llamada <code>layouts</code>, dentro de esta carpeta crearemos otra que se llamara <code>main-layout</code> (esto lo hacemos por si luego tenemos m\u00e1s de un layout que cada uno tenga su carpeta para tener sus propias cosas) y dentro de la carpeta <code>main-layout</code> crearemos el archivo <code>MainLayout.vue</code>, nos deber\u00eda de quedar asi:</li> </ul> <p></p> <p>Una vez tenemos el archivo <code>MainLayout.vue</code> creado lo abriremos y escribiremos el siguiente c\u00f3digo:</p> MainLayout.vue <pre><code>&lt;script setup lang=\"ts\"&gt;\n    const helloWorld = 'Hola Mundo';\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;h1&gt;{{ helloWorld }}&lt;/h1&gt;\n&lt;/template&gt;\n</code></pre> <p>Vamos a intentar explicar este c\u00f3digo un poco:</p> <ul> <li>Dentro de las etiquetas <code>script</code> metemos todo el c\u00f3digo Javascript, en este caso como vamos a trabajar con Typescript le ponemos la etiqueta <code>Lang=\u201dts\u201d</code> para que el compilador sepa que estamos trabajando con Typescript.</li> <li>Ponemos la palabra <code>setup</code> porque estamos trabajando con la <code>composition api</code>, en VUE podemos trabajar con la <code>options api</code> y con la <code>composition api</code>, nosotros vamos a usar la <code>composition api</code> que aunque al principio cuesta un poco m\u00e1s, luego nos va a hacer la vida much\u00edsimo m\u00e1s f\u00e1cil, sobre todo en aplicaciones \"reales\".</li> <li>Dentro de las etiquetas <code>template</code> va el HTML y como estamos usando el m\u00e9todo <code>setup</code> no necesitamos retornar nada para poder acceder a ello desde la plantilla.</li> </ul> <p>Las llaves dobles permiten hacen un binding entre el c\u00f3digo del componente y la plantilla. Es decir, en este caso ir\u00e1 al c\u00f3digo TypeScript y buscar\u00e1 el valor de la variable helloWorld.</p> <p>Consejo</p> <p>El binding tambi\u00e9n nos sirve para ejecutar los m\u00e9todos de TypeScript desde el c\u00f3digo HTML. Adem\u00e1s, si el valor que contiene la variable se modificar\u00e1 durante la ejecuci\u00f3n de alg\u00fan m\u00e9todo, autom\u00e1ticamente el c\u00f3digo HTML refrescar\u00eda el nuevo valor de la variable <code>helloWorld</code>.</p> <p>Ponemos en marcha la aplicaci\u00f3n con <code>npm run dev</code>.</p> <p>Si abrimos el navegador y accedemos a <code>http://localhost:5173/</code> podremos ver el resultado del c\u00f3digo.</p>"},{"location":"develop/basic/vuejsold/#layout-general","title":"Layout general","text":""},{"location":"develop/basic/vuejsold/#crear-componente","title":"Crear componente","text":"<p>Lo primero que vamos a hacer es escoger un tema y una paleta de componentes para trabajar. VUE no tiene una librer\u00eda de componentes oficial al igual que, por ejemplo, Angular tiene Material, por lo que podremos elegir entre las diferentes opciones y ver la que m\u00e1s se ajusta a las necesidades del proyecto o crearnos la nuestra propia, si entramos en proyectos ya comenzados, seguramente este paso ya habr\u00e1 sido abordado y ya sabr\u00e1s con qu\u00e9 librer\u00eda de componentes trabajar, para este proyecto vamos a optar por PrimeVue, no tenemos ning\u00fan motivo especial para decidir esa en especial, pero la hemos usado en un curso anterior y optamos por seguir con la misma librer\u00eda.</p> <p>Para instalarla bastar\u00e1 con seguir los pasos de su documentaci\u00f3n.</p> <p>Vamos a hacerlo y la instalamos en nuestro proyecto:</p> <ul> <li>Lo primero ejecutaremos el comando npm o yarn para instalarla, en mi caso lo hare con npm:</li> <li> <pre><code>npm install primevue\n</code></pre> </li> <li> <p>Despu\u00e9s instalaremos PrimeVue con la funci\u00f3n <code>use</code> en el <code>main.ts</code> que es donde tenemos nuestra configuraci\u00f3n, quedando asi nuestro <code>main.ts</code>:</p> </li> </ul> <p></p> <ul> <li>Despu\u00e9s a\u00f1adiremos los estilos necesarios a nuestro <code>main.ts</code>:</li> </ul> <p></p> <ul> <li>Por \u00faltimo en nuestro <code>base.css</code> cambiaremos la fuente del proyecto por la que trae el tema de PrimeVue, cambiando en el <code>body</code> la l\u00ednea:</li> </ul> base.css <pre><code>...\n font-family: Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu,\n Cantarell, 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;\n...\n</code></pre> <p>Por:</p> base.css <pre><code>...\nfont-family: (--font-family);\n...\n</code></pre> <p>Recuerda</p> <p>Al a\u00f1adir una nueva librer\u00eda tenemos que parar el servidor y volver a arrancarlo para que compile y pre-cargue las nuevas dependencias.</p> <p>Una vez a\u00f1adida la dependencia, lo que queremos es crear una primera estructura inicial a la p\u00e1gina. Si te acuerdas cual era la estructura (y si no te acuerdas, vuelve a la secci\u00f3n Contexto de la aplicaci\u00f3n y lo revisas), ten\u00edamos una cabecera superior con un logo y t\u00edtulo y unas opciones de men\u00fa.</p> <p>Antes de empezar a crear y programar vamos a instalar unas extensiones en Visual Studio Code que nos har\u00e1n la vida mucho mas f\u00e1cil, en cada una de ellas podeis ver una descripci\u00f3n de que hacen y para que sirven, tu ya dices si la quieres instalar o no, nosotros vamos a trabajar con ellas y por eso te las recomendamos:</p> <ul> <li>Vue Volar extension Pack</li> <li>Vue Discovery</li> <li>IntelliCode</li> <li>npm Intellisense</li> <li>Vue VSCode Snippets</li> </ul> <p>Para poder seguir trabajando con comodidad vamos a a\u00f1adir una fuente de iconos para todos los iconitos que usemos en la aplicaci\u00f3n, nosotros vamos a usar Material porque es la que estamos acostumbrados, para a\u00f1adirla tenemos una gu\u00eda.</p> <p>Lo haremos paso a paso:</p> <ul> <li>Lo primero a\u00f1adimos al <code>index.html</code> la fuente a trav\u00e9s de Google fonts, hay muchas otras maneras de hacerlo, como bajarla y servirla desde local, pero para este tutorial vamos a usar esta por ser la m\u00e1s f\u00e1cil, para a\u00f1adirla pegaremos en el <code>index.html</code> esta l\u00ednea:</li> </ul> <pre><code>&lt;link href=\"https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined\" rel=\"stylesheet\" /&gt;\n</code></pre> <p>Quedando de esta manera:</p> index.html <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;link rel=\"icon\" href=\"/favicon.ico\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;link\n      href=\"https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined\"\n      rel=\"stylesheet\"\n    /&gt;\n    &lt;title&gt;Vite App&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"app\"&gt;&lt;/div&gt;\n    &lt;script type=\"module\" src=\"/src/main.ts\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Para que no nos salga el error de comments, a\u00f1adiremos al <code>eslintrc.js</code> estas l\u00edneas:</p> eslintrc.js <pre><code>...\nrules: {\n    'vue/comment-directive': 'off'\n}\n...\n</code></pre> <p>Despu\u00e9s nos iremos al fichero <code>base.css</code> y a\u00f1adiremos esto al final del archivo:</p> base.css <pre><code>...\n.material-symbols-outlined {\n  font-family: \"Material Symbols Outlined\", sans-serif;\n  font-weight: normal;\n  font-style: normal;\n  font-size: 24px;  /* Preferred icon size */\n  display: inline-block;\n  line-height: 1;\n  text-transform: none;\n  letter-spacing: normal;\n  word-wrap: normal;\n  white-space: nowrap;\n  direction: ltr;\n}\n</code></pre> <p>Con esto ya tendremos a\u00f1adida la fuente material-symbols y podremos usar todos los iconos disponibles.</p> <ul> <li>Despu\u00e9s instalaremos tambi\u00e9n los iconos de PrimeVue para poder usarlos f\u00e1cilmente en los componentes, lo primero pondremos:</li> </ul> <pre><code>npm install primeicons\n</code></pre> <p>Una vez instalados, importaremos los iconos en el <code>main.ts</code> poniendo este import debajo de todos los de css:</p> main.ts <pre><code>...\nimport 'primeicons/primeicons.css';\n...\n</code></pre> <p>Con esto ya lo tendr\u00edamos todo.</p> <p>Pues vamos a ello, con las extensiones ya instaladas y la fuente para los iconos a\u00f1adida crearemos esa estructura com\u00fan para toda la aplicaci\u00f3n.</p> <p>Lo primero crearemos el componente header, dentro de la carpeta components al ser un m\u00f3dulo de la aplicaci\u00f3n y no especifico de una vista o p\u00e1gina. Para eso crearemos una nueva carpeta dentro de components que llamaremos header, nos situaremos encima de la carpeta header y crearemos el archivo <code>HeaderComponent.vue</code>, con el archivo vac\u00edo escribiremos, <code>vbase-3-ts-setup</code> y conforme lo escribimos nos aparecer\u00e1 esto:</p> <p></p> <p>Consejo</p> <p>Esto nos aparece gracias a las extensiones que hemos instalado, aseg\u00farate de instalarlas para que aparezca o si no las quieres instalar lo puedes crear a mano. Si no te aparece y has instalado las extensiones, cierra vscode y vu\u00e9lvelo a abrir.</p> <p>Podemos seleccionar <code>vbase-3-ts-setup</code>, esto es un snippet que lo que har\u00e1 es generarnos todo el c\u00f3digo de un componente vac\u00edo y lo dejara asi:</p> HeaderComponent.vue <pre><code>&lt;template&gt;\n    &lt;div&gt;\n\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\n\n&lt;/script&gt;\n\n&lt;style scoped&gt;\n\n&lt;/style&gt;\n</code></pre> <p>Con esto solo nos faltar\u00eda agregar a la etiqueta style que vamos a trabajar con Sass y la dejar\u00edamos asi:</p> HeaderComponent.vue <pre><code>...\n&lt;style lang=\"scss\" scoped&gt;\n\n&lt;/style&gt;\n...\n</code></pre> <p>Si os dais cuenta hemos a\u00f1adido <code>Lang=\u201dscss\u201d</code> y con esto ya estamos preparados para crear nuestro componente.</p> <p>Para continuar cambiaremos el c\u00f3digo del <code>HeaderComponent.vue</code> por este:</p> HeaderComponent.vue <pre><code>&lt;template&gt;\n  &lt;div class=\"card relative z-2\"&gt;\n    &lt;Menubar :model=\"items\"&gt;\n      &lt;template #start&gt;\n        &lt;span class=\"material-symbols-outlined\"&gt;storefront&lt;/span&gt;\n        &lt;span class=\"title\"&gt;LUDOTECA TAN&lt;/span&gt;\n      &lt;/template&gt;\n      &lt;template #end&gt;\n        &lt;Avatar icon=\"pi pi-user\" class=\"mr-2 avatar-image\" size=\"large\" shape=\"circle\" /&gt;\n        &lt;span class=\"sign-text\"&gt;Sign in&lt;/span&gt;\n      &lt;/template&gt;\n    &lt;/Menubar&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport { ref } from \"vue\";\nimport Menubar from \"primevue/menubar\";\nimport Avatar from \"primevue/avatar\";\n\nconst items = ref([\n  {\n    label: \"Cat\u00e1logo\",\n  },\n  {\n    label: \"Categor\u00edas\",\n  },\n  {\n    label: \"Autores\",\n  },\n]);\n&lt;/script&gt;\n\n&lt;style lang=\"scss\" scoped&gt;\n.p-menubar {\n  padding: 0.5rem;\n  background: var(--primary);\n  color: var(--text-dark);\n  border: none;\n  border-radius: 0px;\n}\n\n.title {\n  margin-left: 1rem;\n  font-weight: 600;\n}\n\n.avatar-image {\n  background-color: var(--secondary);\n  color: var(--text-dark);\n  border: 1px solid var(--text-dark);\n  cursor: pointer;\n}\n\n.sign-text {\n  color: var(--text-dark);\n  margin-left: 1rem;\n  cursor: pointer;\n}\n\n:deep(.p-menubar-start) {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: center;\n  margin-right: 1rem;\n}\n\n:deep(.p-menubar-end) {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: center;\n}\n\n:deep(.p-menuitem-text) {\n  color: var(--text-dark) !important;\n}\n\n:deep(.p-menuitem-content:hover) {\n  background: var(--secondary) !important;\n}\n\n.material-symbols-outlined {\n  font-size: 36px;\n}\n&lt;/style&gt;\n</code></pre> <p>Intentaremos explicarlo un poco:</p> <p>En el template estamos a\u00f1adiendo el <code>Menubar</code> de la librer\u00eda de componentes que estamos utilizando, si queremos saber como se a\u00f1ade podemos verlo en este link.</p> <p>Veremos que lo primero que hacemos es el <code>import</code> dentro de las etiquetas <code>&lt;script&gt;</code> para poder tener el componente disponible y poder usarlo.</p> HeaderComponent.vue <pre><code>...\nimport Menubar from \"primevue/menubar\";\n...\n</code></pre> <p>Luego, con el <code>import</code> ya hecho, podemos copiar el HTML que nos dan y ponerlo en nuestro componente:</p> HeaderComponent.vue <pre><code>...\n&lt;div class=\"card relative z-2\"&gt;\n    &lt;Menubar :model=\"items\"&gt;\n        &lt;template #start&gt;\n            &lt;span class=\"material-symbols-outlined\"&gt;storefront&lt;/span&gt;\n            &lt;span class=\"title\"&gt;LUDOTECA TAN&lt;/span&gt;\n        &lt;/template&gt;\n        &lt;template #end&gt;\n            &lt;Avatar icon=\"pi pi-user\" class=\"mr-2 avatar-image\" size=\"large\" shape=\"circle\" /&gt;\n            &lt;span class=\"sign-text\"&gt;Sign in&lt;/span&gt;\n        &lt;/template&gt;\n    &lt;/Menubar&gt;\n&lt;/div&gt;\n...\n</code></pre> <p>Si os dais cuenta es el c\u00f3digo que ellos nos dan retocado para cubrir nuestras necesidades, primero hemos metido un icono de material dentro del template <code>#start</code> que es lo que se situara al principio pegado a la izquierda del <code>Menubar</code> y tras el icono metemos el t\u00edtulo.</p> <p>El template <code>#end</code> se situar\u00e1 al final pegado a la derecha y alli estamos metiendo otro componente de la librer\u00eda de componentes, pod\u00e9is ver la info de como usarlo en este link.</p> <p>Este simplemente lo pegamos como esta y le a\u00f1adimos detr\u00e1s la frase <code>Sign in</code>.</p> <p>En la parte del script metemos todo nuestro Javascript/Typescript:</p> HeaderComponent.vue <pre><code>...\n&lt;script setup lang=\"ts\"&gt;\nimport { ref } from \"vue\";\nimport Menubar from \"primevue/menubar\";\nimport Avatar from \"primevue/avatar\";\n\nconst items = ref([\n  {\n    label: \"Cat\u00e1logo\",\n  },\n  {\n    label: \"Categor\u00edas\",\n  },\n  {\n    label: \"Autores\",\n  },\n]);\n&lt;/script&gt;\n...\n</code></pre> <p>Si os dais cuenta, lo \u00fanico que estamos haciendo son los imports necesarios para que todo funcione y creando una variable <code>\u00edtems</code> que es la que luego estamos usando en el men\u00fa para pintar los diferentes menus. Si os dais cuenta envolvemos el valor de la variable dentro de <code>ref()</code>. En Vue 3, la funci\u00f3n <code>ref()</code> se utiliza para crear una referencia reactiva a un valor. Una referencia reactiva es un objeto que puede ser pasado como prop, utilizado en una plantilla, y observado para detectar cambios en su valor.</p> <p>La funci\u00f3n <code>ref()</code> toma un valor como argumento y devuelve un objeto con una propiedad value que contiene el valor proporcionado. Por ejemplo, si queremos crear una referencia a un n\u00famero entero, podemos hacer lo siguiente:</p> <pre><code>import { ref } from 'vue'\nconst myNumber = ref(42)\nconsole.log(myNumber.value) // 42\n</code></pre> <p>La referencia <code>myNumber</code> es ahora un objeto con una propiedad value que contiene el valor <code>42</code>. Si cambiamos el valor de la propiedad <code>value</code>, la referencia notificar\u00e1 a cualquier componente que est\u00e9 observando el valor que ha cambiado. Por ejemplo:</p> <pre><code>myNumber.value = 21\nconsole.log(myNumber.value) // 21\n</code></pre> <p>Cualquier componente que est\u00e9 utilizando myNumber se actualizar\u00e1 autom\u00e1ticamente para reflejar el nuevo valor. La funci\u00f3n <code>ref()</code> es muy \u00fatil en Vue 3 para crear referencias reactivas a valores que pueden cambiar con el tiempo.</p> <p>En los styles tenemos poco que explicar, simplemente estamos haciendo que se vea como nosotros queremos, que todos los colores y dem\u00e1s los traemos de las variables que hemos creado antes en el <code>base.css</code> y adem\u00e1s me gustar\u00eda mencionar una cosa:</p> HeaderComponent.vue <pre><code>...\n:deep(.p-menubar-start) {\n    display: flex;\n    flex-direction: row;\n    align-items: center;\n    justify-content: center;\n    margin-right: 1rem;\n}\n...\n</code></pre> <p>Si os dais cuenta algunos estilos llevan el :Deep delante, como seguro ya sabes, puedes utilizar el atributo <code>scoped</code> dentro de la etiqueta <code>&lt;style&gt;</code> para escribir CSS y as\u00ed impedir que tus estilos afecten a posibles sub-componentes. Pero, \u00bfqu\u00e9 ocurre si necesitas que al menos una regla s\u00ed afecte a tu componente hijo?. Para ello puedes usar la pseudo-clase <code>:deep</code> de Vue 3.</p> <p>En este ejemplo lo hemos creado asi para que sepas de su existencia y busques un poco de informaci\u00f3n sobre ella y las otras que existen, este CSS lo podr\u00edamos poner en el <code>styles.scss</code> principal y no tendr\u00edamos que poner el <code>:deep</code> que seria lo mas recomendado. Es importante tener en cuenta que la directiva <code>:deep</code> puede tener un impacto en el rendimiento, ya que Vue necesita buscar en todo el \u00e1rbol de elementos para aplicar los estilos. Por lo tanto, se recomienda utilizar esta directiva con moderaci\u00f3n y solo en casos en los que sea necesario seleccionar elementos anidados de forma din\u00e1mica. Tenerlo en cuenta y solo usarla cuando de verdad sea necesario.</p> <p>Ya por \u00faltimo nos iremos a nuestro <code>MainLayout.vue</code> y a\u00f1adiremos el header que acabamos de crearnos:</p> MainLayout.vue <pre><code>&lt;script setup lang=\"ts\"&gt;\n    import HeaderComponent from '@/components/header/HeaderComponent.vue';\n\n    const helloWorld = 'Hola Mundo';\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;HeaderComponent&gt;&lt;/HeaderComponent&gt;\n    &lt;h1&gt;{{ helloWorld }}&lt;/h1&gt;\n&lt;/template&gt;\n</code></pre> <p>Como antes, lo \u00fanico que hacemos es importar el componente en el <code>script</code> y usarlo en el HTML.</p> <p>Lo siguiente iremos a la carpeta <code>router</code>, al archivo <code>index.ts</code> y lo dejaremos asi:</p> index.ts <pre><code>import { createRouter, createWebHistory } from 'vue-router'\nimport MainLayout from '@/layouts/main-layout/MainLayout.vue'\n\nconst router = createRouter({\n    history: createWebHistory(import.meta.env.BASE_URL),\n    routes: [\n        {\n            path: '/',\n            name: 'home',\n            component: MainLayout\n        }\n    ]\n})\n\nexport default router\n</code></pre> <p>Hemos cambiado la ruta principal para que apunte a nuestro <code>layout</code> y nada m\u00e1s entrar en la aplicaci\u00f3n lo carguemos gracias al router de VUE.</p> <p>Si guardamos todo y ponemos en marcha el proyecto ya veremos algo como esto:</p> <p></p>"},{"location":"develop/basic/vuejsold/#creando-un-listado-basico","title":"Creando un listado b\u00e1sico","text":""},{"location":"develop/basic/vuejsold/#crear-componente_1","title":"Crear componente","text":"<p>Ya tenemos la estructura principal, ahora vamos a crear nuestra primera pantalla. Vamos a empezar por la de Categor\u00edas que es la m\u00e1s sencilla, ya que se trata de un listado, que muestra datos sin filtrar ni paginar.</p> <p>Como categor\u00edas es un dominio funcional de la aplicaci\u00f3n, vamos a crear una nueva carpeta dentro de la carpeta <code>views</code> llamada categories, todas las pantallas, componentes y servicios que creemos, referidos a este dominio funcional, deber\u00e1n ir dentro del m\u00f3dulo categories. Dentro de esa carpeta crearemos un fichero que se llamara <code>CategoriesView.vue</code> y dentro nos crearemos el esqueleto de la misma manera que hicimos anteriormente.</p> <p>Escribiremos <code>vbase-3-ts-setup</code>, le daremos al enter y nos generara toda la estructura a la que solo faltara agregar a la etiqueta <code>&lt;style&gt; Lang=\u201dscss\u201d</code> para decirle que vamos a trabajar con SASS. Con esto tenemos nuestra vista preparada para empezar a trabajar.</p> <p>Lo primero vamos a conectar nuestro componente al <code>router</code> para que cuando hagamos click en el men\u00fa correspondiente podamos llegar hasta \u00e9l y tambi\u00e9n para poder ver lo que vamos trabajando. Para ello lo primero que vamos a hacer en el template de nuestro componente es a\u00f1adir cualquier cosa para saber que estamos donde toca, por ejemplo:</p> CategoriesView.vue <pre><code>&lt;template&gt;\n  &lt;div&gt;SOY CATEGORIAS&lt;/div&gt;\n&lt;/template&gt;\n</code></pre> <p>Con esto cuando entremos en la ruta de categor\u00edas deber\u00edamos ver <code>SOY CATEGORIAS</code>.</p> <p>Lo siguiente crearemos en el <code>layout</code> un sitio para cargar todas nuestras rutas que van a ir dentro de ese layout, para ello iremos al archivo <code>MainLayout.vue</code> y a\u00f1adiremos un <code>&lt;RouterView /&gt;</code> que ser\u00e1 el segundo de nuestra aplicaci\u00f3n, el primero lo tenemos en el <code>App.vue</code> que servir\u00e1 para cargar nuestras rutas principales (diferentes layouts, pagina 404, etc) y el segundo es este que acabamos de crear, podemos tener tantos como queramos en una aplicaci\u00f3n y cada uno tendr\u00e1 su cometido. Este que acabamos de crear ser\u00e1 donde se cargaran todas las rutas que quieran estar dentro del <code>layout</code> principal.</p> <p>Para crearlo importaremos \u00e9l <code>RouterView</code> dentro de los <code>&lt;script&gt;</code> desde <code>vue-router</code>:</p> MainLayout.vue <pre><code>import { RouterView } from 'vue-router';\n</code></pre> <p>Lo a\u00f1adiremos dentro de los <code>&lt;template&gt;</code> exactamente donde queramos cargar las rutas y si puede ser con un <code>div</code> padre que haga de contenedor asi podremos darle los estilos sin sufrir demasiado.</p> MainLayout.vue <pre><code>&lt;div class=\"outlet-container\"&gt;\n    &lt;RouterView /&gt;\n&lt;/div&gt;\n</code></pre> <p>Y luego dentro de <code>&lt;style&gt;</code> le daremos estilo al contenedor padre de acuerdo a lo que necesitemos (grid, flex, etc\u2026) en este ejemplo para hacerlo f\u00e1cil lo haremos con flex, con todo esto quedar\u00eda asi:</p> MainLayout.vue <pre><code>&lt;script setup lang=\"ts\"&gt;\nimport { RouterView } from 'vue-router';\nimport HeaderComponent from \"@/components/header/HeaderComponent.vue\";\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;HeaderComponent&gt;&lt;/HeaderComponent&gt;\n  &lt;div class=\"outlet-container\"&gt;\n    &lt;RouterView /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style lang=\"scss\" scoped&gt;\n.outlet-container {\n  display: flex;\n  flex-direction: column;\n  flex-grow: 1;\n  width: 100%;\n  min-height: calc(100vh - 65px);\n  padding: 1rem;\n}\n&lt;/style&gt;\n</code></pre> <p>Ahora vamos a a\u00f1adirlo a nuestras rutas, para ello nos vamos a la carpeta <code>router</code> y dentro tendremos el <code>index.ts</code> con nuestras rutas actuales, vamos a a\u00f1adir la nueva ruta como hija de <code>layout</code> para que siempre se muestre dentro del <code>layout</code> que hemos creado con \u00e9l <code>header</code>:</p> index.ts <pre><code>import { createRouter, createWebHistory } from 'vue-router'\nimport MainLayout from '@/layouts/main-layout/MainLayout.vue'\n\nconst router = createRouter({\n    history: createWebHistory(import.meta.env.BASE_URL),\n    routes: [\n        {\n            path: '/',\n            name: 'home',\n            component: MainLayout,\n            children: [\n                {\n                    path: '/categories',\n                    name: 'categories',\n                    component: () =&gt; import('../views/categories/CategoriesView.vue')\n                }\n            ]\n        }\n    ]\n})\n\nexport default router\n</code></pre> <p>Si os dais cuenta lo hemos a\u00f1adido como hijo de <code>layout</code> y adem\u00e1s lo hemos hecho con <code>lazy loading</code>, es decir, este componente solo se cargara cuando el usuario navegue a esa ruta, asi evitamos cargas much\u00edsimo m\u00e1s grandes al inicio de la aplicaci\u00f3n.</p> <p>Posteriormente nos iremos al <code>HeaderComponent.vue</code> y a\u00f1adiremos la ruta a los \u00edtems del men\u00fa de esta manera:</p> HeaderComponent.vue <pre><code>const items = ref([\n    {\n        label: \"Cat\u00e1logo\",\n    },\n    {\n        label: \"Categor\u00edas\",\n        to: { name: 'categories'}\n    },\n    {\n        label: \"Autores\",\n    },\n]);\n</code></pre> <p>Si nos fijamos hemos a\u00f1adido la navegaci\u00f3n por el nombre de ruta en el men\u00fa categor\u00edas para que sepa cuando apretemos ese men\u00fa donde nos tiene que llevar.</p> <p>Con todo esto si ponemos en marcha nuestra aplicaci\u00f3n, ya podremos navegar haciendo click en el men\u00fa Categor\u00edas a esta nueva ruta que hemos creado y ya ver\u00edamos el <code>SOY CATEGORIAS</code> pero tenemos un problemilla en los menus, cuando apretamos un men\u00fa se pone el fondo gris, lo cual no nos gusta y adem\u00e1s aunque estemos en categor\u00edas si apretamos en otro men\u00fa se pone el otro gris y se quita el categor\u00edas lo cual tampoco es lo deseado ya que queremos que se quede marcado el men\u00fa donde estamos actualmente para informaci\u00f3n del usuario. Para ello nos iremos al <code>base.css</code> y a\u00f1adiremos al final estas l\u00edneas:</p> base.css <pre><code>...\n.router-link-active {\n    background: var(--secondary);\n    border-radius: 5px;\n}\n\n.p-menuitem.p-focus &gt; .p-menuitem-content:not(:hover) {\n    background: transparent !important;\n}\n</code></pre> <p>En Vue 3, la directiva <code>router-link-active</code> se utiliza para establecer una clase CSS en un enlace de router activo, con esto ya tendremos resuelto el problema y todo estar\u00e1 funcionando como toca y poniendo en marcha la aplicaci\u00f3n y haciendo click en el men\u00fa Categor\u00edas ya deber\u00edamos ver esto:</p> <p></p>"},{"location":"develop/basic/vuejsold/#codigo-de-la-pantalla","title":"C\u00f3digo de la pantalla","text":"<p>Ahora vamos a construir la pantalla. Para manejar la informaci\u00f3n del listado, necesitamos tipar los datos para que Typescript no se queje. Para ello crearemos un fichero en <code>categories\\models\\category-interface.ts</code> donde implementaremos la interface necesaria. Esta interface ser\u00e1 la que utilizaremos para tipar el c\u00f3digo de nuestro componente.</p> category-interface.ts <pre><code>export interface Category {\n    id: number\n    name: string\n}\n</code></pre> <p>Tambi\u00e9n, escribiremos el c\u00f3digo de <code>CategoriesView.vue</code>:</p> CategoriesView.vue <pre><code>&lt;template&gt;\n  &lt;div class=\"card\"&gt;\n    &lt;DataTable\n      v-model:editingRows=\"editingRows\"\n      :value=\"categories\"\n      tableStyle=\"min-width: 50rem\"\n      editMode=\"row\"\n      dataKey=\"id\"\n      @row-edit-save=\"onRowEditSave\"\n    &gt;\n      &lt;Column field=\"id\" header=\"IDENTIFICADOR\"&gt;\n        &lt;template #editor=\"{ data, field }\"&gt;\n          &lt;InputText v-model=\"data[field]\" /&gt;\n        &lt;/template&gt;\n      &lt;/Column&gt;\n      &lt;Column field=\"name\" header=\"NOMBRE CATEGOR\u00cdA\"&gt;\n        &lt;template #editor=\"{ data, field }\"&gt;\n          &lt;InputText v-model=\"data[field]\" /&gt;\n        &lt;/template&gt;\n      &lt;/Column&gt;\n      &lt;Column\n        :rowEditor=\"true\"\n        style=\"width: 110px\"\n        bodyStyle=\"text-align:center\"\n      &gt;&lt;/Column&gt;\n      &lt;Column\n        style=\"width: 30px; padding: 0px 2rem 0px 0px; color: red\"\n        bodyStyle=\"text-align:center\"\n      &gt;\n        &lt;template #body=\"{ data }\"&gt;\n          &lt;i class=\"pi pi-times\" @click=\"onRowDelete(data)\"&gt;&lt;/i&gt;\n        &lt;/template&gt;\n      &lt;/Column&gt;\n    &lt;/DataTable&gt;\n  &lt;/div&gt;\n  &lt;div class=\"actions\"&gt;\n    &lt;Button label=\"Nueva categor\u00eda\" /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport { ref } from \"vue\";\nimport DataTable, { type DataTableRowEditSaveEvent } from \"primevue/datatable\";\nimport Column from \"primevue/column\";\nimport InputText from \"primevue/inputtext\";\nimport Button from 'primevue/button';\nimport type { CategoryInterface } from \"./model/category.interface\";\nconst categories = ref([]);\nconst editingRows = ref([]);\nconst onRowEditSave = (event: DataTableRowEditSaveEvent) =&gt; {\n  console.log(event);\n};\nconst onRowDelete = (data: CategoryInterface) =&gt; {\n  console.log(data);\n}\n&lt;/script&gt;\n\n&lt;style lang=\"scss\" scoped&gt;\n.actions {\n  display: flex;\n  flex-direction: row;\n  margin-top: 1rem;\n  justify-content: flex-end;\n}\n\n.p-button {\n  background: var(--primary);\n  border: 1px solid var(--primary);\n\n  &amp;:enabled {\n    &amp;:hover {\n      background: var(--secondary);\n      border-color: var(--secondary);\n    }\n  }\n}\n&lt;/style&gt;\n</code></pre> <p>Intentaremos explicar un poco el c\u00f3digo:</p> <p>Lo primero vamos a importar el componente DataTable desde la librer\u00eda de componentes que estamos usando, para ello podemos ver algunos ejemplos de como hacerlo en la documentaci\u00f3n oficial</p> <p>Nosotros hemos puesto las importaciones que necesitamos en el <code>&lt;script&gt;</code>:</p> CategoriesView.vue <pre><code>import DataTable, { type DataTableRowEditSaveEvent } from \"primevue/datatable\";\nimport Column from \"primevue/column\";\n</code></pre> <p>Hemos creado nuestra tabla con las exigencias de la aplicaci\u00f3n, hemos puesto dos columnas, la columna identificador donde en \u00e9l <code>header=\u201d\u201d</code> le ponemos que nombre se muestra en la cabecera y le hemos dicho que debe mostrar en ella el dato id poni\u00e9ndolo en \u00e9l <code>field=\u201d\u201d</code>.</p> CategoriesView.vue <pre><code>&lt;Column field=\"id\" header=\"IDENTIFICADOR\"&gt;&lt;/Column&gt;\n</code></pre> <p>Como a la tabla le hemos dicho que debe ser editable con:</p> CategoriesView.vue <pre><code>editMode=\"row\"\n</code></pre> <p>Le decimos a esta columna que debe hacer cuando entremos en modo de edici\u00f3n, con el template le decimos que mostrara un <code>InputText</code> que es otro componente de la librer\u00eda de componentes que viene a ser un input de toda la vida donde podemos escribir texto para editar el valor, quedando al final asi:</p> CategoriesView.vue <pre><code>&lt;Column field=\"id\" header=\"IDENTIFICADOR\"&gt;\n    &lt;template #editor=\"{ data, field }\"&gt;\n        &lt;InputText v-model=\"data[field]\" /&gt;\n    &lt;/template&gt;\n&lt;/Column&gt;\n</code></pre> <p>Luego hemos creado dos columnas, una que tiene el l\u00e1piz y activa el modo edici\u00f3n:</p> CategoriesView.vue <pre><code>&lt;Column\n    :rowEditor=\"true\"\n    style=\"width: 110px\"\n    bodyStyle=\"text-align:center\"&gt;\n&lt;/Column&gt;\n</code></pre> <p>Y otra que tiene la X y lo que har\u00e1 ser\u00e1 borrar la fila:</p> CategoriesView.vue <pre><code>&lt;Column\n    style=\"width: 30px; padding: 0px 2rem 0px 0px; color: red\"\n    bodyStyle=\"text-align:center\"\n&gt;\n    &lt;template #body=\"{ data }\"&gt;\n    &lt;i class=\"pi pi-times\" @click=\"onRowDelete(data)\"&gt;&lt;/i&gt;\n    &lt;/template&gt;\n&lt;/Column&gt;\n</code></pre> <p>Al final a\u00f1adimos otro contenedor que vale para alojar los botones como en nuestro caso el de crear nueva categor\u00eda, el bot\u00f3n es tambi\u00e9n un componente de la librer\u00eda por lo que tendremos que hacer su import en la etiqueta <code>&lt;script&gt;</code>:</p> CategoriesView.vue <pre><code>&lt;div class=\"actions\"&gt;\n    &lt;Button label=\"Nueva categor\u00eda\" /&gt;\n&lt;/div&gt;\n</code></pre> <p>Si abrimos el navegador y accedemos a <code>http://localhost:5173/</code> y pulsamos en el men\u00fa de Categor\u00edas obtendremos una pantalla con un listado vac\u00edo (solo con cabeceras) y un bot\u00f3n de crear <code>Nueva Categor\u00eda</code> que a\u00fan no hace nada.</p>"},{"location":"develop/basic/vuejsold/#anadiendo-datos","title":"A\u00f1adiendo datos","text":"<p>En este punto y para ver como responde el listado, vamos a a\u00f1adir datos. Si tuvi\u00e9ramos el backend implementado podr\u00edamos consultar los datos directamente de una operaci\u00f3n de negocio de backend, pero ahora mismo no lo tenemos implementado as\u00ed que para no bloquear el desarrollo vamos a mockear los datos.</p> <p>En Vue para conectar a APIS externas solemos usar una librer\u00eda llamada Axios, lo primero que haremos ser\u00e1 descargarla e instalarla como indica en su documentaci\u00f3n oficial.</p> <p>Para instalarla simplemente nos iremos a la terminal dentro de la carpeta donde tenemos el proyecto y pondremos:</p> <pre><code>npm install axios\n</code></pre> <p>Con esto ya podremos ver que se ha a\u00f1adido a nuestro <code>package.json</code>, luego crearemos una carpeta <code>api</code> dentro de la carpeta <code>src</code> y dentro de la carpeta <code>api</code> crearemos el archivo <code>app-api.ts</code>. Dentro de este archivo vamos a inicializar nuestra config de la API y guardaremos todos los par\u00e1metros iniciales conforme nos vayan haciendo falta, de momento pondremos solo este c\u00f3digo:</p> app-api.ts <pre><code>import axios from 'axios';\n\nexport const appApi = axios.create({\n    baseURL: 'http://localhost:8080',\n});\n</code></pre> <p>Si os dais cuenta lo \u00fanico que hacemos es importar <code>axios</code> que acabamos de instalarlo y definir nuestra url base del api para no tener que escribirla cada vez y para s\u00ed alg\u00fan d\u00eda cambia, tener que cambiarla solo en un sitio y no en todos los servicios que la usen.</p> <p>Para mockear los datos con <code>axios</code> usaremos una librer\u00eda que se llama <code>axios-mock-adapter</code> y la pod\u00e9is encontrar en este link.</p> <p>Para instalarla lo haremos con npm como siempre, pondremos esta orden en el terminal y enter:</p> <pre><code>npm install axios-mock-adapter --save-dev\n</code></pre> <p>Si nos vamos al <code>package.json</code> veremos que ya la tenemos en las <code>devDependencies</code>, la diferencia entre estas y las dependencias es que las dependencias las necesitamos en el proyecto y estar\u00e1n en nuestro <code>bundle</code> final que serviremos a la gente, las <code>devDependencies</code> se usan solo mientras programamos y no entraran en el <code>bundle</code> final. Los mocks los usaremos solo en el desarrollo y hasta que podamos conectar con la API real por eso los metemos en las devDependencies.</p>"},{"location":"develop/basic/vuejsold/#mockeando-datos","title":"Mockeando datos","text":"<p>Como hemos comentado anteriormente, el backend todav\u00eda no est\u00e1 implementado as\u00ed que vamos a mockear datos. Nos crearemos un fichero <code>mock-categories.ts</code> dentro de <code>views/categories/mocks</code>, con datos ficticios y crearemos una llamada a la API que nos devuelva estos datos. De esta forma, cuando tengamos implementada la operaci\u00f3n de negocio en backend, tan solo tenemos que sustituir el c\u00f3digo que devuelve datos est\u00e1ticos por una llamada HTTP.</p> <p>Dentro de la carpeta <code>mocks</code> crearemos el archivo <code>mock-categories.ts</code> con el siguiente c\u00f3digo:</p> mock-categories.ts <pre><code>import type { Category } from \"@/views/categories/models/category-interface\";\n\nexport const CATEGORY_DATA_MOCK: Category[] = [\n    { id: 1, name: 'Dados' },\n    { id: 2, name: 'Fichas' },\n    { id: 3, name: 'Cartas' },\n    { id: 4, name: 'Rol' },\n    { id: 5, name: 'Tableros' },\n    { id: 6, name: 'Tem\u00e1ticos' },\n    { id: 7, name: 'Europeos' },\n    { id: 8, name: 'Guerra' },\n    { id: 9, name: 'Abstractos' },\n]\n</code></pre> <p>Despu\u00e9s nos crearemos un <code>composable</code> que usaremos para llamar a la API y poder reutilizarlo en otros componentes si hiciera falta. Dentro de la carpeta <code>categories</code> crearemos otra carpeta llamada <code>composables</code> y dentro crearemos un archivo llamado <code>categories-composable.ts</code>, en ese archivo escribiremos este c\u00f3digo:</p> categories-composable.ts <pre><code>import appApi from '@/api/app-api'\nimport MockAdapter from 'axios-mock-adapter';\nimport { CATEGORY_DATA_MOCK } from '@/views/categories/mocks/mock-categories'\n\nconst mock = new MockAdapter(appApi);\n\nconst useCategoriesApiComposable = () =&gt; {\nmock.onGet(\"/category\").reply(200, CATEGORY_DATA_MOCK);\n\n    const getCategories = async () =&gt; {\n        const categories = await appApi.get(\"/category\");\n        return categories.data;\n    };\n\n    return {\n        getCategories\n    }\n}\n\nexport default useCategoriesApiComposable\n</code></pre> <p>A\u00f1adiremos \u00e9l <code>composable</code> a nuestro <code>CategoriesView.vue</code> dentro de las etiquetas <code>&lt;script&gt;</code>, lo primero en el <code>import</code> que ya tenemos desde Vue a\u00f1adiremos el m\u00e9todo <code>onMounted</code> dej\u00e1ndolo asi:</p> CategoriesView.vue <pre><code>import { onMounted, ref } from 'vue'\n</code></pre> <p>El m\u00e9todo <code>onMounted</code> es un ciclo de vida que se dispara nada m\u00e1s montarse el componente, despu\u00e9s a\u00f1adiremos al final el <code>import</code> del <code>composable</code> para poder usarlo:</p> CategoriesView.vue <pre><code>import useCategoriesApiComposable from '@/views/categories/composables/categories-composable'\n</code></pre> <p>Nos traeremos el m\u00e9todo del <code>composable</code> con la desestructuraci\u00f3n del objeto:</p> CategoriesView.vue <pre><code>const { getCategories } = useCategoriesApiComposable()\n</code></pre> <p>Crearemos una funci\u00f3n as\u00edncrona para llamar al <code>composable</code> y llamaremos al <code>composable</code> en el <code>onMounted</code>:</p> CategoriesView.vue <pre><code>async function getInitCategories() {\n    categories.value = await getCategories()\n}\n\nonMounted(() =&gt; {\n    getInitCategories()\n})\n</code></pre> <p>El <code>CategoriesView.vue</code> quedar\u00eda asi:</p> CategoriesView.vue <pre><code>&lt;template&gt;\n  &lt;div class=\"card\"&gt;\n    &lt;DataTable\n      v-model:editingRows=\"editingRows\"\n      :value=\"categories\"\n      tableStyle=\"min-width: 50rem\"\n      editMode=\"row\"\n      dataKey=\"id\"\n      @row-edit-save=\"onRowEditSave\"\n    &gt;\n      &lt;Column field=\"id\" header=\"IDENTIFICADOR\"&gt;\n        &lt;template #editor=\"{ data, field }\"&gt;\n          &lt;InputText v-model=\"data[field]\" /&gt;\n        &lt;/template&gt;\n      &lt;/Column&gt;\n      &lt;Column field=\"name\" header=\"NOMBRE CATEGOR\u00cdA\"&gt;\n        &lt;template #editor=\"{ data, field }\"&gt;\n          &lt;InputText v-model=\"data[field]\" /&gt;\n        &lt;/template&gt;\n      &lt;/Column&gt;\n      &lt;Column :rowEditor=\"true\" style=\"width: 110px\" bodyStyle=\"text-align:center\"&gt;&lt;/Column&gt;\n      &lt;Column\n        style=\"width: 30px; padding: 0px 2rem 0px 0px; color: red\"\n        bodyStyle=\"text-align:center\"\n      &gt;\n        &lt;template #body=\"{ data }\"&gt;\n          &lt;i class=\"pi pi-times\" @click=\"onRowDelete(data)\"&gt;&lt;/i&gt;\n        &lt;/template&gt;\n      &lt;/Column&gt;\n    &lt;/DataTable&gt;\n  &lt;/div&gt;\n  &lt;div class=\"actions\"&gt;\n    &lt;Button label=\"Nueva categor\u00eda\" /&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport { onMounted, ref } from 'vue'\nimport DataTable, { type DataTableRowEditSaveEvent } from 'primevue/datatable'\nimport Column from 'primevue/column'\nimport InputText from 'primevue/inputtext'\nimport Button from 'primevue/button'\nimport type { CategoryInterface } from './model/category.interface'\nimport useCategoriesApiComposable from '@/views/categories/composables/categories-composable'\n\nconst categories = ref([])\nconst editingRows = ref([])\n\nconst { getCategories } = useCategoriesApiComposable()\n\nconst onRowEditSave = (event: DataTableRowEditSaveEvent) =&gt; {\n  console.log(event)\n}\n\nconst onRowDelete = (data: CategoryInterface) =&gt; {\n  console.log(data)\n}\n\nasync function getInitCategories() {\n  categories.value = await getCategories()\n}\n\nonMounted(() =&gt; {\n  getInitCategories()\n})\n&lt;/script&gt;\n\n&lt;style lang=\"scss\" scoped&gt;\n.actions {\n  display: flex;\n  flex-direction: row;\n  margin-top: 1rem;\n  justify-content: flex-end;\n}\n\n.p-button {\n  background: var(--primary);\n  border: 1px solid var(--primary);\n\n  &amp;:enabled {\n    &amp;:hover {\n      background: var(--secondary);\n      border-color: var(--secondary);\n    }\n  }\n}\n&lt;/style&gt;\n</code></pre> <p>Si ahora refrescamos la p\u00e1gina web, veremos que el listado ya tiene datos con los que vamos a interactuar.</p> <p></p>"},{"location":"develop/basic/vuejsold/#simulando-las-otras-peticiones","title":"Simulando las otras peticiones","text":"<p>Para terminar, vamos a simular las otras dos peticiones, la de editar y la de borrar para cuando tengamos que utilizarlas. \u00c9l <code>composable</code> debe quedar m\u00e1s o menos as\u00ed:</p> categories-composable.ts <pre><code>import appApi from '@/api/app-api'\nimport MockAdapter from 'axios-mock-adapter'\nimport type { Category } from '@/views/categories/models/category-interface'\nimport { CATEGORY_DATA_MOCK } from '@/views/categories/mocks/mock-categories'\n\nconst mock = new MockAdapter(appApi)\n\nconst useCategoriesApiComposable = () =&gt; {\n  mock.onAny('/category').reply(200, CATEGORY_DATA_MOCK)\n\n  const getCategories = async () =&gt; {\n    const categories = await appApi.get('/category')\n    return categories.data\n  }\n\n  const saveCategory = async (category: Category) =&gt; {\n    const categoryEdit = await appApi.post('/category', category)\n    return categoryEdit.data\n  }\n\n  const editCategory = async (category: Category) =&gt; {\n    const categoryEdit = await appApi.put('/category', category)\n    return categoryEdit.data\n  }\n\n  const deleteCategory = async (categoryId: number) =&gt; {\n    const categoryEdit = await appApi.delete(`/category/${categoryId}`)\n    return categoryEdit.data\n  }\n\n  return {\n    getCategories,\n    saveCategory,\n    editCategory,\n    deleteCategory\n  }\n}\n\nexport default useCategoriesApiComposable\n</code></pre>"},{"location":"develop/filtered/angular/","title":"Listado filtrado - Angular","text":"<p>En este punto ya tenemos dos listados, uno b\u00e1sico y otro paginado. Ahora vamos a implementar un listado un poco diferente, con filtros y con una presentaci\u00f3n un tanto distinta.</p> <p>Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.</p>"},{"location":"develop/filtered/angular/#crear-componentes","title":"Crear componentes","text":"<p>Vamos a desarrollar el listado de <code>Juegos</code>. Este listado es un tanto peculiar, porque no tiene una tabla como tal, sino que tiene una tabla con \"tiles\" para cada uno de los juegos. Necesitaremos un componente para el listado y otro componente para el detalle del juego. Tambi\u00e9n necesitaremos otro componente para el dialogo de edici\u00f3n / alta.</p> <p>Manos a la obra:</p> <pre><code>ng generate module game\n\nng generate component game/game-list\nng generate component game/game-list/game-item\nng generate component game/game-edit\n\nng generate service game/game\n</code></pre> <p>Y a\u00f1adimos el nuevo m\u00f3dulo al <code>app.module.ts</code> como hemos hecho con el resto de m\u00f3dulos.</p> Game.ts <pre><code>import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { CoreModule } from './core/core.module';\nimport { CategoryModule } from './category/category.module';\nimport { AuthorModule } from './author/author.module';\nimport { GameModule } from './game/game.module';\n\n@NgModule({\n    declarations: [\n        AppComponent\n    ],\n    imports: [\n        BrowserModule,\n        AppRoutingModule,\n        CoreModule,\n        CategoryModule,\n        AuthorModule,\n        GameModule,\n        BrowserAnimationsModule\n    ],\n    providers: [],\n    bootstrap: [AppComponent]\n})\nexport class AppModule { }\n</code></pre>"},{"location":"develop/filtered/angular/#crear-el-modelo","title":"Crear el modelo","text":"<p>Lo primero que vamos a hacer es crear el modelo en <code>game/model/Game.ts</code> con todas las propiedades necesarias para trabajar con un juego:</p> Game.ts <pre><code>import { Category } from \"src/app/category/model/Category\";\nimport { Author } from \"src/app/author/model/Author\";\n\nexport class Game {\n    id: number;\n    title: string;\n    age: number;\n    category: Category;\n    author: Author;\n}\n</code></pre> <p>Como ves, el juego tiene dos objetos para mapear categor\u00eda y autor.</p>"},{"location":"develop/filtered/angular/#anadir-el-punto-de-entrada","title":"A\u00f1adir el punto de entrada","text":"<p>A\u00f1adimos la ruta al men\u00fa para que podamos navegar a esta pantalla:</p> app-routing.module.ts <pre><code>import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { AuthorListComponent } from './author/author-list/author-list.component';\nimport { CategoryListComponent } from './category/category-list/category-list.component';\nimport { GameListComponent } from './game/game-list/game-list.component';\n\n\nconst routes: Routes = [\n    { path: '', redirectTo: '/games', pathMatch: 'full'},\n    { path: 'categories', component: CategoryListComponent },\n    { path: 'authors', component: AuthorListComponent },\n    { path: 'games', component: GameListComponent },\n];\n\n@NgModule({\n    imports: [RouterModule.forRoot(routes)],\n    exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n</code></pre> <p>Adem\u00e1s, hemos a\u00f1adido una regla adicional con el path vac\u00edo para indicar que si no pone ruta, por defecto la p\u00e1gina inicial redirija al path <code>/games</code>, que es nuevo path que hemos a\u00f1adido.</p>"},{"location":"develop/filtered/angular/#implementar-servicio","title":"Implementar servicio","text":"<p>A continuaci\u00f3n implementamos el servicio y mockeamos datos de ejemplo:</p> mock-games.tsgame.service.ts <pre><code>import { Game } from \"./Game\";\n\nexport const GAME_DATA: Game[] = [\n    { id: 1, title: 'Juego 1', age: 6, category: { id: 1, name: 'Categor\u00eda 1' }, author: { id: 1, name: 'Autor 1', nationality: 'Nacionalidad 1' } },\n    { id: 2, title: 'Juego 2', age: 8, category: { id: 1, name: 'Categor\u00eda 1' }, author: { id: 2, name: 'Autor 2', nationality: 'Nacionalidad 2' } },\n    { id: 3, title: 'Juego 3', age: 4, category: { id: 1, name: 'Categor\u00eda 1' }, author: { id: 3, name: 'Autor 3', nationality: 'Nacionalidad 3' } },\n    { id: 4, title: 'Juego 4', age: 10, category: { id: 2, name: 'Categor\u00eda 2' }, author: { id: 1, name: 'Autor 1', nationality: 'Nacionalidad 1' } },\n    { id: 5, title: 'Juego 5', age: 16, category: { id: 2, name: 'Categor\u00eda 2' }, author: { id: 2, name: 'Autor 2', nationality: 'Nacionalidad 2' } },\n    { id: 6, title: 'Juego 6', age: 16, category: { id: 2, name: 'Categor\u00eda 2' }, author: { id: 3, name: 'Autor 3', nationality: 'Nacionalidad 3' } },\n    { id: 7, title: 'Juego 7', age: 12, category: { id: 3, name: 'Categor\u00eda 3' }, author: { id: 1, name: 'Autor 1', nationality: 'Nacionalidad 1' } },\n    { id: 8, title: 'Juego 8', age: 14, category: { id: 3, name: 'Categor\u00eda 3' }, author: { id: 2, name: 'Autor 2', nationality: 'Nacionalidad 2' } },\n]\n</code></pre> <pre><code>import { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Game } from './model/Game';\nimport { GAME_DATA } from './model/mock-games';\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class GameService {\n\n    constructor() { }\n\n    getGames(title?: String, categoryId?: number): Observable&lt;Game[]&gt; {\n        return of(GAME_DATA);\n    }\n\n    saveGame(game: Game): Observable&lt;void&gt; {\n        return of(null);\n    }\n\n}\n</code></pre>"},{"location":"develop/filtered/angular/#implementar-listado","title":"Implementar listado","text":"<p>Ya tenemos las operaciones del servicio con datoos, as\u00ed que ahora vamos a por el listado filtrado.</p> game-list.component.htmlgame-list.component.scssgame-list.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1&gt;Cat\u00e1logo de juegos&lt;/h1&gt;\n\n    &lt;div class=\"filters\"&gt;\n        &lt;form&gt;\n            &lt;mat-form-field&gt;\n                &lt;mat-label&gt;T\u00edtulo del juego&lt;/mat-label&gt;\n                &lt;input type=\"text\" matInput placeholder=\"T\u00edtulo del juego\" [(ngModel)]=\"filterTitle\" name=\"title\"&gt;\n            &lt;/mat-form-field&gt;\n\n            &lt;mat-form-field&gt;\n                &lt;mat-label&gt;Categor\u00eda del juego&lt;/mat-label&gt;\n                &lt;mat-select disableRipple [(ngModel)]=\"filterCategory\" name=\"category\"&gt;\n                    &lt;mat-option *ngFor=\"let category of categories\" [value]=\"category\"&gt;{{category.name}}&lt;/mat-option&gt;\n                &lt;/mat-select&gt;\n            &lt;/mat-form-field&gt;    \n        &lt;/form&gt;\n\n        &lt;div class=\"buttons\"&gt;\n            &lt;button mat-stroked-button (click)=\"onCleanFilter()\"&gt;Limpiar&lt;/button&gt; \n            &lt;button mat-stroked-button (click)=\"onSearch()\"&gt;Filtrar&lt;/button&gt; \n        &lt;/div&gt;   \n    &lt;/div&gt;   \n\n    &lt;div class=\"game-list\"&gt;\n        &lt;app-game-item *ngFor=\"let game of games; let i = index;\" (click)=\"editGame(game)\"&gt;\n        &lt;/app-game-item&gt;\n    &lt;/div&gt;\n\n    &lt;div class=\"buttons\"&gt;\n        &lt;button mat-flat-button color=\"primary\" (click)=\"createGame()\"&gt;Nuevo juego&lt;/button&gt;            \n    &lt;/div&gt;   \n&lt;/div&gt;\n</code></pre> <pre><code>.container {\n    margin: 20px;\n\n    .filters {\n        display: flex;\n\n        mat-form-field {\n            width: 300px;\n            margin-right: 20px;\n        }\n\n        .buttons {\n            flex: auto;\n            align-self: center;\n\n            button {\n                margin-left: 15px;\n            }\n        }\n    }\n\n    .game-list { \n        margin-top: 20px;\n        margin-bottom: 20px;\n\n        display: flex;\n        flex-flow: wrap;\n        overflow: auto;  \n    }\n\n    .buttons {\n        text-align: right;\n    }\n}\n\nbutton {\n    width: 125px;\n}\n</code></pre> <pre><code>import { Component, OnInit } from '@angular/core';\nimport { MatDialog } from '@angular/material/dialog';\nimport { CategoryService } from 'src/app/category/category.service';\nimport { Category } from 'src/app/category/model/Category';\nimport { GameEditComponent } from '../game-edit/game-edit.component';\nimport { GameService } from '../game.service';\nimport { Game } from '../model/Game';\n\n@Component({\n    selector: 'app-game-list',\n    templateUrl: './game-list.component.html',\n    styleUrls: ['./game-list.component.scss']\n})\nexport class GameListComponent implements OnInit {\n\n    categories : Category[];\n    games: Game[];\n    filterCategory: Category;\n    filterTitle: string;\n\n    constructor(\n        private gameService: GameService,\n        private categoryService: CategoryService,\n        public dialog: MatDialog,\n    ) { }\n\n    ngOnInit(): void {\n\n        this.gameService.getGames().subscribe(\n            games =&gt; this.games = games\n        );\n\n        this.categoryService.getCategories().subscribe(\n            categories =&gt; this.categories = categories\n        );\n    }\n\n    onCleanFilter(): void {\n        this.filterTitle = null;\n        this.filterCategory = null;\n\n        this.onSearch();\n    }\n\n    onSearch(): void {\n\n        let title = this.filterTitle;\n        let categoryId = this.filterCategory != null ? this.filterCategory.id : null;\n\n        this.gameService.getGames(title, categoryId).subscribe(\n            games =&gt; this.games = games\n        );\n    }\n\n    createGame() {    \n        const dialogRef = this.dialog.open(GameEditComponent, {\n            data: {}\n        });\n\n        dialogRef.afterClosed().subscribe(result =&gt; {\n            this.ngOnInit();\n        });    \n    }  \n\n    editGame(game: Game) {\n        const dialogRef = this.dialog.open(GameEditComponent, {\n            data: { game: game }\n        });\n\n        dialogRef.afterClosed().subscribe(result =&gt; {\n            this.onSearch();\n        });\n    }\n}\n</code></pre> <p>Recuerda, de nuevo, que todos los componentes de Angular que utilicemos hay que importarlos en el m\u00f3dulo padre correspondiente para que se puedan precargar correctamente.</p> game.module.ts <pre><code>import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { GameListComponent } from './game-list/game-list.component';\nimport { GameEditComponent } from './game-edit/game-edit.component';\nimport { GameItemComponent } from './game-list/game-item/game-item.component';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { MatButtonModule } from '@angular/material/button';\nimport { MatOptionModule } from '@angular/material/core';\nimport { MatDialogModule } from '@angular/material/dialog';\nimport { MatFormFieldModule } from '@angular/material/form-field';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatInputModule } from '@angular/material/input';\nimport { MatPaginatorModule } from '@angular/material/paginator';\nimport { MatSelectModule } from '@angular/material/select';\nimport { MatTableModule } from '@angular/material/table';\nimport { MatCardModule } from '@angular/material/card';\n\n\n@NgModule({\ndeclarations: [\n    GameListComponent,\n    GameEditComponent,\n    GameItemComponent\n],\nimports: [\n    CommonModule,\n    MatTableModule,\n    MatIconModule, \n    MatButtonModule,\n    MatDialogModule,\n    MatFormFieldModule,\n    MatInputModule,\n    FormsModule,\n    ReactiveFormsModule,\n    MatPaginatorModule,\n    MatOptionModule,\n    MatSelectModule,\n    MatCardModule,\n]\n})\nexport class GameModule { }\n</code></pre> <p>Con todos estos cambios y si refrescamos el navegador, deber\u00eda verse una pantalla similar a esta:</p> <p></p> <p>Tenemos una pantalla con una secci\u00f3n de filtros en la parte superior, donde podemos introducir un texto o seleccionar una categor\u00eda de un dropdown, un listado que de momento tiene todos los componentes b\u00e1sicos en una fila uno detr\u00e1s del otro, y un bot\u00f3n para crear juegos nuevos.</p> <p>Dropdown</p> <p>El componente <code>Dropdown</code> es uno de los componentes m\u00e1s utilizados en las pantallas y formularios de Angular. Ves familiariz\u00e1ndote con \u00e9l porque lo vas a usar mucho. Es bastante potente y medianamente sencillo de utilizar. Los datos del listado pueden ser din\u00e1micos (desde servidor) o est\u00e1ticos (si los valores ya los tienes prefijados).</p>"},{"location":"develop/filtered/angular/#implementar-detalle-del-item","title":"Implementar detalle del item","text":"<p>Ahora vamos a implementar el detalle de cada uno de los items que forman el listado. Para ello lo primero que haremos ser\u00e1 pasarle la informaci\u00f3n del juego a cada componente como un dato de entrada <code>Input</code> hacia el componente.</p> game-list.component.html <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1&gt;Cat\u00e1logo de juegos&lt;/h1&gt;\n\n    &lt;div class=\"filters\"&gt;\n        &lt;form&gt;\n            &lt;mat-form-field&gt;\n                &lt;mat-label&gt;T\u00edtulo del juego&lt;/mat-label&gt;\n                &lt;input type=\"text\" matInput placeholder=\"T\u00edtulo del juego\" [(ngModel)]=\"filterTitle\" name=\"title\"&gt;\n            &lt;/mat-form-field&gt;\n\n            &lt;mat-form-field&gt;\n                &lt;mat-label&gt;Categor\u00eda del juego&lt;/mat-label&gt;\n                &lt;mat-select disableRipple [(ngModel)]=\"filterCategory\" name=\"category\"&gt;\n                    &lt;mat-option *ngFor=\"let category of categories\" [value]=\"category\"&gt;{{category.name}}&lt;/mat-option&gt;\n                &lt;/mat-select&gt;\n            &lt;/mat-form-field&gt;    \n        &lt;/form&gt;\n\n        &lt;div class=\"buttons\"&gt;\n            &lt;button mat-stroked-button (click)=\"onCleanFilter()\"&gt;Limpiar&lt;/button&gt; \n            &lt;button mat-stroked-button (click)=\"onSearch()\"&gt;Filtrar&lt;/button&gt; \n        &lt;/div&gt;   \n    &lt;/div&gt;   \n\n    &lt;div class=\"game-list\"&gt;\n        &lt;app-game-item *ngFor=\"let game of games; let i = index;\" (click)=\"editGame(game)\" [game]=\"game\"&gt;\n        &lt;/app-game-item&gt;\n    &lt;/div&gt;\n\n    &lt;div class=\"buttons\"&gt;\n        &lt;button mat-flat-button color=\"primary\" (click)=\"createGame()\"&gt;Nuevo juego&lt;/button&gt;            \n    &lt;/div&gt;   \n&lt;/div&gt;\n</code></pre> <p>Tambi\u00e9n vamos a necesitar una foto de ejemplo para poner dentro de la tarjeta detalle de los juegos. Vamos a utilizar esta imagen:</p> <p></p> <p>Desc\u00e1rgala y d\u00e9jala dentro del proyecto en <code>assets/foto.png</code>. Y ya para terminar, implementamos el componente de detalle:</p> game-item.component.htmlgame-item.component.scssgame-item.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;mat-card&gt;\n        &lt;div class=\"photo\"&gt;\n            &lt;img src=\"./assets/foto.png\"&gt;\n        &lt;/div&gt;\n        &lt;div class=\"detail\"&gt;\n            &lt;div class=\"title\"&gt;{{game.title}}&lt;/div&gt;\n            &lt;div class=\"properties\"&gt;\n                &lt;div&gt;&lt;i&gt;Edad recomendada: &lt;/i&gt;+{{game.age}}&lt;/div&gt;\n                &lt;div&gt;&lt;i&gt;Categor\u00eda: &lt;/i&gt;{{game.category.name}}&lt;/div&gt;\n                &lt;div&gt;&lt;i&gt;Autor: &lt;/i&gt;{{game.author.name}}&lt;/div&gt;\n                &lt;div&gt;&lt;i&gt;Nacionalidad: &lt;/i&gt;{{game.author.nationality}}&lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/mat-card&gt;\n&lt;/div&gt;\n</code></pre> <pre><code>.container {\n    display: flex;\n    width: 325px;\n\n    mat-card {\n        width: 100%;\n        margin: 10px;\n        display: flex;\n\n        .photo {\n            margin-right: 10px;\n\n            img {\n                width: 80px;\n                height: 80px;\n            }\n        }\n\n        .detail {\n            .title {\n                font-size: 14px;\n                font-weight: bold;\n            }\n\n            .properties {\n                font-size: 11px;\n\n                div {\n                    height: 15px;\n                }                \n            }\n        }\n    }\n}    \n</code></pre> <pre><code>import { Component, OnInit, Input } from '@angular/core';\nimport { Game } from '../../model/Game';\n\n@Component({\n    selector: 'app-game-item',\n    templateUrl: './game-item.component.html',\n    styleUrls: ['./game-item.component.scss']\n})\nexport class GameItemComponent implements OnInit {\n\n    @Input() game: Game;\n\n    constructor() { }\n\n    ngOnInit(): void {\n    }\n\n}\n</code></pre> <p>Ahora si que deber\u00eda quedar algo similar a esta pantalla:</p> <p></p>"},{"location":"develop/filtered/angular/#implementar-dialogo-de-edicion","title":"Implementar dialogo de edici\u00f3n","text":"<p>Ya solo nos falta el \u00faltimo paso, implementar el cuadro de edici\u00f3n / alta de un nuevo juego. Pero tenemos un peque\u00f1o problema, y es que al crear o editar un juego debemos seleccionar una <code>Categor\u00eda</code> y un <code>Autor</code>. </p> <p>Para la <code>Categor\u00eda</code> no tenemos ning\u00fan problema, pero para el <code>Autor</code> no tenemos un servicio que nos devuelva todos los autores, solo tenemos un servicio que nos devuelve una <code>Page</code> de autores.</p> <p>As\u00ed que lo primero que haremos ser\u00e1 implementar una operaci\u00f3n <code>getAllAuthors</code> para poder recuperar una lista.</p> mock-authors-list.tsauthor.service.ts <pre><code>import { Author } from \"./Author\";\n\nexport const AUTHOR_DATA_LIST : Author[] = [\n    { id: 1, name: 'Klaus Teuber', nationality: 'Alemania' },\n    { id: 2, name: 'Matt Leacock', nationality: 'Estados Unidos' },\n    { id: 3, name: 'Keng Leong Yeo', nationality: 'Singapur' },\n    { id: 4, name: 'Gil Hova', nationality: 'Estados Unidos'},\n    { id: 5, name: 'Kelly Adams', nationality: 'Estados Unidos' },\n]    \n</code></pre> <pre><code>import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Pageable } from '../core/model/page/Pageable';\nimport { Author } from './model/Author';\nimport { AuthorPage } from './model/AuthorPage';\nimport { AUTHOR_DATA_LIST } from './model/mock-authors-list';\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class AuthorService {\n\n    constructor(\n        private http: HttpClient\n    ) { }\n\n    getAuthors(pageable: Pageable): Observable&lt;AuthorPage&gt; {\n        return this.http.post&lt;AuthorPage&gt;('http://localhost:8080/author', {pageable:pageable});\n    }\n\n    saveAuthor(author: Author): Observable&lt;void&gt; {\n\n        let url = 'http://localhost:8080/author';\n        if (author.id != null) url += '/'+author.id;\n\n        return this.http.put&lt;void&gt;(url, author);\n    }\n\n    deleteAuthor(idAuthor : number): Observable&lt;void&gt; {\n        return this.http.delete&lt;void&gt;('http://localhost:8080/author/'+idAuthor);\n    }    \n\n    getAllAuthors(): Observable&lt;Author[]&gt; {\n        return of(AUTHOR_DATA_LIST);\n    }\n\n}\n</code></pre> <p>Ahora s\u00ed que tenemos todo listo para implementar el cuadro de dialogo para dar de alta o editar juegos.</p> game-edit.component.htmlgame-edit.component.scssgame-edit.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1 *ngIf=\"game.id == null\"&gt;Crear juego&lt;/h1&gt;\n    &lt;h1 *ngIf=\"game.id != null\"&gt;Modificar juego&lt;/h1&gt;\n\n    &lt;form&gt;\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;Identificador&lt;/mat-label&gt;\n            &lt;input type=\"text\" matInput placeholder=\"Identificador\" [(ngModel)]=\"game.id\" name=\"id\" disabled&gt;\n        &lt;/mat-form-field&gt;\n\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;T\u00edtulo&lt;/mat-label&gt;\n            &lt;input type=\"text\" matInput placeholder=\"T\u00edtulo del juego\" [(ngModel)]=\"game.title\" name=\"title\" required&gt;\n            &lt;mat-error&gt;El t\u00edtulo no puede estar vac\u00edo&lt;/mat-error&gt;\n        &lt;/mat-form-field&gt;\n\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;Edad recomendada&lt;/mat-label&gt;\n            &lt;input type=\"number\" matInput placeholder=\"Edad recomendada\" [(ngModel)]=\"game.age\" name=\"age\" required&gt;\n            &lt;mat-error&gt;La edad no puede estar vac\u00eda&lt;/mat-error&gt;\n        &lt;/mat-form-field&gt;\n\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;Categor\u00eda&lt;/mat-label&gt;\n            &lt;mat-select disableRipple [(ngModel)]=\"game.category\" name=\"category\" required&gt;\n                &lt;mat-option *ngFor=\"let category of categories\" [value]=\"category\"&gt;{{category.name}}&lt;/mat-option&gt;\n            &lt;/mat-select&gt;\n            &lt;mat-error&gt;La categor\u00eda no puede estar vac\u00eda&lt;/mat-error&gt;\n        &lt;/mat-form-field&gt;\n\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;Autor&lt;/mat-label&gt;\n            &lt;mat-select disableRipple [(ngModel)]=\"game.author\" name=\"author\" required&gt;\n                &lt;mat-option *ngFor=\"let author of authors\" [value]=\"author\"&gt;{{author.name}}&lt;/mat-option&gt;\n            &lt;/mat-select&gt;\n            &lt;mat-error&gt;El autor no puede estar vac\u00edo&lt;/mat-error&gt;\n        &lt;/mat-form-field&gt;\n    &lt;/form&gt;\n\n    &lt;div class=\"buttons\"&gt;\n        &lt;button mat-stroked-button (click)=\"onClose()\"&gt;Cerrar&lt;/button&gt;\n        &lt;button mat-flat-button color=\"primary\" (click)=\"onSave()\"&gt;Guardar&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <pre><code>.container {\n    min-width: 350px;\n    max-width: 500px;\n    padding: 20px;\n\n    form {\n        display: flex;\n        flex-direction: column;\n        margin-bottom:20px;\n    }\n\n    .buttons {\n        text-align: right;\n\n        button {\n            margin-left: 10px;\n        }\n    }\n}\n</code></pre> <pre><code>import { Component, Inject, OnInit } from '@angular/core';\nimport { MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';\nimport { AuthorService } from 'src/app/author/author.service';\nimport { Author } from 'src/app/author/model/Author';\nimport { CategoryService } from 'src/app/category/category.service';\nimport { Category } from 'src/app/category/model/Category';\nimport { GameService } from '../game.service';\nimport { Game } from '../model/Game';\n\n@Component({\n    selector: 'app-game-edit',\n    templateUrl: './game-edit.component.html',\n    styleUrls: ['./game-edit.component.scss']\n})\nexport class GameEditComponent implements OnInit {\n\n    game: Game; \n    authors: Author[];\n    categories: Category[];\n\n    constructor(\n        public dialogRef: MatDialogRef&lt;GameEditComponent&gt;,\n        @Inject(MAT_DIALOG_DATA) public data: any,\n        private gameService: GameService,\n        private categoryService: CategoryService,\n        private authorService: AuthorService,\n    ) { }\n\n    ngOnInit(): void {\n        if (this.data.game != null) {\n            this.game = Object.assign({}, this.data.game);\n        }\n        else {\n            this.game = new Game();\n        }\n\n        this.categoryService.getCategories().subscribe(\n            categories =&gt; {\n                this.categories = categories;\n\n                if (this.game.category != null) {\n                    let categoryFilter: Category[] = categories.filter(category =&gt; category.id == this.data.game.category.id);\n                    if (categoryFilter != null) {\n                        this.game.category = categoryFilter[0];\n                    }\n                }\n            }\n        );\n\n        this.authorService.getAllAuthors().subscribe(\n            authors =&gt; {\n                this.authors = authors\n\n                if (this.game.author != null) {\n                    let authorFilter: Author[] = authors.filter(author =&gt; author.id == this.data.game.author.id);\n                    if (authorFilter != null) {\n                        this.game.author = authorFilter[0];\n                    }\n                }\n            }\n        );\n    }\n\n    onSave() {\n        this.gameService.saveGame(this.game).subscribe(result =&gt; {\n            this.dialogRef.close();\n        });    \n    }  \n\n    onClose() {\n        this.dialogRef.close();\n    }\n\n}\n</code></pre> <p>Como puedes ver, para rellenar los componentes seleccionables de dropdown, hemos realizado una consulta al servicio para recuperar todos los autores y categorias, y en la respuesta de cada uno de ellos, hemos buscado en los resultados cual es el que coincide con el ID enviado desde el listado, y ese es el que hemos fijado en el objeto <code>Game</code>.</p> <p>De esta forma, no estamos cogiendo directamente los datos del listado, sino que no estamos asegurando que los datos de autor y de categor\u00eda son los que vienen del servicio, siempre filtrando por su ID.</p>"},{"location":"develop/filtered/angular/#conectar-con-backend","title":"Conectar con Backend","text":"<p>Antes de seguir</p> <p>Antes de seguir con este punto, debes implementar el c\u00f3digo de backend en la tecnolog\u00eda que quieras (Springboot o Nodejs). Si has empezado este cap\u00edtulo implementando el frontend, por favor accede a la secci\u00f3n correspondiente de backend para poder continuar con el tutorial. Una vez tengas implementadas todas las operaciones para este listado, puedes volver a este punto y continuar con Angular.</p> <p>Una vez implementado front y back, lo que nos queda es modificar el servicio del front para que conecte directamente con las operaciones ofrecidas por el back.</p> author-service.tsgame-service.ts <pre><code>import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Pageable } from '../core/model/page/Pageable';\nimport { Author } from './model/Author';\nimport { AuthorPage } from './model/AuthorPage';\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class AuthorService {\n\n    constructor(\n        private http: HttpClient\n    ) { }\n\n    getAuthors(pageable: Pageable): Observable&lt;AuthorPage&gt; {\n        return this.http.post&lt;AuthorPage&gt;('http://localhost:8080/author', {pageable:pageable});\n    }\n\n    saveAuthor(author: Author): Observable&lt;void&gt; {\n\n        let url = 'http://localhost:8080/author';\n        if (author.id != null) url += '/'+author.id;\n\n        return this.http.put&lt;void&gt;(url, author);\n    }\n\n    deleteAuthor(idAuthor : number): Observable&lt;void&gt; {\n        return this.http.delete&lt;void&gt;('http://localhost:8080/author/'+idAuthor);\n    }    \n\n    getAllAuthors(): Observable&lt;Author[]&gt; {\n        return this.http.get&lt;Author[]&gt;('http://localhost:8080/author');\n    }\n\n}\n</code></pre> <pre><code>import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Game } from './model/Game';\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class GameService {\n\n    constructor(\n        private http: HttpClient\n    ) { }\n\n    getGames(title?: String, categoryId?: number): Observable&lt;Game[]&gt; {            \n        return this.http.get&lt;Game[]&gt;(this.composeFindUrl(title, categoryId));\n    }\n\n    saveGame(game: Game): Observable&lt;void&gt; {\n        let url = 'http://localhost:8080/game';\n\n        if (game.id != null) {\n            url += '/'+game.id;\n        }\n\n        return this.http.put&lt;void&gt;(url, game);\n    }\n\n    private composeFindUrl(title?: String, categoryId?: number) : string {\n        let params = '';\n\n        if (title != null) {\n            params += 'title='+title;\n        }\n\n        if (categoryId != null) {\n            if (params != '') params += \"&amp;\";\n            params += \"idCategory=\"+categoryId;\n        }\n\n        let url = 'http://localhost:8080/game'\n\n        if (params == '') return url;\n        else return url + '?'+params;\n    }\n}\n</code></pre> <p>Y ahora si, podemos navegar por la web y ver el resultado completo.</p>"},{"location":"develop/filtered/nodejs/","title":"Listado simple - Nodejs","text":"<p>En este punto ya tenemos dos listados, uno b\u00e1sico y otro paginado. Ahora vamos a implementar un listado un poco diferente, este listado va a tener filtros de b\u00fasqueda.</p> <p>Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.</p>"},{"location":"develop/filtered/nodejs/#crear-modelos","title":"Crear Modelos","text":"<p>Lo primero que vamos a hacer es crear el modelo de author para trabajar con BBDD. En la carpeta schemas creamos el archivo <code>game.schema.js</code>:</p> game.schema.js <pre><code>import mongoose from \"mongoose\";\nconst { Schema, model } = mongoose;\nimport normalize from 'normalize-mongoose';\n\nconst gameSchema = new Schema({\n    title: {\n        type: String,\n        require: true\n    },\n    age: {\n        type: Number,\n        require: true,\n        max: 99,\n        min: 0\n    },\n    category: {\n        type: Schema.Types.ObjectId,\n        ref: 'Category',\n        required: true\n    },\n    author: {\n        type: Schema.Types.ObjectId,\n        ref: 'Author',\n        required: true\n    }\n});\n\ngameSchema.plugin(normalize);\nconst GameModel = model('Game', gameSchema);\n\nexport default GameModel;\n</code></pre> <p>Lo m\u00e1s novedoso aqu\u00ed es que ahora cada juego va a tener una categor\u00eda y un autor asociados. Para ello simplemente en el tipo del dato <code>Category</code> y <code>Author</code> tenemos que hacer referencia al id del esquema deseado.</p>"},{"location":"develop/filtered/nodejs/#implementar-el-service","title":"Implementar el Service","text":"<p>Creamos el service correspondiente <code>game.service.js</code>:</p> game.service.js <pre><code>import GameModel from '../schemas/game.schema.js';\n\nexport const getGames = async (title, category) =&gt; {\n    try {\n        const regexTitle = new RegExp(title, 'i');\n        const find = category? { $and: [{ title: regexTitle }, { category: category }] } : { title: regexTitle };\n        return await GameModel.find(find).sort('id').populate('category').populate('author');\n    } catch(e) {\n        throw Error('Error fetching games');\n    }\n}\n\nexport const createGame = async (data) =&gt; {\n    try {\n        const game = new GameModel({\n            ...data,\n            category: data.category.id,\n            author: data.author.id,\n        });\n        return await game.save();\n    } catch (e) {\n        throw Error('Error creating game');\n    }\n}\n\nexport const updateGame = async (id, data) =&gt; {\n    try {\n        const game = await GameModel.findById(id);\n        if (!game) {\n            throw Error('There is no game with that Id');\n        }    \n        const gameToUpdate = {\n            ...data,\n            category: data.category.id,\n            author: data.author.id,\n        };\n        return await GameModel.findByIdAndUpdate(id, gameToUpdate, { new: false });\n    } catch (e) {\n        throw Error(e);\n    }\n}\n</code></pre> <p>En este caso recibimos en el m\u00e9todo para recuperar juegos dos par\u00e1metros, el titulo del juego y la categor\u00eda. Aqu\u00ed vamos a utilizar una expresi\u00f3n regular para que podamos encontrar cualquier juego que contenga el titulo que pasemos en su nombre. Con la categor\u00eda tiene que ser el valor exacto de su id. El m\u00e9todo populate lo que hace es traernos toda la informaci\u00f3n de la categor\u00eda y del autor. Sino lo us\u00e1semos solo nos recuperar\u00eda el id.</p>"},{"location":"develop/filtered/nodejs/#implementar-el-controller","title":"Implementar el Controller","text":"<p>Creamos el controlador <code>game.controller.js</code>:</p> game.controller.js <pre><code>import * as GameService from '../services/game.service.js';\n\nexport const getGames = async (req, res) =&gt; {\n    try {\n        const titleToFind = req.query?.title || '';\n        const categoryToFind = req.query?.idCategory || null;\n        const games = await GameService.getGames(titleToFind, categoryToFind);\n        res.status(200).json(games);\n    } catch(err) {\n        res.status(400).json({\n            msg: err.toString()\n        });\n    }\n}\n\nexport const createGame = async (req, res) =&gt; {\n    try {\n        const game = await GameService.createGame(req.body);\n        res.status(200).json({\n            game\n        });\n    } catch (err) {\n        res.status(400).json({\n            msg: err.toString()\n        });\n    }\n}\n\nexport const updateGame = async (req, res) =&gt; {\n    const gameId = req.params.id;\n    try {\n        await GameService.updateGame(gameId, req.body);\n        res.status(200).json(1);\n    } catch (err) {\n        res.status(400).json({\n            msg: err.toString()\n        });\n    }\n}\n</code></pre> <p>Los m\u00e9todos son muy parecidos al resto de los controllers. En este caso para recuperar los datos del filtro tendremos que hacerlo con <code>req.query</code> para leer los datos que nos lleguen como query params en la url. Por ejemplo: <code>http://localhost:8080/game?title=trivial&amp;category=1</code></p>"},{"location":"develop/filtered/nodejs/#implementar-las-rutas","title":"Implementar las Rutas","text":"<p>Y por \u00faltimo creamos nuestro archivo de rutas <code>game.routes.js</code>:</p> game.routes.js <pre><code>import { Router } from 'express';\nimport { check } from 'express-validator';\nimport validateFields from '../middlewares/validateFields.js';\nimport { createGame, getGames, updateGame } from '../controllers/game.controller.js';\nconst gameRouter = Router();\n\ngameRouter.put('/:id', [\n    check('title').not().isEmpty(),\n    check('age').not().isEmpty(),\n    check('age').isNumeric(),\n    check('category.id').not().isEmpty(),\n    check('author.id').not().isEmpty(),\n    validateFields\n], updateGame);\n\ngameRouter.put('/', [\n    check('title').not().isEmpty(),\n    check('age').not().isEmpty(),\n    check('age').isNumeric(),\n    check('category.id').not().isEmpty(),\n    check('author.id').not().isEmpty(),\n    validateFields\n], createGame);\n\ngameRouter.get('/', getGames);\ngameRouter.get('/:query', getGames);\n\nexport default gameRouter;\n</code></pre> <p>En este caso hemos tenido que meter dos rutas para <code>get</code>, una para cuando se informen los filtros y otra para cuando no vayan informados. Si lo hici\u00e9ramos con una \u00fanica ruta nos fallar\u00eda en el otro caso.</p> <p>Finalmente en nuestro archivo <code>index.js</code> vamos a a\u00f1adir el nuevo router:</p> index.js <pre><code>...\n\nimport gameRouter from './src/routes/game.routes.js';\n\n...\n\napp.use('/game', gameRouter);\n\n...\n</code></pre>"},{"location":"develop/filtered/nodejs/#probar-las-operaciones","title":"Probar las operaciones","text":"<p>Y ahora que tenemos todo creado, ya podemos probarlo con Postman:</p> <p>Por un lado creamos juegos con:</p> <p>** PUT /game **</p> <p>** PUT /game/{id} **</p> <pre><code>{\n    \"title\": \"Nuevo juego\",\n    \"age\": \"18\",\n    \"category\": {\n        \"id\": \"63e8b795f7dae4b980b63202\"\n },\n    \"author\": {\n        \"id\": \"63e8bda064c208e065667bfa\"\n    }\n}\n</code></pre> <p></p> <p>Tambi\u00e9n podemos filtrar y recuperar informaci\u00f3n:</p> <p>** GET /game **</p> <p>** GET /game?title=xxx **</p> <p>** GET /game?idCategory=xxx **</p> <p></p> <p></p>"},{"location":"develop/filtered/nodejs/#implementar-validaciones","title":"Implementar validaciones","text":"<p>Ahora que ya tenemos todos nuestros CRUDs creados vamos a introducir unas peque\u00f1as validaciones.</p>"},{"location":"develop/filtered/nodejs/#validacion-en-borrado","title":"Validaci\u00f3n en borrado","text":"<p>La primera validaci\u00f3n sera para que no podamos borrar categor\u00edas ni autores que tengan un juego asociado. Para ello primero tendremos que crear un m\u00e9todo en el servicio de juegos para buscar los juegos que correspondan con un campo dado. En <code>game.service.js</code> a\u00f1adimos:</p> game.service.js <pre><code>...\nexport const getGame = async (field) =&gt; {\n    try {\n        return await GameModel.find(field);\n    } catch (e) {\n        throw Error('Error fetching games');\n    }\n}\n...\n</code></pre> <p>Y ahora en <code>category.service.js</code> importamos el m\u00e9todo creado y modificamos el m\u00e9todo para borrar categor\u00edas:</p> category.service.js <pre><code>...\nimport { getGame } from './game.service.js';\n...\n\n...\nexport const deleteCategory = async (id) =&gt; {\n    try {\n        const category = await CategoryModel.findById(id);\n        if (!category) {\n            throw 'There is no category with that Id';\n        }\n        const games = await getGame({category});\n        if(games.length &gt; 0) {\n            throw 'There are games related to this category';\n        }\n        return await CategoryModel.findByIdAndDelete(id);\n    } catch (e) {\n        throw Error(e);\n    }\n}\n...\n</code></pre> <p>De este modo si encontramos alg\u00fan juego con esta categor\u00eda no nos dejar\u00e1 borrarla.</p> <p>Por \u00faltimo, hacemos lo mismo en <code>author.service.js</code>:</p> author.service.js <pre><code>...\nimport { getGame } from './game.service.js';\n...\n\n...\nexport const deleteAuthor = async (id) =&gt; {\n    try {\n        const author = await AuthorModel.findById(id);\n        if (!author) {\n            throw 'There is no author with that Id';\n        }\n        const games = await getGame({author});\n        if(games.length &gt; 0) {\n            throw 'There are games related to this author';\n        }\n        return await AuthorModel.findByIdAndDelete(id);\n    } catch (e) {\n        throw Error(e);\n    }\n}\n...\n</code></pre>"},{"location":"develop/filtered/nodejs/#validacion-en-creacion","title":"Validaci\u00f3n en creaci\u00f3n","text":"<p>En las creaciones es conveniente validad la existencia de las entidades relacionadas para garantizar la integridad de la BBDD.</p> <p>Para esto vamos a introducir una validaci\u00f3n en la creaci\u00f3n y edici\u00f3n de los juegos para garantizar que la categor\u00eda y el autor proporcionados existen.</p> <p>En primer lugar vamos a crear los servicios de consulta de categor\u00eda y autor:</p> category.service.js <pre><code>...\nexport const getCategory = async (id) =&gt; {\n    try {\n        return await CategoryModel.findById(id);\n    } catch (e) {\n        throw Error('There is no category with that Id');\n    }\n}\n...\n</code></pre> author.service.js <pre><code>...\nexport const getAuthor = async (id) =&gt; {\n    try {\n        return await AuthorModel.findById(id);\n    } catch (e) {\n        throw Error('There is no author with that Id');\n    }\n}\n...\n</code></pre> <p>Teniendo los servicios ya disponibles, vamos a a\u00f1adir las validaciones a los servicios de creaci\u00f3n y edici\u00f3n:</p> game.service.js <pre><code>...\nimport { getCategory } from './category.service.js';\nimport { getAuthor } from './author.service.js';\n...\n\n...\nexport const createGame = async (data) =&gt; {\n    try {\n        const category = await getCategory(data.category.id);\n        if (!category) {\n            throw Error('There is no category with that Id');\n        }\n\n        const author = await getAuthor(data.author.id);\n        if (!author) {\n            throw Error('There is no author with that Id');\n        }\n\n        const game = new GameModel({\n            ...data,\n            category: data.category.id,\n            author: data.author.id,\n        });\n        return await game.save();\n    } catch (e) {\n        throw Error(e);\n    }\n}\n...\n\n...\nexport const updateGame = async (id, data) =&gt; {\n    try {\n        const game = await GameModel.findById(id);\n        if (!game) {\n            throw Error('There is no game with that Id');\n        }\n\n        const category = await getCategory(data.category.id);\n        if (!category) {\n            throw Error('There is no category with that Id');\n        }\n\n        const author = await getAuthor(data.author.id);\n        if (!author) {\n            throw Error('There is no author with that Id');\n        }\n\n        const gameToUpdate = {\n            ...data,\n            category: data.category.id,\n            author: data.author.id,\n        };\n        return await GameModel.findByIdAndUpdate(id, gameToUpdate, { new: false });\n    } catch (e) {\n        throw Error(e);\n    }\n}\n...\n</code></pre> <p>Con esto ya tendr\u00edamos acabado nuestro CRUD.</p>"},{"location":"develop/filtered/react/","title":"Listado filtrado - Angular","text":"<p>En este punto ya tenemos dos listados, uno b\u00e1sico y otro paginado. Ahora vamos a implementar un listado un poco diferente, con filtros y con una presentaci\u00f3n un tanto distinta.</p> <p>Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.</p> <p>Vamos a desarrollar el listado de <code>Juegos</code>. Este listado es un tanto peculiar, porque no tiene una tabla como tal, sino que vamos a mostrar los juegos como cards. Ya tenemos creado nuestro componentes pagina pero vamos a necesitar un componente para mostrar cada uno de los juegos  y otro para crear y editar los juegos.</p>"},{"location":"develop/filtered/react/#crear-componente-game","title":"Crear componente game","text":"<p>Manos a la obra:</p> <p>Creamos el fichero <code>Game.ts</code> dentro de la carpeta <code>types</code>:</p> Game.ts <pre><code>import { Category } from \"./Category\";\nimport { Author } from \"./Author\";\n\nexport interface Game {\n  id: string;\n  title: string;\n  age: number;\n  category?: Category;\n  author?: Author;\n}\n</code></pre> <p>Modificamos nuestra api de <code>Toolkit</code> para a\u00f1adir los <code>endpoints</code> de juegos y aparte creamos un <code>endpoint</code> para recuperar los autores que necesitaremos para crear un nuevo juego, el fichero completo quedar\u00eda de esta manera:</p> <pre><code>import { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\nimport { Game } from \"../../types/Game\";\nimport { Category } from \"../../types/Category\";\nimport { Author, AuthorResponse } from \"../../types/Author\";\n\nexport const ludotecaAPI = createApi({\n  reducerPath: \"ludotecaApi\",\n  baseQuery: fetchBaseQuery({\n    baseUrl: \"http://localhost:8080\",\n  }),\n  tagTypes: [\"Category\", \"Author\", \"Game\"],\n  endpoints: (builder) =&gt; ({\n    getCategories: builder.query&lt;Category[], null&gt;({\n      query: () =&gt; \"category\",\n      providesTags: [\"Category\"],\n    }),\n    createCategory: builder.mutation({\n      query: (payload) =&gt; ({\n        url: \"/category\",\n        method: \"PUT\",\n        body: payload,\n        headers: {\n          \"Content-type\": \"application/json; charset=UTF-8\",\n        },\n      }),\n      invalidatesTags: [\"Category\"],\n    }),\n    deleteCategory: builder.mutation({\n      query: (id: string) =&gt; ({\n        url: `/category/${id}`,\n        method: \"DELETE\",\n      }),\n      invalidatesTags: [\"Category\"],\n    }),\n    updateCategory: builder.mutation({\n      query: (payload: Category) =&gt; ({\n        url: `category/${payload.id}`,\n        method: \"PUT\",\n        body: payload,\n      }),\n      invalidatesTags: [\"Category\"],\n    }),\n    getAllAuthors: builder.query&lt;Author[], null&gt;({\n      query: () =&gt; \"author\",\n      providesTags: [\"Author\"],\n    }),\n    getAuthors: builder.query&lt;\n      AuthorResponse,\n      { pageNumber: number; pageSize: number }\n    &gt;({\n      query: ({ pageNumber, pageSize }) =&gt; {\n        return {\n          url: \"author/\",\n          method: \"POST\",\n          body: {\n            pageable: {\n              pageNumber,\n              pageSize,\n            },\n          },\n        };\n      },\n      providesTags: [\"Author\"],\n    }),\n    createAuthor: builder.mutation({\n      query: (payload) =&gt; ({\n        url: \"/author\",\n        method: \"PUT\",\n        body: payload,\n        headers: {\n          \"Content-type\": \"application/json; charset=UTF-8\",\n        },\n      }),\n      invalidatesTags: [\"Author\"],\n    }),\n    deleteAuthor: builder.mutation({\n      query: (id: string) =&gt; ({\n        url: `/author/${id}`,\n        method: \"DELETE\",\n      }),\n      invalidatesTags: [\"Author\"],\n    }),\n    updateAuthor: builder.mutation({\n      query: (payload: Author) =&gt; ({\n        url: `author/${payload.id}`,\n        method: \"PUT\",\n        body: payload,\n      }),\n      invalidatesTags: [\"Author\", \"Game\"],\n    }),\n    getGames: builder.query&lt;Game[], { title: string; idCategory: string }&gt;({\n      query: ({ title, idCategory }) =&gt; {\n        return {\n          url: \"game/\",\n          params: { title, idCategory },\n        };\n      },\n      providesTags: [\"Game\"],\n    }),\n    createGame: builder.mutation({\n      query: (payload: Game) =&gt; ({\n        url: \"/game\",\n        method: \"PUT\",\n        body: { ...payload },\n        headers: {\n          \"Content-type\": \"application/json; charset=UTF-8\",\n        },\n      }),\n      invalidatesTags: [\"Game\"],\n    }),\n    updateGame: builder.mutation({\n      query: (payload: Game) =&gt; ({\n        url: `game/${payload.id}`,\n        method: \"PUT\",\n        body: { ...payload },\n      }),\n      invalidatesTags: [\"Game\"],\n    }),\n\n  }),\n});\n\nexport const {\n  useGetCategoriesQuery,\n  useCreateCategoryMutation,\n  useDeleteCategoryMutation,\n  useUpdateCategoryMutation,\n  useCreateAuthorMutation,\n  useDeleteAuthorMutation,\n  useGetAllAuthorsQuery,\n  useGetAuthorsQuery,\n  useUpdateAuthorMutation,\n  useCreateGameMutation,\n  useGetGamesQuery,\n  useUpdateGameMutation\n} = ludotecaAPI;\n</code></pre> <p>Creamos una nueva carpeta <code>components</code> dentro de <code>src/pages/Game</code> y dentro creamos un archivo llamado <code>CreateGame.tsx</code> con el siguiente contenido:</p> CreateGame.tsx <pre><code>import { ChangeEvent, useContext, useEffect, useState } from \"react\";\nimport Button from \"@mui/material/Button\";\nimport MenuItem from \"@mui/material/MenuItem\";\nimport TextField from \"@mui/material/TextField\";\nimport Dialog from \"@mui/material/Dialog\";\nimport DialogActions from \"@mui/material/DialogActions\";\nimport DialogContent from \"@mui/material/DialogContent\";\nimport DialogTitle from \"@mui/material/DialogTitle\";\nimport {\n  useGetAllAuthorsQuery,\n  useGetCategoriesQuery,\n} from \"../../../redux/services/ludotecaApi\";\nimport { LoaderContext } from \"../../../context/LoaderProvider\";\nimport { Game } from \"../../../types/Game\";\nimport { Category } from \"../../../types/Category\";\nimport { Author } from \"../../../types/Author\";\n\ninterface Props {\n  game: Game | null;\n  closeModal: () =&gt; void;\n  create: (game: Game) =&gt; void;\n}\n\nconst initialState = {\n  id: \"\",\n  title: \"\",\n  age: 0,\n  category: undefined,\n  author: undefined,\n};\n\nexport default function CreateGame(props: Props) {\n  const [form, setForm] = useState&lt;Game&gt;(initialState);\n  const loader = useContext(LoaderContext);\n  const { data: categories, isLoading: isLoadingCategories } =\n    useGetCategoriesQuery(null);\n  const { data: authors, isLoading: isLoadingAuthors } =\n    useGetAllAuthorsQuery(null);\n\n  useEffect(() =&gt; {\n    setForm({\n      id: props.game?.id || \"\",\n      title: props.game?.title || \"\",\n      age: props.game?.age || 0,\n      category: props.game?.category,\n      author: props.game?.author,\n    });\n  }, [props?.game]);\n\n  useEffect(() =&gt; {\n    loader.showLoading(isLoadingCategories || isLoadingAuthors);\n  }, [isLoadingCategories, isLoadingAuthors]);\n\n  const handleChangeForm = (\n    event: ChangeEvent&lt;HTMLInputElement | HTMLTextAreaElement&gt;\n  ) =&gt; {\n    setForm({\n      ...form,\n      [event.target.id]: event.target.value,\n    });\n  };\n\n  const handleChangeSelect = (\n    event: ChangeEvent&lt;HTMLInputElement | HTMLTextAreaElement&gt;\n  ) =&gt; {\n    const values = event.target.name === \"category\" ? categories : authors;\n    setForm({\n      ...form,\n      [event.target.name]: values?.find((val) =&gt; val.id === event.target.value),\n    });\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;Dialog open={true} onClose={props.closeModal}&gt;\n        &lt;DialogTitle&gt;\n          {props.game ? \"Actualizar Juego\" : \"Crear Juego\"}\n        &lt;/DialogTitle&gt;\n        &lt;DialogContent&gt;\n          {props.game &amp;&amp; (\n            &lt;TextField\n              margin=\"dense\"\n              disabled\n              id=\"id\"\n              label=\"Id\"\n              fullWidth\n              value={props.game.id}\n              variant=\"standard\"\n            /&gt;\n          )}\n          &lt;TextField\n            margin=\"dense\"\n            id=\"title\"\n            label=\"Titulo\"\n            fullWidth\n            variant=\"standard\"\n            onChange={handleChangeForm}\n            value={form.title}\n          /&gt;\n          &lt;TextField\n            margin=\"dense\"\n            id=\"age\"\n            label=\"Edad Recomendada\"\n            fullWidth\n            type=\"number\"\n            variant=\"standard\"\n            onChange={handleChangeForm}\n            value={form.age}\n          /&gt;\n          &lt;TextField\n            id=\"category\"\n            select\n            label=\"Categor\u00eda\"\n            defaultValue=\"''\"\n            fullWidth\n            variant=\"standard\"\n            name=\"category\"\n            value={form.category ? form.category.id : \"\"}\n            onChange={handleChangeSelect}\n          &gt;\n            {categories &amp;&amp;\n              categories.map((option: Category) =&gt; (\n                &lt;MenuItem key={option.id} value={option.id}&gt;\n                  {option.name}\n                &lt;/MenuItem&gt;\n              ))}\n          &lt;/TextField&gt;\n          &lt;TextField\n            id=\"author\"\n            select\n            label=\"Autor\"\n            defaultValue=\"''\"\n            fullWidth\n            variant=\"standard\"\n            name=\"author\"\n            value={form.author ? form.author.id : \"\"}\n            onChange={handleChangeSelect}\n          &gt;\n            {authors &amp;&amp;\n              authors.map((option: Author) =&gt; (\n                &lt;MenuItem key={option.id} value={option.id}&gt;\n                  {option.name}\n                &lt;/MenuItem&gt;\n              ))}\n          &lt;/TextField&gt;\n        &lt;/DialogContent&gt;\n        &lt;DialogActions&gt;\n          &lt;Button onClick={props.closeModal}&gt;Cancelar&lt;/Button&gt;\n          &lt;Button\n            onClick={() =&gt;\n              props.create({\n                id: \"\",\n                title: form.title,\n                age: form.age,\n                category: form.category,\n                author: form.author,\n              })\n            }\n            disabled={\n              !form.title || !form.age || !form.category || !form.author\n            }\n          &gt;\n            {props.game ? \"Actualizar\" : \"Crear\"}\n          &lt;/Button&gt;\n        &lt;/DialogActions&gt;\n      &lt;/Dialog&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>Ahora en esa misma carpeta crearemos el componente <code>GameCard.tsx</code> para mostrar nuestros juegos con un dise\u00f1o de carta:</p> GameCard.tsx <pre><code>import Card from \"@mui/material/Card\";\nimport CardContent from \"@mui/material/CardContent\";\nimport CardMedia from \"@mui/material/CardMedia\";\nimport CardHeader from \"@mui/material/CardHeader\";\nimport List from \"@mui/material/List\";\nimport ListItem from \"@mui/material/ListItem\";\nimport ListItemAvatar from \"@mui/material/ListItemAvatar\";\nimport ListItemText from \"@mui/material/ListItemText\";\nimport Avatar from \"@mui/material/Avatar\";\nimport PersonIcon from \"@mui/icons-material/Person\";\nimport LanguageIcon from \"@mui/icons-material/Language\";\nimport CardActionArea from \"@mui/material/CardActionArea\";\nimport red from \"@mui/material/colors/red\";\nimport imageGame from \"./../../../assets/foto.png\";\nimport { Game } from \"../../../types/Game\";\n\ninterface GameCardProps {\n  game: Game;\n}\n\nexport default function GameCard(props: GameCardProps) {\n  const { title, age, category, author } = props.game;\n  return (\n    &lt;Card sx={{ maxWidth: 265 }}&gt;\n      &lt;CardHeader\n        sx={{\n          \".MuiCardHeader-title\": {\n            fontSize: \"20px\",\n          },\n        }}\n        avatar={\n          &lt;Avatar sx={{ bgcolor: red[500] }} aria-label=\"age\"&gt;\n            +{age}\n          &lt;/Avatar&gt;\n        }\n        title={title}\n        subheader={category?.name}\n      /&gt;\n      &lt;CardActionArea&gt;\n        &lt;CardMedia\n          component=\"img\"\n          height=\"140\"\n          image={imageGame}\n          alt=\"game image\"\n        /&gt;\n        &lt;CardContent&gt;\n          &lt;List dense={true}&gt;\n            &lt;ListItem&gt;\n              &lt;ListItemAvatar&gt;\n                &lt;Avatar&gt;\n                  &lt;PersonIcon /&gt;\n                &lt;/Avatar&gt;\n              &lt;/ListItemAvatar&gt;\n              &lt;ListItemText primary={`Autor: ${author?.name}`} /&gt;\n            &lt;/ListItem&gt;\n            &lt;ListItem&gt;\n              &lt;ListItemAvatar&gt;\n                &lt;Avatar&gt;\n                  &lt;LanguageIcon /&gt;\n                &lt;/Avatar&gt;\n              &lt;/ListItemAvatar&gt;\n              &lt;ListItemText primary={`Nacionalidad: ${author?.nationality}`} /&gt;\n            &lt;/ListItem&gt;\n          &lt;/List&gt;\n        &lt;/CardContent&gt;\n      &lt;/CardActionArea&gt;\n    &lt;/Card&gt;\n  );\n}\n</code></pre> <p>En la carpeta <code>src/pages/game</code> vamos a crear un fichero para los estilos llamado <code>Game.module.css</code>: </p> Game.module.css <pre><code>.filter {\n    display: flex;\n    align-items: center;\n}\n\n.cards {\n    display: flex;\n    gap: 20px;\n    padding: 10px;\n    flex-wrap: wrap;\n}\n\n.card {\n    cursor: pointer;\n}\n\n@media (max-width: 800px) {\n    .cards {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n    }\n\n    .filter {\n        display: flex;\n        flex-direction: column;\n    }\n}\n</code></pre> <p>Y por \u00faltimo modificamos nuestro componente p\u00e1gina <code>Game</code> y lo dejamos de esta manera:</p> Game.tsx <pre><code>import { useState, useContext, useEffect } from \"react\";\nimport MenuItem from \"@mui/material/MenuItem\";\nimport FormControl from \"@mui/material/FormControl\";\nimport TextField from \"@mui/material/TextField\";\nimport Button from \"@mui/material/Button\";\nimport GameCard from \"./components/GameCard\";\nimport styles from \"./Game.module.css\";\nimport {\n  useCreateGameMutation,\n  useGetCategoriesQuery,\n  useGetGamesQuery,\n  useUpdateGameMutation,\n} from \"../../redux/services/ludotecaApi\";\nimport CreateGame from \"./components/CreateGame\";\nimport { LoaderContext } from \"../../context/LoaderProvider\";\nimport { useAppDispatch } from \"../../redux/hooks\";\nimport { setMessage } from \"../../redux/features/messagesSlice\";\nimport { Game as GameModel } from \"../../types/Game\";\nimport { Category } from \"../../types/Category\";\n\nexport const Game = () =&gt; {\n  const [openCreate, setOpenCreate] = useState(false);\n  const [filterTitle, setFilterTitle] = useState(\"\");\n  const [filterCategory, setFilterCategory] = useState(\"\");\n  const [gameToUpdate, setGameToUpdate] = useState&lt;GameModel | null&gt;(null);\n  const loader = useContext(LoaderContext);\n  const dispatch = useAppDispatch();\n\n  const { data, error, isLoading, isFetching } = useGetGamesQuery({\n    title: filterTitle,\n    idCategory: filterCategory,\n  });\n\n  const [updateGameApi, { isLoading: isLoadingUpdate, error: errorUpdate }] =\n    useUpdateGameMutation();\n\n  const { data: categories } = useGetCategoriesQuery(null);\n\n  const [createGameApi, { isLoading: isLoadingCreate, error: errorCreate }] =\n    useCreateGameMutation();\n\n  useEffect(() =&gt; {\n    loader.showLoading(\n      isLoadingCreate || isLoadingUpdate || isLoading || isFetching\n    );\n  }, [isLoadingCreate, isLoadingUpdate, isLoading, isFetching]);\n\n  useEffect(() =&gt; {\n    if (errorCreate || errorUpdate) {\n      setMessage({\n        text: \"Se ha producido un error al realizar la operaci\u00f3n\",\n        type: \"error\",\n      });\n    }\n  }, [errorUpdate, errorCreate]);\n\n  if (error) return &lt;p&gt;Error cargando!!!&lt;/p&gt;;\n\n  const createGame = (game: GameModel) =&gt; {\n    setOpenCreate(false);\n    if (gameToUpdate) {\n      updateGameApi({\n        ...game,\n        id: gameToUpdate.id,\n      })\n        .then(() =&gt; {\n          dispatch(\n            setMessage({\n              text: \"Juego actualizado correctamente\",\n              type: \"ok\",\n            })\n          );\n          setGameToUpdate(null);\n        })\n        .catch((err) =&gt; console.log(err));\n    } else {\n      createGameApi(game)\n        .then(() =&gt; {\n          dispatch(\n            setMessage({\n              text: \"Juego creado correctamente\",\n              type: \"ok\",\n            })\n          );\n          setGameToUpdate(null);\n        })\n        .catch((err) =&gt; console.log(err));\n    }\n  };\n\n  return (\n    &lt;div className=\"container\"&gt;\n      &lt;h1&gt;Cat\u00e1logo de juegos&lt;/h1&gt;\n      &lt;div className={styles.filter}&gt;\n        &lt;FormControl variant=\"standard\" sx={{ m: 1, minWidth: 220 }}&gt;\n          &lt;TextField\n            margin=\"dense\"\n            id=\"title\"\n            label=\"Titulo\"\n            fullWidth\n            value={filterTitle}\n            variant=\"standard\"\n            onChange={(event) =&gt; setFilterTitle(event.target.value)}\n          /&gt;\n        &lt;/FormControl&gt;\n        &lt;FormControl variant=\"standard\" sx={{ m: 1, minWidth: 220 }}&gt;\n          &lt;TextField\n            id=\"category\"\n            select\n            label=\"Categor\u00eda\"\n            defaultValue=\"''\"\n            fullWidth\n            variant=\"standard\"\n            name=\"author\"\n            value={filterCategory}\n            onChange={(event) =&gt; setFilterCategory(event.target.value)}\n          &gt;\n            {categories &amp;&amp;\n              categories.map((option: Category) =&gt; (\n                &lt;MenuItem key={option.id} value={option.id}&gt;\n                  {option.name}\n                &lt;/MenuItem&gt;\n              ))}\n          &lt;/TextField&gt;\n        &lt;/FormControl&gt;\n        &lt;Button\n          variant=\"outlined\"\n          onClick={() =&gt; {\n            setFilterCategory(\"\");\n            setFilterTitle(\"\");\n          }}\n        &gt;\n          Limpiar\n        &lt;/Button&gt;\n      &lt;/div&gt;\n      &lt;div className={styles.cards}&gt;\n        {data?.map((card) =&gt; (\n          &lt;div\n            key={card.id}\n            className={styles.card}\n            onClick={() =&gt; {\n              setGameToUpdate(card);\n              setOpenCreate(true);\n            }}\n          &gt;\n            &lt;GameCard game={card} /&gt;\n          &lt;/div&gt;\n        ))}\n      &lt;/div&gt;\n      &lt;div className=\"newButton\"&gt;\n        &lt;Button variant=\"contained\" onClick={() =&gt; setOpenCreate(true)}&gt;\n          Nuevo juego\n        &lt;/Button&gt;\n      &lt;/div&gt;\n      {openCreate &amp;&amp; (\n        &lt;CreateGame\n          create={createGame}\n          game={gameToUpdate}\n          closeModal={() =&gt; {\n            setGameToUpdate(null);\n            setOpenCreate(false);\n          }}\n        /&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Y por \u00faltimo descargamos la siguiente imagen y la guardamos en la carpeta <code>src/assets</code>.</p> <p>En este listado realizamos el filtro de manera din\u00e1mica, en el momento en que cambiamos el valor de la categor\u00eda o el t\u00edtulo a filtrar, como estas variables est\u00e1n asociadas al estado de nuestro componente, se vuelve a renderizar y por lo tanto se actualiza el valor de \"data\" modificando as\u00ed los resultados.</p> <p>El resto es muy parecido a lo que ya hemos realizado antes. Aqu\u00ed no tenemos una tabla, sino que mostramos nuestros juegos como Cards y si pulsamos sobre cualquier Card se mostrar\u00e1 el formulario de edici\u00f3n del juego.</p> <p>Si ahora arrancamos el proyecto y nos vamos a la pagina de juegos podremos crear y ver nuestros juegos.</p>"},{"location":"develop/filtered/springboot/","title":"Listado filtrado - Spring Boot","text":"<p>En este punto ya tenemos dos listados, uno b\u00e1sico y otro paginado. Ahora vamos a implementar un listado un poco diferente, este listado va a tener filtros de b\u00fasqueda.</p> <p>Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.</p>"},{"location":"develop/filtered/springboot/#crear-modelos","title":"Crear Modelos","text":"<p>Lo primero que vamos a hacer es crear los modelos para trabajar con BBDD y con peticiones hacia el front. Adem\u00e1s, tambi\u00e9n tenemos que a\u00f1adir datos al script de inicializaci\u00f3n de BBDD.</p> Game.javaGameDto.javadata.sql <pre><code>package com.ccsw.tutorial.game.model;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport com.ccsw.tutorial.category.model.Category;\n\nimport jakarta.persistence.*;\n\n\n/**\n * @author ccsw\n *\n */\n@Entity\n@Table(name = \"game\")\npublic class Game {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\", nullable = false)\n    private Long id;\n\n    @Column(name = \"title\", nullable = false)\n    private String title;\n\n    @Column(name = \"age\", nullable = false)\n    private String age;\n\n    @ManyToOne\n    @JoinColumn(name = \"category_id\", nullable = false)\n    private Category category;\n\n    @ManyToOne\n    @JoinColumn(name = \"author_id\", nullable = false)\n    private Author author;\n\n    /**\n     * @return id\n     */\n    public Long getId() {\n\n        return this.id;\n    }\n\n    /**\n     * @param id new value of {@link #getId}.\n     */\n    public void setId(Long id) {\n\n        this.id = id;\n    }\n\n    /**\n     * @return title\n     */\n    public String getTitle() {\n\n        return this.title;\n    }\n\n    /**\n     * @param title new value of {@link #getTitle}.\n     */\n    public void setTitle(String title) {\n\n        this.title = title;\n    }\n\n    /**\n     * @return age\n     */\n    public String getAge() {\n\n        return this.age;\n    }\n\n    /**\n     * @param age new value of {@link #getAge}.\n     */\n    public void setAge(String age) {\n\n        this.age = age;\n    }\n\n    /**\n     * @return category\n     */\n    public Category getCategory() {\n\n        return this.category;\n    }\n\n    /**\n     * @param category new value of {@link #getCategory}.\n     */\n    public void setCategory(Category category) {\n\n        this.category = category;\n    }\n\n    /**\n     * @return author\n     */\n    public Author getAuthor() {\n\n        return this.author;\n    }\n\n    /**\n     * @param author new value of {@link #getAuthor}.\n     */\n    public void setAuthor(Author author) {\n\n        this.author = author;\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.game.model;\n\nimport com.ccsw.tutorial.author.model.AuthorDto;\nimport com.ccsw.tutorial.category.model.CategoryDto;\n\n/**\n * @author ccsw\n *\n */\npublic class GameDto {\n\n    private Long id;\n\n    private String title;\n\n    private String age;\n\n    private CategoryDto category;\n\n    private AuthorDto author;\n\n    /**\n     * @return id\n     */\n    public Long getId() {\n\n        return this.id;\n    }\n\n    /**\n     * @param id new value of {@link #getId}.\n     */\n    public void setId(Long id) {\n\n        this.id = id;\n    }\n\n    /**\n     * @return title\n     */\n    public String getTitle() {\n\n        return this.title;\n    }\n\n    /**\n     * @param title new value of {@link #getTitle}.\n     */\n    public void setTitle(String title) {\n\n        this.title = title;\n    }\n\n    /**\n     * @return age\n     */\n    public String getAge() {\n\n        return this.age;\n    }\n\n    /**\n     * @param age new value of {@link #getAge}.\n     */\n    public void setAge(String age) {\n\n        this.age = age;\n    }\n\n    /**\n     * @return category\n     */\n    public CategoryDto getCategory() {\n\n        return this.category;\n    }\n\n    /**\n     * @param category new value of {@link #getCategory}.\n     */\n    public void setCategory(CategoryDto category) {\n\n        this.category = category;\n    }\n\n    /**\n     * @return author\n     */\n    public AuthorDto getAuthor() {\n\n        return this.author;\n    }\n\n    /**\n     * @param author new value of {@link #getAuthor}.\n     */\n    public void setAuthor(AuthorDto author) {\n\n        this.author = author;\n    }\n\n}\n</code></pre> <pre><code>INSERT INTO category(name) VALUES ('Eurogames');\nINSERT INTO category(name) VALUES ('Ameritrash');\nINSERT INTO category(name) VALUES ('Familiar');\n\nINSERT INTO author(name, nationality) VALUES ('Alan R. Moon', 'US');\nINSERT INTO author(name, nationality) VALUES ('Vital Lacerda', 'PT');\nINSERT INTO author(name, nationality) VALUES ('Simone Luciani', 'IT');\nINSERT INTO author(name, nationality) VALUES ('Perepau Llistosella', 'ES');\nINSERT INTO author(name, nationality) VALUES ('Michael Kiesling', 'DE');\nINSERT INTO author(name, nationality) VALUES ('Phil Walker-Harding', 'US');\n\nINSERT INTO game(title, age, category_id, author_id) VALUES ('On Mars', '14', 1, 2);\nINSERT INTO game(title, age, category_id, author_id) VALUES ('Aventureros al tren', '8', 3, 1);\nINSERT INTO game(title, age, category_id, author_id) VALUES ('1920: Wall Street', '12', 1, 4);\nINSERT INTO game(title, age, category_id, author_id) VALUES ('Barrage', '14', 1, 3);\nINSERT INTO game(title, age, category_id, author_id) VALUES ('Los viajes de Marco Polo', '12', 1, 3);\nINSERT INTO game(title, age, category_id, author_id) VALUES ('Azul', '8', 3, 5);\n</code></pre> <p>Relaciones anidadas</p> <p>F\u00edjate que tanto la <code>Entity</code> como el <code>Dto</code> tienen relaciones con <code>Author</code> y <code>Category</code>. Gracias a Spring JPA se pueden resolver de esta forma y tener toda la informaci\u00f3n de las relaciones hijas dentro del objeto padre. Muy importante recordar que en el mundo entity las relaciones ser\u00e1n con objetos <code>Entity</code> mientras que en el mundo dto las relaciones deben ser siempre con objetos <code>Dto</code>. La utilidad beanMapper ya har\u00e1 las conversiones necesarias, siempre que tengan el mismo nombre de propiedades.</p>"},{"location":"develop/filtered/springboot/#tdd-pruebas","title":"TDD - Pruebas","text":"<p>Para desarrollar todas las operaciones, empezaremos primero dise\u00f1ando las pruebas y luego implementando el c\u00f3digo necesario que haga funcionar correctamente esas pruebas. Para ir m\u00e1s r\u00e1pido vamos a poner todas las pruebas de golpe, pero realmente se deber\u00edan crear una a una e ir implementando el c\u00f3digo necesario para esa prueba. Para evitar tantas iteraciones en el tutorial las haremos todas de golpe.</p> <p>Vamos a pararnos a pensar un poco que necesitamos en la pantalla. En este caso solo tenemos dos operaciones:</p> <ul> <li>Una consulta filtrada, que reciba datos de filtro opcionales (t\u00edtulo e idCategor\u00eda) y devuelva los datos ya filtrados</li> <li>Una operaci\u00f3n de guardado y modificaci\u00f3n</li> </ul> <p>De nuevo tendremos que desglosar esto en varios casos de prueba:</p> <ul> <li>Buscar un juego sin filtros</li> <li>Buscar un t\u00edtulo que exista</li> <li>Buscar una categor\u00eda que exista</li> <li>Buscar un t\u00edtulo y una categor\u00eda que existan</li> <li>Buscar un t\u00edtulo que no exista</li> <li>Buscar una categor\u00eda que no exista</li> <li>Buscar un t\u00edtulo y una categor\u00eda que no existan</li> <li>Crear un juego nuevo (en realidad deber\u00edamos probar diferentes combinaciones y errores)</li> <li>Modificar un juego que exista</li> <li>Modificar un juego que no exista</li> </ul> <p>Tambi\u00e9n crearemos una clase <code>GameController</code> dentro del package de <code>com.ccsw.tutorial.game</code> con la implementaci\u00f3n de los m\u00e9todos vac\u00edos, para que no falle la compilaci\u00f3n.</p> <p>\u00a1Vamos a implementar test!</p> GameController.javaGameIT.java <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.game.model.Game;\nimport com.ccsw.tutorial.game.model.GameDto;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Tag(name = \"Game\", description = \"API of Game\")\n@RequestMapping(value = \"/game\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class GameController {\n\n    /**\n     * M\u00e9todo para recuperar una lista de {@link Game}\n     *\n     * @param title t\u00edtulo del juego\n     * @param idCategory PK de la categor\u00eda\n     * @return {@link List} de {@link GameDto}\n     */\n    @Operation(summary = \"Find\", description = \"Method that return a filtered list of Games\")\n    @RequestMapping(path = \"\", method = RequestMethod.GET)\n    public List&lt;GameDto&gt; find(@RequestParam(value = \"title\", required = false) String title,\n                              @RequestParam(value = \"idCategory\", required = false) Long idCategory) {\n\n        return null;\n    }\n\n    /**\n     * M\u00e9todo para crear o actualizar un {@link Game}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    @Operation(summary = \"Save or Update\", description = \"Method that saves or updates a Game\")\n    @RequestMapping(path = { \"\", \"/{id}\" }, method = RequestMethod.PUT)\n    public void save(@PathVariable(name = \"id\", required = false) Long id, @RequestBody GameDto dto) {\n\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.author.model.AuthorDto;\nimport com.ccsw.tutorial.category.model.CategoryDto;\nimport com.ccsw.tutorial.game.model.GameDto;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.web.client.TestRestTemplate;\nimport org.springframework.boot.test.web.server.LocalServerPort;\nimport org.springframework.core.ParameterizedTypeReference;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.test.annotation.DirtiesContext;\nimport org.springframework.web.util.UriComponentsBuilder;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\npublic class GameIT {\n\n    public static final String LOCALHOST = \"http://localhost:\";\n    public static final String SERVICE_PATH = \"/game\";\n\n    public static final Long EXISTS_GAME_ID = 1L;\n    public static final Long NOT_EXISTS_GAME_ID = 0L;\n    private static final String NOT_EXISTS_TITLE = \"NotExists\";\n    private static final String EXISTS_TITLE = \"Aventureros\";\n    private static final String NEW_TITLE = \"Nuevo juego\";\n    private static final Long NOT_EXISTS_CATEGORY = 0L;\n    private static final Long EXISTS_CATEGORY = 3L;\n\n    private static final String TITLE_PARAM = \"title\";\n    private static final String CATEGORY_ID_PARAM = \"idCategory\";\n\n    @LocalServerPort\n    private int port;\n\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    ParameterizedTypeReference&lt;List&lt;GameDto&gt;&gt; responseType = new ParameterizedTypeReference&lt;List&lt;GameDto&gt;&gt;(){};\n\n    private String getUrlWithParams(){\n    return UriComponentsBuilder.fromHttpUrl(LOCALHOST + port + SERVICE_PATH)\n    .queryParam(TITLE_PARAM, \"{\" + TITLE_PARAM +\"}\")\n    .queryParam(CATEGORY_ID_PARAM, \"{\" + CATEGORY_ID_PARAM +\"}\")\n    .encode()\n    .toUriString();\n    }\n\n    @Test\n    public void findWithoutFiltersShouldReturnAllGamesInDB() {\n\n          int GAMES_WITH_FILTER = 6;\n\n          Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();\n          params.put(TITLE_PARAM, null);\n          params.put(CATEGORY_ID_PARAM, null);\n\n          ResponseEntity&lt;List&lt;GameDto&gt;&gt; response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\n          assertNotNull(response);\n          assertEquals(GAMES_WITH_FILTER, response.getBody().size());\n    }\n\n    @Test\n    public void findExistsTitleShouldReturnGames() {\n\n          int GAMES_WITH_FILTER = 1;\n\n          Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();\n          params.put(TITLE_PARAM, EXISTS_TITLE);\n          params.put(CATEGORY_ID_PARAM, null);\n\n          ResponseEntity&lt;List&lt;GameDto&gt;&gt; response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\n          assertNotNull(response);\n          assertEquals(GAMES_WITH_FILTER, response.getBody().size());\n    }\n\n    @Test\n    public void findExistsCategoryShouldReturnGames() {\n\n          int GAMES_WITH_FILTER = 2;\n\n          Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();\n          params.put(TITLE_PARAM, null);\n          params.put(CATEGORY_ID_PARAM, EXISTS_CATEGORY);\n\n          ResponseEntity&lt;List&lt;GameDto&gt;&gt; response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\n          assertNotNull(response);\n          assertEquals(GAMES_WITH_FILTER, response.getBody().size());\n    }\n\n    @Test\n    public void findExistsTitleAndCategoryShouldReturnGames() {\n\n          int GAMES_WITH_FILTER = 1;\n\n          Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();\n          params.put(TITLE_PARAM, EXISTS_TITLE);\n          params.put(CATEGORY_ID_PARAM, EXISTS_CATEGORY);\n\n          ResponseEntity&lt;List&lt;GameDto&gt;&gt; response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\n          assertNotNull(response);\n          assertEquals(GAMES_WITH_FILTER, response.getBody().size());\n    }\n\n    @Test\n    public void findNotExistsTitleShouldReturnEmpty() {\n\n          int GAMES_WITH_FILTER = 0;\n\n          Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();\n          params.put(TITLE_PARAM, NOT_EXISTS_TITLE);\n          params.put(CATEGORY_ID_PARAM, null);\n\n          ResponseEntity&lt;List&lt;GameDto&gt;&gt; response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\n          assertNotNull(response);\n          assertEquals(GAMES_WITH_FILTER, response.getBody().size());\n    }\n\n    @Test\n    public void findNotExistsCategoryShouldReturnEmpty() {\n\n          int GAMES_WITH_FILTER = 0;\n\n          Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();\n          params.put(TITLE_PARAM, null);\n          params.put(CATEGORY_ID_PARAM, NOT_EXISTS_CATEGORY);\n\n          ResponseEntity&lt;List&lt;GameDto&gt;&gt; response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\n          assertNotNull(response);\n          assertEquals(GAMES_WITH_FILTER, response.getBody().size());\n    }\n\n    @Test\n    public void findNotExistsTitleOrCategoryShouldReturnEmpty() {\n\n          int GAMES_WITH_FILTER = 0;\n\n          Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();\n          params.put(TITLE_PARAM, NOT_EXISTS_TITLE);\n          params.put(CATEGORY_ID_PARAM, NOT_EXISTS_CATEGORY);\n\n          ResponseEntity&lt;List&lt;GameDto&gt;&gt; response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n          assertNotNull(response);\n          assertEquals(GAMES_WITH_FILTER, response.getBody().size());\n\n          params.put(TITLE_PARAM, NOT_EXISTS_TITLE);\n          params.put(CATEGORY_ID_PARAM, EXISTS_CATEGORY);\n\n          response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n          assertNotNull(response);\n          assertEquals(GAMES_WITH_FILTER, response.getBody().size());\n\n          params.put(TITLE_PARAM, EXISTS_TITLE);\n          params.put(CATEGORY_ID_PARAM, NOT_EXISTS_CATEGORY);\n\n          response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n          assertNotNull(response);\n          assertEquals(GAMES_WITH_FILTER, response.getBody().size());\n    }\n\n    @Test\n    public void saveWithoutIdShouldCreateNewGame() {\n\n          GameDto dto = new GameDto();\n          AuthorDto authorDto = new AuthorDto();\n          authorDto.setId(1L);\n\n          CategoryDto categoryDto = new CategoryDto();\n          categoryDto.setId(1L);\n\n          dto.setTitle(NEW_TITLE);\n          dto.setAge(\"18\");\n          dto.setAuthor(authorDto);\n          dto.setCategory(categoryDto);\n\n          Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();\n          params.put(TITLE_PARAM, NEW_TITLE);\n          params.put(CATEGORY_ID_PARAM, null);\n\n          ResponseEntity&lt;List&lt;GameDto&gt;&gt; response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\n          assertNotNull(response);\n          assertEquals(0, response.getBody().size());\n\n          restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.PUT, new HttpEntity&lt;&gt;(dto), Void.class);\n\n          response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\n          assertNotNull(response);\n          assertEquals(1, response.getBody().size());\n    }\n\n    @Test\n    public void modifyWithExistIdShouldModifyGame() {\n\n          GameDto dto = new GameDto();\n          AuthorDto authorDto = new AuthorDto();\n          authorDto.setId(1L);\n\n          CategoryDto categoryDto = new CategoryDto();\n          categoryDto.setId(1L);\n\n          dto.setTitle(NEW_TITLE);\n          dto.setAge(\"18\");\n          dto.setAuthor(authorDto);\n          dto.setCategory(categoryDto);\n\n          Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();\n          params.put(TITLE_PARAM, NEW_TITLE);\n          params.put(CATEGORY_ID_PARAM, null);\n\n          ResponseEntity&lt;List&lt;GameDto&gt;&gt; response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\n          assertNotNull(response);\n          assertEquals(0, response.getBody().size());\n\n          restTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + EXISTS_GAME_ID, HttpMethod.PUT, new HttpEntity&lt;&gt;(dto), Void.class);\n\n          response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\n          assertNotNull(response);\n          assertEquals(1, response.getBody().size());\n          assertEquals(EXISTS_GAME_ID, response.getBody().get(0).getId());\n    }\n\n    @Test\n    public void modifyWithNotExistIdShouldThrowException() {\n\n          GameDto dto = new GameDto();\n          dto.setTitle(NEW_TITLE);\n\n          ResponseEntity&lt;?&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + NOT_EXISTS_GAME_ID, HttpMethod.PUT, new HttpEntity&lt;&gt;(dto), Void.class);\n\n          assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());\n    }\n\n}\n</code></pre> <p>B\u00fasquedas en BBDD</p> <p>Siempre deber\u00edamos buscar a los hijos por primary keys, nunca hay que hacerlo por una descripci\u00f3n libre, ya que el usuario podr\u00eda teclear el mismo nombre de diferentes formas y no habr\u00eda manera de buscar correctamente el resultado. As\u00ed que siempre que haya un dropdown, se debe filtrar por su ID.</p> <p>Si ahora ejecutas los jUnits, ver\u00e1s que en este caso hemos construido 10 pruebas, para cubrir los casos b\u00e1sicos del <code>Controller</code>, y todas ellas fallan la ejecuci\u00f3n. Vamos a seguir implementando el resto de capas para hacer que los test funcionen.</p>"},{"location":"develop/filtered/springboot/#controller","title":"Controller","text":"<p>De nuevo para poder compilar esta capa, nos hace falta delegar sus operaciones de l\u00f3gica de negocio en un <code>Service</code> as\u00ed que lo crearemos al mismo tiempo que lo vamos necesitando.</p> GameService.javaGameController.java <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.game.model.Game;\nimport com.ccsw.tutorial.game.model.GameDto;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\npublic interface GameService {\n\n    /**\n     * Recupera los juegos filtrando opcionalmente por t\u00edtulo y/o categor\u00eda\n     *\n     * @param title t\u00edtulo del juego\n     * @param idCategory PK de la categor\u00eda\n     * @return {@link List} de {@link Game}\n     */\n    List&lt;Game&gt; find(String title, Long idCategory);\n\n    /**\n     * Guarda o modifica un juego, dependiendo de si el identificador est\u00e1 o no informado\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    void save(Long id, GameDto dto);\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.game.model.Game;\nimport com.ccsw.tutorial.game.model.GameDto;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport org.modelmapper.ModelMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * @author ccsw\n *\n */\n@Tag(name = \"Game\", description = \"API of Game\")\n@RequestMapping(value = \"/game\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class GameController {\n\n    @Autowired\n    GameService gameService;\n\n    @Autowired\n    ModelMapper mapper;\n\n    /**\n     * M\u00e9todo para recuperar una lista de {@link Game}\n     *\n     * @param title t\u00edtulo del juego\n     * @param idCategory PK de la categor\u00eda\n     * @return {@link List} de {@link GameDto}\n     */\n    @Operation(summary = \"Find\", description = \"Method that return a filtered list of Games\")\n    @RequestMapping(path = \"\", method = RequestMethod.GET)\n    public List&lt;GameDto&gt; find(@RequestParam(value = \"title\", required = false) String title,\n                              @RequestParam(value = \"idCategory\", required = false) Long idCategory) {\n\n        List&lt;Game&gt; games = gameService.find(title, idCategory);\n\n        return games.stream().map(e -&gt; mapper.map(e, GameDto.class)).collect(Collectors.toList());\n    }\n\n    /**\n     * M\u00e9todo para crear o actualizar un {@link Game}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    @Operation(summary = \"Save or Update\", description = \"Method that saves or updates a Game\")\n    @RequestMapping(path = { \"\", \"/{id}\" }, method = RequestMethod.PUT)\n    public void save(@PathVariable(name = \"id\", required = false) Long id, @RequestBody GameDto dto) {\n\n        gameService.save(id, dto);\n    }\n\n}\n</code></pre> <p>En esta ocasi\u00f3n, para el m\u00e9todo de b\u00fasqueda hemos decidido utilizar par\u00e1metros en la URL de tal forma que nos quedar\u00e1 algo as\u00ed <code>http://localhost:8080/game/?title=xxx&amp;idCategoria=yyy</code>. Queremos recuperar el recurso <code>Game</code> que es el raiz de la ruta, pero filtrado por cero o varios par\u00e1metros.</p>"},{"location":"develop/filtered/springboot/#service","title":"Service","text":"<p>Siguiente paso, la capa de l\u00f3gica de negocio, es decir el <code>Service</code>, que por tanto har\u00e1 uso de un <code>Repository</code>.</p> GameServiceImpl.javaGameRepository.java <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.game.model.Game;\nimport com.ccsw.tutorial.game.model.GameDto;\nimport jakarta.transaction.Transactional;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Service\n@Transactional\npublic class GameServiceImpl implements GameService {\n\n    @Autowired\n    GameRepository gameRepository;\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public List&lt;Game&gt; find(String title, Long idCategory) {\n\n        return (List&lt;Game&gt;) this.gameRepository.findAll();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void save(Long id, GameDto dto) {\n\n        Game game;\n\n        if (id == null) {\n            game = new Game();\n        } else {\n            game = this.gameRepository.findById(id).orElse(null);\n        }\n\n        BeanUtils.copyProperties(dto, game, \"id\", \"author\", \"category\");\n\n        this.gameRepository.save(game);\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.game.model.Game;\nimport org.springframework.data.repository.CrudRepository;\n\n/**\n * @author ccsw\n *\n */\npublic interface GameRepository extends CrudRepository&lt;Game, Long&gt; {\n\n}\n</code></pre> <p>Este servicio tiene dos peculiaridades, remarcadas en amarillo en la clase anterior. Por un lado tenemos la consulta, que no es un listado completo ni un listado paginado, sino que es un listado con filtros. Luego veremos como se hace eso, de momento lo dejaremos como un m\u00e9todo que recibe los dos filtros.</p> <p>La segunda peculiaridad es que de cliente nos est\u00e1 llegando un <code>GameDto</code>, que internamente tiene un <code>AuthorDto</code> y un <code>CategoryDto</code>, pero nosotros lo tenemos que traducir a entidades de BBDD. No sirve con copiar las propiedades tal cual, ya que entonces Spring lo que har\u00e1 ser\u00e1 crear un objeto nuevo y persistir ese objeto nuevo de <code>Author</code> y de <code>Category</code>. Adem\u00e1s, de cliente generalmente tan solo nos llega el ID de esos objetos hijo, y no el resto de informaci\u00f3n de la entidad. Por esos motivos lo hemos ignorado del copyProperties.</p> <p>Pero de alguna forma tendremos que asignarle esos valores a la entidad <code>Game</code>. Si conocemos sus ID que es lo que generalmente llega, podemos recuperar esos objetos de BBDD y asignarlos en el objeto <code>Game</code>. Si recuerdas las reglas b\u00e1sicas, un <code>Repository</code> debe pertenecer a un solo <code>Service</code>, por lo que en lugar de llamar a m\u00e9todos de los <code>AuthorRepository</code> y <code>CategoryRepository</code> desde nuestro <code>GameServiceImpl</code>, debemos llamar a m\u00e9todos expuestos en <code>AuthorService</code> y <code>CategoryService</code>, que son los que gestionan sus repositorios. Para ello necesitaremos crear esos m\u00e9todos get en los otros <code>Services</code>. </p> <p>Y ya sabes, para implementar nuevos m\u00e9todos, antes se deben hacer las pruebas jUnit, que en este caso, por variar, cubriremos con pruebas unitarias. Recuerda que los test van en <code>src/test/java</code></p> AuthorTest.javaAuthorService.javaAuthorServiceImpl.java <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport java.util.Optional;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\n@ExtendWith(MockitoExtension.class)\npublic class AuthorTest {\n\n    public static final Long EXISTS_AUTHOR_ID = 1L;\n    public static final Long NOT_EXISTS_AUTHOR_ID = 0L;\n\n    @Mock\n    private AuthorRepository authorRepository;\n\n    @InjectMocks\n    private AuthorServiceImpl authorService;\n\n    @Test\n    public void getExistsAuthorIdShouldReturnAuthor() {\n\n          Author author = mock(Author.class);\n          when(author.getId()).thenReturn(EXISTS_AUTHOR_ID);\n          when(authorRepository.findById(EXISTS_AUTHOR_ID)).thenReturn(Optional.of(author));\n\n          Author authorResponse = authorService.get(EXISTS_AUTHOR_ID);\n\n          assertNotNull(authorResponse);\n\n          assertEquals(EXISTS_AUTHOR_ID, authorResponse.getId());\n    }\n\n    @Test\n    public void getNotExistsAuthorIdShouldReturnNull() {\n\n          when(authorRepository.findById(NOT_EXISTS_AUTHOR_ID)).thenReturn(Optional.empty());\n\n          Author author = authorService.get(NOT_EXISTS_AUTHOR_ID);\n\n          assertNull(author);\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport com.ccsw.tutorial.author.model.AuthorDto;\nimport com.ccsw.tutorial.author.model.AuthorSearchDto;\nimport org.springframework.data.domain.Page;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\npublic interface AuthorService {\n\n    /**\n     * Recupera un {@link Author} a trav\u00e9s de su ID\n     *\n     * @param id PK de la entidad\n     * @return {@link Author}\n     */\n    Author get(Long id);\n\n    /**\n     * M\u00e9todo para recuperar un listado paginado de {@link Author}\n     *\n     * @param dto dto de b\u00fasqueda\n     * @return {@link Page} de {@link Author}\n     */\n    Page&lt;Author&gt; findPage(AuthorSearchDto dto);\n\n    /**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    void save(Long id, AuthorDto dto);\n\n    /**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     */\n    void delete(Long id) throws Exception;\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport com.ccsw.tutorial.author.model.AuthorDto;\nimport com.ccsw.tutorial.author.model.AuthorSearchDto;\nimport jakarta.transaction.Transactional;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.domain.Page;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Service\n@Transactional\npublic class AuthorServiceImpl implements AuthorService {\n\n    @Autowired\n    AuthorRepository authorRepository;\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Author get(Long id) {\n\n        return this.authorRepository.findById(id).orElse(null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Page&lt;Author&gt; findPage(AuthorSearchDto dto) {\n\n        return this.authorRepository.findAll(dto.getPageable().getPageable());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void save(Long id, AuthorDto data) {\n\n        Author author;\n\n        if (id == null) {\n            author = new Author();\n        } else {\n            author = this.get(id);\n        }\n\n        BeanUtils.copyProperties(data, author, \"id\");\n\n        this.authorRepository.save(author);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void delete(Long id) throws Exception {\n\n        if(this.get(id) == null){\n            throw new Exception(\"Not exists\");\n        }\n\n        this.authorRepository.deleteById(id);\n    }\n\n}\n</code></pre> <p>Y lo mismo para categor\u00edas.</p> CategoryTest.javaCategoryService.javaCategoryServiceImpl.java <pre><code>public static final Long NOT_EXISTS_CATEGORY_ID = 0L;\n\n@Test\npublic void getExistsCategoryIdShouldReturnCategory() {\n\n      Category category = mock(Category.class);\n      when(category.getId()).thenReturn(EXISTS_CATEGORY_ID);\n      when(categoryRepository.findById(EXISTS_CATEGORY_ID)).thenReturn(Optional.of(category));\n\n      Category categoryResponse = categoryService.get(EXISTS_CATEGORY_ID);\n\n      assertNotNull(categoryResponse);\n      assertEquals(EXISTS_CATEGORY_ID, category.getId());\n}\n\n@Test\npublic void getNotExistsCategoryIdShouldReturnNull() {\n\n      when(categoryRepository.findById(NOT_EXISTS_CATEGORY_ID)).thenReturn(Optional.empty());\n\n      Category category = categoryService.get(NOT_EXISTS_CATEGORY_ID);\n\n      assertNull(category);\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.category;\n\nimport com.ccsw.tutorial.category.model.Category;\nimport com.ccsw.tutorial.category.model.CategoryDto;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\npublic interface CategoryService {\n\n    /**\n     * Recupera una {@link Category} a partir de su ID\n     *\n     * @param id PK de la entidad\n     * @return {@link Category}\n     */\n    Category get(Long id);\n\n    /**\n     * M\u00e9todo para recuperar todas las {@link Category}\n     *\n     * @return {@link List} de {@link Category}\n     */\n    List&lt;Category&gt; findAll();\n\n    /**\n     * M\u00e9todo para crear o actualizar una {@link Category}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    void save(Long id, CategoryDto dto);\n\n    /**\n     * M\u00e9todo para borrar una {@link Category}\n     *\n     * @param id PK de la entidad\n     */\n    void delete(Long id) throws Exception;\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.category;\n\nimport com.ccsw.tutorial.category.model.Category;\nimport com.ccsw.tutorial.category.model.CategoryDto;\nimport jakarta.transaction.Transactional;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Service\n@Transactional\npublic class CategoryServiceImpl implements CategoryService {\n\n    @Autowired\n    CategoryRepository categoryRepository;\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Category get(Long id) {\n\n          return this.categoryRepository.findById(id).orElse(null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public List&lt;Category&gt; findAll() {\n\n          return (List&lt;Category&gt;) this.categoryRepository.findAll();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void save(Long id, CategoryDto dto) {\n\n          Category category;\n\n          if (id == null) {\n             category = new Category();\n          } else {\n             category = this.get(id);\n          }\n\n          category.setName(dto.getName());\n\n          this.categoryRepository.save(category);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void delete(Long id) throws Exception {\n\n          if(this.get(id) == null){\n             throw new Exception(\"Not exists\");\n          }\n\n          this.categoryRepository.deleteById(id);\n    }\n\n}\n</code></pre> <p>Clean Code</p> <p>A la hora de implementar m\u00e9todos nuevos, ten siempre presente el <code>Clean Code</code>. \u00a1No dupliques c\u00f3digo!, es muy importante de cara al futuro mantenimiento. Si en nuestro m\u00e9todo <code>save</code> hac\u00edamos uso de una operaci\u00f3n <code>findById</code> y ahora hemos creado una nueva operaci\u00f3n <code>get</code>, hagamos uso de esta nueva operaci\u00f3n y no repitamos el c\u00f3digo.</p> <p>Y ahora que ya tenemos los m\u00e9todos necesarios, ya podemos implementar correctamente nuestro <code>GameServiceImpl</code>.</p> GameServiceImpl.java <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.author.AuthorService;\nimport com.ccsw.tutorial.category.CategoryService;\nimport com.ccsw.tutorial.game.model.Game;\nimport com.ccsw.tutorial.game.model.GameDto;\nimport jakarta.transaction.Transactional;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Service\n@Transactional\npublic class GameServiceImpl implements GameService {\n\n    @Autowired\n    GameRepository gameRepository;\n\n    @Autowired\n    AuthorService authorService;\n\n    @Autowired\n    CategoryService categoryService;\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public List&lt;Game&gt; find(String title, Long idCategory) {\n\n        return this.gameRepository.findAll();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void save(Long id, GameDto dto) {\n\n        Game game;\n\n        if (id == null) {\n            game = new Game();\n        } else {\n            game = this.gameRepository.findById(id).orElse(null);\n        }\n\n        BeanUtils.copyProperties(dto, game, \"id\", \"author\", \"category\");\n\n        game.setAuthor(authorService.get(dto.getAuthor().getId()));\n        game.setCategory(categoryService.get(dto.getCategory().getId()));\n\n        this.gameRepository.save(game);\n    }\n\n}\n</code></pre> <p>Ahora si que tenemos la capa de l\u00f3gica de negocio terminada, podemos pasar a la siguiente capa.</p>"},{"location":"develop/filtered/springboot/#repository","title":"Repository","text":"<p>Y llegamos a la \u00faltima capa donde, si recordamos, ten\u00edamos un m\u00e9todo que recibe dos par\u00e1metros. Necesitamos traducir esto en una consulta a la BBDD.</p> <p>Vamos a necesitar un listado filtrado por t\u00edtulo o por categor\u00eda, as\u00ed que necesitaremos pasarle esos datos y filtrar la query. Para el t\u00edtulo vamos a buscar por una cadena contenida, as\u00ed que el par\u00e1metro ser\u00e1 de tipo <code>String</code>, mientras que para la categor\u00eda vamos a buscar por su primary key, as\u00ed que el par\u00e1metro ser\u00e1 de tipo <code>Long</code>.</p> <p>Existen varias estrategias para abordar esta implementaci\u00f3n. Podr\u00edamos utilizar los QueryMethods para que Spring JPA haga su magia, pero en esta ocasi\u00f3n ser\u00eda bastante complicado encontrar un predicado correcto.</p> <p>Tambi\u00e9n podr\u00edamos hacer una implementaci\u00f3n de la interface y hacer la consulta directamente con Criteria. </p> <p>Por otro lado se podr\u00eda hacer uso de la anotaci\u00f3n @Query. Esta anotaci\u00f3n nos permite definir una consulta en SQL nativo o en JPQL (Java Persistence Query Language) y Spring JPA se encargar\u00e1 de realizar todo el mapeo y conversi\u00f3n de los datos de entrada y salida. Pero esta opci\u00f3n no es la m\u00e1s recomendable.</p>"},{"location":"develop/filtered/springboot/#specifications","title":"Specifications","text":"<p>En este caso vamos a hacer uso de las Specifications que es la opci\u00f3n m\u00e1s robusta y no presenta acoplamientos con el tipo de BBDD.</p> <p>Haciendo un resumen muy r\u00e1pido y con poco detalle, las <code>Specifications</code> sirven para generar de forma robusta las clausulas <code>where</code> de una consulta SQL. Estas clausulas se generar\u00e1n mediante <code>Predicate</code> (predicados) que realizar\u00e1n operaciones de comparaci\u00f3n entre un campo y un valor. </p> <p>En el siguiente ejemplo podemos verlo m\u00e1s claro: en la sentencia <code>select * from</code><code>Table</code><code>where</code><code>name = 'b\u00fasqueda'</code> tenemos un solo predicado que es <code>name = 'b\u00fasqueda'</code>. En ese predicado diferenciamos tres etiquetas:</p> <ul> <li><code>name</code> \u2192 es el campo sobre el que hacemos el predicado</li> <li><code>=</code> \u2192 es la operaci\u00f3n que realizamos</li> <li><code>'b\u00fasqueda'</code> \u2192 es el valor con el que realizamos la operaci\u00f3n</li> </ul> <p>Lo que trata de hacer <code>Specifications</code> es agregar varios predicados con <code>AND</code> o con <code>OR</code> de forma tipada en c\u00f3digo. Y \u00bfqu\u00e9 intentamos conseguir con esta forma de programar?, pues f\u00e1cil, intentamos hacer que si cambiamos alg\u00fan tipo o el nombre de alguna propiedad involucrada en la query, nos salte un fallo en tiempo de compilaci\u00f3n y nos demos cuenta de donde est\u00e1 el error.  Si utiliz\u00e1ramos queries construidas directamente con <code>String</code>, al cambiar alg\u00fan tipo o el nombre de alguna propiedad involucrada, no nos dar\u00edamos cuenta hasta que saltara un fallo en tiempo de ejecuci\u00f3n.</p> <p>Por este motivo hay que programar con <code>Specifications</code>, porque son robustas ante cambios de c\u00f3digo y tenemos que tratar de evitar las construcciones a trav\u00e9s de cadenas de texto.</p> <p>Dicho esto, \u00a1vamos a implementar!</p> <p>Lo primero que necesitaremos ser\u00e1 una clase que nos permita guardar la informaci\u00f3n de un <code>Predicate</code> para luego generar facilmente la construcci\u00f3n.  Para ello vamos a crear una clase que guarde informaci\u00f3n de los criterios de filtrado (campo, operaci\u00f3n y valor), por suerte esta clase ser\u00e1 gen\u00e9rica y la podremos usar en toda la aplicaci\u00f3n, as\u00ed que la vamos a crear en el paquete <code>com.ccsw.tutorial.common.criteria</code></p> SearchCriteria.java <pre><code>package com.ccsw.tutorial.common.criteria;\n\npublic class SearchCriteria {\n\n    private String key;\n    private String operation;\n    private Object value;\n\n    public SearchCriteria(String key, String operation, Object value) {\n\n        this.key = key;\n        this.operation = operation;\n        this.value = value;\n    }\n\n    public String getKey() {\n        return key;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public String getOperation() {\n        return operation;\n    }\n\n    public void setOperation(String operation) {\n        this.operation = operation;\n    }\n\n    public Object getValue() {\n        return value;\n    }\n\n    public void setValue(Object value) {\n        this.value = value;\n    }\n\n}\n</code></pre> <p>Hecho esto pasamos a definir el <code>Specification</code> de nuestra clase la cual contendr\u00e1 la construcci\u00f3n de la consulta en funci\u00f3n de los criterios que se le proporcionan. No queremos construir los predicados directamente en nuestro <code>Service</code> ya que duplicariamos mucho c\u00f3digo, mucho mejor si hacemos una clase para centralizar la construcci\u00f3n de predicados.</p> <p>De esta forma vamos a crear una clase <code>Specification</code> por cada una de las <code>Entity</code> que queramos consultar. En nuestro caso solo vamos a generar <code>queries</code> para <code>Game</code>, as\u00ed que solo crearemos un <code>GameSpecification</code> donde construirmos los predicados.</p> GameSpecification.java <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.common.criteria.SearchCriteria;\nimport com.ccsw.tutorial.game.model.Game;\nimport jakarta.persistence.criteria.*;\nimport org.springframework.data.jpa.domain.Specification;\n\n\npublic class GameSpecification implements Specification&lt;Game&gt; {\n\n    private static final long serialVersionUID = 1L;\n\n    private final SearchCriteria criteria;\n\n    public GameSpecification(SearchCriteria criteria) {\n\n        this.criteria = criteria;\n    }\n\n    @Override\n    public Predicate toPredicate(Root&lt;Game&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder builder) {\n        if (criteria.getOperation().equalsIgnoreCase(\":\") &amp;&amp; criteria.getValue() != null) {\n            Path&lt;String&gt; path = getPath(root);\n            if (path.getJavaType() == String.class) {\n                return builder.like(path, \"%\" + criteria.getValue() + \"%\");\n            } else {\n                return builder.equal(path, criteria.getValue());\n            }\n        }\n        return null;\n    }\n\n    private Path&lt;String&gt; getPath(Root&lt;Game&gt; root) {\n        String key = criteria.getKey();\n        String[] split = key.split(\"[.]\", 0);\n\n        Path&lt;String&gt; expression = root.get(split[0]);\n        for (int i = 1; i &lt; split.length; i++) {\n            expression = expression.get(split[i]);\n        }\n\n        return expression;\n    }\n\n}\n</code></pre> <p>Voy a tratar de explicar con calma cada una de las l\u00edneas marcadas, ya que son conceptos dificiles de entender hasta que no se utilizan.</p> <ul> <li> <p>Las dos primeras l\u00edneas marcadas hacen referencia a que cuando se crea un <code>Specification</code>, esta debe generar un predicado, con lo que necesita unos criterios de filtrado para poder generarlo. En el constructor le estamos pasando esos criterios de filtrado que luego utilizaremos.</p> </li> <li> <p>La tercera l\u00ednea marcada est\u00e1 seleccionando el tipo de operaci\u00f3n. En nuestro caso solo vamos a utilizar operaciones de comparaci\u00f3n. Por convenio las operaciones de comparaci\u00f3n se marcan como \":\" ya que el s\u00edmbolo = est\u00e1 reservado. Aqu\u00ed es donde podr\u00edamos a\u00f1adir otro tipo de operaciones como \"&gt;\" o \"&lt;&gt;\" o cualquiera que queramos implementar. Gu\u00e1rdate esa informaci\u00f3n que te servir\u00e1 en el ejercicio final .</p> </li> <li> <p>Las dos siguientes l\u00edneas, las de <code>return</code> est\u00e1n construyendo un <code>Predicate</code> al ser de tipo comparaci\u00f3n, si es un texto har\u00e1 un <code>like</code> y si no es texto (que es un n\u00famero o fecha) har\u00e1 un <code>equals</code>.</p> </li> <li> <p>Por \u00faltimo, tenemos un m\u00e9todo <code>getPath</code> que invocamos dentro la generaci\u00f3n del predicado y que implementamos m\u00e1s abajo. Esta funci\u00f3n nos permite explorar las sub-entidades para realizar consultas sobre los atributos de estas. Por ejemplo, si queremos navegar hasta <code>game.author.name</code>, lo que har\u00e1 la exploraci\u00f3n ser\u00e1 recuperar el atributo <code>name</code> del objeto <code>author</code> de la entidad <code>game</code>.</p> </li> </ul> <p>Una vez implementada nuestra clase de <code>Specification</code>, que lo \u00fanico que hace es recoger un criterio de filtrado y construir un predicado, y que en principio solo permite generar comparaciones de igualdad, vamos a utilizarlo dentro de nuestro <code>Service</code>:</p> GameServiceImpl.javaGameRepository.java <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.author.AuthorService;\nimport com.ccsw.tutorial.category.CategoryService;\nimport com.ccsw.tutorial.common.criteria.SearchCriteria;\nimport com.ccsw.tutorial.game.model.Game;\nimport com.ccsw.tutorial.game.model.GameDto;\nimport jakarta.transaction.Transactional;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.jpa.domain.Specification;\nimport org.springframework.stereotype.Service;\n\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Service\n@Transactional\npublic class GameServiceImpl implements GameService {\n\n    @Autowired\n    GameRepository gameRepository;\n\n    @Autowired\n    AuthorService authorService;\n\n    @Autowired\n    CategoryService categoryService;\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public List&lt;Game&gt; find(String title, Long idCategory) {\n\n        GameSpecification titleSpec = new GameSpecification(new SearchCriteria(\"title\", \":\", title));\n        GameSpecification categorySpec = new GameSpecification(new SearchCriteria(\"category.id\", \":\", idCategory));\n\n        Specification&lt;Game&gt; spec = Specification.where(titleSpec).and(categorySpec);\n\n        return this.gameRepository.findAll(spec);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void save(Long id, GameDto dto) {\n\n        Game game;\n\n        if (id == null) {\n            game = new Game();\n        } else {\n            game = this.gameRepository.findById(id).orElse(null);\n        }\n\n        BeanUtils.copyProperties(dto, game, \"id\", \"author\", \"category\");\n\n        game.setAuthor(authorService.get(dto.getAuthor().getId()));\n        game.setCategory(categoryService.get(dto.getCategory().getId()));\n\n        this.gameRepository.save(game);\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.game.model.Game;\nimport org.springframework.data.jpa.domain.Specification;\nimport org.springframework.data.jpa.repository.EntityGraph;\nimport org.springframework.data.jpa.repository.JpaSpecificationExecutor;\nimport org.springframework.data.repository.CrudRepository;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\npublic interface GameRepository extends CrudRepository&lt;Game, Long&gt;, JpaSpecificationExecutor&lt;Game&gt; {\n\n}\n</code></pre> <p>Lo que hemos hecho es crear los dos criterios de filtrado que necesit\u00e1bamos. En nuestro caso eran <code>title</code>, que es un atributo de la entidad <code>Game</code> y por otro lado el identificador de categor\u00eda, que en este caso, ya no es un atributo directo de la entidad, si no, de la categor\u00eda asociada, por lo que debemos navegar hasta el atributo <code>id</code> a trav\u00e9s del atributo <code>category</code> (para esto utilizamos el <code>getPath</code> que hemos visto anteriormente).</p> <p>A partir de estos dos predicados, podemos generar el <code>Specification</code> global para la consulta, uniendo los dos predicados mediante el operador <code>AND</code>.</p> <p>Una vez construido el <code>Specification</code> ya podemos usar el m\u00e9todo por defecto que nos proporciona Spring Data para dicho fin, tan solo tenemos que decirle a nuestro <code>GameRepository</code> que adem\u00e1s extender de <code>CrudRepository</code> debe extender de <code>JpaSpecificationExecutor</code>, para que pueda ejecutarlas.</p>"},{"location":"develop/filtered/springboot/#mejoras-rendimiento","title":"Mejoras rendimiento","text":"<p>Finalmente, de cara a mejorar el rendimiento de nuestros servicios vamos a hacer foco en la generaci\u00f3n de transacciones con la base de datos. Si ejecut\u00e1ramos esta petici\u00f3n tal cual lo tenemos implementado ahora mismo, en la consola ver\u00edamos lo siguiente:</p> <pre><code>Hibernate: select g1_0.id,g1_0.age,g1_0.author_id,g1_0.category_id,g1_0.title from game g1_0\nHibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=?\nHibernate: select c1_0.id,c1_0.name from category c1_0 where c1_0.id=?\nHibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=?\nHibernate: select c1_0.id,c1_0.name from category c1_0 where c1_0.id=?\nHibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=?\nHibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=?\nHibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=?\n</code></pre> <p>Esto es debido a que no le hemos dado indicaciones a Spring Data de como queremos que construya las consultas con relaciones y por defecto est\u00e1 configurado para generar sub-consultas cuando tenemos tablas relacionadas.</p> <p>En nuestro caso la tabla <code>Game</code> est\u00e1 relacionada con <code>Author</code> y <code>Category</code>. Al realizar la consulta a <code>Game</code> realiza las sub-consultas por cada uno de los registros relacionados con los resultados <code>Game</code>.</p> <p>Para evitar tantas consultas contra la BBDD y realizar esto de una forma mucho m\u00e1s \u00f3ptima, podemos decirle a Spring Data el comportamiento que queremos, que en nuestro caso ser\u00e1 que haga una \u00fanica consulta y haga las sub-consultas mediante los <code>join</code> correspondientes.</p> <p>Para ello a\u00f1adimos una sobre-escritura del m\u00e9todo <code>findAll</code>, que ya ten\u00edamos implementado en <code>JpaSpecificationExecutor</code> y que utlizamos de forma heredada, pero en este caso le a\u00f1adimos la anotaci\u00f3n <code>@EntityGraph</code> con los atributos que queremos que se incluyan dentro de la consulta principal mediante <code>join</code>:</p> GameRepository.java <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.game.model.Game;\nimport org.springframework.data.jpa.domain.Specification;\nimport org.springframework.data.jpa.repository.EntityGraph;\nimport org.springframework.data.jpa.repository.JpaSpecificationExecutor;\nimport org.springframework.data.repository.CrudRepository;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\npublic interface GameRepository extends CrudRepository&lt;Game, Long&gt;, JpaSpecificationExecutor&lt;Game&gt; {\n\n    @Override\n    @EntityGraph(attributePaths = {\"category\", \"author\"})\n    List&lt;Game&gt; findAll(Specification&lt;Game&gt; spec);\n\n}\n</code></pre> <p>Tras realizar este cambio, podemos observar que la nueva consulta generada es la siguiente:</p> <pre><code>Hibernate: select g1_0.id,g1_0.age,a1_0.id,a1_0.name,a1_0.nationality,c1_0.id,c1_0.name,g1_0.title from game g1_0 join author a1_0 on a1_0.id=g1_0.author_id join category c1_0 on c1_0.id=g1_0.category_id\n</code></pre> <p>Como podemos observar, ahora se realiza una \u00fanica consulta con la correspondiente transacci\u00f3n con la BBDD, y se trae todos los datos necesarios de <code>Game</code>, <code>Author</code> y <code>Category</code> sin lanzar m\u00faltiples queries.</p>"},{"location":"develop/filtered/springboot/#prueba-de-las-operaciones","title":"Prueba de las operaciones","text":"<p>Si ahora ejecutamos de nuevo los jUnits, vemos que todos los que hemos desarrollado en <code>GameIT</code> ya funcionan correctamente, e incluso el resto de test de la aplicaci\u00f3n tambi\u00e9n funcionan correctamente. </p> <p>Pruebas jUnit</p> <p>Cada vez que desarrollemos un caso de uso nuevo, debemos relanzar todas las pruebas autom\u00e1ticas que tenga la aplicaci\u00f3n. Es muy com\u00fan que al implementar alg\u00fan desarrollo nuevo, interfiramos de alguna forma en el funcionamiento de otra funcionalidad. Si lanzamos toda la bater\u00eda de pruebas, nos daremos cuenta si algo ha dejado de funcionar y podremos solucionarlo antes de llevar ese error a Producci\u00f3n. Las pruebas jUnit son nuestra red de seguridad.</p> <p>Adem\u00e1s de las pruebas autom\u00e1ticas, podemos ver como se comporta la aplicaci\u00f3n y que respuesta nos ofrece, lanzando peticiones Rest con Postman, como hemos hecho en los casos anteriores. As\u00ed que podemos levantar la aplicaci\u00f3n y lanzar las operaciones:</p> <p>** GET http://localhost:8080/game ** </p> <p>** GET http://localhost:8080/game?title=xxx **</p> <p>** GET http://localhost:8080/game?idCategory=xxx **</p> <p>Nos devuelve un listado filtrado de <code>Game</code>. F\u00edjate bien en la petici\u00f3n donde enviamos los filtros y la respuesta que tiene los objetos <code>Category</code> y <code>Author</code> inclu\u00eddos.</p> <p></p> <p>** PUT http://localhost:8080/game **  ** PUT http://localhost:8080/game/{id} ** </p> <pre><code>{\n    \"title\": \"Nuevo juego\",\n    \"age\": \"18\",\n    \"category\": {\n        \"id\": 3\n    },\n    \"author\": {\n        \"id\": 1\n    }\n}\n</code></pre> <p>Nos sirve para insertar un <code>Game</code> nuevo (si no tienen el id informado) o para actualizar un <code>Game</code> (si tienen el id informado). F\u00edjate que para enlazar <code>Category</code> y <code>Author</code> tan solo hace falta el id de cada no de ellos, ya que en el m\u00e9todo <code>save</code> se hace una consulta <code>get</code> para recuperarlos por su id. Adem\u00e1s que no tendr\u00eda sentido enviar toda la informaci\u00f3n de esas entidades ya que no est\u00e1s dando de alta una <code>Category</code> ni un <code>Author</code>.</p> <p> </p> <p>Rendimiento en las consultas JPA</p> <p>En este punto te recomiendo que visites el Anexo. Funcionamiento JPA para conocer un poco m\u00e1s como funciona por dentro JPA y alg\u00fan peque\u00f1o truco que puede mejorar el rendimiento.</p>"},{"location":"develop/filtered/springboot/#implementar-listado-autores","title":"Implementar listado Autores","text":"<p>Antes de poder conectar front con back, si recuerdas, en la edici\u00f3n de un <code>Game</code>, nos hac\u00eda falta un listado de <code>Author</code> y un listado de <code>Category</code>. El segundo ya lo tenemos ya que lo reutilizaremos del listado de categor\u00edas que implementamos. Pero el primero no lo tenemos, porque en la pantalla que hicimos, se mostraban de forma paginada. </p> <p>As\u00ed que necesitamos implementar esa funcionalidad, y como siempre vamos de la capa de testing hacia las siguientes capas. Deber\u00edamos a\u00f1adir los siguientes m\u00e9todos:</p> AuthorIT.javaAuthorController.javaAuthorService.javaAuthorServiceImpl.java <pre><code>...\n\nParameterizedTypeReference&lt;List&lt;AuthorDto&gt;&gt; responseTypeList = new ParameterizedTypeReference&lt;List&lt;AuthorDto&gt;&gt;(){};\n\n@Test\npublic void findAllShouldReturnAllAuthor() {\n\n      ResponseEntity&lt;List&lt;AuthorDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.GET, null, responseTypeList);\n\n      assertNotNull(response);\n      assertEquals(TOTAL_AUTHORS, response.getBody().size());\n}\n\n...\n</code></pre> <pre><code>...\n\n/**\n * Recupera un listado de autores {@link Author}\n *\n * @return {@link List} de {@link AuthorDto}\n */\n@Operation(summary = \"Find\", description = \"Method that return a list of Authors\")\n@RequestMapping(path = \"\", method = RequestMethod.GET)\npublic List&lt;AuthorDto&gt; findAll() {\n\n    List&lt;Author&gt; authors = this.authorService.findAll();\n\n    return authors.stream().map(e -&gt; mapper.map(e, AuthorDto.class)).collect(Collectors.toList());\n}\n\n...\n</code></pre> <pre><code>...\n\n/**\n * Recupera un listado de autores {@link Author}\n *\n * @return {@link List} de {@link Author}\n */\nList&lt;Author&gt; findAll();\n\n...\n</code></pre> <pre><code>...\n\n/**\n * {@inheritDoc}\n */\n@Override\npublic List&lt;Author&gt; findAll() {\n\n    return (List&lt;Author&gt;) this.authorRepository.findAll();\n}\n\n\n...\n</code></pre>"},{"location":"develop/filtered/vuejs/","title":"Listado filtrado - VUE","text":"<p>Aqu\u00ed vamos a volver a la pantalla de cat\u00e1logo para realizar un filtrado en la propia tabla.</p> <p>Empezaremos por modificar el template de la tabla que modificamos para a\u00f1adir el bot\u00f3n de a\u00f1adir nueva fila para a\u00f1adir tambi\u00e9n tres inputs: uno de texto para el nombre del juego y dos seleccionables para la categor\u00eda y el autor (les tendremos que asignar las opciones que haya en ese momento). </p> <p>Tambi\u00e9n a\u00f1adiremos un bot\u00f3n para que no se lance la petici\u00f3n cada vez que el usuario introduce una letra en el input de texto. Esto quedar\u00eda as\u00ed:</p> <pre><code>&lt;template v-slot:top&gt;\n        &lt;div class=\"q-table__title\"&gt;Cat\u00e1logo&lt;/div&gt;\n        &lt;q-btn flat round color=\"primary\" icon=\"add\" @click=\"showAdd = true\" /&gt;\n        &lt;q-space /&gt;\n        &lt;q-input dense v-model=\"filter.title\" placeholder=\"T\u00edtulo\"&gt;\n          &lt;template v-slot:append&gt;\n            &lt;q-icon name=\"search\" /&gt;\n          &lt;/template&gt;\n        &lt;/q-input&gt;\n        &lt;q-separator inset /&gt;\n        &lt;div style=\"width: 10%\"&gt;\n          &lt;q-select\n            dense\n            name=\"category\"\n            v-model=\"filter.category\"\n            :options=\"categories\"\n            emit-value\n            map-options\n            option-value=\"id\"\n            option-label=\"name\"\n            label=\"Categor\u00eda\"\n          /&gt;\n        &lt;/div&gt;\n        &lt;q-separator inset /&gt;\n        &lt;div style=\"width: 10%\"&gt;\n          &lt;q-select\n            dense\n            name=\"author\"\n            v-model=\"filter.author\"\n            :options=\"authors\"\n            emit-value\n            map-options\n            option-value=\"id\"\n            option-label=\"name\"\n            label=\"Autor\"\n          /&gt;\n        &lt;/div&gt;\n        &lt;q-separator inset /&gt;\n        &lt;q-btn flat round color=\"primary\" icon=\"filter_alt\" @click=\"getGames\" /&gt;\n      &lt;/template&gt;\n</code></pre> <p>Adem\u00e1s, tambi\u00e9n vamos a a\u00f1adir un estado para todos los filtros juntos:</p> <pre><code>const filter = ref({ title: '', category: '', author: '' });\n</code></pre> <p>Por \u00faltimo, para no estar haciendo las tres peticiones (juegos, categor\u00edas y autores) las hemos extra\u00eddo en funciones diferentes de la siguiente manera:</p> <pre><code>const getGames = () =&gt; {\n  const { data } = useFetch(url.value).get().json();\n  whenever(data, () =&gt; (catalogData.value = data.value));\n};\n\nconst getCategories = () =&gt; {\n  const { data: categoriesData } = useFetch('http://localhost:8080/category')\n    .get()\n    .json();\n  whenever(categoriesData, () =&gt; (categories.value = categoriesData.value));\n};\n\nconst getAuthors = () =&gt; {\n  const { data: authorsData } = useFetch('http://localhost:8080/author')\n    .get()\n    .json();\n  whenever(authorsData, () =&gt; (authors.value = authorsData.value));\n};\n\nconst firstLoad = () =&gt; {\n  getGames();\n  getCategories();\n  getAuthors();\n};\nfirstLoad();\n</code></pre> <p>Y como podemos ver, ahora la petici\u00f3n de juegos no tiene la url. Esto es porque hemos hecho que sea una variable computada para a\u00f1adirle los par\u00e1metros de filtrado y ha quedado as\u00ed:</p> <pre><code>const url = computed(() =&gt; {\n  const _url = new URL('http://localhost:8080/game');\n  _url.search = new URLSearchParams({\n    title: filter.value.title,\n    idCategory: filter.value.category ?? '',\n    idAuthor: filter.value.author ?? '',\n  });\n  return _url.toString();\n});\n</code></pre>"},{"location":"develop/paginated/angular/","title":"Listado paginado - Angular","text":"<p>Ya tienes tu primer CRUD desarrollado. \u00bfHa sido sencillo, verdad?.</p> <p>Ahora vamos a implementar un CRUD un poco m\u00e1s complejo, este tiene datos paginados en servidor, esto quiere decir que no nos sirve un array de datos como en el anterior ejemplo.  Para que un listado paginado en servidor funcione, el cliente debe enviar en cada petici\u00f3n que p\u00e1gina est\u00e1 solicitando y cual es el tama\u00f1o de la p\u00e1gina, para que el servidor devuelva solamente un subconjunto de datos, en lugar de devolver el listado completo.</p> <p>Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.</p>"},{"location":"develop/paginated/angular/#crear-modulo-y-componentes","title":"Crear modulo y componentes","text":"<p>Vamos a desarrollar el listado de <code>Autores</code> as\u00ed que, debemos crear los componentes:</p> <pre><code>ng generate module author\nng generate component author/author-list\nng generate component author/author-edit\n\nng generate service author/author\n</code></pre> <p>Este m\u00f3dulo lo vamos a a\u00f1adir a la aplicaci\u00f3n para que se cargue en el arranque. Abrimos el fichero <code>app.module.ts</code> y a\u00f1adimos el m\u00f3dulo:</p> app.module.ts <pre><code>import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { CoreModule } from './core/core.module';\nimport { CategoryModule } from './category/category.module';\nimport { AuthorModule } from './author/author.module';\n\n@NgModule({\ndeclarations: [\n    AppComponent\n],\nimports: [\n    BrowserModule,\n    AppRoutingModule,\n    CoreModule,\n    CategoryModule,\n    AuthorModule,\n    BrowserAnimationsModule\n],\nproviders: [],\nbootstrap: [AppComponent]\n})\nexport class AppModule { }\n</code></pre>"},{"location":"develop/paginated/angular/#crear-el-modelo","title":"Crear el modelo","text":"<p>Creamos el modelo en <code>author/model/Author.ts</code> con las propiedades necesarias para trabajar con la informaci\u00f3n de un autor:</p> Author.ts <pre><code>export class Author {\n    id: number;\n    name: string;\n    nationality: string;\n}\n</code></pre>"},{"location":"develop/paginated/angular/#anadir-el-punto-de-entrada","title":"A\u00f1adir el punto de entrada","text":"<p>A\u00f1adimos la ruta al men\u00fa para que podamos acceder a la pantalla:</p> app-routing.module.ts <pre><code>import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { CategoryListComponent } from './category/category-list/category-list.component';\nimport { AuthorListComponent } from './author/author-list/author-list.component';\n\nconst routes: Routes = [\n    { path: 'categories', component: CategoriesComponent },\n    { path: 'authors', component: AuthorListComponent },\n];\n\n@NgModule({\n    imports: [RouterModule.forRoot(routes)],\n    exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n</code></pre>"},{"location":"develop/paginated/angular/#implementar-servicio","title":"Implementar servicio","text":"<p>Y realizamos las diferentes implementaciones. Empezaremos por el servicio. En este caso, hay un cambio sustancial con el anterior ejemplo. Al tratarse de un listado paginado, la operaci\u00f3n <code>getAuthors</code> necesita informaci\u00f3n extra acerca de que p\u00e1gina de datos debe mostrar, adem\u00e1s de que el resultado ya no ser\u00e1 un listado sino una p\u00e1gina. </p> <p>Por defecto el esquema de datos de Spring para la paginaci\u00f3n es como el siguiente:</p> Esquema de datos de paginaci\u00f3n <pre><code>{\n    \"content\": [ ... &lt;listado con los resultados paginados&gt; ... ],\n    \"pageable\": {\n        \"pageNumber\": &lt;n\u00famero de p\u00e1gina empezando por 0&gt;,\n        \"pageSize\": &lt;tama\u00f1o de p\u00e1gina&gt;,\n        \"sort\": [\n            { \n                \"property\": &lt;nombre de la propiedad a ordenar&gt;, \n                \"direction\": &lt;direcci\u00f3n de la ordenaci\u00f3n ASC / DESC&gt; \n            }\n        ]\n    },\n    \"totalElements\": &lt;numero total de elementos en la tabla&gt;\n}\n</code></pre> <p>As\u00ed que necesitamos poder enviar y recuperar esa informaci\u00f3n desde Angular, nos hace falta crear esos objetos. Los objetos de paginaci\u00f3n al ser comunes a toda la aplicaci\u00f3n, vamos a crearlos en <code>core/model/page</code>, mientras que la paginaci\u00f3n de <code>AuthorPage.ts</code> la crear\u00e9 en su propio model dentro de <code>author/model</code>.</p> SortPage.tsPageable.tsAuthorPage.ts <pre><code>export class SortPage {\n    property: String;\n    direction: String;\n}\n</code></pre> <pre><code>import { SortPage } from './SortPage';\n\nexport class Pageable {\n    pageNumber: number;\n    pageSize: number;\n    sort: SortPage[];\n}\n</code></pre> <pre><code>import { Pageable } from \"src/app/core/model/page/Pageable\";\nimport { Author } from \"./Author\";\n\nexport class AuthorPage {\n    content: Author[];\n    pageable: Pageable;\n    totalElements: number;\n}\n</code></pre> <p>Con estos objetos creados ya podemos implementar el servicio y sus datos mockeados.</p> mock-authors.tsauthor.service.ts <pre><code>import { AuthorPage } from \"./AuthorPage\";\n\nexport const AUTHOR_DATA: AuthorPage = {\n    content: [\n        { id: 1, name: 'Klaus Teuber', nationality: 'Alemania' },\n        { id: 2, name: 'Matt Leacock', nationality: 'Estados Unidos' },\n        { id: 3, name: 'Keng Leong Yeo', nationality: 'Singapur' },\n        { id: 4, name: 'Gil Hova', nationality: 'Estados Unidos'},\n        { id: 5, name: 'Kelly Adams', nationality: 'Estados Unidos' },\n        { id: 6, name: 'J. Alex Kavern', nationality: 'Estados Unidos' },\n        { id: 7, name: 'Corey Young', nationality: 'Estados Unidos' },\n    ],  \n    pageable : {\n        pageSize: 5,\n        pageNumber: 0,\n        sort: [\n            {property: \"id\", direction: \"ASC\"}\n        ]\n    },\n    totalElements: 7\n}\n</code></pre> <pre><code>import { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Pageable } from '../core/model/page/Pageable';\nimport { Author } from './model/Author';\nimport { AuthorPage } from './model/AuthorPage';\nimport { AUTHOR_DATA } from './model/mock-authors';\n\n@Injectable({\n    providedIn: 'root'\n})\nexport class AuthorService {\n\n    constructor() { }\n\n    getAuthors(pageable: Pageable): Observable&lt;AuthorPage&gt; {\n        return of(AUTHOR_DATA);\n    }\n\n    saveAuthor(author: Author): Observable&lt;void&gt; {\n        return of(null);\n    }\n\n    deleteAuthor(idAuthor : number): Observable&lt;void&gt; {\n        return of(null);\n    }    \n}\n</code></pre>"},{"location":"develop/paginated/angular/#implementar-listado","title":"Implementar listado","text":"<p>Ya tenemos el servicio con los datos, ahora vamos a por el listado paginado.</p> author-list.component.htmlauthor-list.component.scssauthor-list.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1&gt;Listado de Autores&lt;/h1&gt;\n\n    &lt;mat-table [dataSource]=\"dataSource\"&gt; \n        &lt;ng-container matColumnDef=\"id\"&gt;\n            &lt;mat-header-cell *matHeaderCellDef&gt; Identificador &lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.id}} &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n        &lt;ng-container matColumnDef=\"name\"&gt;\n            &lt;mat-header-cell *matHeaderCellDef&gt; Nombre autor  &lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.name}} &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n        &lt;ng-container matColumnDef=\"nationality\"&gt;\n            &lt;mat-header-cell *matHeaderCellDef&gt; Nacionalidad  &lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.nationality}} &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n        &lt;ng-container matColumnDef=\"action\"&gt;\n            &lt;mat-header-cell *matHeaderCellDef&gt;&lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt;\n                &lt;button mat-icon-button color=\"primary\" (click)=\"editAuthor(element)\"&gt;\n                    &lt;mat-icon&gt;edit&lt;/mat-icon&gt;\n                &lt;/button&gt;\n                &lt;button mat-icon-button color=\"accent\" (click)=\"deleteAuthor(element)\"&gt;\n                    &lt;mat-icon&gt;clear&lt;/mat-icon&gt;\n                &lt;/button&gt;\n            &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n        &lt;mat-header-row *matHeaderRowDef=\"displayedColumns; sticky: true\"&gt;&lt;/mat-header-row&gt;\n        &lt;mat-row *matRowDef=\"let row; columns: displayedColumns;\"&gt;&lt;/mat-row&gt;\n    &lt;/mat-table&gt; \n\n    &lt;mat-paginator (page)=\"loadPage($event)\" [pageSizeOptions]=\"[5, 10, 20]\" [pageIndex]=\"pageNumber\" [pageSize]=\"pageSize\" [length]=\"totalElements\" showFirstLastButtons&gt;&lt;/mat-paginator&gt;\n\n    &lt;div class=\"buttons\"&gt;\n        &lt;button mat-flat-button color=\"primary\" (click)=\"createAuthor()\"&gt;Nuevo autor&lt;/button&gt; \n    &lt;/div&gt;   \n&lt;/div&gt;\n</code></pre> <pre><code>.container {\n    margin: 20px;\n\n    mat-table {\n        margin-top: 10px;\n        margin-bottom: 20px;\n\n        .mat-header-row {\n            background-color:#f5f5f5;\n\n            .mat-header-cell {\n                text-transform: uppercase;\n                font-weight: bold;\n                color: #838383;\n            }      \n        }\n\n        .mat-column-id {\n            flex: 0 0 20%;\n            justify-content: center;\n        }\n\n        .mat-column-action {\n            flex: 0 0 10%;\n            justify-content: center;\n        }\n    }\n\n    .buttons {\n        text-align: right;\n    }\n}\n</code></pre> <pre><code>import { Component, OnInit } from '@angular/core';\nimport { MatDialog } from '@angular/material/dialog';\nimport { PageEvent } from '@angular/material/paginator';\nimport { MatTableDataSource } from '@angular/material/table';\nimport { DialogConfirmationComponent } from 'src/app/core/dialog-confirmation/dialog-confirmation.component';\nimport { Pageable } from 'src/app/core/model/page/Pageable';\nimport { AuthorEditComponent } from '../author-edit/author-edit.component';\nimport { AuthorService } from '../author.service';\nimport { Author } from '../model/Author';\n\n@Component({\nselector: 'app-author-list',\ntemplateUrl: './author-list.component.html',\nstyleUrls: ['./author-list.component.scss']\n})\nexport class AuthorListComponent implements OnInit {\n\n    pageNumber: number = 0;\n    pageSize: number = 5;\n    totalElements: number = 0;\n\n    dataSource = new MatTableDataSource&lt;Author&gt;();\n    displayedColumns: string[] = ['id', 'name', 'nationality', 'action'];\n\n    constructor(\n        private authorService: AuthorService,\n        public dialog: MatDialog,\n    ) { }\n\n    ngOnInit(): void {\n        this.loadPage();\n    }\n\n    loadPage(event?: PageEvent) {\n\n        let pageable : Pageable =  {\n            pageNumber: this.pageNumber,\n            pageSize: this.pageSize,\n            sort: [{\n                property: 'id',\n                direction: 'ASC'\n            }]\n        }\n\n        if (event != null) {\n            pageable.pageSize = event.pageSize\n            pageable.pageNumber = event.pageIndex;\n        }\n\n        this.authorService.getAuthors(pageable).subscribe(data =&gt; {\n            this.dataSource.data = data.content;\n            this.pageNumber = data.pageable.pageNumber;\n            this.pageSize = data.pageable.pageSize;\n            this.totalElements = data.totalElements;\n        });\n\n    }  \n\n    createAuthor() {      \n        const dialogRef = this.dialog.open(AuthorEditComponent, {\n            data: {}\n        });\n\n        dialogRef.afterClosed().subscribe(result =&gt; {\n            this.ngOnInit();\n        });      \n    }  \n\n    editAuthor(author: Author) {    \n        const dialogRef = this.dialog.open(AuthorEditComponent, {\n            data: { author: author }\n        });\n\n        dialogRef.afterClosed().subscribe(result =&gt; {\n            this.ngOnInit();\n        });    \n    }\n\n    deleteAuthor(author: Author) {    \n        const dialogRef = this.dialog.open(DialogConfirmationComponent, {\n            data: { title: \"Eliminar autor\", description: \"Atenci\u00f3n si borra el autor se perder\u00e1n sus datos.&lt;br&gt; \u00bfDesea eliminar el autor?\" }\n        });\n\n        dialogRef.afterClosed().subscribe(result =&gt; {\n            if (result) {\n                this.authorService.deleteAuthor(author.id).subscribe(result =&gt;  {\n                    this.ngOnInit();\n                }); \n            }\n        });\n    }  \n}\n</code></pre> <p>F\u00edjate como hemos a\u00f1adido la paginaci\u00f3n. </p> <ul> <li>Al HTML le hemos a\u00f1adido un componente nuevo <code>mat-paginator</code>, lo que nos va a obligar a a\u00f1adirlo al m\u00f3dulo tambi\u00e9n como dependencia. Ese componente le hemos definido un m\u00e9todo <code>page</code> que se ejecuta cada vez que la p\u00e1gina cambia, y unas propiedades con las que calcular\u00e1 la p\u00e1gina, el tama\u00f1o y el n\u00famero total de p\u00e1ginas.</li> <li>Al Typescript le hemos tenido que a\u00f1adir esas variables y hemos creado un m\u00e9todo para cargar datos que lo que hace es construir un objeto <code>pageable</code> con los valores actuales del componente paginador y lanza la petici\u00f3n con esos datos en el body. Obviamente al ser un mock no funcionar\u00e1 el cambio de p\u00e1gina y dem\u00e1s.</li> </ul> <p>Como siempre, a\u00f1adimos las dependencias al m\u00f3dulo, vamos a intentar a\u00f1adir todas las que vamos a necesitar a futuro.</p> author.module.ts <pre><code>import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { AuthorListComponent } from './author-list/author-list.component';\nimport { AuthorEditComponent } from './author-edit/author-edit.component';\nimport { MatTableModule } from '@angular/material/table';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { MatButtonModule } from '@angular/material/button';\nimport { MatDialogModule, MAT_DIALOG_DATA } from '@angular/material/dialog';\nimport { MatFormFieldModule } from '@angular/material/form-field';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatInputModule } from '@angular/material/input';\nimport { MatPaginatorModule } from '@angular/material/paginator';\n\n\n\n@NgModule({\ndeclarations: [\n    AuthorListComponent,\n    AuthorEditComponent\n],\nimports: [\n    CommonModule,\n    MatTableModule,\n    MatIconModule, \n    MatButtonModule,\n    MatDialogModule,\n    MatFormFieldModule,\n    MatInputModule,\n    FormsModule,\n    ReactiveFormsModule,\n    MatPaginatorModule,\n],\nproviders: [\n    {\n        provide: MAT_DIALOG_DATA,\n        useValue: {},\n    },\n]\n})\nexport class AuthorModule { }\n</code></pre> <p>Deber\u00eda verse algo similar a esto:</p> <p></p>"},{"location":"develop/paginated/angular/#implementar-dialogo-edicion","title":"Implementar dialogo edici\u00f3n","text":"<p>El \u00faltimo paso, es definir la pantalla de dialogo que realizar\u00e1 el alta y modificado de los datos de un <code>Autor</code>.</p> author-edit.component.htmlauthor-edit.component.scssauthor-edit.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1 *ngIf=\"author.id == null\"&gt;Crear autor&lt;/h1&gt;\n    &lt;h1 *ngIf=\"author.id != null\"&gt;Modificar autor&lt;/h1&gt;\n\n    &lt;form&gt;\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;Identificador&lt;/mat-label&gt;\n            &lt;input type=\"text\" matInput placeholder=\"Identificador\" [(ngModel)]=\"author.id\" name=\"id\" disabled&gt;\n        &lt;/mat-form-field&gt;\n\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;Nombre&lt;/mat-label&gt;\n            &lt;input type=\"text\" matInput placeholder=\"Nombre del autor\" [(ngModel)]=\"author.name\" name=\"name\" required&gt;\n            &lt;mat-error&gt;El nombre no puede estar vac\u00edo&lt;/mat-error&gt;\n        &lt;/mat-form-field&gt;\n\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;Nacionalidad&lt;/mat-label&gt;\n            &lt;input type=\"text\" matInput placeholder=\"Nacionalidad del autor\" [(ngModel)]=\"author.nationality\" name=\"nationality\" required&gt;\n            &lt;mat-error&gt;La nacionalidad no puede estar vac\u00eda&lt;/mat-error&gt;\n        &lt;/mat-form-field&gt;\n    &lt;/form&gt;\n\n    &lt;div class=\"buttons\"&gt;\n        &lt;button mat-stroked-button (click)=\"onClose()\"&gt;Cerrar&lt;/button&gt;\n        &lt;button mat-flat-button color=\"primary\" (click)=\"onSave()\"&gt;Guardar&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <pre><code>.container {\n    min-width: 350px;\n    max-width: 500px;\n    padding: 20px;\n\n    form {\n        display: flex;\n        flex-direction: column;\n        margin-bottom:20px;\n    }\n\n    .buttons {\n    text-align: right;\n\n    button {\n        margin-left: 10px;\n    }\n    }\n}\n</code></pre> <pre><code>import { Component, Inject, OnInit } from '@angular/core';\nimport { MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';\nimport { AuthorService } from '../author.service';\nimport { Author } from '../model/Author';\n\n@Component({\nselector: 'app-author-edit',\ntemplateUrl: './author-edit.component.html',\nstyleUrls: ['./author-edit.component.scss']\n})\nexport class AuthorEditComponent implements OnInit {\n\n    author : Author;\n\n    constructor(\n        public dialogRef: MatDialogRef&lt;AuthorEditComponent&gt;,\n        @Inject(MAT_DIALOG_DATA) public data: any,\n        private authorService: AuthorService\n    ) { }\n\n    ngOnInit(): void {\n        if (this.data.author != null) {\n            this.author = Object.assign({}, this.data.author);\n        }\n        else {\n            this.author = new Author();\n        }\n    }\n\n    onSave() {\n        this.authorService.saveAuthor(this.author).subscribe(result =&gt;  {\n            this.dialogRef.close();\n        }); \n    }  \n\n    onClose() {\n        this.dialogRef.close();\n    }\n\n}\n</code></pre> <p>Que deber\u00eda quedar algo as\u00ed:</p> <p></p>"},{"location":"develop/paginated/angular/#conectar-con-backend","title":"Conectar con Backend","text":"<p>Antes de seguir</p> <p>Antes de seguir con este punto, debes implementar el c\u00f3digo de backend en la tecnolog\u00eda que quieras (Springboot o Nodejs). Si has empezado este cap\u00edtulo implementando el frontend, por favor accede a la secci\u00f3n correspondiente de backend para poder continuar con el tutorial. Una vez tengas implementadas todas las operaciones para este listado, puedes volver a este punto y continuar con Angular.</p> <p>Una vez implementado front y back, lo que nos queda es modificar el servicio del front para que conecte directamente con las operaciones ofrecidas por el back.</p> author.service.ts <pre><code>import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Pageable } from '../core/model/page/Pageable';\nimport { Author } from './model/Author';\nimport { AuthorPage } from './model/AuthorPage';\n\n@Injectable({\nprovidedIn: 'root'\n})\nexport class AuthorService {\n\n    constructor(\n        private http: HttpClient\n    ) { }\n\n    getAuthors(pageable: Pageable): Observable&lt;AuthorPage&gt; {\n        return this.http.post&lt;AuthorPage&gt;('http://localhost:8080/author', {pageable:pageable});\n    }\n\n    saveAuthor(author: Author): Observable&lt;void&gt; {\n        let url = 'http://localhost:8080/author';\n        if (author.id != null) url += '/'+author.id;\n\n        return this.http.put&lt;void&gt;(url, author);\n    }\n\n    deleteAuthor(idAuthor : number): Observable&lt;void&gt; {\n        return this.http.delete&lt;void&gt;('http://localhost:8080/author/'+idAuthor);\n    }    \n}\n</code></pre>"},{"location":"develop/paginated/nodejs/","title":"Listado paginado - Nodejs","text":"<p>Ahora vamos a implementar las operaciones necesarias para ayudar al front a cubrir la funcionalidad del CRUD paginado en servidor.  Recuerda que para que un listado paginado en servidor funcione, el cliente debe enviar en cada petici\u00f3n que p\u00e1gina est\u00e1 solicitando y cual es el tama\u00f1o de la p\u00e1gina, para que el servidor devuelva solamente un subconjunto de datos, en lugar de devolver el listado completo.</p> <p>Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.</p>"},{"location":"develop/paginated/nodejs/#crear-modelos","title":"Crear modelos","text":"<p>Lo primero que vamos a hacer es crear el modelo de author para trabajar con BBDD. En la carpeta schemas creamos el archivo <code>author.schema.js</code>:</p> author.schema.js <pre><code>import mongoose from \"mongoose\";\nimport normalize from 'normalize-mongoose';\nimport mongoosePaginate from 'mongoose-paginate-v2';\nconst { Schema, model } = mongoose;\n\nconst authorSchema = new Schema({\n    name: {\n        type: String,\n        require: true\n    },\n    nationality: {\n        type: String,\n        require: true\n    }\n});\nauthorSchema.plugin(normalize);\nauthorSchema.plugin(mongoosePaginate);\n\nconst AuthorModel = model('Author', authorSchema);\n\nexport default AuthorModel;\n</code></pre>"},{"location":"develop/paginated/nodejs/#implementar-el-service","title":"Implementar el Service","text":"<p>Creamos el service correspondiente <code>author.service.js</code>:</p> author.service.js <pre><code>import AuthorModel from '../schemas/author.schema.js';\n\nexport const getAuthors = async () =&gt; {\n    try {\n        return await AuthorModel.find().sort('id');\n    } catch (e) {\n        throw Error('Error fetching authors');\n    }\n}\n\nexport const createAuthor = async (data) =&gt; {\n    const { name, nationality } = data;\n    try {\n        const author = new AuthorModel({ name, nationality });\n        return await author.save();\n    } catch (e) {\n        throw Error('Error creating author');\n    }\n}\n\nexport const updateAuthor = async (id, data) =&gt; {\n    try {\n        const author = await AuthorModel.findById(id);\n        if (!author) {\n            throw Error('There is no author with that Id');\n        }    \n        return await AuthorModel.findByIdAndUpdate(id, data);\n    } catch (e) {\n        throw Error(e);\n    }\n}\n\nexport const deleteAuthor = async (id) =&gt; {\n    try {\n        const author = await AuthorModel.findById(id);\n        if (!author) {\n            throw Error('There is no author with that Id');\n        }\n        return await AuthorModel.findByIdAndDelete(id);\n    } catch (e) {\n        throw Error(e);\n    }\n}\n\nexport const getAuthorsPageable = async (page, limit, sort) =&gt; {\n    const sortObj = {\n        [sort?.property || 'name']: sort?.direction === 'DESC' ? 'DESC' : 'ASC'\n    };\n    try {\n       const options = {\n            page: parseInt(page) + 1,\n            limit,\n            sort: sortObj\n        };\n\n        return await AuthorModel.paginate({}, options);\n    } catch (e) {\n        throw Error('Error fetching authors page');\n    }    \n}\n</code></pre> <p>Como podemos observar es muy parecido al servicio de categor\u00edas, pero hemos incluido un nuevo m\u00e9todo <code>getAuthorsPageable</code>. Este m\u00e9todo tendr\u00e1 como par\u00e1metros de entrada la p\u00e1gina que queramos mostrar, el tama\u00f1o de esta y las propiedades de ordenaci\u00f3n. Moongose nos proporciona el m\u00e9todo paginate que es muy parecido a find salvo que adem\u00e1s podemos pasar las opciones de paginaci\u00f3n y el solo realizar\u00e1 todo el trabajo.</p>"},{"location":"develop/paginated/nodejs/#implementar-el-controller","title":"Implementar el Controller","text":"<p>Creamos el controlador <code>author.controller.js</code>:</p> author.controller.js <pre><code>import * as AuthorService from '../services/author.service.js';\n\nexport const getAuthors = async (req, res) =&gt; {\n    try {\n        const authors = await AuthorService.getAuthors();\n        res.status(200).json(\n            authors\n        );\n    } catch (err) {\n        res.status(400).json({\n            msg: err.toString()\n        });\n    }\n}\n\nexport const createAuthor = async (req, res) =&gt; {\n    try {\n        const author = await AuthorService.createAuthor(req.body);\n        res.status(200).json({\n            author\n        });\n    } catch (err) {\n        res.status(400).json({\n            msg: err.toString()\n        });\n    }\n}\n\nexport const updateAuthor = async (req, res) =&gt; {\n    const authorId = req.params.id;\n    try {\n        await AuthorService.updateAuthor(authorId, req.body);\n        res.status(200).json(1);\n    } catch (err) {\n        res.status(400).json({\n            msg: err.toString()\n        });\n    }\n}\n\nexport const deleteAuthor = async (req, res) =&gt; {\n    const authorId = req.params.id;\n    try {\n        const deletedAuthor = await AuthorService.deleteAuthor(authorId);\n        res.status(200).json({\n            author: deletedAuthor\n        });\n    } catch (err) {\n        res.status(400).json({\n            msg: err.toString()\n        });\n    }\n}\n\nexport const getAuthorsPageable = async (req, res) =&gt; {\n    const page = req.body.pageable.pageNumber || 0;\n    const limit = req.body.pageable.pageSize || 5;\n    const sort = req.body.pageable.sort || null;\n\n    try {\n        const response = await AuthorService.getAuthorsPageable(page, limit, sort);\n        res.status(200).json({\n            content: response.docs,\n            pageable: {\n                pageNumber: response.page - 1,\n                pageSize: response.limit\n            },\n            totalElements: response.totalDocs\n        });\n    } catch (err) {\n        res.status(400).json({\n            msg: err.toString()\n        });\n    }\n}\n</code></pre> <p>Y vemos que el m\u00e9todo getAuthorsPageable lee los datos de la request, se los pasa al servicio y por \u00faltimo transforma la response con los datos obtenidos.</p>"},{"location":"develop/paginated/nodejs/#implementar-las-rutas","title":"Implementar las Rutas","text":"<p>Creamos nuestro archivo de rutas <code>author.routes.js</code>:</p> author.routes.js <pre><code>import { Router } from 'express';\nimport { check } from 'express-validator';\nimport validateFields from '../middlewares/validateFields.js';\nimport { createAuthor, deleteAuthor, getAuthors, updateAuthor, getAuthorsPageable } from '../controllers/author.controller.js';\nconst authorRouter = Router();\n\nauthorRouter.put('/:id', [\n    check('name').not().isEmpty(),\n    check('nationality').not().isEmpty(),\n    validateFields\n], updateAuthor);\n\nauthorRouter.put('/', [\n    check('name').not().isEmpty(),\n    check('nationality').not().isEmpty(),\n    validateFields\n], createAuthor);\n\nauthorRouter.get('/', getAuthors);\nauthorRouter.delete('/:id', deleteAuthor);\n\nauthorRouter.post('/', [\n    check('pageable').not().isEmpty(),\n    check('pageable.pageSize').not().isEmpty(),\n    check('pageable.pageNumber').not().isEmpty(),\n    validateFields\n], getAuthorsPageable)\n\nexport default authorRouter;\n</code></pre> <p>Podemos observar que si hacemos una petici\u00f3n con get a <code>/author</code> nos devolver\u00e1 todos los autores. Pero si hacemos una petici\u00f3n post con el objeto pageable en el body realizaremos el listado paginado.</p> <p>Finalmente en nuestro archivo <code>index.js</code> vamos a a\u00f1adir el nuevo router:</p> index.js <pre><code>...\n\nimport authorRouter from './src/routes/author.routes.js';\n\n...\n\napp.use('/author', authorRouter);\n\n...\n</code></pre>"},{"location":"develop/paginated/nodejs/#probar-las-operaciones","title":"Probar las operaciones","text":"<p>Y ahora que tenemos todo creado, ya podemos probarlo con Postman:</p> <p>Por un lado creamos autores con:</p> <p>** PUT /author ** </p> <p>** PUT /author/{id} **  <pre><code>{\n    \"name\" : \"Nuevo autor\",\n    \"nationality\" : \"Nueva nacionalidad\"\n}\n</code></pre></p> <p>Nos sirve para insertar <code>Autores</code> nuevas (si no tienen el id informado) o para actualizar <code>Autores</code> (si tienen el id informado en la URL).  F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no te dar\u00e1 un error.</p> <p></p> <p></p> <p>** DELETE /author/{id} **  nos sirve eliminar <code>Autores</code>. F\u00edjate que el dato del ID que se env\u00eda est\u00e1 en el path.</p> <p></p> <p>Luego recuperamos los autores con el m\u00e9todo <code>GET</code> (antes tienes que crear unos cuantos para poder ver un listado):</p> <p></p> <p>Y por \u00faltimo listamos los autores paginados:</p> <p>** POST /author **</p> <pre><code>{\n    \"pageable\": {\n        \"pageSize\" : 4,\n        \"pageNumber\" : 0,\n        \"sort\" : [\n            {\n                \"property\": \"name\",\n                \"direction\": \"ASC\"\n            }\n        ]\n    }\n}\n</code></pre> <p></p>"},{"location":"develop/paginated/react/","title":"Listado paginado - React","text":"<p>Ya tienes tu primer CRUD desarrollado. \u00bfHa sido sencillo, verdad?.</p> <p>Ahora vamos a implementar un CRUD un poco m\u00e1s complejo, este tiene datos paginados en servidor, esto quiere decir que no nos sirve un array de datos como en el anterior ejemplo.  Para que un listado paginado en servidor funcione, el cliente debe enviar en cada petici\u00f3n que p\u00e1gina est\u00e1 solicitando y cual es el tama\u00f1o de la p\u00e1gina, para que el servidor devuelva solamente un subconjunto de datos, en lugar de devolver el listado completo.</p> <p>Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.</p>"},{"location":"develop/paginated/react/#crear-componente-author","title":"Crear componente author","text":"<p>Lo primero que vamos a hacer es crear una carpeta llamada types dentro de <code>src</code>. Aqu\u00ed crearemos los tipos de typescript. Creamos un nuevo fichero llamado <code>Author.ts</code> cuyo contenido ser\u00e1 el siguiente:</p> Author.ts <pre><code>export interface Author {\n    id: string,\n    name: string,\n    nationality: string\n}\n\nexport interface AuthorResponse {\n    content: Author[];\n    totalElements: number;\n}\n</code></pre> <p>Ahora vamos a crear un archivo de estilos que ser\u00e1 solo utilizado por la p\u00e1gina de author. Para ello dentro de la carpeta <code>Author</code> creamos un archivo llamado <code>Author.module.css</code>. Al llamar al archivo de esta manera React reconoce este archivo como un archivo \u00fanico para un componente y hace que sus reglas css sean m\u00e1s prioritarias, aunque por ejemplo exista una clase con el mismo nombre en el archivo <code>index.css</code>.</p> <p>El contenido de nuestro archivo css ser\u00e1 el siguiente:</p> index.css <pre><code>.tableActions {\n    margin-right: 20px;\n    display: flex;\n    justify-content: flex-end;\n    align-content: flex-start;\n    gap: 19px;\n}\n</code></pre> <p>Al igual que hicimos con categor\u00edas vamos a crear un nuevo componente para el formulario de alta y edici\u00f3n, para ello creamos una nueva carpeta llamada components en <code>src/pages/Author</code> y dentro de esta carpeta crearemos un fichero llamado <code>CreateAuthor.tsx</code>:</p> CreateAuthor.tsx <pre><code>import { ChangeEvent, useEffect, useState } from \"react\";\nimport Button from \"@mui/material/Button\";\nimport TextField from \"@mui/material/TextField\";\nimport Dialog from \"@mui/material/Dialog\";\nimport DialogActions from \"@mui/material/DialogActions\";\nimport DialogContent from \"@mui/material/DialogContent\";\nimport DialogTitle from \"@mui/material/DialogTitle\";\nimport { Author } from \"../../../types/Author\";\n\ninterface Props {\n  author: Author | null;\n  closeModal: () =&gt; void;\n  create: (author: Author) =&gt; void;\n}\n\nconst initialState = {\n  name: \"\",\n  nationality: \"\",\n};\n\nexport default function CreateAuthor(props: Props) {\n  const [form, setForm] = useState(initialState);\n\n  useEffect(() =&gt; {\n    setForm(props?.author || initialState);\n  }, [props?.author]);\n\n  const handleChangeForm = (\n    event: ChangeEvent&lt;HTMLInputElement | HTMLTextAreaElement&gt;\n  ) =&gt; {\n    setForm({\n      ...form,\n      [event.target.id]: event.target.value,\n    });\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;Dialog open={true} onClose={props.closeModal}&gt;\n        &lt;DialogTitle&gt;\n          {props.author ? \"Actualizar Autor\" : \"Crear Autor\"}\n        &lt;/DialogTitle&gt;\n        &lt;DialogContent&gt;\n          {props.author &amp;&amp; (\n            &lt;TextField\n              margin=\"dense\"\n              disabled\n              id=\"id\"\n              label=\"Id\"\n              fullWidth\n              value={props.author.id}\n              variant=\"standard\"\n            /&gt;\n          )}\n          &lt;TextField\n            margin=\"dense\"\n            id=\"name\"\n            label=\"Nombre\"\n            fullWidth\n            variant=\"standard\"\n            onChange={handleChangeForm}\n            value={form.name}\n          /&gt;\n          &lt;TextField\n            margin=\"dense\"\n            id=\"nationality\"\n            label=\"Nacionalidad\"\n            fullWidth\n            variant=\"standard\"\n            onChange={handleChangeForm}\n            value={form.nationality}\n          /&gt;\n        &lt;/DialogContent&gt;\n        &lt;DialogActions&gt;\n          &lt;Button onClick={props.closeModal}&gt;Cancelar&lt;/Button&gt;\n          &lt;Button\n            onClick={() =&gt;\n              props.create({\n                id: props.author ? props.author.id : \"\",\n                name: form.name,\n                nationality: form.nationality,\n              })\n            }\n            disabled={!form.name || !form.nationality}\n          &gt;\n            {props.author ? \"Actualizar\" : \"Crear\"}\n          &lt;/Button&gt;\n        &lt;/DialogActions&gt;\n      &lt;/Dialog&gt;\n    &lt;/div&gt;\n  );\n}\n</code></pre> <p>Como los autores tienen m\u00e1s campos hemos a\u00f1adido un poco de funcionalidad extra que no ten\u00edamos en el formulario de categor\u00edas, pero no es demasiado complicada.</p> <p>Vamos a a\u00f1adir los m\u00e9todos necesarios para el crud de autores en el fichero <code>src/redux/services/ludotecaApi.ts</code>:</p> ludotecaApi.ts <pre><code>    getAllAuthors: builder.query&lt;Author[], null&gt;({\n  query: () =&gt; \"author\",\n  providesTags: [\"Author\" ],\n}),\ngetAuthors: builder.query&lt;\n  AuthorResponse,\n  { pageNumber: number; pageSize: number }\n&gt;({\n  query: ({ pageNumber, pageSize }) =&gt; {\n    return {\n      url: \"author/\",\n      method: \"POST\",\n      body: {\n        pageable: {\n          pageNumber,\n          pageSize,\n        },\n      },\n    };\n  },\n  providesTags: [\"Author\"],\n}),\ncreateAuthor: builder.mutation({\n  query: (payload) =&gt; ({\n    url: \"/author\",\n    method: \"PUT\",\n    body: payload,\n    headers: {\n      \"Content-type\": \"application/json; charset=UTF-8\",\n    },\n  }),\n  invalidatesTags: [\"Author\"],\n}),\ndeleteAuthor: builder.mutation({\n  query: (id: string) =&gt; ({\n    url: `/author/${id}`,\n    method: \"DELETE\",\n  }),\n  invalidatesTags: [\"Author\"],\n}),\nupdateAuthor: builder.mutation({\n  query: (payload: Author) =&gt; ({\n    url: `author/${payload.id}`,\n    method: \"PUT\",\n    body: payload,\n  }),\n  invalidatesTags: [\"Author\", \"Game\"],\n}),\n</code></pre> <p>A\u00f1adimos tambi\u00e9n los imports, tags y exports necesarios y guardamos. <pre><code>import { Author, AuthorResponse } from \"../../types/Author\";\n\ntagTypes: [\"Category\", \"Author\", \"Game\"],\n\nexport const {\n  useGetCategoriesQuery,\n  useCreateCategoryMutation,\n  useDeleteCategoryMutation,\n  useUpdateCategoryMutation,\n  useCreateAuthorMutation,\n  useDeleteAuthorMutation,\n  useGetAllAuthorsQuery,\n  useGetAuthorsQuery,\n  useUpdateAuthorMutation,\n} = ludotecaAPI;\n</code></pre></p> <p>Y por \u00faltimo el contenido de nuestro fichero <code>Author.tsx</code> quedar\u00eda as\u00ed:</p> Author.tsx <pre><code>import { useEffect, useState, useContext } from \"react\";\nimport Button from \"@mui/material/Button\";\nimport TableHead from \"@mui/material/TableHead\";\nimport Table from \"@mui/material/Table\";\nimport TableBody from \"@mui/material/TableBody\";\nimport TableCell from \"@mui/material/TableCell\";\nimport TableContainer from \"@mui/material/TableContainer\";\nimport TableFooter from \"@mui/material/TableFooter\";\nimport TablePagination from \"@mui/material/TablePagination\";\nimport TableRow from \"@mui/material/TableRow\";\nimport Paper from \"@mui/material/Paper\";\nimport IconButton from \"@mui/material/IconButton\";\nimport EditIcon from \"@mui/icons-material/Edit\";\nimport ClearIcon from \"@mui/icons-material/Clear\";\nimport styles from \"./Author.module.css\";\nimport CreateAuthor from \"./components/CreateAuthor\";\nimport { ConfirmDialog } from \"../../components/ConfirmDialog\";\nimport { useAppDispatch } from \"../../redux/hooks\";\nimport { setMessage } from \"../../redux/features/messageSlice\";\nimport { BackError } from \"../../types/appTypes\";\nimport { Author as AuthorModel } from \"../../types/Author\";\nimport {\n  useDeleteAuthorMutation,\n  useGetAuthorsQuery,\n  useCreateAuthorMutation,\n  useUpdateAuthorMutation,\n} from \"../../redux/services/ludotecaApi\";\nimport { LoaderContext } from \"../../context/LoaderProvider\";\n\nexport const Author = () =&gt; {\n  const [pageNumber, setPageNumber] = useState(0);\n  const [pageSize, setPageSize] = useState(5);\n  const [total, setTotal] = useState(0);\n  const [authors, setAuthors] = useState&lt;AuthorModel[]&gt;([]);\n  const [openCreate, setOpenCreate] = useState(false);\n  const [idToDelete, setIdToDelete] = useState(\"\");\n  const [authorToUpdate, setAuthorToUpdate] = useState&lt;AuthorModel | null&gt;(\n    null\n  );\n\n  const dispatch = useAppDispatch();\n  const loader = useContext(LoaderContext);\n\n  const handleChangePage = (\n    _event: React.MouseEvent&lt;HTMLButtonElement&gt; | null,\n    newPage: number\n  ) =&gt; {\n    setPageNumber(newPage);\n  };\n\n  const handleChangeRowsPerPage = (\n    event: React.ChangeEvent&lt;HTMLInputElement | HTMLTextAreaElement&gt;\n  ) =&gt; {\n    setPageNumber(0);\n    setPageSize(parseInt(event.target.value, 10));\n  };\n\n  const { data, error, isLoading } = useGetAuthorsQuery({\n    pageNumber,\n    pageSize,\n  });\n\n  const [deleteAuthorApi, { isLoading: isLoadingDelete, error: errorDelete }] =\n    useDeleteAuthorMutation();\n\n  const [createAuthorApi, { isLoading: isLoadingCreate }] =\n    useCreateAuthorMutation();\n\n  const [updateAuthorApi, { isLoading: isLoadingUpdate }] =\n    useUpdateAuthorMutation();\n\n  useEffect(() =&gt; {\n    loader.showLoading(\n      isLoadingCreate || isLoading || isLoadingDelete || isLoadingUpdate\n    );\n  }, [isLoadingCreate, isLoading, isLoadingDelete, isLoadingUpdate]);\n\n  useEffect(() =&gt; {\n    if (data) {\n      setAuthors(data.content);\n      setTotal(data.totalElements);\n    }\n  }, [data]);\n\n  useEffect(() =&gt; {\n    if (errorDelete) {\n      if (\"status\" in errorDelete) {\n        dispatch(\n          setMessage({\n            text: (errorDelete?.data as BackError).msg,\n            type: \"error\",\n          })\n        );\n      }\n    }\n  }, [errorDelete, dispatch]);\n\n  useEffect(() =&gt; {\n    if (error) {\n      dispatch(setMessage({ text: \"Se ha producido un error\", type: \"error\" }));\n    }\n  }, [error]);\n\n  const createAuthor = (author: AuthorModel) =&gt; {\n    setOpenCreate(false);\n    if (author.id) {\n      updateAuthorApi(author)\n        .then(() =&gt; {\n          dispatch(\n            setMessage({\n              text: \"Autor actualizado correctamente\",\n              type: \"ok\",\n            })\n          );\n          setAuthorToUpdate(null);\n        })\n        .catch((err) =&gt; console.log(err));\n    } else {\n      createAuthorApi(author)\n        .then(() =&gt; {\n          dispatch(\n            setMessage({ text: \"Autor creado correctamente\", type: \"ok\" })\n          );\n          setAuthorToUpdate(null);\n        })\n        .catch((err) =&gt; console.log(err));\n    }\n  };\n\n  const deleteAuthor = () =&gt; {\n    deleteAuthorApi(idToDelete)\n      .then(() =&gt; {\n        setIdToDelete(\"\");\n      })\n      .catch((err) =&gt; console.log(err));\n  };\n\n  return (\n    &lt;div className=\"container\"&gt;\n      &lt;h1&gt;Listado de Autores&lt;/h1&gt;\n      &lt;TableContainer component={Paper}&gt;\n        &lt;Table sx={{ minWidth: 500 }} aria-label=\"custom pagination table\"&gt;\n          &lt;TableHead\n            sx={{\n              \"&amp; th\": {\n                backgroundColor: \"lightgrey\",\n              },\n            }}\n          &gt;\n            &lt;TableRow&gt;\n              &lt;TableCell&gt;Identificador&lt;/TableCell&gt;\n              &lt;TableCell&gt;Nombre Autor&lt;/TableCell&gt;\n              &lt;TableCell&gt;Nacionalidad&lt;/TableCell&gt;\n              &lt;TableCell align=\"right\"&gt;&lt;/TableCell&gt;\n            &lt;/TableRow&gt;\n          &lt;/TableHead&gt;\n          &lt;TableBody&gt;\n            {authors.map((author: AuthorModel) =&gt; (\n              &lt;TableRow key={author.id}&gt;\n                &lt;TableCell component=\"th\" scope=\"row\"&gt;\n                  {author.id}\n                &lt;/TableCell&gt;\n                &lt;TableCell style={{ width: 160 }}&gt;{author.name}&lt;/TableCell&gt;\n                &lt;TableCell style={{ width: 160 }}&gt;\n                  {author.nationality}\n                &lt;/TableCell&gt;\n                &lt;TableCell align=\"right\"&gt;\n                  &lt;div className={styles.tableActions}&gt;\n                    &lt;IconButton\n                      aria-label=\"update\"\n                      color=\"primary\"\n                      onClick={() =&gt; {\n                        setAuthorToUpdate(author);\n                        setOpenCreate(true);\n                      }}\n                    &gt;\n                      &lt;EditIcon /&gt;\n                    &lt;/IconButton&gt;\n                    &lt;IconButton\n                      aria-label=\"delete\"\n                      color=\"error\"\n                      onClick={() =&gt; {\n                        setIdToDelete(author.id);\n                      }}\n                    &gt;\n                      &lt;ClearIcon /&gt;\n                    &lt;/IconButton&gt;\n                  &lt;/div&gt;\n                &lt;/TableCell&gt;\n              &lt;/TableRow&gt;\n            ))}\n          &lt;/TableBody&gt;\n          &lt;TableFooter&gt;\n            &lt;TableRow&gt;\n              &lt;TablePagination\n                rowsPerPageOptions={[5, 10, 25]}\n                colSpan={4}\n                count={total}\n                rowsPerPage={pageSize}\n                page={pageNumber}\n                SelectProps={{\n                  inputProps: {\n                    \"aria-label\": \"rows per page\",\n                  },\n                  native: true,\n                }}\n                onPageChange={handleChangePage}\n                onRowsPerPageChange={handleChangeRowsPerPage}\n              /&gt;\n            &lt;/TableRow&gt;\n          &lt;/TableFooter&gt;\n        &lt;/Table&gt;\n      &lt;/TableContainer&gt;\n      &lt;div className=\"newButton\"&gt;\n        &lt;Button variant=\"contained\" onClick={() =&gt; setOpenCreate(true)}&gt;\n          Nuevo autor\n        &lt;/Button&gt;\n      &lt;/div&gt;\n      {openCreate &amp;&amp; (\n        &lt;CreateAuthor\n          create={createAuthor}\n          author={authorToUpdate}\n          closeModal={() =&gt; {\n            setAuthorToUpdate(null);\n            setOpenCreate(false);\n          }}\n        /&gt;\n      )}\n      {!!idToDelete &amp;&amp; (\n        &lt;ConfirmDialog\n          title=\"Eliminar Autor\"\n          text=\"Atenci\u00f3n si borra el autor se perder\u00e1n sus datos. \u00bfDesea eliminar el autor?\"\n          confirm={deleteAuthor}\n          closeModal={() =&gt; setIdToDelete(\"\")}\n        /&gt;\n      )}\n    &lt;/div&gt;\n  );\n};\n</code></pre> <p>Al tratarse de un listado paginado hemos creado dos nuevas variables en nuestro estado para almacenar la p\u00e1gina y el n\u00famero de registros a mostrar en la p\u00e1gina. Cuando cambiamos estos valores en el navegador como estas variables van como par\u00e1metro en nuestro <code>hook</code> para recuperar datos autom\u00e1ticamente el listado se va a modificar.</p> <p>El resto de funcionalidad es muy parecida a la de categor\u00edas. </p>"},{"location":"develop/paginated/springboot/","title":"Listado paginado - Spring Boot","text":"<p>Ahora vamos a implementar las operaciones necesarias para ayudar al front a cubrir la funcionalidad del CRUD paginado en servidor.  Recuerda que para que un listado paginado en servidor funcione, el cliente debe enviar en cada petici\u00f3n que p\u00e1gina est\u00e1 solicitando y cu\u00e1l es el tama\u00f1o de la p\u00e1gina, para que el servidor devuelva solamente un subconjunto de datos, en lugar de devolver el listado completo.</p> <p>Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.</p>"},{"location":"develop/paginated/springboot/#crear-modelos","title":"Crear modelos","text":"<p>Lo primero que vamos a hacer es crear los modelos para trabajar con BBDD y con peticiones hacia el front. Adem\u00e1s, tambi\u00e9n tenemos que a\u00f1adir datos al script de inicializaci\u00f3n de BBDD, siempre respetando la nomenclatura que le hemos dado a la tabla y columnas de BBDD.</p> Author.javaAuthorDto.javadata.sql <pre><code>package com.ccsw.tutorial.author.model;\n\nimport jakarta.persistence.*;\n\n/**\n * @author ccsw\n *\n */\n@Entity\n@Table(name = \"author\")\npublic class Author {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\", nullable = false)\n    private Long id;\n\n    @Column(name = \"name\", nullable = false)\n    private String name;\n\n    @Column(name = \"nationality\")\n    private String nationality;\n\n    /**\n     * @return id\n     */\n    public Long getId() {\n\n        return this.id;\n    }\n\n    /**\n     * @param id new value of {@link #getId}.\n     */\n    public void setId(Long id) {\n\n        this.id = id;\n    }\n\n    /**\n     * @return name\n     */\n    public String getName() {\n\n        return this.name;\n    }\n\n    /**\n     * @param name new value of {@link #getName}.\n     */\n    public void setName(String name) {\n\n        this.name = name;\n    }\n\n    /**\n     * @return nationality\n     */\n    public String getNationality() {\n\n        return this.nationality;\n    }\n\n    /**\n     * @param nationality new value of {@link #getNationality}.\n     */\n    public void setNationality(String nationality) {\n\n        this.nationality = nationality;\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.author.model;\n\n/**\n * @author ccsw\n *\n */\npublic class AuthorDto {\n\n    private Long id;\n\n    private String name;\n\n    private String nationality;\n\n    /**\n     * @return id\n     */\n    public Long getId() {\n\n        return this.id;\n    }\n\n    /**\n     * @param id new value of {@link #getId}.\n     */\n    public void setId(Long id) {\n\n        this.id = id;\n    }\n\n    /**\n     * @return name\n     */\n    public String getName() {\n\n        return this.name;\n    }\n\n    /**\n     * @param name new value of {@link #getName}.\n     */\n    public void setName(String name) {\n\n        this.name = name;\n    }\n\n    /**\n     * @return nationality\n     */\n    public String getNationality() {\n\n        return this.nationality;\n    }\n\n    /**\n     * @param nationality new value of {@link #getNationality}.\n     */\n    public void setNationality(String nationality) {\n\n        this.nationality = nationality;\n    }\n\n}\n</code></pre> <pre><code>INSERT INTO category(name) VALUES ('Eurogames');\nINSERT INTO category(name) VALUES ('Ameritrash');\nINSERT INTO category(name) VALUES ('Familiar');\n\nINSERT INTO author(name, nationality) VALUES ('Alan R. Moon', 'US');\nINSERT INTO author(name, nationality) VALUES ('Vital Lacerda', 'PT');\nINSERT INTO author(name, nationality) VALUES ('Simone Luciani', 'IT');\nINSERT INTO author(name, nationality) VALUES ('Perepau Llistosella', 'ES');\nINSERT INTO author(name, nationality) VALUES ('Michael Kiesling', 'DE');\nINSERT INTO author(name, nationality) VALUES ('Phil Walker-Harding', 'US');\n</code></pre>"},{"location":"develop/paginated/springboot/#implementar-tdd-pruebas","title":"Implementar TDD - Pruebas","text":"<p>Para desarrollar todas las operaciones, empezaremos primero dise\u00f1ando las pruebas y luego implementando el c\u00f3digo necesario que haga funcionar correctamente esas pruebas. Para ir m\u00e1s r\u00e1pido vamos a poner todas las pruebas de golpe, pero realmente se deber\u00edan crear una a una e ir implementando el c\u00f3digo necesario para esa prueba. Para evitar tantas iteraciones en el tutorial las haremos todas de golpe.</p> <p>Vamos a pararnos a pensar un poco que necesitamos en la pantalla. Ahora mismo nos sirve con:</p> <ul> <li>Una consulta paginada, que reciba datos de la p\u00e1gina a consultar y devuelva los datos paginados</li> <li>Una operaci\u00f3n de guardado y modificaci\u00f3n</li> <li>Una operaci\u00f3n de borrado</li> </ul> <p>Para la primera prueba que hemos descrito (consulta paginada) se necesita un objeto que contenga los datos de la p\u00e1gina a consultar. As\u00ed que crearemos una clase <code>AuthorSearchDto</code> para utilizarlo como 'paginador'.</p> <p>Para ello, en primer lugar, deberemos a\u00f1adir una clase que vamos a utilizar como envoltorio para las peticiones de paginaci\u00f3n en el proyecto. Hacemos esto para desacoplar la interface de Spring Boot de nuestro contrato de entrada. Crearemos esta clase en el paquete <code>com.ccsw.tutorial.common.pagination</code>.</p> PageableRequest.java <pre><code>package com.ccsw.tutorial.common.pagination;\n\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport org.springframework.data.domain.*;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class PageableRequest implements Serializable {\n\n    private static final long serialVersionUID = 1L;\n\n    private int pageNumber;\n\n    private int pageSize;\n\n    private List&lt;SortRequest&gt; sort;\n\n    public PageableRequest() {\n\n        sort = new ArrayList&lt;&gt;();\n    }\n\n    public PageableRequest(int pageNumber, int pageSize) {\n\n        this();\n        this.pageNumber = pageNumber;\n        this.pageSize = pageSize;\n    }\n\n    public PageableRequest(int pageNumber, int pageSize, List&lt;SortRequest&gt; sort) {\n\n        this();\n        this.pageNumber = pageNumber;\n        this.pageSize = pageSize;\n        this.sort = sort;\n    }\n\n    public int getPageNumber() {\n        return pageNumber;\n    }\n\n    public void setPageNumber(int pageNumber) {\n        this.pageNumber = pageNumber;\n    }\n\n    public int getPageSize() {\n        return pageSize;\n    }\n\n    public void setPageSize(int pageSize) {\n        this.pageSize = pageSize;\n    }\n\n    public List&lt;SortRequest&gt; getSort() {\n        return sort;\n    }\n\n    public void setSort(List&lt;SortRequest&gt; sort) {\n        this.sort = sort;\n    }\n\n    @JsonIgnore\n    public Pageable getPageable() {\n\n        return PageRequest.of(this.pageNumber, this.pageSize, Sort.by(sort.stream().map(e -&gt; new Sort.Order(e.getDirection(), e.getProperty())).collect(Collectors.toList())));\n    }\n\n    public static class SortRequest implements Serializable {\n\n        private static final long serialVersionUID = 1L;\n\n        private String property;\n\n        private Sort.Direction direction;\n\n        protected String getProperty() {\n            return property;\n        }\n\n        protected void setProperty(String property) {\n            this.property = property;\n        }\n\n        protected Sort.Direction getDirection() {\n            return direction;\n        }\n\n        protected void setDirection(Sort.Direction direction) {\n            this.direction = direction;\n        }\n    }\n\n}\n</code></pre> <p>Adicionalmente necesitaremos una clase para deserializar las respuestas de Page recibidas en los test que vamos a implementar. Para ello creamos la clase necesaria dentro de la fuente de la carpeta de los <code>test</code> en el paquete <code>com.ccsw.tutorial.config</code>. Esto solo hace falta porque necesitamos leer la respuesta paginada en el test, si no hicieramos test, no har\u00eda falta.</p> ResponsePage.java <pre><code>package com.ccsw.tutorial.config;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport org.springframework.data.domain.PageImpl;\nimport org.springframework.data.domain.PageRequest;\nimport org.springframework.data.domain.Pageable;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class ResponsePage&lt;T&gt; extends PageImpl&lt;T&gt; {\n\n    private static final long serialVersionUID = 1L;\n\n    @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)\n    public ResponsePage(@JsonProperty(\"content\") List&lt;T&gt; content,\n                        @JsonProperty(\"number\") int number,\n                        @JsonProperty(\"size\") int size,\n                        @JsonProperty(\"totalElements\") Long totalElements,\n                        @JsonProperty(\"pageable\") JsonNode pageable,\n                        @JsonProperty(\"last\") boolean last,\n                        @JsonProperty(\"totalPages\") int totalPages,\n                        @JsonProperty(\"sort\") JsonNode sort,\n                        @JsonProperty(\"first\") boolean first,\n                        @JsonProperty(\"numberOfElements\") int numberOfElements) {\n\n        super(content, PageRequest.of(number, size), totalElements);\n    }\n\n    public ResponsePage(List&lt;T&gt; content, Pageable pageable, long total) {\n        super(content, pageable, total);\n    }\n\n    public ResponsePage(List&lt;T&gt; content) {\n        super(content);\n    }\n\n    public ResponsePage() {\n        super(new ArrayList&lt;&gt;());\n    }\n\n}\n</code></pre> <p>Paginaci\u00f3n en Springframework</p> <p>Cuando utilicemos paginaci\u00f3n en Springframework, debemos recordar que ya vienen implementados algunos objetos que podemos utilizar y que nos facilitan la vida. Es el caso de <code>Pageable</code> y <code>Page</code>.</p> <ul> <li>El objeto <code>Pageable</code> no es m\u00e1s que una interface que le permite a Spring JPA saber que p\u00e1gina se quiere buscar, cual es el tama\u00f1o de p\u00e1gina y cuales son las propiedades de ordenaci\u00f3n que se debe lanzar en la consulta.</li> <li>El objeto <code>PageRequest</code> es una utilidad que permite crear objetos de tipo <code>Pageable</code> de forma sencilla. Se utiliza mucho para codificaci\u00f3n de test.</li> <li>El objeto <code>Page</code> no es m\u00e1s que un contenedor que engloba la informaci\u00f3n b\u00e1sica de la p\u00e1gina que se est\u00e1 consultando (n\u00famero de p\u00e1gina, tama\u00f1o de p\u00e1gina, n\u00famero total de resultados) y el conjunto de datos de la BBDD que contiene esa p\u00e1gina una vez han sido buscados y ordenados.</li> </ul> <p>Tambi\u00e9n crearemos una clase <code>AuthorController</code> dentro del package de <code>com.ccsw.tutorial.author</code> con la implementaci\u00f3n de los m\u00e9todos vac\u00edos, para que no falle la compilaci\u00f3n.</p> <p>\u00a1Vamos a implementar test!</p> AuthorSearchDto.javaAuthorController.javaAuthorIT.java <pre><code>package com.ccsw.tutorial.author.model;\n\nimport com.ccsw.tutorial.common.pagination.PageableRequest;\n\n/**\n * @author ccsw\n *\n */\npublic class AuthorSearchDto {\n\n    private PageableRequest pageable;\n\n    public PageableRequest getPageable() {\n        return pageable;\n    }\n\n    public void setPageable(PageableRequest pageable) {\n        this.pageable = pageable;\n    }\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport com.ccsw.tutorial.author.model.AuthorDto;\nimport com.ccsw.tutorial.author.model.AuthorSearchDto;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport org.springframework.data.domain.Page;\nimport org.springframework.web.bind.annotation.*;\n\n/**\n * @author ccsw\n *\n */\n@Tag(name = \"Author\", description = \"API of Author\")\n@RequestMapping(value = \"/author\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class AuthorController {\n\n    /**\n     * M\u00e9todo para recuperar un listado paginado de {@link Author}\n     *\n     * @param dto dto de b\u00fasqueda\n     * @return {@link Page} de {@link AuthorDto}\n     */\n    @Operation(summary = \"Find Page\", description = \"Method that return a page of Authors\")\n    @RequestMapping(path = \"\", method = RequestMethod.POST)\n    public Page&lt;AuthorDto&gt; findPage(@RequestBody AuthorSearchDto dto) {\n\n        return null;\n    }\n\n    /**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    @Operation(summary = \"Save or Update\", description = \"Method that saves or updates a Author\")\n    @RequestMapping(path = { \"\", \"/{id}\" }, method = RequestMethod.PUT)\n    public void save(@PathVariable(name = \"id\", required = false) Long id, @RequestBody AuthorDto dto) {\n\n    }\n\n    /**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     */\n    @Operation(summary = \"Delete\", description = \"Method that deletes a Author\")\n    @RequestMapping(path = \"/{id}\", method = RequestMethod.DELETE)\n    public void delete(@PathVariable(\"id\") Long id) throws Exception {\n\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.AuthorDto;\nimport com.ccsw.tutorial.author.model.AuthorSearchDto;\nimport com.ccsw.tutorial.common.pagination.PageableRequest;\nimport com.ccsw.tutorial.config.ResponsePage;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.web.client.TestRestTemplate;\nimport org.springframework.boot.test.web.server.LocalServerPort;\nimport org.springframework.core.ParameterizedTypeReference;\nimport org.springframework.http.*;\nimport org.springframework.test.annotation.DirtiesContext;\n\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\npublic class AuthorIT {\n\n    public static final String LOCALHOST = \"http://localhost:\";\n    public static final String SERVICE_PATH = \"/author\";\n\n    public static final Long DELETE_AUTHOR_ID = 6L;\n    public static final Long MODIFY_AUTHOR_ID = 3L;\n    public static final String NEW_AUTHOR_NAME = \"Nuevo Autor\";\n    public static final String NEW_NATIONALITY = \"Nueva Nacionalidad\";\n\n    private static final int TOTAL_AUTHORS = 6;\n    private static final int PAGE_SIZE = 5;\n\n    @LocalServerPort\n    private int port;\n\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    ParameterizedTypeReference&lt;ResponsePage&lt;AuthorDto&gt;&gt; responseTypePage = new ParameterizedTypeReference&lt;ResponsePage&lt;AuthorDto&gt;&gt;(){};\n\n    @Test\n    public void findFirstPageWithFiveSizeShouldReturnFirstFiveResults() {\n\n          AuthorSearchDto searchDto = new AuthorSearchDto();\n          searchDto.setPageable(new PageableRequest(0, PAGE_SIZE));\n\n          ResponseEntity&lt;ResponsePage&lt;AuthorDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.POST, new HttpEntity&lt;&gt;(searchDto), responseTypePage);\n\n          assertNotNull(response);\n          assertEquals(TOTAL_AUTHORS, response.getBody().getTotalElements());\n          assertEquals(PAGE_SIZE, response.getBody().getContent().size());\n    }\n\n    @Test\n    public void findSecondPageWithFiveSizeShouldReturnLastResult() {\n\n          int elementsCount = TOTAL_AUTHORS - PAGE_SIZE;\n\n          AuthorSearchDto searchDto = new AuthorSearchDto();\n          searchDto.setPageable(new PageableRequest(1, PAGE_SIZE));\n\n          ResponseEntity&lt;ResponsePage&lt;AuthorDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.POST, new HttpEntity&lt;&gt;(searchDto), responseTypePage);\n\n          assertNotNull(response);\n          assertEquals(TOTAL_AUTHORS, response.getBody().getTotalElements());\n          assertEquals(elementsCount, response.getBody().getContent().size());\n    }\n\n    @Test\n    public void saveWithoutIdShouldCreateNewAuthor() {\n\n          long newAuthorId = TOTAL_AUTHORS + 1;\n          long newAuthorSize = TOTAL_AUTHORS + 1;\n\n          AuthorDto dto = new AuthorDto();\n          dto.setName(NEW_AUTHOR_NAME);\n          dto.setNationality(NEW_NATIONALITY);\n\n          restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.PUT, new HttpEntity&lt;&gt;(dto), Void.class);\n\n          AuthorSearchDto searchDto = new AuthorSearchDto();\n          searchDto.setPageable(new PageableRequest(0, (int) newAuthorSize));\n\n          ResponseEntity&lt;ResponsePage&lt;AuthorDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.POST, new HttpEntity&lt;&gt;(searchDto), responseTypePage);\n\n          assertNotNull(response);\n          assertEquals(newAuthorSize, response.getBody().getTotalElements());\n\n          AuthorDto author = response.getBody().getContent().stream().filter(item -&gt; item.getId().equals(newAuthorId)).findFirst().orElse(null);\n          assertNotNull(author);\n          assertEquals(NEW_AUTHOR_NAME, author.getName());\n    }\n\n    @Test\n    public void modifyWithExistIdShouldModifyAuthor() {\n\n          AuthorDto dto = new AuthorDto();\n          dto.setName(NEW_AUTHOR_NAME);\n          dto.setNationality(NEW_NATIONALITY);\n\n          restTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + MODIFY_AUTHOR_ID, HttpMethod.PUT, new HttpEntity&lt;&gt;(dto), Void.class);\n\n          AuthorSearchDto searchDto = new AuthorSearchDto();\n          searchDto.setPageable(new PageableRequest(0, PAGE_SIZE));\n\n          ResponseEntity&lt;ResponsePage&lt;AuthorDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.POST, new HttpEntity&lt;&gt;(searchDto), responseTypePage);\n\n          assertNotNull(response);\n          assertEquals(TOTAL_AUTHORS, response.getBody().getTotalElements());\n\n          AuthorDto author = response.getBody().getContent().stream().filter(item -&gt; item.getId().equals(MODIFY_AUTHOR_ID)).findFirst().orElse(null);\n          assertNotNull(author);\n          assertEquals(NEW_AUTHOR_NAME, author.getName());\n          assertEquals(NEW_NATIONALITY, author.getNationality());\n    }\n\n    @Test\n    public void modifyWithNotExistIdShouldThrowException() {\n\n          long authorId = TOTAL_AUTHORS + 1;\n\n          AuthorDto dto = new AuthorDto();\n          dto.setName(NEW_AUTHOR_NAME);\n\n          ResponseEntity&lt;?&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + authorId, HttpMethod.PUT, new HttpEntity&lt;&gt;(dto), Void.class);\n\n          assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());\n    }\n\n    @Test\n    public void deleteWithExistsIdShouldDeleteCategory() {\n\n          long newAuthorsSize = TOTAL_AUTHORS - 1;\n\n          restTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + DELETE_AUTHOR_ID, HttpMethod.DELETE, null, Void.class);\n\n          AuthorSearchDto searchDto = new AuthorSearchDto();\n          searchDto.setPageable(new PageableRequest(0, TOTAL_AUTHORS));\n\n          ResponseEntity&lt;ResponsePage&lt;AuthorDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.POST, new HttpEntity&lt;&gt;(searchDto), responseTypePage);\n\n          assertNotNull(response);\n          assertEquals(newAuthorsSize, response.getBody().getTotalElements());\n    }\n\n    @Test\n    public void deleteWithNotExistsIdShouldThrowException() {\n\n          long deleteAuthorId = TOTAL_AUTHORS + 1;\n\n          ResponseEntity&lt;?&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + deleteAuthorId, HttpMethod.DELETE, null, Void.class);\n\n          assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());\n    }\n\n}\n</code></pre> <p>Cuidado con las clases de Test</p> <p>Recuerda que el c\u00f3digo de aplicaci\u00f3n debe ir en <code>src/main/java</code>, mientras que las clases de test deben ir en <code>src/test/java</code> para que no se mezclen unas con otras y se empaquete todo en el artefacto final. En este caso <code>AuthorIT.java</code> va en el directorio de test <code>src/test/java</code>.</p> <p>Si ejecutamos los test, el resultado ser\u00e1 7 maravillosos test que fallan su ejecuci\u00f3n. Es normal, puesto que no hemos implementado nada de c\u00f3digo de aplicaci\u00f3n para corresponder esos test.</p>"},{"location":"develop/paginated/springboot/#implementar-controller","title":"Implementar Controller","text":"<p>Si recuerdas, esta capa de <code>Controller</code> es la que tiene los endpoints de entrada a la aplicaci\u00f3n. Nosotros ya tenemos definidas 3 operaciones, que hemos dise\u00f1ado directamente desde los tests. Ahora vamos a implementar esos m\u00e9todos con el c\u00f3digo necesario para que los test funcionen correctamente, y teniendo en mente que debemos apoyarnos en las capas inferiores <code>Service</code> y <code>Repository</code> para repartir l\u00f3gica de negocio y acceso a datos.</p> AuthorController.javaAuthorService.java <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport com.ccsw.tutorial.author.model.AuthorDto;\nimport com.ccsw.tutorial.author.model.AuthorSearchDto;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport org.modelmapper.ModelMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.PageImpl;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * @author ccsw\n *\n */\n@Tag(name = \"Author\", description = \"API of Author\")\n@RequestMapping(value = \"/author\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class AuthorController {\n\n    @Autowired\n    AuthorService authorService;\n\n    @Autowired\n    ModelMapper mapper;\n\n    /**\n     * M\u00e9todo para recuperar un listado paginado de {@link Author}\n     *\n     * @param dto dto de b\u00fasqueda\n     * @return {@link Page} de {@link AuthorDto}\n     */\n    @Operation(summary = \"Find Page\", description = \"Method that return a page of Authors\")\n    @RequestMapping(path = \"\", method = RequestMethod.POST)\n    public Page&lt;AuthorDto&gt; findPage(@RequestBody AuthorSearchDto dto) {\n\n        Page&lt;Author&gt; page = this.authorService.findPage(dto);\n\n        return new PageImpl&lt;&gt;(page.getContent().stream().map(e -&gt; mapper.map(e, AuthorDto.class)).collect(Collectors.toList()), page.getPageable(), page.getTotalElements());\n    }\n\n    /**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    @Operation(summary = \"Save or Update\", description = \"Method that saves or updates a Author\")\n    @RequestMapping(path = { \"\", \"/{id}\" }, method = RequestMethod.PUT)\n    public void save(@PathVariable(name = \"id\", required = false) Long id, @RequestBody AuthorDto dto) {\n\n        this.authorService.save(id, dto);\n    }\n\n    /**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     */\n    @Operation(summary = \"Delete\", description = \"Method that deletes a Author\")\n    @RequestMapping(path = \"/{id}\", method = RequestMethod.DELETE)\n    public void delete(@PathVariable(\"id\") Long id) throws Exception {\n\n        this.authorService.delete(id);\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport com.ccsw.tutorial.author.model.AuthorDto;\nimport com.ccsw.tutorial.author.model.AuthorSearchDto;\nimport org.springframework.data.domain.Page;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\npublic interface AuthorService {\n\n    /**\n     * M\u00e9todo para recuperar un listado paginado de {@link Author}\n     *\n     * @param dto dto de b\u00fasqueda\n     * @return {@link Page} de {@link Author}\n     */\n    Page&lt;Author&gt; findPage(AuthorSearchDto dto);\n\n    /**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n    void save(Long id, AuthorDto dto);\n\n    /**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     */\n    void delete(Long id) throws Exception;\n\n}\n</code></pre> <p>Si te fijas, hemos trasladado toda la l\u00f3gica a llamadas al <code>AuthorService</code> que hemos inyectado, y para que no falle la compilaci\u00f3n hemos creado una interface con los m\u00e9todos necesarios.</p> <p>En la clase <code>AuthorController</code> es donde se hacen las conversiones de cara al cliente, pasaremos de un <code>Page&lt;Author&gt;</code> (modelo entidad) a un <code>Page&lt;AuthorDto&gt;</code> (modelo DTO) con la ayuda del beanMapper. Recuerda que al cliente no le deben llegar modelos entidades sino DTOs.</p> <p>Adem\u00e1s, el m\u00e9todo de carga <code>findPage</code> ya no es un m\u00e9todo de tipo <code>GET</code>, ahora es de tipo <code>POST</code> porque le tenemos que enviar los datos de la paginaci\u00f3n para que Spring JPA pueda hacer su magia.</p> <p>Ahora debemos implementar la siguiente capa.</p>"},{"location":"develop/paginated/springboot/#implementar-service","title":"Implementar Service","text":"<p>La siguiente capa que vamos a implementar es justamente la capa que contiene toda la l\u00f3gica de negocio, hace uso del <code>Repository</code> para acceder a los datos, y recibe llamadas generalmente de los <code>Controller</code>.</p> AuthorServiceImpl.javaAuthorRepository.java <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport com.ccsw.tutorial.author.model.AuthorDto;\nimport com.ccsw.tutorial.author.model.AuthorSearchDto;\nimport jakarta.transaction.Transactional;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.domain.Page;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Service\n@Transactional\npublic class AuthorServiceImpl implements AuthorService {\n\n    @Autowired\n    AuthorRepository authorRepository;\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Page&lt;Author&gt; findPage(AuthorSearchDto dto) {\n\n        return this.authorRepository.findAll(dto.getPageable().getPageable());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void save(Long id, AuthorDto data) {\n\n        Author author;\n\n        if (id == null) {\n            author = new Author();\n        } else {\n            author = this.authorRepository.findById(id).orElse(null);\n        }\n\n        BeanUtils.copyProperties(data, author, \"id\");\n\n        this.authorRepository.save(author);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void delete(Long id) throws Exception {\n\n        if(this.authorRepository.findById(id).orElse(null) == null){\n            throw new Exception(\"Not exists\");\n        }\n\n        this.authorRepository.deleteById(id);\n    }\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.repository.CrudRepository;\n\n/**\n * @author ccsw\n *\n */\npublic interface AuthorRepository extends CrudRepository&lt;Author, Long&gt; {\n\n}\n</code></pre> <p>De nuevo pasa lo mismo que con la capa anterior, aqu\u00ed delegamos muchas operaciones de consulta y guardado de datos en <code>AuthorRepository</code>. Hemos tenido que crearlo como interface para que no falle la compilaci\u00f3n. Recuerda que cuando creamos un <code>Repository</code> es de gran ayuda hacerlo extender de <code>CrudRepository&lt;T, ID&gt;</code> ya que tiene muchos m\u00e9todos implementados de base que nos pueden servir, como el <code>delete</code> o el <code>save</code>.</p> <p>F\u00edjate tambi\u00e9n que cuando queremos copiar m\u00e1s de un dato de una clase a otra, tenemos una utilidad llamada <code>BeanUtils</code> que nos permite realizar esa copia (siempre que las propiedades de ambas clases se llamen igual). Adem\u00e1s, en nuestro ejemplo hemos ignorado el 'id' para que no nos copie un null a la clase destino.</p>"},{"location":"develop/paginated/springboot/#implementar-repository","title":"Implementar Repository","text":"<p>Y llegamos a la \u00faltima capa, la que est\u00e1 m\u00e1s cerca de los datos finales. Tenemos la siguiente interface:</p> AuthorRepository.java <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.repository.CrudRepository;\n\n/**\n * @author ccsw\n *\n */\npublic interface AuthorRepository extends CrudRepository&lt;Author, Long&gt; {\n\n    /**\n     * M\u00e9todo para recuperar un listado paginado de {@link Author}\n     *\n     * @param pageable pageable\n     * @return {@link Page} de {@link Author}\n     */\n    Page&lt;Author&gt; findAll(Pageable pageable);\n\n}\n</code></pre> <p>Si te fijas, este <code>Repository</code> ya no est\u00e1 vac\u00edo como el anterior, no nos sirve con las operaciones b\u00e1sicas del <code>CrudRepository</code> en este caso hemos tenido que a\u00f1adir un m\u00e9todo nuevo al que pasandole un objeto de tipo <code>Pageable</code> nos devuelva una <code>Page</code>.</p> <p>Pues bien, resulta que la m\u00e1gina de Spring JPA en este caso har\u00e1 su trabajo y nosotros no necesitamos implementar ninguna query, Spring ya entiende que un <code>findAll</code> significa que debe recuperar todos los datos de la tabla <code>Author</code> (que es la tabla que tiene como <code>generico</code> en <code>CrudRepository</code>) y adem\u00e1s deben estar paginados ya que el m\u00e9todo devuelve un objeto tipo <code>Page</code>. Nos ahorra tener que generar una sql para buscar una p\u00e1gina concreta de datos y hacer un <code>count</code> de la tabla para obtener el total de resultados. Para ver otros ejemplos y m\u00e1s informaci\u00f3n, visita la p\u00e1gina de QueryMethods. Realmente se puede hacer much\u00edsimas cosas con solo escribir el nombre del m\u00e9todo, sin tener que pensar ni teclear ninguna sql.</p> <p>Con esto ya lo tendr\u00edamos todo. </p>"},{"location":"develop/paginated/springboot/#probar-las-operaciones","title":"Probar las operaciones","text":"<p>Si ahora ejecutamos los test jUnit, veremos que todos funcionan y est\u00e1n en verde. Hemos implementado todas nuestras pruebas y la aplicaci\u00f3n es correcta.</p> <p></p> <p>Aun as\u00ed, debemos realizar pruebas con el postman para ver los resultados que nos ofrece el back. Para ello, tienes que levantar la aplici\u00f3n y ejecutar las siguientes operaciones:</p> <p>** POST /author **  <pre><code>{\n    \"pageable\": {\n        \"pageSize\" : 4,\n        \"pageNumber\" : 0,\n        \"sort\" : [\n            {\n                \"property\": \"name\",\n                \"direction\": \"ASC\"\n            }\n        ]\n    }\n}\n</code></pre> Nos devuelve un listado paginado de <code>Autores</code>. F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no env\u00edas datos con formato <code>Pageable</code>, te dar\u00e1 un error. Tambi\u00e9n f\u00edjate que la respuesta es de tipo <code>Page</code>. Prueba a jugar con los datos de paginaci\u00f3n e incluso de ordenaci\u00f3n. No hemos programado ninguna SQL pero Spring hace su magia.</p> <p></p> <p>** PUT /author ** </p> <p>** PUT /author/{id} **  <pre><code>{\n    \"name\" : \"Nuevo autor\",\n    \"nationality\" : \"Nueva nacionalidad\"\n}\n</code></pre> Nos sirve para insertar <code>Autores</code> nuevas (si no tienen el id informado) o para actualizar <code>Autores</code> (si tienen el id informado en la URL).  F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no te dar\u00e1 un error.</p> <p> </p> <p>** DELETE /author/{id} **  nos sirve eliminar <code>Autores</code>. F\u00edjate que el dato del ID que se env\u00eda est\u00e1 en el path.</p> <p></p>"},{"location":"develop/paginated/vuejs/","title":"Listado paginado - VUE","text":"<p>Ahora nos ponemos con la pantalla de autores y vamos a realizar los cambios para poder realizar un paginado en la tabla de autores, adem\u00e1s de realizar los cambios oportunos para poder a\u00f1adir, editar y borrar autores.</p>"},{"location":"develop/paginated/vuejs/#acciones-posibles","title":"Acciones posibles","text":""},{"location":"develop/paginated/vuejs/#anadir-una-fila","title":"A\u00f1adir una fila","text":"<p>Para poder a\u00f1adir una fila, vamos a tener que a\u00f1adir al componente de dialog de adici\u00f3n un nuevo campo que ser\u00e1 la nacionalidad habiendo quitado los que hab\u00edamos copiado del cat\u00e1logo dejando finalmente solo dos: el nombre y la nacionalidad.</p> <p>Veremos el estado del c\u00f3digo en el apartado de borrado.</p>"},{"location":"develop/paginated/vuejs/#editar-una-fila","title":"Editar una fila","text":"<p>A la hora de editar una fila, modificaremos la columna de \u201cedad\u201d para reutilizarla con la nacionalidad, reutilizaremos la columna de \u201cnombre\u201d tal cual est\u00e1 y borraremos las dem\u00e1s exceptuando la de opciones que ah\u00ed pondremos el bot\u00f3n para el borrado.</p> <p>Veremos el estado del c\u00f3digo en el apartado de borrado.</p>"},{"location":"develop/paginated/vuejs/#borrar-una-fila","title":"Borrar una fila","text":"<p>Y, por \u00faltimo, haremos lo mismo que hicimos en la pantalla de categor\u00edas, que es a\u00f1adir la funci\u00f3n delete despu\u00e9s del dialog de confirmaci\u00f3n.</p> <p>El estado del c\u00f3digo ahora mismo quedar\u00eda as\u00ed: <pre><code>&lt;template&gt;\n  &lt;q-page padding&gt;\n    &lt;q-table\n      hide-bottom\n      :rows=\"authorsData\"\n      :columns=\"columns\"\n      v-model:pagination=\"pagination\"\n      title=\"Cat\u00e1logo\"\n      class=\"my-sticky-header-table\"\n      no-data-label=\"No hay resultados\"\n      row-key=\"id\"\n    &gt;\n      &lt;template v-slot:top&gt;\n        &lt;q-btn flat round color=\"primary\" icon=\"add\" @click=\"showAdd = true\" /&gt;\n      &lt;/template&gt;\n      &lt;template v-slot:body=\"props\"&gt;\n        &lt;q-tr :props=\"props\"&gt;\n          &lt;q-td key=\"id\" :props=\"props\"&gt;{{ props.row.id }}&lt;/q-td&gt;\n          &lt;q-td key=\"name\" :props=\"props\"&gt;\n            {{ props.row.name }}\n            &lt;q-popup-edit\n              v-model=\"props.row.name\"\n              title=\"Cambiar nombre\"\n              v-slot=\"scope\"\n            &gt;\n              &lt;q-input\n                v-model=\"scope.value\"\n                dense\n                autofocus\n                counter\n                @keyup.enter=\"editRow(props, scope, 'name')\"\n              &gt;\n                &lt;template v-slot:append&gt;\n                  &lt;q-icon name=\"edit\" /&gt;\n                &lt;/template&gt;\n              &lt;/q-input&gt;\n            &lt;/q-popup-edit&gt;\n          &lt;/q-td&gt;\n          &lt;q-td key=\"nationality\" :props=\"props\"&gt;\n            {{ props.row.nationality }}\n            &lt;q-popup-edit\n              v-model=\"props.row.nationality\"\n              title=\"Cambiar nacionalidad\"\n              v-slot=\"scope\"\n            &gt;\n              &lt;q-input\n                v-model=\"scope.value\"\n                dense\n                autofocus\n                counter\n                @keyup.enter=\"editRow(props, scope, 'nationality')\"\n              &gt;\n                &lt;template v-slot:append&gt;\n                  &lt;q-icon name=\"edit\" /&gt;\n                &lt;/template&gt;\n              &lt;/q-input&gt;\n            &lt;/q-popup-edit&gt;\n          &lt;/q-td&gt;\n          &lt;q-td key=\"options\" :props=\"props\"&gt;\n            &lt;q-btn\n              flat\n              round\n              color=\"negative\"\n              icon=\"delete\"\n              @click=\"showDeleteDialog(props.row)\"\n            /&gt;\n          &lt;/q-td&gt;\n        &lt;/q-tr&gt;\n      &lt;/template&gt;\n    &lt;/q-table&gt;\n    &lt;q-dialog v-model=\"showDelete\" persistent&gt;\n      &lt;q-card&gt;\n        &lt;q-card-section class=\"row items-center\"&gt;\n          &lt;q-icon\n            name=\"delete\"\n            size=\"sm\"\n            color=\"negative\"\n            @click=\"showDelete = true\"\n          /&gt;\n          &lt;span class=\"q-ml-sm\"&gt;\n            \u00bfEst\u00e1s seguro de que quieres borrar este elemento?\n          &lt;/span&gt;\n        &lt;/q-card-section&gt;\n\n        &lt;q-card-actions align=\"right\"&gt;\n          &lt;q-btn flat label=\"Cancelar\" color=\"primary\" v-close-popup /&gt;\n          &lt;q-btn\n            flat\n            label=\"Confirmar\"\n            color=\"primary\"\n            v-close-popup\n            @click=\"deleteAuthor\"\n          /&gt;\n        &lt;/q-card-actions&gt;\n      &lt;/q-card&gt;\n    &lt;/q-dialog&gt;\n    &lt;q-dialog v-model=\"showAdd\"&gt;\n      &lt;q-card style=\"width: 300px\" class=\"q-px-sm q-pb-md\"&gt;\n        &lt;q-card-section&gt;\n          &lt;div class=\"text-h6\"&gt;Nuevo autor&lt;/div&gt;\n        &lt;/q-card-section&gt;\n\n        &lt;q-item-label header&gt;Nombre&lt;/q-item-label&gt;\n        &lt;q-item dense&gt;\n          &lt;q-item-section avatar&gt;\n            &lt;q-icon name=\"badge\" /&gt;\n          &lt;/q-item-section&gt;\n          &lt;q-item-section&gt;\n            &lt;q-input dense v-model=\"authorToAdd.name\" autofocus /&gt;\n          &lt;/q-item-section&gt;\n        &lt;/q-item&gt;\n\n        &lt;q-item-label header&gt;Nacionalidad&lt;/q-item-label&gt;\n        &lt;q-item dense&gt;\n          &lt;q-item-section avatar&gt;\n            &lt;q-icon name=\"flag\" /&gt;\n          &lt;/q-item-section&gt;\n          &lt;q-item-section&gt;\n            &lt;q-input\n              dense\n              v-model=\"authorToAdd.nationality\"\n              autofocus\n              @keyup.enter=\"addAuthor\"\n            /&gt;\n          &lt;/q-item-section&gt;\n        &lt;/q-item&gt;\n\n        &lt;q-card-actions align=\"right\" class=\"text-primary\"&gt;\n          &lt;q-btn flat label=\"Cancelar\" v-close-popup /&gt;\n          &lt;q-btn flat label=\"A\u00f1adir autor\" v-close-popup @click=\"addAuthor\" /&gt;\n        &lt;/q-card-actions&gt;\n      &lt;/q-card&gt;\n    &lt;/q-dialog&gt;\n  &lt;/q-page&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=\"ts\"&gt;\nimport { ref } from 'vue';\nimport { useFetch, whenever } from '@vueuse/core';\n\nconst columns = [\n  { name: 'id', align: 'left', label: 'ID', field: 'id', sortable: true },\n  {\n    name: 'name',\n    align: 'left',\n    label: 'Nombre',\n    field: 'name',\n    sortable: true,\n  },\n  {\n    name: 'nationality',\n    align: 'left',\n    label: 'Nacionalidad',\n    field: 'nationality',\n    sortable: true,\n  },\n  { name: 'options', align: 'left', label: 'Options', field: 'options' },\n];\nconst pagination = {\n  page: 1,\n  rowsPerPage: 0,\n};\nconst newAuthor = {\n  name: '',\n  nationality: '',\n};\n\nconst authorsData = ref([]);\nconst showDelete = ref(false);\nconst showAdd = ref(false);\nconst selectedRow = ref({});\nconst authorToAdd = ref({ ...newAuthor });\n\nconst getAuthors = () =&gt; {\n  const { data } = useFetch('http://localhost:8080/author').get().json();\n  whenever(data, () =&gt; (authorsData.value = data.value));\n};\ngetAuthors();\n\nconst showDeleteDialog = (item: any) =&gt; {\n  selectedRow.value = item;\n  showDelete.value = true;\n};\n\nconst addAuthor = async () =&gt; {\n  await useFetch('http://localhost:8080/author', {\n    method: 'PUT',\n    redirect: 'manual',\n    headers: {\n      accept: '*/*',\n      origin: window.origin,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(authorToAdd.value),\n  })\n    .put()\n    .json();\n\n  getAuthors();\n  authorToAdd.value = newAuthor;\n  showAdd.value = false;\n};\n\nconst editRow = (props: any, scope: any, field: any) =&gt; {\n  const row = {\n    name: props.row.name,\n    nationality: props.row.nationality,\n  };\n  row[field] = scope.value;\n  scope.set();\n  editAuthor(props.row.id, row);\n};\n\nconst editAuthor = async (id: string, reqBody: any) =&gt; {\n  await useFetch(`http://localhost:8080/author/${id}`, {\n    method: 'PUT',\n    redirect: 'manual',\n    headers: {\n      accept: '*/*',\n      origin: window.origin,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(reqBody),\n  })\n    .put()\n    .json();\n\n  getAuthors();\n};\n\nconst deleteAuthor = async () =&gt; {\n  await useFetch(`http://localhost:8080/author/${selectedRow.value.id}`, {\n    method: 'DELETE',\n    redirect: 'manual',\n    headers: {\n      accept: '*/*',\n      origin: window.origin,\n      'Content-Type': 'application/json',\n    },\n  })\n    .delete()\n    .json();\n\n  getAuthors();\n};\n&lt;/script&gt;\n</code></pre></p>"},{"location":"develop/paginated/vuejs/#paginado","title":"Paginado","text":"<p>Lo primero que tenemos que hacer es usar las nuevas caracter\u00edsticas de nuestra tabla para poder a\u00f1adir datos y as\u00ed hacer funcionar el paginado correctamente.</p> <p>Lo primero que vamos a hacer es cambiar el objeto de paginaci\u00f3n para que tenga lo siguiente:</p> <pre><code>const pagination = ref({\n  page: 0,\n  rowsPerPage: 5,\n  rowsNumber: 10,\n});\n</code></pre> <p>Y debido a que la tabla y el back requieren de formatos diferentes para la paginaci\u00f3n, vamos a tener que realizar una funci\u00f3n que formatee el objeto para enviarlo al back. Esta funci\u00f3n ser\u00e1, m\u00e1s o menos, as\u00ed:</p> <pre><code>const formatPageableBody = (props: any) =&gt; {\n  return {\n    pageable: {\n      pageSize:\n        props.pagination.rowsPerPage !== 0\n          ? props.pagination.rowsPerPage\n          : props.pagination.rowsNumber,\n      pageNumber: props.pagination.page - 1,\n      sort: [\n        {\n          property: 'name',\n          direction: 'ASC',\n        },\n      ],\n    },\n  };\n};\n</code></pre> <p>Tal y como podemos ver, se realiza una condici\u00f3n en el formato ya que, si el usuario selecciona que quiere ver todas las filas de golpe el valor de dicha variable ser\u00e1 0 y el back necesitar\u00e1 el valor del n\u00famero m\u00e1ximo de filas para que nosotros recibamos todas.</p> <p>Y por \u00faltimo vamos a hacer que la funci\u00f3n de recibir los datos reciba por par\u00e1metro el paginado (siempre habr\u00e1 uno por defecto) y que cuando todo haya ido bien se actualice la paginaci\u00f3n local.</p> <pre><code>const updateLocalPagination = (props: any) =&gt; {\n  pagination.value.page = props.pagination.page;\n  pagination.value.rowsPerPage = props.pagination.rowsPerPage;\n};\n\nconst getAuthors = (props: any = { pagination: pagination.value }) =&gt; {\n  const { data } = useFetch('http://localhost:8080/author', {\n    method: 'POST',\n    redirect: 'manual',\n    headers: {\n      accept: '*/*',\n      origin: window.origin,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(formatPageableBody(props)),\n  })\n    .post()\n    .json();\n  whenever(data, () =&gt; {\n    updateLocalPagination(props);\n    authorsData.value = data.value.content;\n    pagination.value.rowsNumber = data.value.totalElements;\n  });\n};\n</code></pre> <p>Importante</p> <p>En la primera de las peticiones (y si quieres en las dem\u00e1s tambi\u00e9n) se ha de recoger el atributo de filas totales y setearlo en el objeto de paginaci\u00f3n con el nombre de <code>rowsNumber</code>. Esto se realiza en la zona subrayada anterior.</p> <p>Y por \u00faltimo, hacemos que se realicen peticiones siempre que el usuario cambie par\u00e1metros de la tabla, como el cambio de p\u00e1gina o el cambio de filas mostradas. Esto se realiza a\u00f1adiendo a la creaci\u00f3n de la tabla la siguiente l\u00ednea:</p> <pre><code>&lt;q-table\n      :rows=\"authorsData\"\n      :columns=\"columns\"\n      v-model:pagination=\"pagination\"\n      title=\"Autores\"\n      class=\"my-sticky-header-table\"\n      no-data-label=\"No hay resultados\"\n      row-key=\"id\"\n      @request=\"getAuthors\"\n    &gt;\n</code></pre> <p>Con estos cambios, la pantalla deber\u00eda funcionar correctamente con el paginado funcionando y todas sus funciones b\u00e1sicas.</p>"},{"location":"install/angular/","title":"Entorno de desarrollo - Angular","text":""},{"location":"install/angular/#instalacion-de-herramientas","title":"Instalaci\u00f3n de herramientas","text":"<p>Las herramientas b\u00e1sicas que vamos a utilizar para esta tecnolog\u00eda son:</p> <ul> <li>Visual Studio Code</li> <li>Scoop.sh</li> <li>Nodejs</li> <li>Angular CLI</li> </ul>"},{"location":"install/angular/#visual-studio-code","title":"Visual Studio Code","text":"<p>Lo primero de todo es instalar el IDE para el desarrollo front.</p> <p>Te recomiendo utilizar Visual Studio Code, en un IDE que a nosotros nos gusta mucho y tiene muchos plugins configurables. Puedes entrar en su p\u00e1gina y descargarte la versi\u00f3n estable.</p> <p>Si no tuvieras permisos para instalar la herramienta por restricciones en el port\u00e1til existe una alternativa para poder instalarlo, a trav\u00e9s del \"Portal de Empresa\" que tenemos instalado en nuestro port\u00e1til. Para ello teclea en el buscador de Windows (o en el men\u00fa de inicio) el texto \"Portal de empresa\". Deber\u00eda aparecerte una app instalada en tu ordenador, tan solo tendr\u00e1s que hacer click en ella:</p> <p></p> <p>Una vez dentro del portal de empresa, ver\u00e1s una aplicaci\u00f3n que se llama \"Pre-Approved Catalogue\". Deber\u00e1s instalarla, de hecho cada vez que quieras acceder a ella, tendr\u00e1s que instalarla para que se descargue el nuevo cat\u00e1logo.</p> <p></p> <p>Despu\u00e9s de unos minutos de instalaci\u00f3n, entrar\u00e1s en un listado de las aplicaciones que est\u00e1n pre-aprobadas por la empresa. Solo tendr\u00e1s que buscar \"Visual Studio Code\" e instalarla.</p> <p></p> <p>Pasados unos minutos, ya tendr\u00e1s instalado el IDE en tu port\u00e1til.</p>"},{"location":"install/angular/#scoopsh","title":"Scoop.sh","text":"<p>Muchas de las herramientas que necesitar\u00e1s a lo largo de tu estancia en los proyectos, no podr\u00e1s instalarlas por temas de permisos de seguridad en nuestros port\u00e1tiles. Una forma de evitar estos permisos de seguridad y poder instalar herramientas (sobre todo a nivel de consola), es utilizando a Scoop.sh.</p> <p>Para instalar scoop.sh tan solo necesitas abrir un termina de PowerShell (OJO que es PowerShell y no una consola de msdos) y ejecutar los siguientes comandos:</p> <pre><code>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\nInvoke-RestMethod -Uri https://get.scoop.sh | Invoke-Expression\n</code></pre> <p>Esto nos instalar\u00e1 scoop.sh en nuestros port\u00e1tiles. Adem\u00e1s de la instalaci\u00f3n, y debido a las restricciones de seguridad que tenemos, necesitaremos activar el lessmsi para que las aplicaciones que necesitemos instalar no intenten ejecutar los .exe de instalaci\u00f3n, sino que descompriman el zip. Para ello deberemos ejecutar el comando:</p> <pre><code>scoop config use_lessmsi true\n</code></pre> <p>A partir de este punto, ya tenemos listo el port\u00e1til para instalar herramientas y aplicaciones.</p>"},{"location":"install/angular/#nodejs","title":"Nodejs","text":"<p>El siguiente paso ser\u00e1 instalar el motor de Nodejs. Para esto vamos a usar scoop.sh ya que lo tenemos instalado, y vamos a pedirle que nos instal\u00e9 el motor de Nodejs. Abriremos una consola de msdos y ejecutaremos el comando:</p> <pre><code>scoop install main/nodejs\n</code></pre> <p>Con esto, scoop ya nos instalar\u00e1 todo lo necesario.</p>"},{"location":"install/angular/#angular-cli","title":"Angular CLI","text":"<p>El siguiente pas\u00f3 ser\u00e1 instalar una capa de gesti\u00f3n por encima de Nodejs que nos ayudar\u00e1 en concreto con la funcionalidad de Angular. En concreto instalaremos el CLI de Angular para la versi\u00f3n 16. Para poder instalarlo, tan solo hay que abrir una consola de msdos y ejecutar el comando y Nodejs ya har\u00e1 el resto:</p> <pre><code>npm install -g @angular/cli@16\n</code></pre> <p>Y con esto ya tendremos todo instalado, listo para empezar a crear los proyectos.</p>"},{"location":"install/angular/#creacion-de-proyecto","title":"Creaci\u00f3n de proyecto","text":"<p>La mayor\u00eda de los proyectos con Angular en los que trabajamos normalmente, suelen ser proyectos web usando las librer\u00edas mas comunes de angular, como Angular Material.</p> <p>Crear un proyecto de Angular es muy sencillo si tienes instalado el CLI de Angular. Lo primero abrir una consola de msdos y posicionarte en el directorio raiz donde quieres crear tu proyecto Angular, y ejecutamos lo siguiente:</p> <pre><code>ng new tutorial --strict=false\n</code></pre> <p>El propio CLI nos ir\u00e1 realizando una serie de preguntas.</p> <p>Would you like to add Angular routing? (y/N)</p> <p><code>Preferiblemente: y</code></p> <p>Which stylesheet format would you like to use?</p> <p><code>Preferiblemente: SCSS</code></p> <p>En el caso del tutorial como vamos a tener dos proyectos para nuestra aplicaci\u00f3n (front y back), para poder seguir correctamente las explicaciones, voy a renombrar la carpeta para poder diferenciarla del otro proyecto. A partir de ahora se llamar\u00e1 <code>client</code>.</p> <p>Info</p> <p>Si durante el desarrollo del proyecto necesitas a\u00f1adir nuevos m\u00f3dulos al proyecto Angular, ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor de dependencias de Nodejs, directamente en consola ejecuta el comando <code>npm update</code> y descargar\u00e1 e instalar\u00e1 las nuevas dependencias.</p>"},{"location":"install/angular/#arrancar-el-proyecto","title":"Arrancar el proyecto","text":"<p>Para arrancar el proyecto, tan solo necesitamos ejecutar en consola el siguiente comando siempre dentro del directorio creado por Angular CLI:</p> <pre><code>ng serve\n</code></pre> <p>Angular compilar\u00e1 el c\u00f3digo fuente, levantar\u00e1 un servidor local al que podremos acceder por defecto mediante la URL: http://localhost:4200/</p> <p>Y ya podemos empezar a trabajar con Angular.</p> <p>Info</p> <p>Cuando se trata de un proyecto nuevo recien descargado de un repositorio, recuerda que ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor de dependencias de Nodejs, directamente en consola ejecuta el comando <code>npm update</code> y descargar\u00e1 e instalar\u00e1 las nuevas dependencias.</p> <p>Comandos de Angular CLI</p> <p>Si necesitas m\u00e1s informaci\u00f3n sobre los comandos que ofrece Angular CLI para poder crear aplicaciones, componentes, servicios, etc. los tienes disponibles en: https://angular.io/cli#command-overview</p>"},{"location":"install/nodejs/","title":"Entorno de desarrollo - Nodejs","text":""},{"location":"install/nodejs/#instalacion-de-herramientas","title":"Instalaci\u00f3n de herramientas","text":"<p>Las herramientas b\u00e1sicas que vamos a utilizar para esta tecnolog\u00eda son:</p> <ul> <li>Visual Studio Code</li> <li>Scoop.sh</li> <li>Nodejs</li> <li>MongoDB Atlas</li> <li>Postman</li> </ul>"},{"location":"install/nodejs/#visual-studio-code","title":"Visual Studio Code","text":"<p>Lo primero de todo es instalar el IDE para el desarrollo en node si no lo has hecho previamente.</p> <p>Te recomiendo utilizar Visual Studio Code, en un IDE que a nosotros nos gusta mucho y tiene muchos plugins configurables. Puedes entrar en su p\u00e1gina y descargarte la versi\u00f3n estable.</p>"},{"location":"install/nodejs/#scoopsh","title":"Scoop.sh","text":"<p>Muchas de las herramientas que necesitar\u00e1s a lo largo de tu estancia en los proyectos, no podr\u00e1s instalarlas por temas de permisos de seguridad en nuestros port\u00e1tiles. Una forma de evitar estos permisos de seguridad y poder instalar herramientas (sobre todo a nivel de consola), es utilizando a Scoop.sh.</p> <p>Para instalar scoop.sh tan solo necesitas abrir un termina de PowerShell (OJO que es PowerShell y no una consola de msdos) y ejecutar los siguientes comandos:</p> <pre><code>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\nInvoke-RestMethod -Uri https://get.scoop.sh | Invoke-Expression\n</code></pre> <p>Esto nos instalar\u00e1 scoop.sh en nuestros port\u00e1tiles. Adem\u00e1s de la instalaci\u00f3n, y debido a las restricciones de seguridad que tenemos, necesitaremos activar el lessmsi para que las aplicaciones que necesitemos instalar no intenten ejecutar los .exe de instalaci\u00f3n, sino que descompriman el zip. Para ello deberemos ejecutar el comando:</p> <pre><code>scoop config use_lessmsi true\n</code></pre> <p>A partir de este punto, ya tenemos listo el port\u00e1til para instalar herramientas y aplicaciones.</p>"},{"location":"install/nodejs/#nodejs","title":"Nodejs","text":"<p>El siguiente paso ser\u00e1 instalar el motor de Nodejs. Para esto vamos a usar scoop.sh ya que lo tenemos instalado, y vamos a pedirle que nos instal\u00e9 el motor de Nodejs. Abriremos una consola de msdos y ejecutaremos el comando:</p> <pre><code>scoop install main/nodejs\n</code></pre> <p>Con esto, scoop ya nos instalar\u00e1 todo lo necesario.</p>"},{"location":"install/nodejs/#mongodb-atlas","title":"MongoDB Atlas","text":"<p>Tambi\u00e9n necesitaremos crear una cuenta de MongoDB Atlas para crear nuestra base de datos MongoDB en la nube.</p> <p>Accede a la URL, registrate gr\u00e1tis con cualquier cuenta de correo y elige el tipo de cuenta gratuita \ud83d\ude0a:</p> <p></p> <p>Configura el cluster a tu gusto (selecciona la opci\u00f3n gratuita en el cloud que m\u00e1s te guste) y ya tendr\u00edas una BBDD en cloud para hacer pruebas. Lo primero que se muestra es el dashboard que se ver\u00e1 algo similar a lo siguiente:</p> <p></p> <p>A continuaci\u00f3n, pulsamos en la opci\u00f3n <code>Database</code> del men\u00fa y, sobre el <code>Cluster0</code>, pulsamos tambi\u00e9n el bot\u00f3n <code>Connect</code>. Se nos abrir\u00e1 el siguiente pop-up donde tendremos que elegir la opci\u00f3n <code>Connect your application</code>:</p> <p></p> <p>En el siguiente paso es donde se nos muestra la url que tendremos que utilizar en nuestra aplicaci\u00f3n. La copiamos y guardamos para m\u00e1s tarde: </p> <p></p> <p>Pulsamos <code>Close</code> y la BBDD ya estar\u00eda creada.</p> <p>Nota: Al crear la base de datos te aprecer\u00e1 un aviso para introducir tu IP en la whitelist, aseg\u00farate no estar en la VPN cuando lo hagas, de lo contrario no tendr\u00e1s conexi\u00f3n posteriormente.</p>"},{"location":"install/nodejs/#herramientas-para-pruebas","title":"Herramientas para pruebas","text":"<p>Para poder probar las operaciones de negocio que vamos a crear, lo mejor es utilizar una herramienta que permita realizar llamadas a API Rest. Para ello te propongo utilizar Postman, en su versi\u00f3n web o en su versi\u00f3n desktop, cualquiera de las dos sirve.</p> <p>Con esta herramienta se puede generar peticiones GET, POST, PUT, DELETE contra el servidor y pasarle par\u00e1metros de forma muy sencilla y visual. Lo usaremos durante el tutorial.</p>"},{"location":"install/nodejs/#creacion-de-proyecto","title":"Creaci\u00f3n de proyecto","text":"<p>Para la creaci\u00f3n de nuestro proyecto Node nos crearemos una carpeta con el nombre que deseemos y accederemos a ella con la consola de comandos de windows. Una vez dentro ejecutaremos el siguiente comando para inicializar nuestro proyecto con npm:</p> <pre><code>npm init\n</code></pre> <p>Cuando ejecutemos este comando nos pedir\u00e1 los valores para distintos par\u00e1metros de nuestro proyecto. Aconsejo solo cambiar el nombre y el resto dejarlo por defecto pulsando enter para cada valor. Una vez que hayamos terminado se nos habr\u00e1 generado un fichero <code>package.json</code> que contendr\u00e1 informaci\u00f3n b\u00e1sica de nuestro proyecto. Dentro de este fichero tendremos que a\u00f1adir un nuevo par\u00e1metro <code>type</code> con el valor <code>module</code>, esto nos permitir\u00e1 importar nuestros m\u00f3dulos con el est\u00e1ndar ES:</p> <pre><code>{\n  \"name\": \"tutorialNode\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"type\": \"module\"\n}\n</code></pre>"},{"location":"install/nodejs/#instalar-dependencias","title":"Instalar dependencias","text":"<p>En ese fichero aparte de la informaci\u00f3n de nuestro proyecto tambi\u00e9n tendremos que a\u00f1adir las dependencias que usara nuestra aplicaci\u00f3n. </p> <p>Para a\u00f1adir las dependencias, desde la consola de comandos y situados en la misma carpeta donde se haya creado el fichero <code>package.json</code> vamos a teclear los siguientes comandos:</p> <pre><code>npm i express\nnpm i express-validator\nnpm i dotenv\nnpm i mongoose\nnpm i mongoose-paginate-v2\nnpm i normalize-mongoose\nnpm i cors\nnpm i nodemon --save-dev\n</code></pre> <p>Tambi\u00e9n podr\u00edamos haber instalado todas a la vez en dos l\u00edneas: </p> <pre><code>npm i express express-validator dotenv  mongoose mongoose-paginate-v2 normalize-mongoose cors\nnpm i nodemon --save-dev\n</code></pre> <p>Las dependencias que acabamos de instalar son las siguientes: </p> <ul> <li>Express es un framework de Node que nos facilitara mucho la tarea a la hora de crear nuestra aplicaci\u00f3n.</li> <li>Dotenv es una librer\u00eda para usar variables de entorno.</li> <li>Mongoose es una librer\u00eda ODM que nos ayudara a los accesos a BBDD.</li> <li>Nodemon es una herramienta que nos ayuda reiniciando nuestro servidor cuando detecta un cambio en alguno de nuestros ficheros y as\u00ed no tener que hacerlo manualmente.</li> <li>Cors es una herramienta que nos ayuda a configurar el CORS de nuestra app para que posteriormente podemos conectarlo al front.</li> </ul> <p>Ahora podemos fijarnos en nuestro fichero <code>package.json</code> donde se habr\u00e1n a\u00f1adido dos nuevos par\u00e1metros: <code>dependencies</code> y <code>devDependencies</code>. La diferencia est\u00e1 en que las <code>devDependencies</code> solo se utilizar en la fase de desarrollo de nuestro proyecto y las <code>dependencies</code> se utilizar\u00e1n en todo momento.</p>"},{"location":"install/nodejs/#configurar-la-bbdd","title":"Configurar la BBDD","text":"<p>A partir de aqu\u00ed ya podemos abrir Visual Studio Code, el IDE recomendado, y abrir la carpeta del proyecto para poder configurarlo y programarlo. Lo primero ser\u00e1 configurar el acceso con la BBDD.</p> <p>Para ello vamos a crear en la ra\u00edz de nuestro proyecto una carpeta <code>config</code> dentro de la cual crearemos un archivo llamado <code>db.js</code>. Este archivo exportar\u00e1 una funci\u00f3n que recibe una url de nuestra BBDD y la conectar\u00e1 con mongoose. El contenido de este archivo debe ser el siguiente:</p> db.js <pre><code>import mongoose from 'mongoose';\n\nconst connectDB = async (url) =&gt; {\n\n    try {\n        await mongoose.connect(url);\n        console.log('BBDD connected');\n    } catch (error) {\n        throw new Error('Error initiating BBDD:' + error);\n    }\n}\n\nexport default connectDB;\n</code></pre> <p>Ahora vamos a crear en la ra\u00edz de nuestro proyecto un archivo con el nombre <code>.env</code>. Este archivo tendr\u00e1 las variables de entorno de nuestro proyecto. Es aqu\u00ed donde pondremos la url que obtuvimos al crear nuestra BBDD. As\u00ed pues, crearemos una nueva variable y pegaremos la URL. Tambi\u00e9n vamos a configurar el puerto del servidor.</p> .env <pre><code>MONGODB_URL='mongodb+srv://&lt;user&gt;:&lt;pass&gt;@&lt;url&gt;.mongodb.net/?retryWrites=true&amp;w=majority'\nPORT='8080'\n</code></pre>"},{"location":"install/nodejs/#arrancar-el-proyecto","title":"Arrancar el proyecto","text":"<p>Con toda esa configuraci\u00f3n, ahora ya podemos crear nuestra p\u00e1gina inicial. Dentro del fichero <code>package.json</code>, en concreto en el contenido de <code>main</code> vemos que nos indica el valor de <code>index.js</code>. Este ser\u00e1 el punto de entrada a nuestra aplicaci\u00f3n, pero este fichero todav\u00eda no existe, as\u00ed que lo crearemos con el siguiente contenido:</p> index.js <pre><code>import express from 'express';\nimport cors from 'cors';\nimport connectDB from './config/db.js';\nimport { config } from 'dotenv';\n\nconfig();\nconnectDB(process.env.MONGODB_URL);\nconst app = express();\n\napp.use(cors({\n    origin: '*'\n}));\n\napp.listen(process.env.PORT, () =&gt; {\n    console.log(`Server running on port ${process.env.PORT}`);\n});\n</code></pre> <p>El funcionamiento de este c\u00f3digo, resumiendo mucho, es el siguiente. Configurar la base de datos, configurar el CORS para que posteriormente podamos realizar peticiones desde el front y crea un servidor con express en el puerto <code>8080</code>.</p> <p>Pero antes, para poder ejecutar nuestro servidor debemos modificar el fichero <code>package.json</code>, y a\u00f1adir un script de arranque. A\u00f1adiremos la siguiente l\u00ednea:</p> <pre><code>\"dev\": \"nodemon ./index.js\"\n</code></pre> <p>Y ahora s\u00ed, desde la consola de comando ya podemos ejecutar el siguiente comando:</p> <pre><code>npm run dev\n</code></pre> <p>y ya podremos ver en la consola como la aplicaci\u00f3n ha arrancado correctamente con el mensaje que le hemos a\u00f1adido.</p>"},{"location":"install/react/","title":"Entorno de desarrollo - React","text":""},{"location":"install/react/#instalacion-de-herramientas","title":"Instalaci\u00f3n de herramientas","text":"<p>Las herramientas b\u00e1sicas que vamos a utilizar para esta tecnolog\u00eda son:</p> <ul> <li>Visual Studio Code</li> <li>Scoop.sh</li> <li>Nodejs</li> </ul>"},{"location":"install/react/#visual-studio-code","title":"Visual Studio Code","text":"<p>Lo primero de todo es instalar el IDE para el desarrollo front.</p> <p>Te recomiendo utilizar Visual Studio Code, en un IDE que a nosotros nos gusta mucho y tiene muchos plugins configurables. Puedes entrar en su p\u00e1gina y descargarte la versi\u00f3n estable.</p>"},{"location":"install/react/#scoopsh","title":"Scoop.sh","text":"<p>Muchas de las herramientas que necesitar\u00e1s a lo largo de tu estancia en los proyectos, no podr\u00e1s instalarlas por temas de permisos de seguridad en nuestros port\u00e1tiles. Una forma de evitar estos permisos de seguridad y poder instalar herramientas (sobre todo a nivel de consola), es utilizando a Scoop.sh.</p> <p>Para instalar scoop.sh tan solo necesitas abrir un termina de PowerShell (OJO que es PowerShell y no una consola de msdos) y ejecutar los siguientes comandos:</p> <pre><code>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\nInvoke-RestMethod -Uri https://get.scoop.sh | Invoke-Expression\n</code></pre> <p>Esto nos instalar\u00e1 scoop.sh en nuestros port\u00e1tiles. Adem\u00e1s de la instalaci\u00f3n, y debido a las restricciones de seguridad que tenemos, necesitaremos activar el lessmsi para que las aplicaciones que necesitemos instalar no intenten ejecutar los .exe de instalaci\u00f3n, sino que descompriman el zip. Para ello deberemos ejecutar el comando:</p> <pre><code>scoop config use_lessmsi true\n</code></pre> <p>A partir de este punto, ya tenemos listo el port\u00e1til para instalar herramientas y aplicaciones.</p>"},{"location":"install/react/#nodejs","title":"Nodejs","text":"<p>El siguiente paso ser\u00e1 instalar el motor de Nodejs. Para esto vamos a usar scoop.sh ya que lo tenemos instalado, y vamos a pedirle que nos instal\u00e9 el motor de Nodejs. Abriremos una consola de msdos y ejecutaremos el comando:</p> <pre><code>scoop install main/nodejs\n</code></pre> <p>Con esto, scoop ya nos instalar\u00e1 todo lo necesario.</p>"},{"location":"install/react/#creacion-de-proyecto","title":"Creaci\u00f3n de proyecto","text":"<p>Hasta ahora para la generaci\u00f3n de un proyecto React se ha utilizado la herramienta \u201ccreate-react-app\u201d pero \u00faltimamente se usa m\u00e1s vite debido a su velocidad para desarrollar y su optimizaci\u00f3n en tiempos de construcci\u00f3n. En realidad, para realizar nuestro proyecto da igual una herramienta u otra m\u00e1s all\u00e1 de un poco de configuraci\u00f3n, pero para este proyecto elegiremos vite por su velocidad.</p> <p>Para generar nuestro proyecto react con Vite abrimos una consola de Windows y escribimos lo siguiente en la carpeta donde queramos localizar nuestro proyecto: </p> <pre><code>npm create vite@latest\n</code></pre> <p>Con esto se nos lanzara un wizard para la creaci\u00f3n de nuestro proyecto donde elegiremos el nombre del proyecto (en mi caso ludoteca-react), el framework (react evidentemente) y en la variante elegiremos typescript. Tras estos pasos instalaremos las dependencias base de nuestro proyecto. Primero accedemos a la ra\u00edz y despu\u00e9s ejecutaremos el comando install de npm. </p> <pre><code>cd ludoteca-react\n</code></pre> <pre><code>npm install\n</code></pre> <p>\u00f3 </p> <pre><code>npm i\n</code></pre>"},{"location":"install/react/#arrancar-el-proyecto","title":"Arrancar el proyecto","text":"<p>Para arrancar el proyecto, tan solo necesitamos ejecutar en consola el siguiente comando siempre dentro del directorio creado por Vite:</p> <pre><code>npm run dev\n</code></pre> <p>Vite compilar\u00e1 el c\u00f3digo fuente, levantar\u00e1 un servidor local al que podremos acceder por defecto mediante la URL: http://localhost:5173/</p> <p>Y ya podemos empezar a trabajar en nuestro proyecto React.</p> <p>Info</p> <p>Cuando se trata de un proyecto nuevo recien descargado de un repositorio, recuerda que ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor de dependencias de Nodejs, directamente en consola ejecuta el comando <code>npm update</code> y descargar\u00e1 e instalar\u00e1 las nuevas dependencias.</p>"},{"location":"install/springboot/","title":"Entorno de desarrollo - Spring Boot","text":""},{"location":"install/springboot/#instalacion-de-herramientas","title":"Instalaci\u00f3n de herramientas","text":"<p>Las herramientas b\u00e1sicas que vamos a utilizar para esta tecnolog\u00eda son:</p> <ul> <li>IntelliJ o Eclipse IDE (el que m\u00e1s te guste)</li> <li>Java 17 o superior</li> <li>Postman</li> </ul>"},{"location":"install/springboot/#instalacion-de-intellij-idea","title":"Instalaci\u00f3n de IntelliJ IDEA","text":"<p>Nuestra preferencia es utilizar IntelliJ ya que es un IDE m\u00e1s moderno que Eclise IDE, pero cualquiera de los dos es v\u00e1lido para hacer el tutorial. Debido a las restricciones que tenemos en nuestros port\u00e1tiles no ser\u00e1 posible descargarnos una versi\u00f3n de la web e instalarlo, aunque existe otra forma de hacerlo.</p> <p>Deberemos acceder al \"Portal de Empresa\" que tenemos instalado en nuestro port\u00e1til. Teclear en el buscador de Windows (o en el men\u00fa de inicio) el texto \"Portal de empresa\". Deber\u00eda aparecerte una app instalada en tu ordenador y hacer click en ella:</p> <p></p> <p>Una vez dentro del portal de empresa, ver\u00e1s una aplicaci\u00f3n que se llama \"Pre-Approved Catalogue\". Deber\u00e1s instalarla, de hecho cada vez que quieras acceder a ella, tendr\u00e1s que instalarla para que se descargue el nuevo cat\u00e1logo.</p> <p></p> <p>Despu\u00e9s de unos minutos de instalaci\u00f3n, entrar\u00e1s en un listado de las aplicaciones que est\u00e1n pre-aprobadas por la empresa. Solo tendr\u00e1s que buscar \"IntelliJ IDEA Community Edition\" e instalarla.</p> <p></p> <p>Pasados unos minutos, ya tendr\u00e1s instalado el IDE en tu port\u00e1til.</p>"},{"location":"install/springboot/#configuracion-del-ide","title":"Configuraci\u00f3n del IDE","text":"<p>Como complemento al IntelliJ, con el fin de crear c\u00f3digo homog\u00e9neo y mantenible, vamos a configurar el formateador de c\u00f3digo autom\u00e1tico.</p> <p>Para ello de nuevo abrimos el men\u00fa <code>Customize -&gt; All Settings</code> o el men\u00fa <code>Settings</code> si estamos en un proyecto, nos vamos a la secci\u00f3n <code>Editor -&gt; Code Style -&gt; Java</code> y aparecer\u00e1 una pantalla similar a esta:</p> <p></p> <p>En el bot\u00f3n de <code>opciones</code>, nos permitir\u00e1 \"Importar esquema\" desde Intellij IDEA:</p> <p></p> <p>Nos descargamos el fichero de Formmatter Profile IntelliJ y lo importamos en IntelliJ.</p> <p>Una vez cofigurado el nuevo formateador debemos activar que se aplique en el guardado. Para ello volvemos acceder a las preferencias de IntelliJ y nos dirigimos a la sub secci\u00f3n <code>Tools -&gt; Actions os Save</code>. Es posible que esta secci\u00f3n solo est\u00e9 disponible cuando creemos o importemos un proyecto, as\u00ed que volveremos m\u00e1s adelante aqu\u00ed.</p> <p></p> <p>Hay que activar la opci\u00f3n <code>Reformat code</code> y <code>Optimize imports</code>.</p>"},{"location":"install/springboot/#obsoleto-instalacion-de-eclipse-ide","title":"(Obsoleto) Instalaci\u00f3n de Eclipse IDE","text":"<p>Si no te gusta IntelliJ, puedes utilizar Eclipse IDE y la m\u00e1quina virtual de java necesaria para ejecutar el c\u00f3digo. Recomendamos Java 17 o superior, que es la versi\u00f3n con la que est\u00e1 desarrollado y probado el tutorial. </p> <p>Para instalar el IDE deber\u00e1s acceder a la web de Eclipse IDE y descargarte la \u00faltima versi\u00f3n del instalador. Una vez lo ejecutes te pedir\u00e1 el tipo de instalaci\u00f3n que deseas instalar. Por lo general con la de \"Eclipse IDE for Java Developers\" es suficiente. Con esta versi\u00f3n ya tiene integrado los plugins de Maven y Git.</p> <p>Pero recuerda que tendr\u00e1s que instalar una versi\u00f3n acorde de Java ya que Eclipse viene con una versi\u00f3n vieja.</p>"},{"location":"install/springboot/#instalacion-de-java","title":"Instalaci\u00f3n de Java","text":"<p>Si has instalado IntelliJ, te puedes saltar este punto.</p> <p>Si has instalado Eclise IDE, debes asegurarte que est\u00e1 usando por defecto la versi\u00f3n de Java 17 o superior y para ello deber\u00e1s instalarla. Desc\u00e1rgala del siguiente enlace. Es posible que te pida un registro de correo, utiliza el email que quieras (corporativo o personal). Revisa bien el enlace para buscar y descargar la versi\u00f3n 17 para Windows.</p> <p>OJO no instales el ejecutable .exe ya que no funcionar\u00e1 debido a nuestras medidas de seguridad. Debes descargarte el .zip y descomprimirlo en alg\u00fan directorio local.</p> <p></p> <p>Ya solo queda a\u00f1adir Java al Eclipse. Para ello, abre el men\u00fa <code>Window -&gt; Preferences</code>:</p> <p></p> <p>y dentro de la secci\u00f3n <code>Java - Installed JREs</code> a\u00f1ade la versi\u00f3n que acabas de descargar, siempre pulsando el bot\u00f3n <code>Add...</code> y buscando el directorio <code>home</code> de la instalaci\u00f3n de Java. Adem\u00e1s, la debes marcar como <code>default</code>.</p> <p></p>"},{"location":"install/springboot/#configuracion-de-eclipse","title":"Configuraci\u00f3n de Eclipse","text":"<p>Como complemento al Eclipse, con el fin de crear c\u00f3digo homog\u00e9neo y mantenible, vamos a configurar el formateador de c\u00f3digo autom\u00e1tico.</p> <p>Para ello de nuevo abrimos el men\u00fa <code>Window -&gt; Preferences</code>, nos vamos a la secci\u00f3n <code>Formatter</code> de Java:</p> <p></p> <p>Aqu\u00ed crearemos un nuevo perfil heredando la configuraci\u00f3n por defecto.</p> <p></p> <p>En el nuevo perfil configuramos que se use espacios en vez de tabuladores con sangrado de 4 caracteres.</p> <p></p> <p>Una vez cofigurado el nuevo formateador debemos activar que se aplique en el guardado. Para ello volvemos acceder a las preferencias de Eclipse y nos dirigimos a la sub secci\u00f3n <code>Save Actions</code> del la secci\u00f3n <code>Editor</code> nuevamente de Java.</p> <p></p> <p>Aqu\u00ed aplicamos la configuraci\u00f3n deseada.</p> <p></p>"},{"location":"install/springboot/#herramientas-para-pruebas","title":"Herramientas para pruebas","text":"<p>Para poder probar las operaciones de negocio que vamos a crear, lo mejor es utilizar una herramienta que permita realizar llamadas a API Rest. Para ello te propongo utilizar Postman, en su versi\u00f3n web o en su versi\u00f3n desktop, cualquiera de las dos sirve.</p> <p>Con esta herramienta se puede generar peticiones GET, POST, PUT, DELETE contra el servidor y pasarle par\u00e1metros de forma muy sencilla y visual. Lo usaremos durante el tutorial.</p>"},{"location":"install/springboot/#creacion-de-proyecto","title":"Creaci\u00f3n de proyecto","text":"<p>La mayor\u00eda de los proyectos Spring Boot en los que trabajamos normalmente, suelen ser proyectos web sencillos con pocas dependencias de terceros o incluso proyectos basados en micro-servicios que ejecutan pocas acciones. Ahora tienes que preparar el proyecto SpringBoot,</p>"},{"location":"install/springboot/#crear-con-initilizr","title":"Crear con Initilizr","text":"<p>Vamos a ver como configurar paso a paso un proyecto de cero, con las librer\u00edas que vamos a utilizar en el tutorial.</p>"},{"location":"install/springboot/#como-usarlo","title":"\u00bfComo usarlo?","text":"<p>Spring ha creado una p\u00e1gina interactiva que permite crear y configurar proyectos en diferentes lenguajes, con diferentes versiones de Spring Boot y a\u00f1adi\u00e9ndole los m\u00f3dulos que nosotros queramos.</p> <p>Esta p\u00e1gina est\u00e1 disponible desde Spring Initializr. Para seguir el ejemplo del tutorial, entraremos en la web y seleccionaremos los siguientes datos:</p> <ul> <li>Tipo de proyecto: Maven</li> <li>Lenguage: Java</li> <li>Versi\u00f3n Spring boot: 3.2.4 (o alguna similar que no sea SNAPSHOPT y que sea 3.x)</li> <li>Group: com.ccsw</li> <li>ArtifactId: tutorial</li> <li>Versi\u00f3n Java: 17 (o superior)</li> <li>Dependencias: Spring Web, Spring Data JPA, H2 Database</li> </ul> <p></p> <p>Esto nos generar\u00e1 un proyecto que ya vendr\u00e1 configurado con Spring Web, JPA y H2 para crear una BBDD en memoria de ejemplo con la que trabajaremos durante el tutorial.</p>"},{"location":"install/springboot/#importar-en-intellij","title":"Importar en IntelliJ","text":"<p>El siguiente paso, es descomprimir el proyecto generado e importarlo en el IDE. Abrimos IntelliJ, pulsamos en \"Open\" y buscamos la carpeta donde hemos descomprimido el proyecto.</p> <p>Una vez importado, recuerda darle al men\u00fa File \u2192 Settings y configurar las acciones de <code>Actions on save</code> que se explicar\u00f3n en el punto <code>Configuraci\u00f3n del IDE</code>.</p>"},{"location":"install/springboot/#importar-en-eclipse","title":"Importar en Eclipse","text":"<p>El siguiente paso, es descomprimir el proyecto generado e importarlo como proyecto Maven. Abrimos el eclipse, pulsamos en File \u2192 Import y seleccionamos <code>Existing Maven Projects</code>. Buscamos el proyecto y le damos a importar.</p>"},{"location":"install/springboot/#configurar-las-dependencias","title":"Configurar las dependencias","text":"<p>Lo primero que vamos a hacer es a\u00f1adir las dependencias a algunas librer\u00edas que vamos a utilizar. Abriremos el fichero <code>pom.xml</code> que nos ha generado el Spring Initilizr y a\u00f1adiremos las siguientes l\u00edneas:</p> pom.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;3.2.4&lt;/version&gt;\n        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;/parent&gt;\n\n    &lt;groupId&gt;com.ccsw&lt;/groupId&gt;\n    &lt;artifactId&gt;tutorial&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;tutorial&lt;/name&gt;\n    &lt;description&gt;Tutorial project for Spring Boot&lt;/description&gt;\n\n    &lt;properties&gt;\n        &lt;java.version&gt;17&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springdoc&lt;/groupId&gt;\n            &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;\n            &lt;version&gt;2.0.3&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n            &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;\n            &lt;version&gt;8.0.0.Final&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.modelmapper&lt;/groupId&gt;\n            &lt;artifactId&gt;modelmapper&lt;/artifactId&gt;\n            &lt;version&gt;3.1.1&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.h2database&lt;/groupId&gt;\n            &lt;artifactId&gt;h2&lt;/artifactId&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <p>Hemos a\u00f1adido las dependencias de que nos permite utilizar Open API para documentar nuestras APIs. Adem\u00e1s de esa dependencia, hemos a\u00f1adido una utilidad para hacer mapeos entre objetos y para configurar los servicios Rest. M\u00e1s adelante veremos como se utilizan.</p>"},{"location":"install/springboot/#configurar-librerias","title":"Configurar librer\u00edas","text":"<p>El siguiente punto es crear las clases de configuraci\u00f3n para las librer\u00edas que hemos a\u00f1adido. Para ello vamos a crear un package de configuraci\u00f3n general de la aplicaci\u00f3n <code>com.ccsw.tutorial.config</code> donde crearemos una clase que llamaremos <code>ModelMapperConfig</code> y usaremos para configurar el bean de ModelMapper.</p> ModelMapperConfig.java <pre><code>package com.ccsw.tutorial.config;\n\nimport org.modelmapper.ModelMapper;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * @author ccsw\n *\n */\n@Configuration\npublic class ModelMapperConfig {\n\n    @Bean\n    public ModelMapper getModelMapper() {\n\n        return new ModelMapper();\n    }\n\n}\n</code></pre> <p>Esta configuraci\u00f3n nos permitir\u00e1 luego hacer transformaciones entre objetos de forma muy sencilla. Ya lo iremos viendo m\u00e1s adelante. Listo, ya podemos empezar a desarrollar nuestros servicios.</p>"},{"location":"install/springboot/#configurar-la-bbdd","title":"Configurar la BBDD","text":"<p>Por \u00faltimo, vamos a dejar configurada la BBDD en memoria. Para ello crearemos un fichero, de momento en blanco, dentro de <code>src/main/resources/</code>:</p> <ul> <li>data.sql \u2192 Ser\u00e1 el fichero que utilizaremos para rellenar con datos iniciales el esquema de BBDD</li> </ul> <p>Este fichero no puede estar vac\u00edo, ya que si no dar\u00e1 un error al arrancar. Puedes a\u00f1adirle la siguiente query (que no hace nada) para que pueda arrancar el proyecto.</p> <p><code>select 1 from dual;</code></p> <p>Y ahora le vamos a decir a Spring Boot que la BBDD ser\u00e1 en memoria, que use un motor de H2 y que la cree autom\u00e1ticamente desde el modelo y que utilice el fichero <code>data.sql</code> (por defecto) para cargar datos en esta. Para ello hay que configurar el fichero <code>application.properties</code> que est\u00e1 dentro de <code>src/main/resources/</code>:</p> application.properties <pre><code>  #Database\n  spring.datasource.url=jdbc:h2:mem:testdb\n  spring.datasource.username=sa\n  spring.datasource.password=sa\n  spring.datasource.driver-class-name=org.h2.Driver\n\n  spring.jpa.database-platform=org.hibernate.dialect.H2Dialect\n  spring.jpa.defer-datasource-initialization=true\n  spring.jpa.show-sql=true\n\n  spring.h2.console.enabled=true\n</code></pre>"},{"location":"install/springboot/#arrancar-el-proyecto","title":"Arrancar el proyecto","text":"<p>Por \u00faltimo ya solo nos queda arrancar el proyecto creado. Para ello buscaremos la clase <code>TutorialApplication.java</code> (o la clase principal del proyecto) y con el bot\u00f3n derecho seleccionaremos Run As \u2192 Java Application. La aplicaci\u00f3n al estar basada en Spring Boot arrancar\u00e1 internamente un Tomcat embebido donde se despliega el proyecto. </p> <p>Si hab\u00e9is seguido el tutorial la aplicaci\u00f3n estar\u00e1 disponible en http://localhost:8080, aunque de momento a\u00fan no tenemos nada accesible y nos dar\u00e1 una p\u00e1gina de error <code>Whitelabel Error Page</code>, error 404. Eso significa que el Tomcat embedido nos ha contestado pero no sabe que devolvernos porque no hemos implementado todav\u00eda nada.</p>"},{"location":"install/vuejs/","title":"Entorno de desarrollo - Vue.js","text":""},{"location":"install/vuejs/#instalacion-de-herramientas","title":"Instalaci\u00f3n de herramientas","text":"<p>Las herramientas b\u00e1sicas que vamos a utilizar para esta tecnolog\u00eda son:</p> <ul> <li>Visual Studio Code</li> <li>Scoop.sh</li> <li>Nodejs</li> <li>Quasar CLI</li> </ul>"},{"location":"install/vuejs/#visual-studio-code","title":"Visual Studio Code","text":"<p>Lo primero de todo es instalar el IDE para el desarrollo front.</p> <p>Te recomiendo utilizar Visual Studio Code, en un IDE que a nosotros nos gusta mucho y tiene muchos plugins configurables. Puedes entrar en su p\u00e1gina y descargarte la versi\u00f3n estable.</p>"},{"location":"install/vuejs/#scoopsh","title":"Scoop.sh","text":"<p>Muchas de las herramientas que necesitar\u00e1s a lo largo de tu estancia en los proyectos, no podr\u00e1s instalarlas por temas de permisos de seguridad en nuestros port\u00e1tiles. Una forma de evitar estos permisos de seguridad y poder instalar herramientas (sobre todo a nivel de consola), es utilizando a Scoop.sh.</p> <p>Para instalar scoop.sh tan solo necesitas abrir un termina de PowerShell (OJO que es PowerShell y no una consola de msdos) y ejecutar los siguientes comandos:</p> <pre><code>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\nInvoke-RestMethod -Uri https://get.scoop.sh | Invoke-Expression\n</code></pre> <p>Esto nos instalar\u00e1 scoop.sh en nuestros port\u00e1tiles. Adem\u00e1s de la instalaci\u00f3n, y debido a las restricciones de seguridad que tenemos, necesitaremos activar el lessmsi para que las aplicaciones que necesitemos instalar no intenten ejecutar los .exe de instalaci\u00f3n, sino que descompriman el zip. Para ello deberemos ejecutar el comando:</p> <pre><code>scoop config use_lessmsi true\n</code></pre> <p>A partir de este punto, ya tenemos listo el port\u00e1til para instalar herramientas y aplicaciones.</p>"},{"location":"install/vuejs/#nodejs","title":"Nodejs","text":"<p>El siguiente paso ser\u00e1 instalar el motor de Nodejs. Para esto vamos a usar scoop.sh ya que lo tenemos instalado, y vamos a pedirle que nos instal\u00e9 el motor de Nodejs. Abriremos una consola de msdos y ejecutaremos el comando:</p> <pre><code>scoop install main/nodejs\n</code></pre> <p>Con esto, scoop ya nos instalar\u00e1 todo lo necesario.</p>"},{"location":"install/vuejs/#creacion-de-proyecto","title":"Creaci\u00f3n de proyecto","text":""},{"location":"install/vuejs/#generar-scaffolding","title":"Generar scaffolding","text":"<p>Lo primero que haremos ser\u00e1 generar un proyecto mediante la librer\u00eda \"Quasar CLI\" para ello ejecutamos en consola el siguiente comando:</p> <pre><code>npm init quasar\n</code></pre> <p>Este comando detectar\u00e1 si tienes el CLI de Quasar instalado y en caso contrario te preguntar\u00e1 si deseas instalarlo. Debes responder que s\u00ed, que lo instale. </p> <p>Una vez instalado, aparecer\u00e1 un wizzard en el que se ir\u00e1n preguntando una serie de datos para crear la aplicaci\u00f3n:</p> <p></p> <p>Y tendremos que elegir lo siguiente:</p> <p>What would you like to build?</p> <p><code>App with Quasar CLI, let's go!</code></p> <p>Project folder</p> <p><code>tutorial-vue</code></p> <p>Pick Quasar version</p> <p><code>Quasar v2 (Vue 3 | latest and greatest)</code></p> <p>Pick script type</p> <p><code>Typescript</code></p> <p>Pick Quasar App CLI variant</p> <p><code>Quasar App CLI with Vite</code></p> <p>Package name</p> <p><code>tutorial-vue</code></p> <p>Project product name</p> <p><code>Ludoceta Tan</code></p> <p>Project description</p> <p><code>Proyecto tutorial Ludoteca Tan</code></p> <p>Author</p> <p><code>&lt;por defecto el email&gt;</code></p> <p>Pick a Vue component style</p> <p><code>Composition API</code></p> <p>Pick your CSS preprocessor</p> <p><code>Sass with SCSS syntax</code></p> <p>Check the features needed for your project</p> <p><code>ESLint</code></p> <p>Pick an ESLint preset</p> <p><code>Prettier</code></p> <p>Install project dependencies?</p> <p><code>Yes, use npm</code></p>"},{"location":"install/vuejs/#arrancar-el-proyecto","title":"Arrancar el proyecto","text":"<p>Cuando todo ha terminado el propio scaffolding te dice lo que tienes que hacer para poner el proyecto en marcha y ver lo que te ha generado, solo tienes que seguir esos pasos.</p> <p>Accedes al directorio que acabas de crear y ejecutas</p> <pre><code>npx quasar dev\n</code></pre> <p>Esto arrancar\u00e1 el servidor y abrir\u00e1 un navegador en el puerto 9000 donde se mostrar\u00e1 la template creada.</p> <p>Tambi\u00e9n podemos navegar nosotros mismos a la URL <code>http://localhost:9000/</code>.</p> <p>Info</p> <p>Si durante el desarrollo del proyecto necesitas a\u00f1adir nuevos m\u00f3dulos al proyecto Vue.js, ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor de dependencias de Nodejs, directamente en consola ejecuta el comando npm install y descargar\u00e1 e instalar\u00e1 las nuevas dependencias..</p> <p>Proyecto descargado</p> <p>Cuando se trata de un proyecto nuevo recien descargado de un repositorio, recuerda que ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor de dependencias de Nodejs, directamente en consola ejecuta el comando npm install y descargar\u00e1 e instalar\u00e1 las nuevas dependencias. </p>"}]}