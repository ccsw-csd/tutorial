{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenido! Si est\u00e1s leyendo esto es porque tienes mucha fuerza de voluntad y unas enormes ganas de aprender a desarrollar con el stack tecnol\u00f3gico de CCA (Java Spring Boot, Nodejs, Angular) o porque te han mandando hacer este tutorial en tu etapa de formaci\u00f3n. En cualquier caso, te agradecemos el esfuerzo que est\u00e1s haciendo y te deseamos suerte . Por favor, si detectas que hay algo incorrecto en el tutorial, que no funciona o que est\u00e1 mal escrito, contacta con nosotros para que podamos solventarlo para futuras lecturas. Escr\u00edbenos un issue aqu\u00ed . \u00bfQue vamos a hacer? Durante este tutorial, vamos a crear una aplicaci\u00f3n web paso a paso con Spring Boot o Nodejs para la parte servidora y con Angular para la parte frontal. Intentar\u00e9 comentar todo lo m\u00e1s detallado posible, pero si echas en falta alguna explicaci\u00f3n por favor, escr\u00edbenos un issue aqu\u00ed para que podamos a\u00f1adirla. \u00bfComo lo vamos a hacer? En primer lugar te comentar\u00e9 brevemente las herramientas que usaremos en el tutorial y la forma de instalarlas (altamente recomendado). Luego veremos un vistazo general de lo que vamos a construir para que tengas un contexto general de la aplicaci\u00f3n. Y por \u00faltimo desarrollaremos paso a paso el backend y el frontend de la aplicaci\u00f3n. Durante todo el tutorial intentar\u00e9 dar unas pautas y consejos de buenas pr\u00e1cticas que todos deber\u00edamos adoptar, en la medida de lo posible, para homogeneizar el desarrollo de todos los proyectos. Adem\u00e1s para cada uno de los cap\u00edtulos que lo requieran, voy a desdoblar el tutorial por cada una de las tecnolog\u00edas disponibles para que vayas construyendo con la que m\u00e1s c\u00f3modo te sientas. As\u00ed que antes de empezar debes elegir bien con que tecnolog\u00edas vas a comenzar de las que tengo disponibles. Puedes volver a este tutorial m\u00e1s adelante por si he ido a\u00f1adiendo nuevas tecnolog\u00edas. Elige UNA tecnolog\u00eda de backend y UNA tecnolog\u00eda de frontend y completa el tutorial con esas dos tecnolog\u00edas. No mezcles ni hagas todas las tecnolog\u00edas a la vez ya que si no, te vas a volver loco. \u00bfHay pre-requisitos? No es obligado tener ning\u00fan conocimiento previo, pero es altamente recomendable que al menos conozcas lo b\u00e1sico de las tecnolog\u00edas que vamos a ver en el tutorial. Si no tienes ni idea, ni has oido hablar de las tecnolog\u00edas que has seleccionado para el tutorial, te sugiero que visites los itinerarios formativos y realices los cursos de nivel Esencial . De momento tenemos estos itinerarios: \ud83d\udd35 Frontend - Angular \ud83d\udfe2 Backend - SpringBoot \ud83d\udfe2 Backend - Nodejs Una vez hayas hecho los cursos esenciales, ya puedes volver y continuar con este tutorial. Repito que no es obligado, si ya tienes conocimientos previos de las tecnolog\u00edas no es necesario que hagas los cursos. Cuando termines el tutorial, ya puedes realizar el resto de cursos de otros niveles. \u00bfY luego qu\u00e9? Pues al final del tutorial, expondremos unos ejercicios pr\u00e1cticos para que los resuelvas tu mismo, aplicando los conocimientos adquiridos en el tutorial. Para ver si has comprendido correctamente todo lo aqu\u00ed descrito. No te preocupes, no es un examen Recomendaciones Te recomiendo que leas todo el tutorial, que no te saltes ning\u00fan punto y si se hace referencia a los anexos, que los visites y los leas tambi\u00e9n. Si tan solo copias y pegas, no ser\u00e1s capaz de hacer el \u00faltimo ejercicio por ti mismo. Debes leer y comprender lo que se est\u00e1 haciendo. Adem\u00e1s, los anexos est\u00e1n ah\u00ed por algo, sirven para completar informaci\u00f3n y para que conozcas los motivos por los que estamos programando as\u00ed el tutorial. Por favor, \u00e9chales un ojo tambi\u00e9n cuando te lo indique. Por \u00faltimo, \u00a1no te olvides! Cuando lo tengas todo listo, por favor no te olvides de subir los proyectos a alg\u00fan repositorio Github propio y av\u00edsanos para que podamos echarle un ojo y darte sugerencias y feedback .","title":"Bienvenido!"},{"location":"#bienvenido","text":"Si est\u00e1s leyendo esto es porque tienes mucha fuerza de voluntad y unas enormes ganas de aprender a desarrollar con el stack tecnol\u00f3gico de CCA (Java Spring Boot, Nodejs, Angular) o porque te han mandando hacer este tutorial en tu etapa de formaci\u00f3n. En cualquier caso, te agradecemos el esfuerzo que est\u00e1s haciendo y te deseamos suerte . Por favor, si detectas que hay algo incorrecto en el tutorial, que no funciona o que est\u00e1 mal escrito, contacta con nosotros para que podamos solventarlo para futuras lecturas. Escr\u00edbenos un issue aqu\u00ed .","title":"Bienvenido!"},{"location":"#que-vamos-a-hacer","text":"Durante este tutorial, vamos a crear una aplicaci\u00f3n web paso a paso con Spring Boot o Nodejs para la parte servidora y con Angular para la parte frontal. Intentar\u00e9 comentar todo lo m\u00e1s detallado posible, pero si echas en falta alguna explicaci\u00f3n por favor, escr\u00edbenos un issue aqu\u00ed para que podamos a\u00f1adirla.","title":"\u00bfQue vamos a hacer?"},{"location":"#como-lo-vamos-a-hacer","text":"En primer lugar te comentar\u00e9 brevemente las herramientas que usaremos en el tutorial y la forma de instalarlas (altamente recomendado). Luego veremos un vistazo general de lo que vamos a construir para que tengas un contexto general de la aplicaci\u00f3n. Y por \u00faltimo desarrollaremos paso a paso el backend y el frontend de la aplicaci\u00f3n. Durante todo el tutorial intentar\u00e9 dar unas pautas y consejos de buenas pr\u00e1cticas que todos deber\u00edamos adoptar, en la medida de lo posible, para homogeneizar el desarrollo de todos los proyectos. Adem\u00e1s para cada uno de los cap\u00edtulos que lo requieran, voy a desdoblar el tutorial por cada una de las tecnolog\u00edas disponibles para que vayas construyendo con la que m\u00e1s c\u00f3modo te sientas. As\u00ed que antes de empezar debes elegir bien con que tecnolog\u00edas vas a comenzar de las que tengo disponibles. Puedes volver a este tutorial m\u00e1s adelante por si he ido a\u00f1adiendo nuevas tecnolog\u00edas. Elige UNA tecnolog\u00eda de backend y UNA tecnolog\u00eda de frontend y completa el tutorial con esas dos tecnolog\u00edas. No mezcles ni hagas todas las tecnolog\u00edas a la vez ya que si no, te vas a volver loco.","title":"\u00bfComo lo vamos a hacer?"},{"location":"#hay-pre-requisitos","text":"No es obligado tener ning\u00fan conocimiento previo, pero es altamente recomendable que al menos conozcas lo b\u00e1sico de las tecnolog\u00edas que vamos a ver en el tutorial. Si no tienes ni idea, ni has oido hablar de las tecnolog\u00edas que has seleccionado para el tutorial, te sugiero que visites los itinerarios formativos y realices los cursos de nivel Esencial . De momento tenemos estos itinerarios: \ud83d\udd35 Frontend - Angular \ud83d\udfe2 Backend - SpringBoot \ud83d\udfe2 Backend - Nodejs Una vez hayas hecho los cursos esenciales, ya puedes volver y continuar con este tutorial. Repito que no es obligado, si ya tienes conocimientos previos de las tecnolog\u00edas no es necesario que hagas los cursos. Cuando termines el tutorial, ya puedes realizar el resto de cursos de otros niveles.","title":"\u00bfHay pre-requisitos?"},{"location":"#y-luego-que","text":"Pues al final del tutorial, expondremos unos ejercicios pr\u00e1cticos para que los resuelvas tu mismo, aplicando los conocimientos adquiridos en el tutorial. Para ver si has comprendido correctamente todo lo aqu\u00ed descrito. No te preocupes, no es un examen","title":"\u00bfY luego qu\u00e9?"},{"location":"#recomendaciones","text":"Te recomiendo que leas todo el tutorial, que no te saltes ning\u00fan punto y si se hace referencia a los anexos, que los visites y los leas tambi\u00e9n. Si tan solo copias y pegas, no ser\u00e1s capaz de hacer el \u00faltimo ejercicio por ti mismo. Debes leer y comprender lo que se est\u00e1 haciendo. Adem\u00e1s, los anexos est\u00e1n ah\u00ed por algo, sirven para completar informaci\u00f3n y para que conozcas los motivos por los que estamos programando as\u00ed el tutorial. Por favor, \u00e9chales un ojo tambi\u00e9n cuando te lo indique.","title":"Recomendaciones"},{"location":"#por-ultimo-no-te-olvides","text":"Cuando lo tengas todo listo, por favor no te olvides de subir los proyectos a alg\u00fan repositorio Github propio y av\u00edsanos para que podamos echarle un ojo y darte sugerencias y feedback .","title":"Por \u00faltimo, \u00a1no te olvides!"},{"location":"exercise/","text":"Ahora hazlo tu! Ahora vamos a ver si has comprendido bien el tutorial. Voy a poner dos ejercicios uno m\u00e1s sencillo que el otro para ver si eres capaz de llevarlos a cabo. \u00a1Vamos alla, mucha suerte! Nuestro amigo Ernesto Esvida ya tiene disponible su web para gestionar su cat\u00e1logo de juegos, autores y categor\u00edas, pero todav\u00eda le falta un poco m\u00e1s para poder hacer buen uso de su ludoteca. As\u00ed que nos ha pedido dos funcionalidades extra. Gesti\u00f3n de clientes Requisitos Por un lado necesita poder tener una base de datos de sus clientes. Para ello nos ha pedido que si podemos crearle una pantalla de CRUD sencilla, al igual que hicimos con las categor\u00edas donde \u00e9l pueda dar de alta a sus clientes. Nos ha pasado un esquema muy sencillo de lo que quiere, tan solo quiere guardar un listado de los nombres de sus clientes para tenerlos fichados , y nos ha hecho un par de pantallas sencillas muy similares a Categor\u00edas . Un listado sin filtros de ning\u00fan tipo ni paginaci\u00f3n. Un formulario de edici\u00f3n / alta, cuyo \u00fanico dato editable sea el nombre. Adem\u00e1s, la \u00fanica restricci\u00f3n que nos ha pedido es que NO podamos dar de alta a un cliente con el mismo nombre que otro existente. As\u00ed que deberemos comprobar el nombre, antes de guardar el cliente. Consejos Para empezar te dar\u00e9 unos consejos: Recuerda crear la tabla de la BBDD y sus datos Intenta primero hacer el listado completo, en el orden que m\u00e1s te guste: frontend o backend. Completa el listado conectando ambas capas. Termina el caso de uso haciendo las funcionalidades de edici\u00f3n, nuevo y borrado. Presta atenci\u00f3n a la validaci\u00f3n a la hora de guardar un cliente, NO se puede guardar si el nombre ya existe. Gesti\u00f3n de pr\u00e9stamos Requisitos Por otro lado, quiere hacer uso de su cat\u00e1logo de juegos y de sus clientes, y quiere saber que juegos ha prestado a cada cliente. Para ello nos ha pedido una p\u00e1gina bastante compleja donde se podr\u00e1 consultar diferente informaci\u00f3n y se permitir\u00e1 realizar el pr\u00e9stamo de los juegos. Nos ha pasado el siguiente boceto y requisitos: La pantalla tendr\u00e1 dos zonas: Una zona de filtrado donde se permitir\u00e1 filtrar por: T\u00edtulo del juego, que deber\u00e1 ser un combo seleccionable con los juegos del cat\u00e1logo de la Ludoteca. Cliente, que deber\u00e1 ser un combo seleccionable con los clientes dados de alta en la aplicaci\u00f3n. Fecha, que deber\u00e1 ser de tipo Datepicker y que permitir\u00e1 elegir una fecha de b\u00fasqueda. Al elegir un d\u00eda nos deber\u00e1 mostrar que juegos est\u00e1n prestados para dicho d\u00eda. OJO que los pr\u00e9stamos son con fecha de inicio y de fin, si elijo un d\u00eda intermedio deber\u00eda aparecer el elemento en la tabla. Una zona de listado paginado que deber\u00e1 mostrar El identificador del pr\u00e9stamo El nombre del juego prestado El nombre del cliente que lo solicit\u00f3 La fecha de inicio del pr\u00e9stamo La fecha de fin del pr\u00e9stamo Un bot\u00f3n que permite eliminar el pr\u00e9stamo Al pulsar el bot\u00f3n de Nuevo pr\u00e9stamo se abrir\u00e1 una pantalla donde se podr\u00e1 ingresar la siguiente informaci\u00f3n, toda ella obligatoria: Identificador, inicialmente vac\u00edo y en modo lectura Nombre del cliente, mediante un combo seleccionable Nombre del juego, mediante un combo seleccionable Fechas del pr\u00e9stamo, donde se podr\u00e1 introducir dos fechas, de inicio y fin del pr\u00e9stamo. Las validaciones son sencillas aunque laboriosas: La fecha de fin NO podr\u00e1 ser anterior a la fecha de inicio El periodo de pr\u00e9stamo m\u00e1ximo solo podr\u00e1 ser de 14 d\u00edas. Si el usuario quiere un pr\u00e9stamo para m\u00e1s de 14 d\u00edas la aplicaci\u00f3n no debe permitirlo mostrando una alerta al intentar guardar. El mismo juego no puede estar prestado a dos clientes distintos en un mismo d\u00eda. OJO que los pr\u00e9stamos tienen fecha de inicio y fecha fin, el juego no puede estar prestado a m\u00e1s de un cliente para ninguno de los d\u00edas que contemplan las fechas actuales del rango. Un mismo cliente no puede tener prestados m\u00e1s de 2 juegos en un mismo d\u00eda. OJO que los pr\u00e9stamos tienen fecha de inicio y fecha fin, el cliente no puede tener m\u00e1s de dos pr\u00e9stamos para ninguno de los d\u00edas que contemplan las fechas actuales del rango. Consejos Para empezar te dar\u00e9 unos consejos: Recuerda crear la tabla de la BBDD y sus datos Intenta primero hacer el listado paginado sin filtros, en el orden que m\u00e1s te guste: frontend o backend. Recuerda que se trata de un listado paginado, as\u00ed que deber\u00e1s utilizar el obtejo Page . Completa el listado conectando ambas capas. Ahora implementa los filtros, presta atenci\u00f3n al filtro de fecha, es el m\u00e1s complejo. Para la paginaci\u00f3n filtrada solo tienes que mezclar los conceptos que hemos visto en los puntos del tutorial anteriores. Si hiciste el backend en Springboot recuerda revisar Baeldung por si tienes dudas sobre las queries y recuerda que las Specifications son muy \u00fatiles, pero en este caso deber\u00e1s implementar otro tipo de operaciones, no te sirve solo con la operaci\u00f3n de igualdad : , que ya vimos en el tutorial. Implementa la pantalla de alta de pr\u00e9stamo, sin ninguna validaci\u00f3n. Cuando ya te funcione, intenta ir a\u00f1adiendo una a una las validaciones. Algunas de ellas pueden hacerse en frontend, mientras que otras deber\u00e1n validarse en backend \u00bfYa has terminado? Si has llegado a este punto es porque ya tienes terminado el tutorial. Por favor no te olvides de subir los proyectos a alg\u00fan repositorio Github propio (puedes revisar el anexo Tutorial b\u00e1sico de Git ) y av\u00edsarnos para que podamos echarle un ojo y darte sugerencias y feedback .","title":"Ahora hazlo tu!"},{"location":"exercise/#ahora-hazlo-tu","text":"Ahora vamos a ver si has comprendido bien el tutorial. Voy a poner dos ejercicios uno m\u00e1s sencillo que el otro para ver si eres capaz de llevarlos a cabo. \u00a1Vamos alla, mucha suerte! Nuestro amigo Ernesto Esvida ya tiene disponible su web para gestionar su cat\u00e1logo de juegos, autores y categor\u00edas, pero todav\u00eda le falta un poco m\u00e1s para poder hacer buen uso de su ludoteca. As\u00ed que nos ha pedido dos funcionalidades extra.","title":"Ahora hazlo tu!"},{"location":"exercise/#gestion-de-clientes","text":"","title":"Gesti\u00f3n de clientes"},{"location":"exercise/#requisitos","text":"Por un lado necesita poder tener una base de datos de sus clientes. Para ello nos ha pedido que si podemos crearle una pantalla de CRUD sencilla, al igual que hicimos con las categor\u00edas donde \u00e9l pueda dar de alta a sus clientes. Nos ha pasado un esquema muy sencillo de lo que quiere, tan solo quiere guardar un listado de los nombres de sus clientes para tenerlos fichados , y nos ha hecho un par de pantallas sencillas muy similares a Categor\u00edas . Un listado sin filtros de ning\u00fan tipo ni paginaci\u00f3n. Un formulario de edici\u00f3n / alta, cuyo \u00fanico dato editable sea el nombre. Adem\u00e1s, la \u00fanica restricci\u00f3n que nos ha pedido es que NO podamos dar de alta a un cliente con el mismo nombre que otro existente. As\u00ed que deberemos comprobar el nombre, antes de guardar el cliente.","title":"Requisitos"},{"location":"exercise/#consejos","text":"Para empezar te dar\u00e9 unos consejos: Recuerda crear la tabla de la BBDD y sus datos Intenta primero hacer el listado completo, en el orden que m\u00e1s te guste: frontend o backend. Completa el listado conectando ambas capas. Termina el caso de uso haciendo las funcionalidades de edici\u00f3n, nuevo y borrado. Presta atenci\u00f3n a la validaci\u00f3n a la hora de guardar un cliente, NO se puede guardar si el nombre ya existe.","title":"Consejos"},{"location":"exercise/#gestion-de-prestamos","text":"","title":"Gesti\u00f3n de pr\u00e9stamos"},{"location":"exercise/#requisitos_1","text":"Por otro lado, quiere hacer uso de su cat\u00e1logo de juegos y de sus clientes, y quiere saber que juegos ha prestado a cada cliente. Para ello nos ha pedido una p\u00e1gina bastante compleja donde se podr\u00e1 consultar diferente informaci\u00f3n y se permitir\u00e1 realizar el pr\u00e9stamo de los juegos. Nos ha pasado el siguiente boceto y requisitos: La pantalla tendr\u00e1 dos zonas: Una zona de filtrado donde se permitir\u00e1 filtrar por: T\u00edtulo del juego, que deber\u00e1 ser un combo seleccionable con los juegos del cat\u00e1logo de la Ludoteca. Cliente, que deber\u00e1 ser un combo seleccionable con los clientes dados de alta en la aplicaci\u00f3n. Fecha, que deber\u00e1 ser de tipo Datepicker y que permitir\u00e1 elegir una fecha de b\u00fasqueda. Al elegir un d\u00eda nos deber\u00e1 mostrar que juegos est\u00e1n prestados para dicho d\u00eda. OJO que los pr\u00e9stamos son con fecha de inicio y de fin, si elijo un d\u00eda intermedio deber\u00eda aparecer el elemento en la tabla. Una zona de listado paginado que deber\u00e1 mostrar El identificador del pr\u00e9stamo El nombre del juego prestado El nombre del cliente que lo solicit\u00f3 La fecha de inicio del pr\u00e9stamo La fecha de fin del pr\u00e9stamo Un bot\u00f3n que permite eliminar el pr\u00e9stamo Al pulsar el bot\u00f3n de Nuevo pr\u00e9stamo se abrir\u00e1 una pantalla donde se podr\u00e1 ingresar la siguiente informaci\u00f3n, toda ella obligatoria: Identificador, inicialmente vac\u00edo y en modo lectura Nombre del cliente, mediante un combo seleccionable Nombre del juego, mediante un combo seleccionable Fechas del pr\u00e9stamo, donde se podr\u00e1 introducir dos fechas, de inicio y fin del pr\u00e9stamo. Las validaciones son sencillas aunque laboriosas: La fecha de fin NO podr\u00e1 ser anterior a la fecha de inicio El periodo de pr\u00e9stamo m\u00e1ximo solo podr\u00e1 ser de 14 d\u00edas. Si el usuario quiere un pr\u00e9stamo para m\u00e1s de 14 d\u00edas la aplicaci\u00f3n no debe permitirlo mostrando una alerta al intentar guardar. El mismo juego no puede estar prestado a dos clientes distintos en un mismo d\u00eda. OJO que los pr\u00e9stamos tienen fecha de inicio y fecha fin, el juego no puede estar prestado a m\u00e1s de un cliente para ninguno de los d\u00edas que contemplan las fechas actuales del rango. Un mismo cliente no puede tener prestados m\u00e1s de 2 juegos en un mismo d\u00eda. OJO que los pr\u00e9stamos tienen fecha de inicio y fecha fin, el cliente no puede tener m\u00e1s de dos pr\u00e9stamos para ninguno de los d\u00edas que contemplan las fechas actuales del rango.","title":"Requisitos"},{"location":"exercise/#consejos_1","text":"Para empezar te dar\u00e9 unos consejos: Recuerda crear la tabla de la BBDD y sus datos Intenta primero hacer el listado paginado sin filtros, en el orden que m\u00e1s te guste: frontend o backend. Recuerda que se trata de un listado paginado, as\u00ed que deber\u00e1s utilizar el obtejo Page . Completa el listado conectando ambas capas. Ahora implementa los filtros, presta atenci\u00f3n al filtro de fecha, es el m\u00e1s complejo. Para la paginaci\u00f3n filtrada solo tienes que mezclar los conceptos que hemos visto en los puntos del tutorial anteriores. Si hiciste el backend en Springboot recuerda revisar Baeldung por si tienes dudas sobre las queries y recuerda que las Specifications son muy \u00fatiles, pero en este caso deber\u00e1s implementar otro tipo de operaciones, no te sirve solo con la operaci\u00f3n de igualdad : , que ya vimos en el tutorial. Implementa la pantalla de alta de pr\u00e9stamo, sin ninguna validaci\u00f3n. Cuando ya te funcione, intenta ir a\u00f1adiendo una a una las validaciones. Algunas de ellas pueden hacerse en frontend, mientras que otras deber\u00e1n validarse en backend","title":"Consejos"},{"location":"exercise/#ya-has-terminado","text":"Si has llegado a este punto es porque ya tienes terminado el tutorial. Por favor no te olvides de subir los proyectos a alg\u00fan repositorio Github propio (puedes revisar el anexo Tutorial b\u00e1sico de Git ) y av\u00edsarnos para que podamos echarle un ojo y darte sugerencias y feedback .","title":"\u00bfYa has terminado?"},{"location":"thanks/","text":"Agradecimientos! Antes de empezar quer\u00edamos dar las gracias a todos los que hab\u00e9is participado de manera directa o indirecta en la elaboraci\u00f3n de este tutorial, y a todos aquellos que lo hab\u00e9is sufrido haciendolo. De verdad G R A C I A S Colaboradores Menci\u00f3n especial a las personas que han participado en el tutorial ya sea como testers, como promotores o como desarrolladores, por orden temporal de colaboraci\u00f3n: Felipe Garcia ( @fgarciafer ) Armen Mirzoyan ( @armirzoya ) Carlos Aguilar ( @caaguila ) Jhonatan Core ( @corevill ) Carlos Navarro ( @DarkWarlord ) Cesar Cardona ( @Cazs03 ) Marina Valls ( @mvalemany ) Jaume Segarra ( @jaumesegarra ) Laura Medina ( @larulirea ) Yolanda Ubeda Pablo Jimenez ( @pajimene )","title":"Agradecimientos!"},{"location":"thanks/#agradecimientos","text":"Antes de empezar quer\u00edamos dar las gracias a todos los que hab\u00e9is participado de manera directa o indirecta en la elaboraci\u00f3n de este tutorial, y a todos aquellos que lo hab\u00e9is sufrido haciendolo. De verdad G R A C I A S","title":"Agradecimientos!"},{"location":"thanks/#colaboradores","text":"Menci\u00f3n especial a las personas que han participado en el tutorial ya sea como testers, como promotores o como desarrolladores, por orden temporal de colaboraci\u00f3n: Felipe Garcia ( @fgarciafer ) Armen Mirzoyan ( @armirzoya ) Carlos Aguilar ( @caaguila ) Jhonatan Core ( @corevill ) Carlos Navarro ( @DarkWarlord ) Cesar Cardona ( @Cazs03 ) Marina Valls ( @mvalemany ) Jaume Segarra ( @jaumesegarra ) Laura Medina ( @larulirea ) Yolanda Ubeda Pablo Jimenez ( @pajimene )","title":"Colaboradores"},{"location":"usecases/","text":"Contexto de la aplicaci\u00f3n Introducci\u00f3n Nuestro amigo Ernesto Esvida es muy aficionado a los juegos de mesa y desde muy peque\u00f1o ha ido coleccionando muchos juegos. Hasta tal punto que ha decidido regentar una Ludoteca. Como la colecci\u00f3n de juegos era suya personal, toda la informaci\u00f3n del cat\u00e1logo de juegos la ten\u00eda perfectamente clasificado en fichas de cart\u00f3n. Pero ahora que va abrir su propio negocio, necesita digitalizar esa informaci\u00f3n y hacerla m\u00e1s accesible. Como es un buen amigo de la infancia, hemos decidido ayudar a Ernesto y colaborar haciendo una peque\u00f1a aplicaci\u00f3n web que le sirva de cat\u00e1logo de juegos. Es m\u00e1s o menos el mismo sistema que estaba utilizando, pero esta vez en digital. Por cierto, la Ludoteca al final se va a llamar Ludoteca T\u00e1n . Info Las im\u00e1genes que aparecen a continuaci\u00f3n son mockups o dise\u00f1os de alambre de las pantallas que vamos a desarrollar durante el tutorial. No quiere decir que el estilo final de las pantallas deba ser as\u00ed, ni mucho menos. Es simplemente una forma sencilla de ejemplificar como debe quedar m\u00e1s o menos una pantalla. Estructura de un proyecto Web En todas las aplicaciones web modernas y los proyectos en los que trabajamos se pueden diferenciar, de forma general, tres grandes bloques funcionales , como se muestra en la imagen inferior. El funcionamiento es muy sencillo y difiere de las aplicaciones instalables que se ejecuta todo en una misma m\u00e1quina o servidor. Con esta estructura, el usuario accede a la aplicaci\u00f3n mediante un navegador web instalado en su m\u00e1quina local. Este navegador solicita informaci\u00f3n mediante una URL a un servidor de recursos est\u00e1ticos. Esto es lo que denominaremos un servidor frontend. Para programar servidores frontend se pueden usar muchas tecnolog\u00edas, en este tutorial lo desarrollaremos en Angular o en Vue.js. Este c\u00f3digo frontend se descarga y se ejecuta dentro del navegador, y contiene la representaci\u00f3n visual de las pantallas y ciertos comportamientos y navegaci\u00f3n entre componentes. Sin embargo, por lo general, no tiene datos ni ejecuta l\u00f3gica de negocio. Para estas labores de obtener datos o ejecutar l\u00f3gica de negocio, el c\u00f3digo frontend necesita invocar endpoints de la segunda capa , el backend. Al igual que antes, el backend, puede estar desarrollado en muchas tecnolog\u00edas, en este tutorial se puede elegir entre Java-Springboot o Nodejs. Lo importante de esta capa es que es necesario exponer unos endpoints que sean invocados por la capa de frontend. T\u00edpicamente estos endpoints son operaciones API Rest que veremos m\u00e1s adelante. Por \u00faltimo, el servidor backend / capa backend, necesitar\u00e1 leer y guardar datos de alg\u00fan sitio. Esto se hace utilizando la tercera capa , la capa de datos. Normalmente esta capa de datos ser\u00e1 una BBDD instalada en alg\u00fan servidor externo, aunque a veces como es el caso del tutorial de Springboot, podemos embeber el servidor en memoria de backend. Pero por norma general, esta capa es externa. As\u00ed pues el flujo normal de una aplicaci\u00f3n ser\u00eda el siguiente: El usuario abre el navegador y solicita una web mediante una URL El servidor frontend, le sirve los recursos (p\u00e1ginas web, javascript, im\u00e1genes, ...) y se cargan en el navegador El navegador renderiza las p\u00e1ginas web, ejecuta los procesos javascript y realiza las navegaciones Si en alg\u00fan momento se requiere invocar una operaci\u00f3n, el navegador lanzar\u00e1 una petici\u00f3n contra una URL del backend El backend estar\u00e1 escuchando las peticiones y las ejecutar\u00e1 en el momento que le invoquen devulviendo un resultado al navegador Si hiciera falta leer o guardar datos, el backend lo realizar\u00e1 lanzando consultas SQL contra la BBDD Dicho esto, por lo general necesitaremos un m\u00ednimo de dos proyectos para desarrollar una aplicaci\u00f3n: Por un lado tendremos un proyecto Frontend que se ejecutar\u00e1 en un servidor web de ficheros est\u00e1ticos, tipo Apache. Este proyecto ser\u00e1 c\u00f3digo javascript, css y html, que se renderizar\u00e1 en el navegador Web y que realizar\u00e1 ciertas operaciones sencillas y validaciones en local y llamadas a nuestro servidor backend para ejecutar las operaciones de negocio. Por otro lado tendremos un proyecto Backend que se ejecutar\u00e1 en un servidor de aplicaciones, tipo Tomcat o Node. Este proyecto tendr\u00e1 la l\u00f3gica de negocio de las operaciones, el acceso a los datos de la BBDD y cualquier integraci\u00f3n con servicios de terceros. La forma de exponer estas operaciones de negocio ser\u00e1 mediante endpoints de acceso, en concreto llamadas tipo REST. Pueden haber otros tipos de proyectos dentro de la aplicaci\u00f3n, sobretodo si est\u00e1n basados en microservicios o tienen componentes batch, pero estos proyectos no vamos a verlos en el tutorial. A partir de ahora, para que sea m\u00e1s sencillo acceder al tutorial, diferenciaremos las tecnolog\u00edas en el men\u00fa mediante los siguientes colores: \ud83d\udd35 Frontend \ud83d\udfe2 Backend Consejo Como norma cada uno de los proyectos que componen la aplicaci\u00f3n, deber\u00eda estar conectado a un repositorio de c\u00f3digo diferente para poder evolucionar y trabajar con cada uno de ellos de forma aislada sin afectar a los dem\u00e1s. As\u00ed adem\u00e1s podemos tener equipos aislados que trabajen con cada uno de los proyectos por separado. Info Durante todo el tutorial, voy a intentar separar la construcci\u00f3n del proyecto Frontend de la construcci\u00f3n del proyecto Backend. Elige una tecnolog\u00eda para cada una de las capas y utiliza siempre la misma en todos los apartados del tutorial. Dise\u00f1o de BD Para el proyecto que vamos a crear vamos a modelizar y gestionar 3 entidades: GAME , CATEGORY y AUTHOR . Para la entidad GAME , Ernesto nos ha comentado que la informaci\u00f3n que est\u00e1 guardando en sus fichas es la siguiente: id (este dato no estaba originalmente en las fichas pero nos ser\u00e1 muy util para indexar y realizar b\u00fasquedas) title age category author La entidad CATEGORY estar\u00e1 compuesta por los siguientes campos: id (lo mismo que en GAME ) name La entidad AUTHOR estar\u00e1 compuesta por los siguientes campos: id (lo mismo que en GAME ) name nationality Comenzaremos con un caso b\u00e1sico que cumpla las siguientes premisas: un juego pertenece a una categor\u00eda y ha sido creado por un \u00fanico autor. Modelando este contexto quedar\u00eda algo similar a esto: Dise\u00f1o de pantallas Deber\u00edamos construir tres pantallas de mantenimiento CRUD (Create, Read, Update, Delete) y una pantalla de Login general para activar las acciones de administrador. M\u00e1s o menos las pantallas deber\u00edan quedar as\u00ed: Listado de juegos Edici\u00f3n de juego Listado de categor\u00edas Edici\u00f3n de categor\u00eda Listado de autores Edici\u00f3n de autor Pantalla de Login Dise\u00f1o funcional Por \u00faltimo vamos a definir un poco la funcionalidad b\u00e1sica que Ernesto necesita para iniciar su negocio. Aspectos generales El sistema tan solo tendr\u00e1 dos roles: usuario b\u00e1sico es el usuario an\u00f3nimo que accede a la web sin registrar. Solo tiene permisos para mostrar listados usuario administrador es el usuario que se registra en la aplicaci\u00f3n. Puede realizar las operaciones de alta, edici\u00f3n y borrado Por defecto cuando entras en la aplicaci\u00f3n tendr\u00e1s los privilegios de un usuario b\u00e1sico hasta que el usuario haga un login correcto con el usuario / password admin / admin . En ese momento pasara a ser un usuario administrador y podr\u00e1 realizar operaciones de alta, baja y modificaci\u00f3n. La estructura general de la aplicaci\u00f3n ser\u00e1: Una cabecer\u00e1 superior que contendr\u00e1: el logo y el nombre de la tienda un enlace a cada uno de los CRUD del sistema un bot\u00f3n de Sign in Zona de trabajo, donde cargaremos las pantallas que el usuario vaya abriendo Al pulsar sobre la funcionalidad de Sign in aparecer\u00e1 una ventana modal que preguntar\u00e1 usuario y password. Esto realizar\u00e1 una llamada al backend, donde se validar\u00e1 si el usuario es correcto. En caso de ser correcto, devolver\u00e1 un token jwt de acceso, que el cliente web deber\u00e1 guardar en sessionStorage para futuras peticiones En caso de no ser correcto, devolver\u00e1 un error de Usuario y/o password incorrectos Todas las operaciones del backend que permitan crear, modificar o borrar datos, deber\u00e1n estar securizadas para que no puedan ser accedidas sin haberse autenticado previamente. CRUD de Juegos Al acceder a esta pantalla se mostrar\u00e1 un listado de los juegos disponibles en el cat\u00e1logo de la BD. Esta tabla debe contener filtros en la parte superior, pero no debe estar paginada. Se debe poder filtrar por: nombre del juego. Donde el usuario podr\u00e1 poner cualquier texto y el filtrado ser\u00e1 todos aquellos juegos que contengan el texto buscado categor\u00eda del juego. Donde aparecer\u00e1 un desplegable que el usuario seleccionar de entre todas las categor\u00edas de juego que existan en la BD. Dos botones permitir\u00e1n realizar el filtrado de juegos (lanzando una nueva consulta a BD) o limpiar los filtros seleccionados (lanzando una consulta con los filtros vac\u00edos). En la tabla debe aparecer a modo de fichas. No hace falta que sea exactamente igual a la maqueta, no es un requisito determinar un ancho general de ficha por lo que pueden caber 2,3 o x fichas en una misma fila, depender\u00e1 del programador. Pero todas las fichas deben tener el mismo ancho: Un espacio destinado a una foto (de momento no pondremos nada en ese espacio) Una columna con la siguiente informaci\u00f3n: T\u00edtulo del juego, resaltado de alguna forma Edad recomendada Categor\u00eda del juego, mostraremos su nombre Autor del juego, mostraremos su nombre Nacionalidad del juego, mostraremos la nacionalidad del autor del juego Los juegos no se pueden eliminar, pero si se puede editar si el usuario pulsa en alguna de las fichas (solo en el caso de que el usuario tenga permisos). Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevos juegos (solo en el caso de que el usuario tenga permisos). Crear Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con cinco inputs: Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Identificador T\u00edtulo. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de T\u00edtulo Edad. Este input es obligatorio, es de tipo num\u00e9rico de 0 a 99, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Edad Categor\u00eda. Este input es obligatorio, ser\u00e1 un campo seleccionable donde aparecer\u00e1n todas las categor\u00edas de la BD, aparecer\u00e1 vac\u00edo por defecto. Con el placeholder de Categor\u00eda Autor. Este input es obligatorio, ser\u00e1 un campo seleccionable donde aparecer\u00e1n todos los autores de la BD, aparecer\u00e1 vac\u00edo por defecto. Con el placeholder de Autor Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. Editar Al pulsar en una de las fichas con un click simple, se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de Crear pero con los cinco campos rellenados con los datos de BD. CRUD de Categor\u00edas Al acceder a esta pantalla se mostrar\u00e1 un listado de las categor\u00edas que tenemos en la BD. La tabla no tiene filtros, puesto que tiene muy pocos registros. Tampoco estar\u00e1 paginada. En la tabla debe aparecer: identificador de la categor\u00eda nombre de la categor\u00eda bot\u00f3n de editar (solo en el caso de que el usuario tenga permisos) bot\u00f3n de borrar (solo en el caso de que el usuario tenga permisos) Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevas categor\u00edas (solo en el caso de que el usuario tenga permisos). Crear Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con dos inputs: Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Identificador Nombre. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Nombre Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. Editar Al pulsar el icono de editar se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de Crear pero con los dos campos rellenados con los datos de BD. Borrar Si el usuario pulsa el bot\u00f3n de borrar, se deber\u00e1 comprobar si esa categor\u00eda tiene alg\u00fan Juego asociado. En caso de tenerlo se le informar\u00e1 al usuario de que dicha categor\u00eda no se puede eliminar por tener asociado un juego. En caso de no estar asociada, se le preguntar\u00e1 al usuario mediante un mensaje de confirmaci\u00f3n si desea eliminar la categor\u00eda. Solo en caso de que la respuesta sea afirmativa, se lanzar\u00e1 el borrado f\u00edsico de la categor\u00eda en BD. CRUD de Autores Al acceder a esta pantalla se mostrar\u00e1 un listado de los autores que tenemos en la BD. La tabla no tiene filtros pero deber\u00e1 estar paginada en servidor. En la tabla debe aparecer: identificador del autor nombre del autor nacionalidad del autor bot\u00f3n de editar (solo en el caso de que el usuario tenga permisos) bot\u00f3n de borrar (solo en el caso de que el usuario tenga permisos) Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevos autores (solo en el caso de que el usuario tenga permisos). Crear Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con tres inputs: Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Identificador Nombre. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Nombre Nacionalidad. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Nacionalidad Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. Editar Al pulsar el icono de editar se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de Crear pero con los tres campos rellenados con los datos de BD. Borrar Si el usuario pulsa el bot\u00f3n de borrar, se deber\u00e1 comprobar si ese autor tiene alg\u00fan Juego asociado. En caso de tenerlo se le informar\u00e1 al usuario de que dicho autor no se puede eliminar por tener asociado un juego. En caso de no estar asociado, se le preguntar\u00e1 al usuario mediante un mensaje de confirmaci\u00f3n si desea eliminar el autor. Solo en caso de que la respuesta sea afirmativa, se lanzar\u00e1 el borrado f\u00edsico de la categor\u00eda en BD.","title":"Contexto de la aplicaci\u00f3n"},{"location":"usecases/#contexto-de-la-aplicacion","text":"","title":"Contexto de la aplicaci\u00f3n"},{"location":"usecases/#introduccion","text":"Nuestro amigo Ernesto Esvida es muy aficionado a los juegos de mesa y desde muy peque\u00f1o ha ido coleccionando muchos juegos. Hasta tal punto que ha decidido regentar una Ludoteca. Como la colecci\u00f3n de juegos era suya personal, toda la informaci\u00f3n del cat\u00e1logo de juegos la ten\u00eda perfectamente clasificado en fichas de cart\u00f3n. Pero ahora que va abrir su propio negocio, necesita digitalizar esa informaci\u00f3n y hacerla m\u00e1s accesible. Como es un buen amigo de la infancia, hemos decidido ayudar a Ernesto y colaborar haciendo una peque\u00f1a aplicaci\u00f3n web que le sirva de cat\u00e1logo de juegos. Es m\u00e1s o menos el mismo sistema que estaba utilizando, pero esta vez en digital. Por cierto, la Ludoteca al final se va a llamar Ludoteca T\u00e1n . Info Las im\u00e1genes que aparecen a continuaci\u00f3n son mockups o dise\u00f1os de alambre de las pantallas que vamos a desarrollar durante el tutorial. No quiere decir que el estilo final de las pantallas deba ser as\u00ed, ni mucho menos. Es simplemente una forma sencilla de ejemplificar como debe quedar m\u00e1s o menos una pantalla.","title":"Introducci\u00f3n"},{"location":"usecases/#estructura-de-un-proyecto-web","text":"En todas las aplicaciones web modernas y los proyectos en los que trabajamos se pueden diferenciar, de forma general, tres grandes bloques funcionales , como se muestra en la imagen inferior. El funcionamiento es muy sencillo y difiere de las aplicaciones instalables que se ejecuta todo en una misma m\u00e1quina o servidor. Con esta estructura, el usuario accede a la aplicaci\u00f3n mediante un navegador web instalado en su m\u00e1quina local. Este navegador solicita informaci\u00f3n mediante una URL a un servidor de recursos est\u00e1ticos. Esto es lo que denominaremos un servidor frontend. Para programar servidores frontend se pueden usar muchas tecnolog\u00edas, en este tutorial lo desarrollaremos en Angular o en Vue.js. Este c\u00f3digo frontend se descarga y se ejecuta dentro del navegador, y contiene la representaci\u00f3n visual de las pantallas y ciertos comportamientos y navegaci\u00f3n entre componentes. Sin embargo, por lo general, no tiene datos ni ejecuta l\u00f3gica de negocio. Para estas labores de obtener datos o ejecutar l\u00f3gica de negocio, el c\u00f3digo frontend necesita invocar endpoints de la segunda capa , el backend. Al igual que antes, el backend, puede estar desarrollado en muchas tecnolog\u00edas, en este tutorial se puede elegir entre Java-Springboot o Nodejs. Lo importante de esta capa es que es necesario exponer unos endpoints que sean invocados por la capa de frontend. T\u00edpicamente estos endpoints son operaciones API Rest que veremos m\u00e1s adelante. Por \u00faltimo, el servidor backend / capa backend, necesitar\u00e1 leer y guardar datos de alg\u00fan sitio. Esto se hace utilizando la tercera capa , la capa de datos. Normalmente esta capa de datos ser\u00e1 una BBDD instalada en alg\u00fan servidor externo, aunque a veces como es el caso del tutorial de Springboot, podemos embeber el servidor en memoria de backend. Pero por norma general, esta capa es externa. As\u00ed pues el flujo normal de una aplicaci\u00f3n ser\u00eda el siguiente: El usuario abre el navegador y solicita una web mediante una URL El servidor frontend, le sirve los recursos (p\u00e1ginas web, javascript, im\u00e1genes, ...) y se cargan en el navegador El navegador renderiza las p\u00e1ginas web, ejecuta los procesos javascript y realiza las navegaciones Si en alg\u00fan momento se requiere invocar una operaci\u00f3n, el navegador lanzar\u00e1 una petici\u00f3n contra una URL del backend El backend estar\u00e1 escuchando las peticiones y las ejecutar\u00e1 en el momento que le invoquen devulviendo un resultado al navegador Si hiciera falta leer o guardar datos, el backend lo realizar\u00e1 lanzando consultas SQL contra la BBDD Dicho esto, por lo general necesitaremos un m\u00ednimo de dos proyectos para desarrollar una aplicaci\u00f3n: Por un lado tendremos un proyecto Frontend que se ejecutar\u00e1 en un servidor web de ficheros est\u00e1ticos, tipo Apache. Este proyecto ser\u00e1 c\u00f3digo javascript, css y html, que se renderizar\u00e1 en el navegador Web y que realizar\u00e1 ciertas operaciones sencillas y validaciones en local y llamadas a nuestro servidor backend para ejecutar las operaciones de negocio. Por otro lado tendremos un proyecto Backend que se ejecutar\u00e1 en un servidor de aplicaciones, tipo Tomcat o Node. Este proyecto tendr\u00e1 la l\u00f3gica de negocio de las operaciones, el acceso a los datos de la BBDD y cualquier integraci\u00f3n con servicios de terceros. La forma de exponer estas operaciones de negocio ser\u00e1 mediante endpoints de acceso, en concreto llamadas tipo REST. Pueden haber otros tipos de proyectos dentro de la aplicaci\u00f3n, sobretodo si est\u00e1n basados en microservicios o tienen componentes batch, pero estos proyectos no vamos a verlos en el tutorial. A partir de ahora, para que sea m\u00e1s sencillo acceder al tutorial, diferenciaremos las tecnolog\u00edas en el men\u00fa mediante los siguientes colores: \ud83d\udd35 Frontend \ud83d\udfe2 Backend Consejo Como norma cada uno de los proyectos que componen la aplicaci\u00f3n, deber\u00eda estar conectado a un repositorio de c\u00f3digo diferente para poder evolucionar y trabajar con cada uno de ellos de forma aislada sin afectar a los dem\u00e1s. As\u00ed adem\u00e1s podemos tener equipos aislados que trabajen con cada uno de los proyectos por separado. Info Durante todo el tutorial, voy a intentar separar la construcci\u00f3n del proyecto Frontend de la construcci\u00f3n del proyecto Backend. Elige una tecnolog\u00eda para cada una de las capas y utiliza siempre la misma en todos los apartados del tutorial.","title":"Estructura de un proyecto Web"},{"location":"usecases/#diseno-de-bd","text":"Para el proyecto que vamos a crear vamos a modelizar y gestionar 3 entidades: GAME , CATEGORY y AUTHOR . Para la entidad GAME , Ernesto nos ha comentado que la informaci\u00f3n que est\u00e1 guardando en sus fichas es la siguiente: id (este dato no estaba originalmente en las fichas pero nos ser\u00e1 muy util para indexar y realizar b\u00fasquedas) title age category author La entidad CATEGORY estar\u00e1 compuesta por los siguientes campos: id (lo mismo que en GAME ) name La entidad AUTHOR estar\u00e1 compuesta por los siguientes campos: id (lo mismo que en GAME ) name nationality Comenzaremos con un caso b\u00e1sico que cumpla las siguientes premisas: un juego pertenece a una categor\u00eda y ha sido creado por un \u00fanico autor. Modelando este contexto quedar\u00eda algo similar a esto:","title":"Dise\u00f1o de BD"},{"location":"usecases/#diseno-de-pantallas","text":"Deber\u00edamos construir tres pantallas de mantenimiento CRUD (Create, Read, Update, Delete) y una pantalla de Login general para activar las acciones de administrador. M\u00e1s o menos las pantallas deber\u00edan quedar as\u00ed:","title":"Dise\u00f1o de pantallas"},{"location":"usecases/#listado-de-juegos","text":"","title":"Listado de juegos"},{"location":"usecases/#edicion-de-juego","text":"","title":"Edici\u00f3n de juego"},{"location":"usecases/#listado-de-categorias","text":"","title":"Listado de categor\u00edas"},{"location":"usecases/#edicion-de-categoria","text":"","title":"Edici\u00f3n de categor\u00eda"},{"location":"usecases/#listado-de-autores","text":"","title":"Listado de autores"},{"location":"usecases/#edicion-de-autor","text":"","title":"Edici\u00f3n de autor"},{"location":"usecases/#pantalla-de-login","text":"","title":"Pantalla de Login"},{"location":"usecases/#diseno-funcional","text":"Por \u00faltimo vamos a definir un poco la funcionalidad b\u00e1sica que Ernesto necesita para iniciar su negocio.","title":"Dise\u00f1o funcional"},{"location":"usecases/#aspectos-generales","text":"El sistema tan solo tendr\u00e1 dos roles: usuario b\u00e1sico es el usuario an\u00f3nimo que accede a la web sin registrar. Solo tiene permisos para mostrar listados usuario administrador es el usuario que se registra en la aplicaci\u00f3n. Puede realizar las operaciones de alta, edici\u00f3n y borrado Por defecto cuando entras en la aplicaci\u00f3n tendr\u00e1s los privilegios de un usuario b\u00e1sico hasta que el usuario haga un login correcto con el usuario / password admin / admin . En ese momento pasara a ser un usuario administrador y podr\u00e1 realizar operaciones de alta, baja y modificaci\u00f3n. La estructura general de la aplicaci\u00f3n ser\u00e1: Una cabecer\u00e1 superior que contendr\u00e1: el logo y el nombre de la tienda un enlace a cada uno de los CRUD del sistema un bot\u00f3n de Sign in Zona de trabajo, donde cargaremos las pantallas que el usuario vaya abriendo Al pulsar sobre la funcionalidad de Sign in aparecer\u00e1 una ventana modal que preguntar\u00e1 usuario y password. Esto realizar\u00e1 una llamada al backend, donde se validar\u00e1 si el usuario es correcto. En caso de ser correcto, devolver\u00e1 un token jwt de acceso, que el cliente web deber\u00e1 guardar en sessionStorage para futuras peticiones En caso de no ser correcto, devolver\u00e1 un error de Usuario y/o password incorrectos Todas las operaciones del backend que permitan crear, modificar o borrar datos, deber\u00e1n estar securizadas para que no puedan ser accedidas sin haberse autenticado previamente.","title":"Aspectos generales"},{"location":"usecases/#crud-de-juegos","text":"Al acceder a esta pantalla se mostrar\u00e1 un listado de los juegos disponibles en el cat\u00e1logo de la BD. Esta tabla debe contener filtros en la parte superior, pero no debe estar paginada. Se debe poder filtrar por: nombre del juego. Donde el usuario podr\u00e1 poner cualquier texto y el filtrado ser\u00e1 todos aquellos juegos que contengan el texto buscado categor\u00eda del juego. Donde aparecer\u00e1 un desplegable que el usuario seleccionar de entre todas las categor\u00edas de juego que existan en la BD. Dos botones permitir\u00e1n realizar el filtrado de juegos (lanzando una nueva consulta a BD) o limpiar los filtros seleccionados (lanzando una consulta con los filtros vac\u00edos). En la tabla debe aparecer a modo de fichas. No hace falta que sea exactamente igual a la maqueta, no es un requisito determinar un ancho general de ficha por lo que pueden caber 2,3 o x fichas en una misma fila, depender\u00e1 del programador. Pero todas las fichas deben tener el mismo ancho: Un espacio destinado a una foto (de momento no pondremos nada en ese espacio) Una columna con la siguiente informaci\u00f3n: T\u00edtulo del juego, resaltado de alguna forma Edad recomendada Categor\u00eda del juego, mostraremos su nombre Autor del juego, mostraremos su nombre Nacionalidad del juego, mostraremos la nacionalidad del autor del juego Los juegos no se pueden eliminar, pero si se puede editar si el usuario pulsa en alguna de las fichas (solo en el caso de que el usuario tenga permisos). Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevos juegos (solo en el caso de que el usuario tenga permisos). Crear Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con cinco inputs: Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Identificador T\u00edtulo. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de T\u00edtulo Edad. Este input es obligatorio, es de tipo num\u00e9rico de 0 a 99, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Edad Categor\u00eda. Este input es obligatorio, ser\u00e1 un campo seleccionable donde aparecer\u00e1n todas las categor\u00edas de la BD, aparecer\u00e1 vac\u00edo por defecto. Con el placeholder de Categor\u00eda Autor. Este input es obligatorio, ser\u00e1 un campo seleccionable donde aparecer\u00e1n todos los autores de la BD, aparecer\u00e1 vac\u00edo por defecto. Con el placeholder de Autor Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. Editar Al pulsar en una de las fichas con un click simple, se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de Crear pero con los cinco campos rellenados con los datos de BD.","title":"CRUD de Juegos"},{"location":"usecases/#crud-de-categorias","text":"Al acceder a esta pantalla se mostrar\u00e1 un listado de las categor\u00edas que tenemos en la BD. La tabla no tiene filtros, puesto que tiene muy pocos registros. Tampoco estar\u00e1 paginada. En la tabla debe aparecer: identificador de la categor\u00eda nombre de la categor\u00eda bot\u00f3n de editar (solo en el caso de que el usuario tenga permisos) bot\u00f3n de borrar (solo en el caso de que el usuario tenga permisos) Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevas categor\u00edas (solo en el caso de que el usuario tenga permisos). Crear Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con dos inputs: Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Identificador Nombre. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Nombre Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. Editar Al pulsar el icono de editar se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de Crear pero con los dos campos rellenados con los datos de BD. Borrar Si el usuario pulsa el bot\u00f3n de borrar, se deber\u00e1 comprobar si esa categor\u00eda tiene alg\u00fan Juego asociado. En caso de tenerlo se le informar\u00e1 al usuario de que dicha categor\u00eda no se puede eliminar por tener asociado un juego. En caso de no estar asociada, se le preguntar\u00e1 al usuario mediante un mensaje de confirmaci\u00f3n si desea eliminar la categor\u00eda. Solo en caso de que la respuesta sea afirmativa, se lanzar\u00e1 el borrado f\u00edsico de la categor\u00eda en BD.","title":"CRUD de Categor\u00edas"},{"location":"usecases/#crud-de-autores","text":"Al acceder a esta pantalla se mostrar\u00e1 un listado de los autores que tenemos en la BD. La tabla no tiene filtros pero deber\u00e1 estar paginada en servidor. En la tabla debe aparecer: identificador del autor nombre del autor nacionalidad del autor bot\u00f3n de editar (solo en el caso de que el usuario tenga permisos) bot\u00f3n de borrar (solo en el caso de que el usuario tenga permisos) Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevos autores (solo en el caso de que el usuario tenga permisos). Crear Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con tres inputs: Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Identificador Nombre. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Nombre Nacionalidad. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Nacionalidad Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. Editar Al pulsar el icono de editar se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de Crear pero con los tres campos rellenados con los datos de BD. Borrar Si el usuario pulsa el bot\u00f3n de borrar, se deber\u00e1 comprobar si ese autor tiene alg\u00fan Juego asociado. En caso de tenerlo se le informar\u00e1 al usuario de que dicho autor no se puede eliminar por tener asociado un juego. En caso de no estar asociado, se le preguntar\u00e1 al usuario mediante un mensaje de confirmaci\u00f3n si desea eliminar el autor. Solo en caso de que la respuesta sea afirmativa, se lanzar\u00e1 el borrado f\u00edsico de la categor\u00eda en BD.","title":"CRUD de Autores"},{"location":"appendix/git/","text":"Tutorial b\u00e1sico de Git Cada vez se tiende m\u00e1s a utilizar repositorios de c\u00f3digo Git y, aunque no sea objeto de este tutorial Springboot-Angular, queremos hacer un resumen muy b\u00e1sico y sencillo de como utilizar Git. En el mercado existen multitud de herramientas para gestionar repositorios Git, podemos utilizar cualquiera de ellas, aunque desde devonfw se recomienda utilizar Git SCM . Adem\u00e1s, existen tambi\u00e9n multitud de servidores de c\u00f3digo que implementan repositorios Git, como podr\u00edan ser GitHub, GitLab, Bitbucket, etc. Todos ellos trabajan de la misma forma, as\u00ed que este resumen servir\u00e1 para todos ellos. Info Este anexo muestra un resumen muy sencillo y b\u00e1sico de los comandos m\u00e1s comunes que se utilizan en Git. Para ver detalles m\u00e1s avanzados o un tutorial completo te recomiendo que leas la guia de Atlassian . Funcionamiento b\u00e1sico Existen dos conceptos en Git que debes tener muy claros: las ramas y los repositorios. Vamos a ver como funciona cada uno de ellos. Ramas Por un lado tenemos las ramas de Git. El repositorio puede tener tantas ramas como se quiera, pero por lo general debe existir una rama maestra a menudo llamada develop o master , y luego muchas ramas con cada una de las funcionalidades desarrolladas. Las ramas siempre se deben crear a partir de una rama (en el ejemplo llamaremos develop ), con una foto concreta y determinada de esa rama. Esta rama deber\u00e1 tener un nombre que describa lo que va a contener esa rama (en el ejemplo feature/xxx ). Y por lo general, esa rama se mergear\u00e1 con otra rama del repositorio, que puede ser la rama de origen o cualquier otra (en el ejemplo ser\u00e1 con la rama origen develop ). As\u00ed pues, podemos tener algo as\u00ed: Las acciones de crear ramas y mergear ramas est\u00e1n explicadas m\u00e1s abajo. En este punto solo es necesario que seas conocedor de: existen ramas maestras --> que contienen el c\u00f3digo completo de la aplicaci\u00f3n existen ramas de desarrollo --> que generalmente se crean de una rama maestra en un punto temporal concreto en alg\u00fan momento esas ramas de desarrollo se deben mergear en una rama maestra ojo cuidado , cuando hay varias personas en el equipo trabajando, habr\u00e1n varias ramas de desarrollo que nazcan de diferentes puntos temporales y que habr\u00e1 que tener en cuenta para posibles conflictos. Recuerda que no est\u00e1s solo programando, hay m\u00e1s gente modificando el c\u00f3digo. Repositorios El otro concepto que debe queda claro, es el de repositorios. Por defecto, en Git, se trabaja con el repositorio local, en el que puedes crear ramas, modificar c\u00f3digo, mergear, etc. pero todos esos cambios que se hagan, ser\u00e1n todos en local, nadie m\u00e1s tendr\u00e1 acceso. Tambi\u00e9n existe el repositorio remoto, tambi\u00e9n llamado origin . Este repositorio es el que todos los integrantes del equipo utilizan como referencia. Existen acciones de Git que permite sincronizar los repositorios. En este punto solo es necesario que seas conocedor de: Los cambios que realices en local (en tu repositorio local) solo ser\u00e1n visibles por ti. Puedes crear ramas y borrarlas, pero solo tu las ver\u00e1s. Los cambios que se suban al repositorio remoto ser\u00e1n visibles para todos. Pueden haber ramas protegidas para que no se puedan modificar desde el equipo, t\u00edpicamente las ramas maestras. Estas ramas solo pueden modificarse previa validaci\u00f3n y pull request o merge request (depende de la aplicaci\u00f3n usada para Git). Existen acciones que permiten subir tus cambios de local a remoto. Recuerda que pueden existir ramas protegidas. Existen acciones que permiten actualizar tus ramas locales con los cambios remotos. Recuerda que no trabajas solo, es posible que tu repositorio local no est\u00e9 sincronizado, tus compa\u00f1eros han podido subir c\u00f3digo y deber\u00edas sincronizarte frecuentemente. Acciones m\u00e1s t\u00edpicas En la Gu\u00eda r\u00e1pida puedes ver m\u00e1s detalle de estas acciones pero por lo general: Lo primero es descargarse una copia del repositorio con todas sus ramas. Se descargar\u00eda de remoto a local. A partir de este momento se trabaja en local. Cada nueva funcionalidad deber\u00eda tener su rama asociada, por tanto, lo l\u00f3gico es crear una rama de desarrollo (t\u00edpicamente feature/xxx ) a partir de una rama maestra (t\u00edpicamente develop o master ). Se trabajar\u00eda de forma local con esa rama. Es buena pr\u00e1ctica que si llevas mucho tiempo con la rama creada, de vez en cuando, sincronices tu repositorio local con lo que exista en el repositorio remoto. Adem\u00e1s, como es posible que la rama maestra de la que part\u00eda haya cambiado, esos cambios deber\u00edas llevarlos tambi\u00e9n a tu rama en desarrollo. Con esto consigues que tu punto temporal sea m\u00e1s moderno y tengas menos conflictos. Recuerda que no est\u00e1s solo trabajando. Cuando lo tengas listo y antes de subir nada, deber\u00edas realizar una \u00faltima sincronizaci\u00f3n de remoto a local. Despu\u00e9s deber\u00edas hacer un merge de tus ramas locales de desarrollo con las ramas maestras locales de las que partieron, por los posibles cambios que alguien hubiera podido subir. Por \u00faltimo, una vez tengas todo actualizado, ya puedes subir el c\u00f3digo al repositorio remoto (tu rama de desarrollo), y solicitar un pull request o merge request contra la rama maestra que quieras modificar. Alguien, diferente a ti, debe revisar esa solicitud y aprobarla antes de que se realice todo el merge correcto en remoto. Y vuelta a empezar. Funcionamiento avanzado A continuaci\u00f3n vamos a describir estos mismos conceptos y acciones que hemos visto, pero m\u00e1s en profundidad para que veas como trabaja internamente Git. No es necesario que leas este punto, aunque es recomendable. Estructuras y flujo de trabajo Lo primero que debes conocer de Git es su funcionamiento b\u00e1sico de flujo de trabajo. Tu repositorio local est\u00e1 compuesto por tres \"estructuras\" que contienen los archivos y los cambios de los ficheros del repositorio. Working directory - Contiene los archivos con los que est\u00e1s trabajando localmente. Staging Area - Es un \u00e1rea intermedia donde vamos a\u00f1adiendo ficheros para ir agrupando modificaciones. Local Repository - Es el repositorio local donde tendr\u00e9mos el registro de todos los commits que hemos realizado. Por defecto apunta a HEAD que es el \u00faltimo commit registrado. Existen operaciones que nos permiten a\u00f1adir o borrar ficheros dentro de cada una de las estructuras desde otra estructura. As\u00ed pues, los comandos b\u00e1sicos dentro de nuestro repositorio local son los siguientes. add y commmit Puedes registrar los cambios realizados en tu working directory y a\u00f1adirlos al staging area usando el comando git add <filename> o si quieres a\u00f1adir todos los ficheros modificados git add . Este es el primer paso en el flujo de trabajo b\u00e1sico. Una vez tenemos los cambios registrados en el staging area podemos hacer un commit y persistirlos dentro del local repository mediante el comando git commit -m \"<Commit message>\" A partir de ese momento, los ficheros modificados y a\u00f1adidos al local repository se han persistido y se han a\u00f1adido a tu HEAD , aunque todav\u00eda siguen estando el local, no lo has enviado a ning\u00fan repositorio remoto. reset De la misma manera que se han a\u00f1adido ficheros a staging area o a local repository , podemos retirarlos de estas estructuras y volver a recuperar los ficheros que ten\u00edamos anteriormente en el working directory . Por ejemplo, si nos hemos equivocado al incluir ficheros en un commit o simplemente queremos deshacer los cambios que hemos realizado bastar\u00eda con lanzar el comando git reset --hard o si queremos volver a un commit concreto git reset <COMMIT> Trabajo con ramas Para complicarlo todo un poco m\u00e1s, el trabajo con git siempre se realiza mediante ramas. Estas ramas nos sirven para desarrollar funcionalidades aisladas unas de otras y poder hacer mezclas de c\u00f3digo de unas ramas a otras. Las ramas m\u00e1s comunes dentro de git suelen ser: master Esta ser\u00e1 la rama que contenga el c\u00f3digo fuente que tenemos en producci\u00f3n . release Esta ser\u00e1 la rama que contenga el c\u00f3digo fuente de cada una de las entregas parciales, no tiene porqu\u00e9 coincidir con la rama master . develop Esta ser\u00e1 la rama que contenga el c\u00f3digo fuente estable que est\u00e1 actualmente en desarrollo. feature/xxxx Estas ser\u00e1nn la rama que contengan el c\u00f3digo fuente de desarrollo de cada una de las funcionalidades. Generalmente estas ramas las crea cada desarrollador, las mantiene en local, hasta que las sube a remoto para realizar un merge a la rama develop . Siempre que trabajes con ramas debes tener en cuenta que al empezar tu desarrollo debes partir de una versi\u00f3n actualizada de la rama develop , y al terminar tu desarrollo debes solicitar un merge contra develop , para que tu funcionalidad est\u00e9 incorporada en la rama de desarrollo. Crear ramas Crear ramas en local es tan sencillo como ejecutar este comando: git checkout -b <NOMBRE_RAMA> Eso nos crear\u00e1 una rama con el nombre que le hayamos dicho y mover\u00e1 el Working Directory a dicha rama. Cambiar de rama Para cambiar de una rama a otra en local tan solo debemos ejecutar el comando: git checkout <NOMBRE_RAMA> La rama debe existir, sino se quejar\u00e1 de que no encuentra la rama. Este comando nos mover\u00e1 el Working Directory a la rama que le hayamos indicado. Si tenemos cambios en el Staging Area que no hayan sido movidos al Local Repository NO nos permitir\u00e1 movernos a la rama ya que perder\u00edamos los cambios. Antes de poder movernos debemos resetear los cambios o bien commitearlos . Remote repository Hasta aqu\u00ed es todo m\u00e1s o menos sencillo, trabajamos con nuestro repositorio local, creamos ramas, commiteamos o reseteamos cambios de c\u00f3digo, pero todo esto lo hacemos en local. Ahora necesitamos que esos cambios se distribuyan y puedan leerlos el resto de integrantes de nuestro equipo. Aqu\u00ed es donde entra en juego los repositorios remotos. Aqu\u00ed debemos tener MUY en cuenta que el c\u00f3digo que vamos a publicar en remoto SOLO es posible publicarlo desde el Local Repository . Es decir que para poder subir c\u00f3digo a remote antes debemos a\u00f1adirlo a Staging Area y hacer un commit para persistirlo en el Local Repository . clone Antes de empezar a tocar c\u00f3digo del proyecto podemos crear un Local Repository vac\u00edo o bien bajarnos un proyecto que ya exista en un Remote Repository . Esta \u00faltima opci\u00f3n es la m\u00e1s normal. Para bajarnos un proyecto desde remoto tan solo hay que ejecutar el comando: git clone <REMOTE_URL> Esto te crear\u00e1 una carpeta con el nombre del proyecto y dentro se descargar\u00e1 la estructura completa del repositorio y te mover\u00e1 al Working Directory todo el c\u00f3digo de la rama por defecto para ese repositorio. env\u00edo de cambios El env\u00edo de datos a un Remote Repository tan solo es posible realizarlo desde Local Repository (por lo que antes deber\u00e1s commitear cambios all\u00ed), y se debe ejecutar el comando: git push origin actualizar y fusionar En ocasiones (bastante habitual) ser\u00e1 necesario descargarse los cambios de un Remote Repository para poder trabajar con la \u00faltima versi\u00f3n. Para ello debemos ejecutar el comando: git pull El propio git realizar\u00e1 la fusi\u00f3n local del c\u00f3digo remoto con el c\u00f3digo de tu Working Directory . Pero en ocasiones, si se ha modificado el mismo fichero en remoto y en local, se puede producir un Conflicto . No pasa nada, tan solo tendr\u00e1s que abrir dicho fichero en conflicto y resolverlo manualmente dejando el c\u00f3digo mezclado correcto. Tambi\u00e9n es posible que el c\u00f3digo que queramos actualizar est\u00e9 en otra rama, si lo que necesitamos es fusionar el c\u00f3digo de otra rama con la rama actual, nos situaremos en la rama destino y ejecutaremos el comando: git merge <RAMA_ORIGEN> Esto har\u00e1 lo mismo que un pull en local y fusionar\u00e1 el c\u00f3digo de una rama en otra. Tambi\u00e9n es posible que se produzcan conflictos que deber\u00e1s resolver de forma manual. Merge Request Ya por \u00faltimo, como estamos trabajando con ramas, lo \u00fanico que hacemos es subir y bajar ramas, pero en alg\u00fan momento alguien debe fusionar el contenido de una rama en la rama develop , release o master , que son las ramas principales. Se podr\u00eda directamente usar el comando merge para eso, pero en la mayor\u00eda de los repositorios no esta permitido subir el c\u00f3digo de una rama principal, por lo que no podr\u00e1s hacer un merge y subirlo. Para eso existe otra opci\u00f3n que es la de Merge Request . Esta opci\u00f3n permite a un usuario solicitar que otro usuario verifique y valide que el c\u00f3digo de su rama es correcto y lo puede fusionar en Remote Repository con una rama principal. Al ser una operaci\u00f3n delicada, tan solo es posible ejecutarla a trav\u00e9s de la web del repositorio git. Por lo general existir\u00e1 una opci\u00f3n / bot\u00f3n que permitir\u00e1 hacer un Merge Request con una rama origen y una rama destino (generalmente una de las principales). A esa petici\u00f3n se le asignar\u00e1 un validador y se enviar\u00e1. El usuario validador verificar\u00e1 si es correcto o no y validar\u00e1 o rechazar\u00e1 la petici\u00f3n. En caso de validarla se fusionar\u00e1 autom\u00e1ticamente en remoto y todos los usuarios podr\u00e1n descargar los nuevos cambios desde la rama. \u00a1Cuidado! Siempre antes de solicitar un Merge Request debes comprobar que tienes actualizada la rama comparandola con la rama remota que queremos mergear, en nuestro ejemplo ser\u00e1 develop . Para actualizarla tu rama hay que seguir tres pasos muy sencillos: Cambias a la rama develop y descargarnos los cambios del repositorio remoto (git pull) Cambias a tu rama y ejecutar un merge desde develop hacia nuestra rama (git merge develop) Subes tus cambios a remoto (git add, git commit y git push) y ya puedes solcitar el Merge Request Gu\u00eda r\u00e1pida Los pasos b\u00e1sicos de utilizaci\u00f3n de git son sencillos. Primero nos bajamos el repositorio o lo creamos en local mediante los comandos git clone o git init Una vez estamos trabajando con nuestro repositorio local, cada vez que vayamos a comenzar una funcionalidad nueva, debemos crear una rama nueva siempre partiendo desde una rama maestra mediante el comando: (en nuestro ejemplo la rama maestra ser\u00e1 develop ) git checkout -b <rama> Cuando tengamos implementados los cambios que queremos realizar, hay que subirlos al staging y luego persistirlos en nuestro repositorio local. Esto lo hacemos con el comando git add . git commit -m \"<Commit message>\" Siempre antes de subir los cambios al repositorio remoto, hay que comprobar que tenemos actualizada nuestra rama comparandola con la rama remota que queremos mergear, en nuestro ejemplo ser\u00e1 develop . Por tanto tenemos que cambiar a la rama develop , descargarnos los cambios del repositorio remoto, volver a cambiar a nuestra rama y ejecutar un merge desde develop hacia nuestra rama, ejecutando estos comandos git checkout develop git pull git checkout <rama> git merge develop Ahora que ya tenemos actualizadas las ramas, tan solo nos basta subir nuestra rama a remoto, con el comando git push --set-upstream origin <rama> Por \u00faltimo accedemos al cliente web del repositorio y solicitamos un merge request contra develop . Para que sea validado y aprobado por otro compa\u00f1ero del equipo. Si en alg\u00fan momento necesitamos modificar nuestro c\u00f3digo del merge request antes de que haya sido aprobado, nos basta con repetir los pasos anteriores git add . git commit -m \"<Commit message>\" git push origin Una vez hayamos terminado el desarrollo y vayamos a empezar una nueva funcionalidad, volveremos al punto 2 de este listado y comenzaremos de nuevo los comando. Debemos recordad que tenemos que partir siempre de la rama develop y adem\u00e1s debe estar actualizada git pull .","title":"GIT: Tutorial b\u00e1sico"},{"location":"appendix/git/#tutorial-basico-de-git","text":"Cada vez se tiende m\u00e1s a utilizar repositorios de c\u00f3digo Git y, aunque no sea objeto de este tutorial Springboot-Angular, queremos hacer un resumen muy b\u00e1sico y sencillo de como utilizar Git. En el mercado existen multitud de herramientas para gestionar repositorios Git, podemos utilizar cualquiera de ellas, aunque desde devonfw se recomienda utilizar Git SCM . Adem\u00e1s, existen tambi\u00e9n multitud de servidores de c\u00f3digo que implementan repositorios Git, como podr\u00edan ser GitHub, GitLab, Bitbucket, etc. Todos ellos trabajan de la misma forma, as\u00ed que este resumen servir\u00e1 para todos ellos. Info Este anexo muestra un resumen muy sencillo y b\u00e1sico de los comandos m\u00e1s comunes que se utilizan en Git. Para ver detalles m\u00e1s avanzados o un tutorial completo te recomiendo que leas la guia de Atlassian .","title":"Tutorial b\u00e1sico de Git"},{"location":"appendix/git/#funcionamiento-basico","text":"Existen dos conceptos en Git que debes tener muy claros: las ramas y los repositorios. Vamos a ver como funciona cada uno de ellos.","title":"Funcionamiento b\u00e1sico"},{"location":"appendix/git/#ramas","text":"Por un lado tenemos las ramas de Git. El repositorio puede tener tantas ramas como se quiera, pero por lo general debe existir una rama maestra a menudo llamada develop o master , y luego muchas ramas con cada una de las funcionalidades desarrolladas. Las ramas siempre se deben crear a partir de una rama (en el ejemplo llamaremos develop ), con una foto concreta y determinada de esa rama. Esta rama deber\u00e1 tener un nombre que describa lo que va a contener esa rama (en el ejemplo feature/xxx ). Y por lo general, esa rama se mergear\u00e1 con otra rama del repositorio, que puede ser la rama de origen o cualquier otra (en el ejemplo ser\u00e1 con la rama origen develop ). As\u00ed pues, podemos tener algo as\u00ed: Las acciones de crear ramas y mergear ramas est\u00e1n explicadas m\u00e1s abajo. En este punto solo es necesario que seas conocedor de: existen ramas maestras --> que contienen el c\u00f3digo completo de la aplicaci\u00f3n existen ramas de desarrollo --> que generalmente se crean de una rama maestra en un punto temporal concreto en alg\u00fan momento esas ramas de desarrollo se deben mergear en una rama maestra ojo cuidado , cuando hay varias personas en el equipo trabajando, habr\u00e1n varias ramas de desarrollo que nazcan de diferentes puntos temporales y que habr\u00e1 que tener en cuenta para posibles conflictos. Recuerda que no est\u00e1s solo programando, hay m\u00e1s gente modificando el c\u00f3digo.","title":"Ramas"},{"location":"appendix/git/#repositorios","text":"El otro concepto que debe queda claro, es el de repositorios. Por defecto, en Git, se trabaja con el repositorio local, en el que puedes crear ramas, modificar c\u00f3digo, mergear, etc. pero todos esos cambios que se hagan, ser\u00e1n todos en local, nadie m\u00e1s tendr\u00e1 acceso. Tambi\u00e9n existe el repositorio remoto, tambi\u00e9n llamado origin . Este repositorio es el que todos los integrantes del equipo utilizan como referencia. Existen acciones de Git que permite sincronizar los repositorios. En este punto solo es necesario que seas conocedor de: Los cambios que realices en local (en tu repositorio local) solo ser\u00e1n visibles por ti. Puedes crear ramas y borrarlas, pero solo tu las ver\u00e1s. Los cambios que se suban al repositorio remoto ser\u00e1n visibles para todos. Pueden haber ramas protegidas para que no se puedan modificar desde el equipo, t\u00edpicamente las ramas maestras. Estas ramas solo pueden modificarse previa validaci\u00f3n y pull request o merge request (depende de la aplicaci\u00f3n usada para Git). Existen acciones que permiten subir tus cambios de local a remoto. Recuerda que pueden existir ramas protegidas. Existen acciones que permiten actualizar tus ramas locales con los cambios remotos. Recuerda que no trabajas solo, es posible que tu repositorio local no est\u00e9 sincronizado, tus compa\u00f1eros han podido subir c\u00f3digo y deber\u00edas sincronizarte frecuentemente.","title":"Repositorios"},{"location":"appendix/git/#acciones-mas-tipicas","text":"En la Gu\u00eda r\u00e1pida puedes ver m\u00e1s detalle de estas acciones pero por lo general: Lo primero es descargarse una copia del repositorio con todas sus ramas. Se descargar\u00eda de remoto a local. A partir de este momento se trabaja en local. Cada nueva funcionalidad deber\u00eda tener su rama asociada, por tanto, lo l\u00f3gico es crear una rama de desarrollo (t\u00edpicamente feature/xxx ) a partir de una rama maestra (t\u00edpicamente develop o master ). Se trabajar\u00eda de forma local con esa rama. Es buena pr\u00e1ctica que si llevas mucho tiempo con la rama creada, de vez en cuando, sincronices tu repositorio local con lo que exista en el repositorio remoto. Adem\u00e1s, como es posible que la rama maestra de la que part\u00eda haya cambiado, esos cambios deber\u00edas llevarlos tambi\u00e9n a tu rama en desarrollo. Con esto consigues que tu punto temporal sea m\u00e1s moderno y tengas menos conflictos. Recuerda que no est\u00e1s solo trabajando. Cuando lo tengas listo y antes de subir nada, deber\u00edas realizar una \u00faltima sincronizaci\u00f3n de remoto a local. Despu\u00e9s deber\u00edas hacer un merge de tus ramas locales de desarrollo con las ramas maestras locales de las que partieron, por los posibles cambios que alguien hubiera podido subir. Por \u00faltimo, una vez tengas todo actualizado, ya puedes subir el c\u00f3digo al repositorio remoto (tu rama de desarrollo), y solicitar un pull request o merge request contra la rama maestra que quieras modificar. Alguien, diferente a ti, debe revisar esa solicitud y aprobarla antes de que se realice todo el merge correcto en remoto. Y vuelta a empezar.","title":"Acciones m\u00e1s t\u00edpicas"},{"location":"appendix/git/#funcionamiento-avanzado","text":"A continuaci\u00f3n vamos a describir estos mismos conceptos y acciones que hemos visto, pero m\u00e1s en profundidad para que veas como trabaja internamente Git. No es necesario que leas este punto, aunque es recomendable.","title":"Funcionamiento avanzado"},{"location":"appendix/git/#estructuras-y-flujo-de-trabajo","text":"Lo primero que debes conocer de Git es su funcionamiento b\u00e1sico de flujo de trabajo. Tu repositorio local est\u00e1 compuesto por tres \"estructuras\" que contienen los archivos y los cambios de los ficheros del repositorio. Working directory - Contiene los archivos con los que est\u00e1s trabajando localmente. Staging Area - Es un \u00e1rea intermedia donde vamos a\u00f1adiendo ficheros para ir agrupando modificaciones. Local Repository - Es el repositorio local donde tendr\u00e9mos el registro de todos los commits que hemos realizado. Por defecto apunta a HEAD que es el \u00faltimo commit registrado. Existen operaciones que nos permiten a\u00f1adir o borrar ficheros dentro de cada una de las estructuras desde otra estructura. As\u00ed pues, los comandos b\u00e1sicos dentro de nuestro repositorio local son los siguientes.","title":"Estructuras y flujo de trabajo"},{"location":"appendix/git/#add-y-commmit","text":"Puedes registrar los cambios realizados en tu working directory y a\u00f1adirlos al staging area usando el comando git add <filename> o si quieres a\u00f1adir todos los ficheros modificados git add . Este es el primer paso en el flujo de trabajo b\u00e1sico. Una vez tenemos los cambios registrados en el staging area podemos hacer un commit y persistirlos dentro del local repository mediante el comando git commit -m \"<Commit message>\" A partir de ese momento, los ficheros modificados y a\u00f1adidos al local repository se han persistido y se han a\u00f1adido a tu HEAD , aunque todav\u00eda siguen estando el local, no lo has enviado a ning\u00fan repositorio remoto.","title":"add y commmit"},{"location":"appendix/git/#reset","text":"De la misma manera que se han a\u00f1adido ficheros a staging area o a local repository , podemos retirarlos de estas estructuras y volver a recuperar los ficheros que ten\u00edamos anteriormente en el working directory . Por ejemplo, si nos hemos equivocado al incluir ficheros en un commit o simplemente queremos deshacer los cambios que hemos realizado bastar\u00eda con lanzar el comando git reset --hard o si queremos volver a un commit concreto git reset <COMMIT>","title":"reset"},{"location":"appendix/git/#trabajo-con-ramas","text":"Para complicarlo todo un poco m\u00e1s, el trabajo con git siempre se realiza mediante ramas. Estas ramas nos sirven para desarrollar funcionalidades aisladas unas de otras y poder hacer mezclas de c\u00f3digo de unas ramas a otras. Las ramas m\u00e1s comunes dentro de git suelen ser: master Esta ser\u00e1 la rama que contenga el c\u00f3digo fuente que tenemos en producci\u00f3n . release Esta ser\u00e1 la rama que contenga el c\u00f3digo fuente de cada una de las entregas parciales, no tiene porqu\u00e9 coincidir con la rama master . develop Esta ser\u00e1 la rama que contenga el c\u00f3digo fuente estable que est\u00e1 actualmente en desarrollo. feature/xxxx Estas ser\u00e1nn la rama que contengan el c\u00f3digo fuente de desarrollo de cada una de las funcionalidades. Generalmente estas ramas las crea cada desarrollador, las mantiene en local, hasta que las sube a remoto para realizar un merge a la rama develop . Siempre que trabajes con ramas debes tener en cuenta que al empezar tu desarrollo debes partir de una versi\u00f3n actualizada de la rama develop , y al terminar tu desarrollo debes solicitar un merge contra develop , para que tu funcionalidad est\u00e9 incorporada en la rama de desarrollo.","title":"Trabajo con ramas"},{"location":"appendix/git/#crear-ramas","text":"Crear ramas en local es tan sencillo como ejecutar este comando: git checkout -b <NOMBRE_RAMA> Eso nos crear\u00e1 una rama con el nombre que le hayamos dicho y mover\u00e1 el Working Directory a dicha rama.","title":"Crear ramas"},{"location":"appendix/git/#cambiar-de-rama","text":"Para cambiar de una rama a otra en local tan solo debemos ejecutar el comando: git checkout <NOMBRE_RAMA> La rama debe existir, sino se quejar\u00e1 de que no encuentra la rama. Este comando nos mover\u00e1 el Working Directory a la rama que le hayamos indicado. Si tenemos cambios en el Staging Area que no hayan sido movidos al Local Repository NO nos permitir\u00e1 movernos a la rama ya que perder\u00edamos los cambios. Antes de poder movernos debemos resetear los cambios o bien commitearlos .","title":"Cambiar de rama"},{"location":"appendix/git/#remote-repository","text":"Hasta aqu\u00ed es todo m\u00e1s o menos sencillo, trabajamos con nuestro repositorio local, creamos ramas, commiteamos o reseteamos cambios de c\u00f3digo, pero todo esto lo hacemos en local. Ahora necesitamos que esos cambios se distribuyan y puedan leerlos el resto de integrantes de nuestro equipo. Aqu\u00ed es donde entra en juego los repositorios remotos. Aqu\u00ed debemos tener MUY en cuenta que el c\u00f3digo que vamos a publicar en remoto SOLO es posible publicarlo desde el Local Repository . Es decir que para poder subir c\u00f3digo a remote antes debemos a\u00f1adirlo a Staging Area y hacer un commit para persistirlo en el Local Repository .","title":"Remote repository"},{"location":"appendix/git/#clone","text":"Antes de empezar a tocar c\u00f3digo del proyecto podemos crear un Local Repository vac\u00edo o bien bajarnos un proyecto que ya exista en un Remote Repository . Esta \u00faltima opci\u00f3n es la m\u00e1s normal. Para bajarnos un proyecto desde remoto tan solo hay que ejecutar el comando: git clone <REMOTE_URL> Esto te crear\u00e1 una carpeta con el nombre del proyecto y dentro se descargar\u00e1 la estructura completa del repositorio y te mover\u00e1 al Working Directory todo el c\u00f3digo de la rama por defecto para ese repositorio.","title":"clone"},{"location":"appendix/git/#envio-de-cambios","text":"El env\u00edo de datos a un Remote Repository tan solo es posible realizarlo desde Local Repository (por lo que antes deber\u00e1s commitear cambios all\u00ed), y se debe ejecutar el comando: git push origin","title":"env\u00edo de cambios"},{"location":"appendix/git/#actualizar-y-fusionar","text":"En ocasiones (bastante habitual) ser\u00e1 necesario descargarse los cambios de un Remote Repository para poder trabajar con la \u00faltima versi\u00f3n. Para ello debemos ejecutar el comando: git pull El propio git realizar\u00e1 la fusi\u00f3n local del c\u00f3digo remoto con el c\u00f3digo de tu Working Directory . Pero en ocasiones, si se ha modificado el mismo fichero en remoto y en local, se puede producir un Conflicto . No pasa nada, tan solo tendr\u00e1s que abrir dicho fichero en conflicto y resolverlo manualmente dejando el c\u00f3digo mezclado correcto. Tambi\u00e9n es posible que el c\u00f3digo que queramos actualizar est\u00e9 en otra rama, si lo que necesitamos es fusionar el c\u00f3digo de otra rama con la rama actual, nos situaremos en la rama destino y ejecutaremos el comando: git merge <RAMA_ORIGEN> Esto har\u00e1 lo mismo que un pull en local y fusionar\u00e1 el c\u00f3digo de una rama en otra. Tambi\u00e9n es posible que se produzcan conflictos que deber\u00e1s resolver de forma manual.","title":"actualizar y fusionar"},{"location":"appendix/git/#merge-request","text":"Ya por \u00faltimo, como estamos trabajando con ramas, lo \u00fanico que hacemos es subir y bajar ramas, pero en alg\u00fan momento alguien debe fusionar el contenido de una rama en la rama develop , release o master , que son las ramas principales. Se podr\u00eda directamente usar el comando merge para eso, pero en la mayor\u00eda de los repositorios no esta permitido subir el c\u00f3digo de una rama principal, por lo que no podr\u00e1s hacer un merge y subirlo. Para eso existe otra opci\u00f3n que es la de Merge Request . Esta opci\u00f3n permite a un usuario solicitar que otro usuario verifique y valide que el c\u00f3digo de su rama es correcto y lo puede fusionar en Remote Repository con una rama principal. Al ser una operaci\u00f3n delicada, tan solo es posible ejecutarla a trav\u00e9s de la web del repositorio git. Por lo general existir\u00e1 una opci\u00f3n / bot\u00f3n que permitir\u00e1 hacer un Merge Request con una rama origen y una rama destino (generalmente una de las principales). A esa petici\u00f3n se le asignar\u00e1 un validador y se enviar\u00e1. El usuario validador verificar\u00e1 si es correcto o no y validar\u00e1 o rechazar\u00e1 la petici\u00f3n. En caso de validarla se fusionar\u00e1 autom\u00e1ticamente en remoto y todos los usuarios podr\u00e1n descargar los nuevos cambios desde la rama. \u00a1Cuidado! Siempre antes de solicitar un Merge Request debes comprobar que tienes actualizada la rama comparandola con la rama remota que queremos mergear, en nuestro ejemplo ser\u00e1 develop . Para actualizarla tu rama hay que seguir tres pasos muy sencillos: Cambias a la rama develop y descargarnos los cambios del repositorio remoto (git pull) Cambias a tu rama y ejecutar un merge desde develop hacia nuestra rama (git merge develop) Subes tus cambios a remoto (git add, git commit y git push) y ya puedes solcitar el Merge Request","title":"Merge Request"},{"location":"appendix/git/#guia-rapida","text":"Los pasos b\u00e1sicos de utilizaci\u00f3n de git son sencillos. Primero nos bajamos el repositorio o lo creamos en local mediante los comandos git clone o git init Una vez estamos trabajando con nuestro repositorio local, cada vez que vayamos a comenzar una funcionalidad nueva, debemos crear una rama nueva siempre partiendo desde una rama maestra mediante el comando: (en nuestro ejemplo la rama maestra ser\u00e1 develop ) git checkout -b <rama> Cuando tengamos implementados los cambios que queremos realizar, hay que subirlos al staging y luego persistirlos en nuestro repositorio local. Esto lo hacemos con el comando git add . git commit -m \"<Commit message>\" Siempre antes de subir los cambios al repositorio remoto, hay que comprobar que tenemos actualizada nuestra rama comparandola con la rama remota que queremos mergear, en nuestro ejemplo ser\u00e1 develop . Por tanto tenemos que cambiar a la rama develop , descargarnos los cambios del repositorio remoto, volver a cambiar a nuestra rama y ejecutar un merge desde develop hacia nuestra rama, ejecutando estos comandos git checkout develop git pull git checkout <rama> git merge develop Ahora que ya tenemos actualizadas las ramas, tan solo nos basta subir nuestra rama a remoto, con el comando git push --set-upstream origin <rama> Por \u00faltimo accedemos al cliente web del repositorio y solicitamos un merge request contra develop . Para que sea validado y aprobado por otro compa\u00f1ero del equipo. Si en alg\u00fan momento necesitamos modificar nuestro c\u00f3digo del merge request antes de que haya sido aprobado, nos basta con repetir los pasos anteriores git add . git commit -m \"<Commit message>\" git push origin Una vez hayamos terminado el desarrollo y vayamos a empezar una nueva funcionalidad, volveremos al punto 2 de este listado y comenzaremos de nuevo los comando. Debemos recordad que tenemos que partir siempre de la rama develop y adem\u00e1s debe estar actualizada git pull .","title":"Gu\u00eda r\u00e1pida"},{"location":"appendix/jpa/","text":"Funcionamiento Spring Data Este anexo no pretende explicar el funcionamiento interno de Spring Data, simplemente conocer un poco como utilizarlo y algunos peque\u00f1os tips que pueden ser interesantes. Funcionamiento b\u00e1sico Lo primero que deber\u00edas tener claro, es que hagas lo que hagas, al final todo termina lanzando una query nativa sobre la BBDD. Da igual que uses cualquier tipo de acelerador (luego veremos alguno), ya que al final Spring Data termina convirtiendo lo que hayas programado en una query nativa. Cuanta m\u00e1s informaci\u00f3n le proporciones a Spring Data, tendr\u00e1s m\u00e1s control sobre la query final, pero m\u00e1s dificil ser\u00e1 de mantener. Lo mejor es utilizar, siempre que se pueda, todos los automatismos y automagias posibles y dejar que Spring haga su faena. Habr\u00e1 ocasiones en que esto no nos sirva, en ese momento tendremos que decidir si queremos bajar el nivel de implementaci\u00f3n o queremos utilizar otra alternativa como procesos por streams. Derived Query Methods Para la realizaci\u00f3n de consultas a la base de datos, Spring Data nos ofrece un sencillo mecanismo que consiste en crear definiciones de m\u00e9todos con una sintaxis especifica, para luego traducirlas autom\u00e1ticamente a consultas nativas, por parte de Spring Data. Esto es muy \u00fatil, ya que convierte a la aplicaci\u00f3n en agn\u00f3sticos de la tecnolog\u00eda de BBDD utilizada y podemos migrar con facilidad entre las muchas soluciones disponibles en el mercado, delegando esta tarea en Spring. Esta es la opci\u00f3n m\u00e1s indicada en la mayor\u00eda de los casos, siempre que puedas deber\u00edas utilizar esta forma de realizar las consultas. Como parte negativa, en algunos casos en consultas m\u00e1s complejas la definici\u00f3n de los m\u00e9todos puede extenderse demasiado dificultando la lectura del c\u00f3digo. De esto tenemos alg\u00fan ejemplo por el tutorial, en el repositorio de GameRepository . Siguiendo el ejemplo del tutorial, si tuvieramos que recuperar los Game por el nombre del juego, se podr\u00eda crear un m\u00e9todo en el GameRepository de esta forma: List < Game > findByName ( String name ); Spring Data entender\u00eda que quieres recuperar un listado de Game que est\u00e1n filtrados por su propiedad Name y generar\u00eda la consulta SQL de forma autom\u00e1tica, sin tener que implementar nada. Se pueden contruir muchos m\u00e9todos diferentes, te recomiendo que leas un peque\u00f1o tutorial de Baeldung y profundices con la documentaci\u00f3n oficial donde podr\u00e1s ver todas las opciones. Anotaci\u00f3n @Query Otra forma de realizar consultas, esta vez menos autom\u00e1tica y m\u00e1s cercana a SQL, es la anotaci\u00f3n @Query. Existen dos opciones a la hora de usar la anotaci\u00f3n @Query . Esta anotaci\u00f3n ya la hemos usado en el tutorial, dentro del GameRepository . En primer lugar tenemos las consultas JPQL. Estas guardan un parecido con el lenguaje SQL pero al igual que en el caso anterior, son traducidas por Spring Data a la consulta final nativa. Su uso no est\u00e1 recomendado ya que estamos a\u00f1adiendo un nivel de concreci\u00f3n y por tanto estamos aumentando la complejidad del c\u00f3digo. Aun as\u00ed, es otra forma de generar consultas. Por otra parte, tambi\u00e9n es posible generar consultas nativas directamente dentro de esta anotaci\u00f3n interactuando de forma directa con la base de datos. Esta pr\u00e1ctica es altamente desaconsejable ya que crea acoplamientos con la tecnolog\u00eda de la BBDD utilizada y es una fuente de errores. Puedes ver m\u00e1s informaci\u00f3n de esta anotaci\u00f3n desde este peque\u00f1o tutorial de Baeldung . Acelerando las consultas En muchas ocasiones necesitamos obtener informaci\u00f3n que no est\u00e1 en una \u00fanica tabla por motivos de dise\u00f1o de la base de datos. Debemos plasmar esta casu\u00edstica con cuidado a nuestro modelo relacional para obtener resultados \u00f3ptimos en cuanto al rendimiento. Para ilustrar el caso vamos a recuperar los objetos utilizados en el tutorial Author , Gategory y Game . Si recuerdas, tenemos que un Game tiene asociado un Author y tiene asociada una Gategory . Cuando utilizamos el m\u00e9todo de filtrado find que construimos en el GameRepository , vemos que Spring Data traduce la @Query que hab\u00edamos dise\u00f1ado en una query SQL para recuperar los juegos. @Query ( \"select g from Game g where (:title is null or g.title like '%'||:title||'%') and (:category is null or g.category.id = :category)\" ) List < Game > find ( @Param ( \"title\" ) String title , @Param ( \"category\" ) Long category ); Esta @Query es la que utiliza Spring Data para traducir las propiedades a objetos de BBDD y mapear los resultados a objetos Java. Si tenemos activada la property spring.jpa.show-sql=true podremos ver las queries que est\u00e1 generando Spring Data. El resultado es el siguiente. Hibernate : select game0_ . id as id1_2_ , game0_ . age as age2_2_ , game0_ . author_id as author_i4_2_ , game0_ . category_id as category5_2_ , game0_ . title as title3_2_ from game game0_ where ( ? is null or game0_ . title like ( '%' ||?|| '%' )) and ( ? is null or game0_ . category_id =? ) Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Hibernate : select category0_ . id as id1_1_0_ , category0_ . name as name2_1_0_ from category category0_ where category0_ . id =? Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Hibernate : select category0_ . id as id1_1_0_ , category0_ . name as name2_1_0_ from category category0_ where category0_ . id =? Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Si te fijas ha generado una query SQL para filtrar los Game , pero luego cuando ha intentado construir los objetos Java, ha tenido que lanzar una serie de queries para recuperar los diferentes Author y Category a trav\u00e9s de sus id . Obviamente Spring Data es muy lista y cachea los resultados obtenidos para no tener que recuperarlos n veces, pero aun as\u00ed, lanza unas cuantas consultas. Esto penaliza el rendimiento de nuestra operaci\u00f3n, ya que tiene que lanzar n queries a BBDD que, aunque son muy \u00f3ptimas, incrementan unos milisegundos el tiempo total. Para evitar esta circunstancia, disponemos de la anotaci\u00f3n denominada @EnitityGraph la cual proporciona directrices a Spring Data sobre la forma en la que deseamos realizar la consulta, permitiendo que realice agrupaciones y uniones de tablas en una \u00fanica query que, aun siendo mas compleja, en muchos casos el rendimiento es mucho mejor que realizar m\u00faltiples interacciones con la BBDD. Siguiendo el ejemplo anterior podr\u00edamos utilizar la anotaci\u00f3n de esta forma: @Query ( \"select g from Game g where (:title is null or g.title like '%'||:title||'%') and (:category is null or g.category.id = :category)\" ) @EntityGraph ( attributePaths = { \"category\" , \"author\" }) List < Game > find ( @Param ( \"title\" ) String title , @Param ( \"category\" ) Long category ); Donde le estamos diciendo a Spring Data que cuando realice la query, haga el cruce con las propiedades category y author , que a su vez son entidades y por tanto mapean dos tablas de BBDD. El resultado es el siguiente: Hibernate : select game0_ . id as id1_2_0_ , category1_ . id as id1_1_1_ , author2_ . id as id1_0_2_ , game0_ . age as age2_2_0_ , game0_ . author_id as author_i4_2_0_ , game0_ . category_id as category5_2_0_ , game0_ . title as title3_2_0_ , category1_ . name as name2_1_1_ , author2_ . name as name2_0_2_ , author2_ . nationality as national3_0_2_ from game game0_ left outer join category category1_ on game0_ . category_id = category1_ . id left outer join author author2_ on game0_ . author_id = author2_ . id where ( ? is null or game0_ . title like ( '%' ||?|| '%' )) and ( ? is null or game0_ . category_id =? ) Una \u00fanica query, que es m\u00e1s compleja que la anterior, ya que hace dos cruces con tablas de BBDD, pero que nos evita tener que lanzar n queries diferentes para recuperar Author y Category . Generalmente, el uso de @EntityGraph acelera mucho los resultados y es muy recomendable utilizarlo para realizar los cruces inline. Se puede utilizar tanto con @Query como con Derived Query Methods . Puedes leer m\u00e1s informaci\u00f3n en este peque\u00f1o tutorial de Baeldung . Alternativa de Streams A partir de Java 8 disponemos de los Java Streams. Se trata de una herramienta que nos permite multitud de opciones relativas tratamiento y trasformaci\u00f3n de los datos manejados. En este apartado \u00fanicamente se menciona debido a que en muchas ocasiones cuando nos enfrentamos a consultas complejas, puede ser beneficioso evitar ofuscar las consultas y realizar las trasformaciones necesarias mediante los Streams. Un ejemplo de uso pr\u00e1ctico podr\u00eda ser, evitar usar la cl\u00e1usula IN de SQL en una determinada consulta que podr\u00eda penalizar notablemente el rendimiento de las consultas. En vez de eso se podr\u00eda utilizar el m\u00e9todo de JAVA filter sobre el conjunto de elementos para obtener el mismo resultado. Puedes leer m\u00e1s informaci\u00f3n en el tutorial de Baeldung . Specifications En algunos casos puede ocurrir que con las herramientas descritas anteriormente no tengamos suficiente alcance, bien porque las definiciones de los m\u00e9todos se complican y alargan demasiado o debido a que la consulta es demasiado gen\u00e9rica como para realizarlo de este modo. Para este caso se dispone de las Specifications que nos proveen de una forma de escribir consultas reutilizables mediante una API que ofrece una forma fluida de crear y combinar consultas complejas. Un ejemplo de caso de uso podr\u00eda ser un CRUD de una determinada entidad que debe poder filtrar por todos los atributos de esta, donde el tipo de filtrado viene especificado en la propia consulta y no siempre es requerido. En este caso no podr\u00edamos construir una consulta basada en definir un determinado m\u00e9todo ya no conocemos de ante mano que filtros ni que atributos vamos a recibir y deberemos recurrir al uso de las Specifications. Puedes leer m\u00e1s informaci\u00f3n en el tutorial de Baeldung .","title":"Spring Data: JPA"},{"location":"appendix/jpa/#funcionamiento-spring-data","text":"Este anexo no pretende explicar el funcionamiento interno de Spring Data, simplemente conocer un poco como utilizarlo y algunos peque\u00f1os tips que pueden ser interesantes.","title":"Funcionamiento Spring Data"},{"location":"appendix/jpa/#funcionamiento-basico","text":"Lo primero que deber\u00edas tener claro, es que hagas lo que hagas, al final todo termina lanzando una query nativa sobre la BBDD. Da igual que uses cualquier tipo de acelerador (luego veremos alguno), ya que al final Spring Data termina convirtiendo lo que hayas programado en una query nativa. Cuanta m\u00e1s informaci\u00f3n le proporciones a Spring Data, tendr\u00e1s m\u00e1s control sobre la query final, pero m\u00e1s dificil ser\u00e1 de mantener. Lo mejor es utilizar, siempre que se pueda, todos los automatismos y automagias posibles y dejar que Spring haga su faena. Habr\u00e1 ocasiones en que esto no nos sirva, en ese momento tendremos que decidir si queremos bajar el nivel de implementaci\u00f3n o queremos utilizar otra alternativa como procesos por streams.","title":"Funcionamiento b\u00e1sico"},{"location":"appendix/jpa/#derived-query-methods","text":"Para la realizaci\u00f3n de consultas a la base de datos, Spring Data nos ofrece un sencillo mecanismo que consiste en crear definiciones de m\u00e9todos con una sintaxis especifica, para luego traducirlas autom\u00e1ticamente a consultas nativas, por parte de Spring Data. Esto es muy \u00fatil, ya que convierte a la aplicaci\u00f3n en agn\u00f3sticos de la tecnolog\u00eda de BBDD utilizada y podemos migrar con facilidad entre las muchas soluciones disponibles en el mercado, delegando esta tarea en Spring. Esta es la opci\u00f3n m\u00e1s indicada en la mayor\u00eda de los casos, siempre que puedas deber\u00edas utilizar esta forma de realizar las consultas. Como parte negativa, en algunos casos en consultas m\u00e1s complejas la definici\u00f3n de los m\u00e9todos puede extenderse demasiado dificultando la lectura del c\u00f3digo. De esto tenemos alg\u00fan ejemplo por el tutorial, en el repositorio de GameRepository . Siguiendo el ejemplo del tutorial, si tuvieramos que recuperar los Game por el nombre del juego, se podr\u00eda crear un m\u00e9todo en el GameRepository de esta forma: List < Game > findByName ( String name ); Spring Data entender\u00eda que quieres recuperar un listado de Game que est\u00e1n filtrados por su propiedad Name y generar\u00eda la consulta SQL de forma autom\u00e1tica, sin tener que implementar nada. Se pueden contruir muchos m\u00e9todos diferentes, te recomiendo que leas un peque\u00f1o tutorial de Baeldung y profundices con la documentaci\u00f3n oficial donde podr\u00e1s ver todas las opciones.","title":"Derived Query Methods"},{"location":"appendix/jpa/#anotacion-query","text":"Otra forma de realizar consultas, esta vez menos autom\u00e1tica y m\u00e1s cercana a SQL, es la anotaci\u00f3n @Query. Existen dos opciones a la hora de usar la anotaci\u00f3n @Query . Esta anotaci\u00f3n ya la hemos usado en el tutorial, dentro del GameRepository . En primer lugar tenemos las consultas JPQL. Estas guardan un parecido con el lenguaje SQL pero al igual que en el caso anterior, son traducidas por Spring Data a la consulta final nativa. Su uso no est\u00e1 recomendado ya que estamos a\u00f1adiendo un nivel de concreci\u00f3n y por tanto estamos aumentando la complejidad del c\u00f3digo. Aun as\u00ed, es otra forma de generar consultas. Por otra parte, tambi\u00e9n es posible generar consultas nativas directamente dentro de esta anotaci\u00f3n interactuando de forma directa con la base de datos. Esta pr\u00e1ctica es altamente desaconsejable ya que crea acoplamientos con la tecnolog\u00eda de la BBDD utilizada y es una fuente de errores. Puedes ver m\u00e1s informaci\u00f3n de esta anotaci\u00f3n desde este peque\u00f1o tutorial de Baeldung .","title":"Anotaci\u00f3n @Query"},{"location":"appendix/jpa/#acelerando-las-consultas","text":"En muchas ocasiones necesitamos obtener informaci\u00f3n que no est\u00e1 en una \u00fanica tabla por motivos de dise\u00f1o de la base de datos. Debemos plasmar esta casu\u00edstica con cuidado a nuestro modelo relacional para obtener resultados \u00f3ptimos en cuanto al rendimiento. Para ilustrar el caso vamos a recuperar los objetos utilizados en el tutorial Author , Gategory y Game . Si recuerdas, tenemos que un Game tiene asociado un Author y tiene asociada una Gategory . Cuando utilizamos el m\u00e9todo de filtrado find que construimos en el GameRepository , vemos que Spring Data traduce la @Query que hab\u00edamos dise\u00f1ado en una query SQL para recuperar los juegos. @Query ( \"select g from Game g where (:title is null or g.title like '%'||:title||'%') and (:category is null or g.category.id = :category)\" ) List < Game > find ( @Param ( \"title\" ) String title , @Param ( \"category\" ) Long category ); Esta @Query es la que utiliza Spring Data para traducir las propiedades a objetos de BBDD y mapear los resultados a objetos Java. Si tenemos activada la property spring.jpa.show-sql=true podremos ver las queries que est\u00e1 generando Spring Data. El resultado es el siguiente. Hibernate : select game0_ . id as id1_2_ , game0_ . age as age2_2_ , game0_ . author_id as author_i4_2_ , game0_ . category_id as category5_2_ , game0_ . title as title3_2_ from game game0_ where ( ? is null or game0_ . title like ( '%' ||?|| '%' )) and ( ? is null or game0_ . category_id =? ) Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Hibernate : select category0_ . id as id1_1_0_ , category0_ . name as name2_1_0_ from category category0_ where category0_ . id =? Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Hibernate : select category0_ . id as id1_1_0_ , category0_ . name as name2_1_0_ from category category0_ where category0_ . id =? Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Si te fijas ha generado una query SQL para filtrar los Game , pero luego cuando ha intentado construir los objetos Java, ha tenido que lanzar una serie de queries para recuperar los diferentes Author y Category a trav\u00e9s de sus id . Obviamente Spring Data es muy lista y cachea los resultados obtenidos para no tener que recuperarlos n veces, pero aun as\u00ed, lanza unas cuantas consultas. Esto penaliza el rendimiento de nuestra operaci\u00f3n, ya que tiene que lanzar n queries a BBDD que, aunque son muy \u00f3ptimas, incrementan unos milisegundos el tiempo total. Para evitar esta circunstancia, disponemos de la anotaci\u00f3n denominada @EnitityGraph la cual proporciona directrices a Spring Data sobre la forma en la que deseamos realizar la consulta, permitiendo que realice agrupaciones y uniones de tablas en una \u00fanica query que, aun siendo mas compleja, en muchos casos el rendimiento es mucho mejor que realizar m\u00faltiples interacciones con la BBDD. Siguiendo el ejemplo anterior podr\u00edamos utilizar la anotaci\u00f3n de esta forma: @Query ( \"select g from Game g where (:title is null or g.title like '%'||:title||'%') and (:category is null or g.category.id = :category)\" ) @EntityGraph ( attributePaths = { \"category\" , \"author\" }) List < Game > find ( @Param ( \"title\" ) String title , @Param ( \"category\" ) Long category ); Donde le estamos diciendo a Spring Data que cuando realice la query, haga el cruce con las propiedades category y author , que a su vez son entidades y por tanto mapean dos tablas de BBDD. El resultado es el siguiente: Hibernate : select game0_ . id as id1_2_0_ , category1_ . id as id1_1_1_ , author2_ . id as id1_0_2_ , game0_ . age as age2_2_0_ , game0_ . author_id as author_i4_2_0_ , game0_ . category_id as category5_2_0_ , game0_ . title as title3_2_0_ , category1_ . name as name2_1_1_ , author2_ . name as name2_0_2_ , author2_ . nationality as national3_0_2_ from game game0_ left outer join category category1_ on game0_ . category_id = category1_ . id left outer join author author2_ on game0_ . author_id = author2_ . id where ( ? is null or game0_ . title like ( '%' ||?|| '%' )) and ( ? is null or game0_ . category_id =? ) Una \u00fanica query, que es m\u00e1s compleja que la anterior, ya que hace dos cruces con tablas de BBDD, pero que nos evita tener que lanzar n queries diferentes para recuperar Author y Category . Generalmente, el uso de @EntityGraph acelera mucho los resultados y es muy recomendable utilizarlo para realizar los cruces inline. Se puede utilizar tanto con @Query como con Derived Query Methods . Puedes leer m\u00e1s informaci\u00f3n en este peque\u00f1o tutorial de Baeldung .","title":"Acelerando las consultas"},{"location":"appendix/jpa/#alternativa-de-streams","text":"A partir de Java 8 disponemos de los Java Streams. Se trata de una herramienta que nos permite multitud de opciones relativas tratamiento y trasformaci\u00f3n de los datos manejados. En este apartado \u00fanicamente se menciona debido a que en muchas ocasiones cuando nos enfrentamos a consultas complejas, puede ser beneficioso evitar ofuscar las consultas y realizar las trasformaciones necesarias mediante los Streams. Un ejemplo de uso pr\u00e1ctico podr\u00eda ser, evitar usar la cl\u00e1usula IN de SQL en una determinada consulta que podr\u00eda penalizar notablemente el rendimiento de las consultas. En vez de eso se podr\u00eda utilizar el m\u00e9todo de JAVA filter sobre el conjunto de elementos para obtener el mismo resultado. Puedes leer m\u00e1s informaci\u00f3n en el tutorial de Baeldung .","title":"Alternativa de Streams"},{"location":"appendix/jpa/#specifications","text":"En algunos casos puede ocurrir que con las herramientas descritas anteriormente no tengamos suficiente alcance, bien porque las definiciones de los m\u00e9todos se complican y alargan demasiado o debido a que la consulta es demasiado gen\u00e9rica como para realizarlo de este modo. Para este caso se dispone de las Specifications que nos proveen de una forma de escribir consultas reutilizables mediante una API que ofrece una forma fluida de crear y combinar consultas complejas. Un ejemplo de caso de uso podr\u00eda ser un CRUD de una determinada entidad que debe poder filtrar por todos los atributos de esta, donde el tipo de filtrado viene especificado en la propia consulta y no siempre es requerido. En este caso no podr\u00edamos construir una consulta basada en definir un determinado m\u00e9todo ya no conocemos de ante mano que filtros ni que atributos vamos a recibir y deberemos recurrir al uso de las Specifications. Puedes leer m\u00e1s informaci\u00f3n en el tutorial de Baeldung .","title":"Specifications"},{"location":"appendix/rest/","text":"Breve detalle sobre REST Antes de empezar vamos a hablar de operaciones REST. Estas operaciones son el punto de entrada a nuestra aplicaci\u00f3n y se pueden diferenciar dos claros elementos: Ruta hacia el recurso, lo que viene siendo la URL. Acci\u00f3n a realizar sobre el recurso, lo que viene siendo la operaci\u00f3n HTTP o el verbo. Ruta del recurso La ruta del recurso nos indica entre otras cosas, el endpoint y su posible jerarqu\u00eda sobre la que se va a realizar la operaci\u00f3n. Debe tener una ra\u00edz de recurso y si se requiere navegar por el recursos, la jerarqu\u00eda ir\u00e1 separada por barras. La URL nunca deber\u00eda tener verbos o acciones solamente recursos, identificadores o atributos. Por ejemplo en nuestro caso de Categor\u00edas , ser\u00edan correctas las siguientes rutas: /category /category/3 /category/?name=Dados Sin embargo, no ser\u00edan del todo correctas las rutas: /getCategory /findCategories /saveCategory /category/save A menudo, se integran datos identificadores o atributos de b\u00fasqueda dentro de la propia ruta. Podr\u00edamos definir la operaci\u00f3n category/3 para referirse a la Categor\u00eda con ID = 3, o category/?name=Dados para referirse a las categor\u00edas con nombre = Dados. A veces, estos datos tambi\u00e9n pueden ir como atributos en la URL o en el cuerpo de la petici\u00f3n, aunque se recomienda que siempre que sean identificadores vayan determinados en la propia URL. Si el dominio categor\u00eda tuviera hijos o relaciones con alg\u00fan otro dominio se podr\u00eda a\u00f1adir esas jerarqu\u00eda a la URL. Por ejemplo podr\u00edamos tener category/3/child/2 para referirnos al hijo de ID = 2 que tiene la Categor\u00eda de ID = 3, y as\u00ed sucesivamente. Acci\u00f3n sobre el recurso La acci\u00f3n sobre el recurso se determina mediante la operaci\u00f3n o verbo HTTP que se utiliza en el endpoint. Los verbos m\u00e1s usados ser\u00edan: GET . Cuando se quiere recuperar un recursos. POST . Cuando se quiere crear un recurso. Aunque a menudo se utiliza para realizar otras acciones de b\u00fasqueda o validaci\u00f3n. PUT . Cuando se quiere actualizar o modificar un recurso. Aunque a menudo se utiliza una sola operaci\u00f3n para crear o actualizar. En ese caso se utilizar\u00eda solamente POST . DELETE . Cuando se quiere eliminar un recurso. De esta forma tendr\u00edamos: GET /category/3 . Realizar\u00eda un acceso para recuperar la categor\u00eda 3. POST o PUT /category/3 . Realizar\u00eda un acceso para crear o modificar la categor\u00eda 3. Los datos a modificar deber\u00edan ir en el body. DELETE /category/3 . Realizar\u00eda un acceso para borrar la categor\u00eda 3. GET /category/?name=Dados . Realizar\u00eda un acceso para recuperar las categor\u00edas que tengan nombre = Dados. Excepciones a la regla A veces hay que ejecutar una operaci\u00f3n que no es 'estandar' en cuanto a verbos HTTP. Para ese caso, deberemos clarificar en la URL la acci\u00f3n que se debe realizar y si vamos a enviar datos deber\u00eda ser de tipo POST mientras que si simplemente se requiere una contestaci\u00f3n sin enviar datos ser\u00e1 de tipo GET . Por ejemplo POST /category/3/validate realizar\u00eda un acceso para ejecutar una validaci\u00f3n sobre los datos enviados en el body de la categor\u00eda 3.","title":"API Rest"},{"location":"appendix/rest/#breve-detalle-sobre-rest","text":"Antes de empezar vamos a hablar de operaciones REST. Estas operaciones son el punto de entrada a nuestra aplicaci\u00f3n y se pueden diferenciar dos claros elementos: Ruta hacia el recurso, lo que viene siendo la URL. Acci\u00f3n a realizar sobre el recurso, lo que viene siendo la operaci\u00f3n HTTP o el verbo.","title":"Breve detalle sobre REST"},{"location":"appendix/rest/#ruta-del-recurso","text":"La ruta del recurso nos indica entre otras cosas, el endpoint y su posible jerarqu\u00eda sobre la que se va a realizar la operaci\u00f3n. Debe tener una ra\u00edz de recurso y si se requiere navegar por el recursos, la jerarqu\u00eda ir\u00e1 separada por barras. La URL nunca deber\u00eda tener verbos o acciones solamente recursos, identificadores o atributos. Por ejemplo en nuestro caso de Categor\u00edas , ser\u00edan correctas las siguientes rutas: /category /category/3 /category/?name=Dados Sin embargo, no ser\u00edan del todo correctas las rutas: /getCategory /findCategories /saveCategory /category/save A menudo, se integran datos identificadores o atributos de b\u00fasqueda dentro de la propia ruta. Podr\u00edamos definir la operaci\u00f3n category/3 para referirse a la Categor\u00eda con ID = 3, o category/?name=Dados para referirse a las categor\u00edas con nombre = Dados. A veces, estos datos tambi\u00e9n pueden ir como atributos en la URL o en el cuerpo de la petici\u00f3n, aunque se recomienda que siempre que sean identificadores vayan determinados en la propia URL. Si el dominio categor\u00eda tuviera hijos o relaciones con alg\u00fan otro dominio se podr\u00eda a\u00f1adir esas jerarqu\u00eda a la URL. Por ejemplo podr\u00edamos tener category/3/child/2 para referirnos al hijo de ID = 2 que tiene la Categor\u00eda de ID = 3, y as\u00ed sucesivamente.","title":"Ruta del recurso"},{"location":"appendix/rest/#accion-sobre-el-recurso","text":"La acci\u00f3n sobre el recurso se determina mediante la operaci\u00f3n o verbo HTTP que se utiliza en el endpoint. Los verbos m\u00e1s usados ser\u00edan: GET . Cuando se quiere recuperar un recursos. POST . Cuando se quiere crear un recurso. Aunque a menudo se utiliza para realizar otras acciones de b\u00fasqueda o validaci\u00f3n. PUT . Cuando se quiere actualizar o modificar un recurso. Aunque a menudo se utiliza una sola operaci\u00f3n para crear o actualizar. En ese caso se utilizar\u00eda solamente POST . DELETE . Cuando se quiere eliminar un recurso. De esta forma tendr\u00edamos: GET /category/3 . Realizar\u00eda un acceso para recuperar la categor\u00eda 3. POST o PUT /category/3 . Realizar\u00eda un acceso para crear o modificar la categor\u00eda 3. Los datos a modificar deber\u00edan ir en el body. DELETE /category/3 . Realizar\u00eda un acceso para borrar la categor\u00eda 3. GET /category/?name=Dados . Realizar\u00eda un acceso para recuperar las categor\u00edas que tengan nombre = Dados. Excepciones a la regla A veces hay que ejecutar una operaci\u00f3n que no es 'estandar' en cuanto a verbos HTTP. Para ese caso, deberemos clarificar en la URL la acci\u00f3n que se debe realizar y si vamos a enviar datos deber\u00eda ser de tipo POST mientras que si simplemente se requiere una contestaci\u00f3n sin enviar datos ser\u00e1 de tipo GET . Por ejemplo POST /category/3/validate realizar\u00eda un acceso para ejecutar una validaci\u00f3n sobre los datos enviados en el body de la categor\u00eda 3.","title":"Acci\u00f3n sobre el recurso"},{"location":"appendix/tdd/","text":"TDD (Test Driven Development) Se trata de una pr\u00e1ctica de programaci\u00f3n que consiste en escribir primero las pruebas (generalmente unitarias), despu\u00e9s escribir el c\u00f3digo fuente que pase la prueba satisfactoriamente y, por \u00faltimo, refactorizar el c\u00f3digo escrito. Este ciclo se suele representar con la siguiente imagen: Con esta pr\u00e1ctica se consigue entre otras cosas: un c\u00f3digo m\u00e1s robusto, m\u00e1s seguro, m\u00e1s mantenible y una mayor rapidez en el desarrollo. Los pasos que se siguen son: Primero hay que escribir el test o los tests que cubran la funcionalidad que voy a implementar. Los test no solo deben probar los casos correctos, sino que deben probar los casos err\u00f3neos e incluso los casos en los que se provoca una excepci\u00f3n. Cuantos m\u00e1s test hagas, mejor probada y m\u00e1s robusta ser\u00e1 tu aplicaci\u00f3n. Adem\u00e1s, como efecto colateral, al escribir el test est\u00e1s pensando el dise\u00f1o de c\u00f3mo va a funcionar la aplicaci\u00f3n. En vez de liarte a programar como loco, te est\u00e1s forzando a pensar primero y ver cual es la mejor soluci\u00f3n. Por ejemplo para implementar una operaci\u00f3n de calculadora primero piensas en qu\u00e9 es lo que necesitar\u00e1s: una clase Calculadora con un m\u00e9todo que se llame Suma y que tenga dos par\u00e1metros. El segundo paso una vez tengo definido el test, que evidentemente fallar\u00e1 (e incluso a menudo ni siquiera compilar\u00e1), es implementar el c\u00f3digo necesario para que los tests funcionen. Aqu\u00ed muchas veces pecamos de querer implementar demasiadas cosas o pensando en que en un futuro necesitaremos modificar ciertas partes y lo dejamos ya preparado para ello. Hay que ir con mucho cuidado con las optimizaciones prematuras , a menudo no son necesarias y solo hacen que dificultar nuestro c\u00f3digo. Piensa en construir el m\u00ednimo c\u00f3digo que haga que tus tests funcionen correctamente. Adem\u00e1s, no es necesario que sea un c\u00f3digo demasiado purista y limpio. El \u00faltimo paso y a menudo el m\u00e1s olvidado es el Refactor . Una vez te has asegurado que tu c\u00f3digo funciona y que los tests funcionan correctamente (ojo no solo los tuyos sino todos los que ya existan en la aplicaci\u00f3n) llega el paso de sacarle brillo a tu c\u00f3digo. En este paso tienes que intentar mejorar tu c\u00f3digo, evitar duplicidades, evitar malos olores de programaci\u00f3n, eliminar posibles malos usos del lenguaje, etc. En definitiva que tu c\u00f3digo se lea y se entienda mejor. Si seguimos estos pasos a la hora de programar, nuestra aplicaci\u00f3n estar\u00e1 muy bien testada. Cada vez que hagamos un cambio tendremos una certeza muy elevada, de forma r\u00e1pida y sencilla, de si la aplicaci\u00f3n sigue funcionando o hemos roto algo. Y lo mejor de todo, las implementaciones que hagamos estar\u00e1n bien pensadas y dise\u00f1adas y acotadas realmente a lo que necesitamos.","title":"TDD"},{"location":"appendix/tdd/#tdd-test-driven-development","text":"Se trata de una pr\u00e1ctica de programaci\u00f3n que consiste en escribir primero las pruebas (generalmente unitarias), despu\u00e9s escribir el c\u00f3digo fuente que pase la prueba satisfactoriamente y, por \u00faltimo, refactorizar el c\u00f3digo escrito. Este ciclo se suele representar con la siguiente imagen: Con esta pr\u00e1ctica se consigue entre otras cosas: un c\u00f3digo m\u00e1s robusto, m\u00e1s seguro, m\u00e1s mantenible y una mayor rapidez en el desarrollo. Los pasos que se siguen son: Primero hay que escribir el test o los tests que cubran la funcionalidad que voy a implementar. Los test no solo deben probar los casos correctos, sino que deben probar los casos err\u00f3neos e incluso los casos en los que se provoca una excepci\u00f3n. Cuantos m\u00e1s test hagas, mejor probada y m\u00e1s robusta ser\u00e1 tu aplicaci\u00f3n. Adem\u00e1s, como efecto colateral, al escribir el test est\u00e1s pensando el dise\u00f1o de c\u00f3mo va a funcionar la aplicaci\u00f3n. En vez de liarte a programar como loco, te est\u00e1s forzando a pensar primero y ver cual es la mejor soluci\u00f3n. Por ejemplo para implementar una operaci\u00f3n de calculadora primero piensas en qu\u00e9 es lo que necesitar\u00e1s: una clase Calculadora con un m\u00e9todo que se llame Suma y que tenga dos par\u00e1metros. El segundo paso una vez tengo definido el test, que evidentemente fallar\u00e1 (e incluso a menudo ni siquiera compilar\u00e1), es implementar el c\u00f3digo necesario para que los tests funcionen. Aqu\u00ed muchas veces pecamos de querer implementar demasiadas cosas o pensando en que en un futuro necesitaremos modificar ciertas partes y lo dejamos ya preparado para ello. Hay que ir con mucho cuidado con las optimizaciones prematuras , a menudo no son necesarias y solo hacen que dificultar nuestro c\u00f3digo. Piensa en construir el m\u00ednimo c\u00f3digo que haga que tus tests funcionen correctamente. Adem\u00e1s, no es necesario que sea un c\u00f3digo demasiado purista y limpio. El \u00faltimo paso y a menudo el m\u00e1s olvidado es el Refactor . Una vez te has asegurado que tu c\u00f3digo funciona y que los tests funcionan correctamente (ojo no solo los tuyos sino todos los que ya existan en la aplicaci\u00f3n) llega el paso de sacarle brillo a tu c\u00f3digo. En este paso tienes que intentar mejorar tu c\u00f3digo, evitar duplicidades, evitar malos olores de programaci\u00f3n, eliminar posibles malos usos del lenguaje, etc. En definitiva que tu c\u00f3digo se lea y se entienda mejor. Si seguimos estos pasos a la hora de programar, nuestra aplicaci\u00f3n estar\u00e1 muy bien testada. Cada vez que hagamos un cambio tendremos una certeza muy elevada, de forma r\u00e1pida y sencilla, de si la aplicaci\u00f3n sigue funcionando o hemos roto algo. Y lo mejor de todo, las implementaciones que hagamos estar\u00e1n bien pensadas y dise\u00f1adas y acotadas realmente a lo que necesitamos.","title":"TDD (Test Driven Development)"},{"location":"appendix/springcloud/basic/","text":"Listado simple - Spring Boot A diferencia del tutorial b\u00e1sico de Spring Boot, donde constru\u00edamos una aplicaci\u00f3n monol\u00edtica, ahora vamos a construir multiples servicios por lo que necesitamos crear proyectos separados. Para la creaci\u00f3n de proyecto nos remitimos a la gu\u00eda de instalaci\u00f3n donde se detalla el proceso de creaci\u00f3n de nuevo proyecto Entorno de desarrollo Todos los pasos son exactamente iguales, lo \u00fanico que va a variar es el nombre de nuestro proyecto, que en este caso se va a llamar tutorial-category . El campo que debemos modificar es artifact en Spring Initilizr, el resto de campos se cambiaran autom\u00e1ticamente. Estructurar el c\u00f3digo y buenas pr\u00e1cticas Esta parte de tutorial es una ampliaci\u00f3n de la parte de backend con Spring Boot, por tanto no se ve a enfocar en las partes b\u00e1sicas aprendidas previamente, si no que se va a explicar el funcionamiento de los micro servicios aplicados al mismo caso de uso. Para cualquier duda sobre la estructura del c\u00f3digo y buenas pr\u00e1cticas, consultar el apartado de Estructura y buenas pr\u00e1cticas , ya que aplican a este caso en el mismo modo. C\u00f3digo Dado de vamos a implementar el micro servicio Spring Boot de Categor\u00edas , vamos a respetar la misma estructura del Listado simple de la version monol\u00edtica. Entity y Dto En primer lugar, vamos a crear la entidad y el DTO dentro del package com.ccsw.tutorialcategory.category.model . Ojo al package que lo hemos renombrado con respecto al listado monol\u00edtico. Category.java CategoryDto.java package com.ccsw.tutorialcategory.category.model ; import jakarta.persistence.* ; /** * @author ccsw * */ @Entity @Table ( name = \"category\" ) public class Category { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"name\" , nullable = false ) private String name ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } } package com.ccsw.tutorialcategory.category.model ; /** * @author ccsw * */ public class CategoryDto { private Long id ; private String name ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } } Repository, Service y Controller Posteriormente, emplazamos el resto de clases dentro del package com.ccsw.tutorialcategory.category . CategoryRepository.java CategoryService.java CategoryServiceImpl.java CategoryController.java package com.ccsw.tutorialcategory.category ; import com.ccsw.tutorialcategory.category.model.Category ; import org.springframework.data.repository.CrudRepository ; /** * @author ccsw * */ public interface CategoryRepository extends CrudRepository < Category , Long > { } package com.ccsw.tutorialcategory.category ; import com.ccsw.tutorialcategory.category.model.Category ; import com.ccsw.tutorialcategory.category.model.CategoryDto ; import java.util.List ; /** * @author ccsw * */ public interface CategoryService { /** * Recupera una {@link Category} a partir de su ID * * @param id PK de la entidad * @return {@link Category} */ Category get ( Long id ); /** * M\u00e9todo para recuperar todas las {@link Category} * * @return {@link List} de {@link Category} */ List < Category > findAll (); /** * M\u00e9todo para crear o actualizar una {@link Category} * * @param id PK de la entidad * @param dto datos de la entidad */ void save ( Long id , CategoryDto dto ); /** * M\u00e9todo para borrar una {@link Category} * * @param id PK de la entidad */ void delete ( Long id ) throws Exception ; } package com.ccsw.tutorialcategory.category ; import com.ccsw.tutorialcategory.category.model.Category ; import com.ccsw.tutorialcategory.category.model.CategoryDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class CategoryServiceImpl implements CategoryService { @Autowired CategoryRepository categoryRepository ; /** * {@inheritDoc} */ @Override public Category get ( Long id ) { return this . categoryRepository . findById ( id ). orElse ( null ); } /** * {@inheritDoc} */ @Override public List < Category > findAll () { return ( List < Category > ) this . categoryRepository . findAll (); } /** * {@inheritDoc} */ @Override public void save ( Long id , CategoryDto dto ) { Category category ; if ( id == null ) { category = new Category (); } else { category = this . get ( id ); } category . setName ( dto . getName ()); this . categoryRepository . save ( category ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) throws Exception { if ( this . get ( id ) == null ){ throw new Exception ( \"Not exists\" ); } this . categoryRepository . deleteById ( id ); } } package com.ccsw.tutorialcategory.category ; import com.ccsw.tutorialcategory.category.model.Category ; import com.ccsw.tutorialcategory.category.model.CategoryDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; import org.modelmapper.ModelMapper ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.* ; import java.util.List ; import java.util.stream.Collectors ; /** * @author ccsw * */ @Tag ( name = \"Category\" , description = \"API of Category\" ) @RequestMapping ( value = \"/category\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class CategoryController { @Autowired CategoryService categoryService ; @Autowired ModelMapper mapper ; /** * M\u00e9todo para recuperar todas las {@link Category} * * @return {@link List} de {@link CategoryDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a list of Categories\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { List < Category > categories = this . categoryService . findAll (); return categories . stream (). map ( e -> mapper . map ( e , CategoryDto . class )). collect ( Collectors . toList ()); } /** * M\u00e9todo para crear o actualizar una {@link Category} * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Category\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody CategoryDto dto ) { this . categoryService . save ( id , dto ); } /** * M\u00e9todo para borrar una {@link Category} * * @param id PK de la entidad */ @Operation ( summary = \"Delete\" , description = \"Method that deletes a Category\" ) @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) throws Exception { this . categoryService . delete ( id ); } } SQL y Configuraci\u00f3n Finalmente, debemos crear el mismo fichero de inicializaci\u00f3n de base de datos con solo los datos de categor\u00edas y modificar ligeramente la configuraci\u00f3n inicial para a\u00f1adir un puerto manualmente. Esto es necesario ya que vamos a levantar varios servicios simult\u00e1neamente y necesitaremos levantarlos en puertos diferentes para que no colisionen entre ellos. data.sql application.properties INSERT INTO category ( name ) VALUES ( 'Eurogames' ); INSERT INTO category ( name ) VALUES ( 'Ameritrash' ); INSERT INTO category ( name ) VALUES ( 'Familiar' ); server.port = 8091 #Database spring.datasource.url = jdbc:h2:mem:testdb spring.datasource.username = sa spring.datasource.password = sa spring.datasource.driver-class-name = org.h2.Driver spring.jpa.database-platform = org.hibernate.dialect.H2Dialect spring.jpa.defer-datasource-initialization = true spring.jpa.show-sql = true spring.h2.console.enabled = true Pruebas Ahora si arrancamos la aplicaci\u00f3n server y abrimos el Postman podemos realizar las mismas pruebas del apartado de Listado simple pero esta vez apuntado al puerto 8091 . Siguientes pasos Con esto ya tendr\u00edamos nuestro primer servicio separado. Podr\u00edamos conectar el frontend a este servicio, pero a medida que nuestra aplicaci\u00f3n creciera en n\u00famero de servicios ser\u00eda un poco engorroso todo, as\u00ed que todav\u00eda no lo vamos a conectar hasta que no tengamos toda la infraestructura. Vamos a convertir en micro servicio el siguiente listado.","title":"Listado simple"},{"location":"appendix/springcloud/basic/#listado-simple-spring-boot","text":"A diferencia del tutorial b\u00e1sico de Spring Boot, donde constru\u00edamos una aplicaci\u00f3n monol\u00edtica, ahora vamos a construir multiples servicios por lo que necesitamos crear proyectos separados. Para la creaci\u00f3n de proyecto nos remitimos a la gu\u00eda de instalaci\u00f3n donde se detalla el proceso de creaci\u00f3n de nuevo proyecto Entorno de desarrollo Todos los pasos son exactamente iguales, lo \u00fanico que va a variar es el nombre de nuestro proyecto, que en este caso se va a llamar tutorial-category . El campo que debemos modificar es artifact en Spring Initilizr, el resto de campos se cambiaran autom\u00e1ticamente.","title":"Listado simple - Spring Boot"},{"location":"appendix/springcloud/basic/#estructurar-el-codigo-y-buenas-practicas","text":"Esta parte de tutorial es una ampliaci\u00f3n de la parte de backend con Spring Boot, por tanto no se ve a enfocar en las partes b\u00e1sicas aprendidas previamente, si no que se va a explicar el funcionamiento de los micro servicios aplicados al mismo caso de uso. Para cualquier duda sobre la estructura del c\u00f3digo y buenas pr\u00e1cticas, consultar el apartado de Estructura y buenas pr\u00e1cticas , ya que aplican a este caso en el mismo modo.","title":"Estructurar el c\u00f3digo y buenas pr\u00e1cticas"},{"location":"appendix/springcloud/basic/#codigo","text":"Dado de vamos a implementar el micro servicio Spring Boot de Categor\u00edas , vamos a respetar la misma estructura del Listado simple de la version monol\u00edtica.","title":"C\u00f3digo"},{"location":"appendix/springcloud/basic/#entity-y-dto","text":"En primer lugar, vamos a crear la entidad y el DTO dentro del package com.ccsw.tutorialcategory.category.model . Ojo al package que lo hemos renombrado con respecto al listado monol\u00edtico. Category.java CategoryDto.java package com.ccsw.tutorialcategory.category.model ; import jakarta.persistence.* ; /** * @author ccsw * */ @Entity @Table ( name = \"category\" ) public class Category { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"name\" , nullable = false ) private String name ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } } package com.ccsw.tutorialcategory.category.model ; /** * @author ccsw * */ public class CategoryDto { private Long id ; private String name ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } }","title":"Entity y Dto"},{"location":"appendix/springcloud/basic/#repository-service-y-controller","text":"Posteriormente, emplazamos el resto de clases dentro del package com.ccsw.tutorialcategory.category . CategoryRepository.java CategoryService.java CategoryServiceImpl.java CategoryController.java package com.ccsw.tutorialcategory.category ; import com.ccsw.tutorialcategory.category.model.Category ; import org.springframework.data.repository.CrudRepository ; /** * @author ccsw * */ public interface CategoryRepository extends CrudRepository < Category , Long > { } package com.ccsw.tutorialcategory.category ; import com.ccsw.tutorialcategory.category.model.Category ; import com.ccsw.tutorialcategory.category.model.CategoryDto ; import java.util.List ; /** * @author ccsw * */ public interface CategoryService { /** * Recupera una {@link Category} a partir de su ID * * @param id PK de la entidad * @return {@link Category} */ Category get ( Long id ); /** * M\u00e9todo para recuperar todas las {@link Category} * * @return {@link List} de {@link Category} */ List < Category > findAll (); /** * M\u00e9todo para crear o actualizar una {@link Category} * * @param id PK de la entidad * @param dto datos de la entidad */ void save ( Long id , CategoryDto dto ); /** * M\u00e9todo para borrar una {@link Category} * * @param id PK de la entidad */ void delete ( Long id ) throws Exception ; } package com.ccsw.tutorialcategory.category ; import com.ccsw.tutorialcategory.category.model.Category ; import com.ccsw.tutorialcategory.category.model.CategoryDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class CategoryServiceImpl implements CategoryService { @Autowired CategoryRepository categoryRepository ; /** * {@inheritDoc} */ @Override public Category get ( Long id ) { return this . categoryRepository . findById ( id ). orElse ( null ); } /** * {@inheritDoc} */ @Override public List < Category > findAll () { return ( List < Category > ) this . categoryRepository . findAll (); } /** * {@inheritDoc} */ @Override public void save ( Long id , CategoryDto dto ) { Category category ; if ( id == null ) { category = new Category (); } else { category = this . get ( id ); } category . setName ( dto . getName ()); this . categoryRepository . save ( category ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) throws Exception { if ( this . get ( id ) == null ){ throw new Exception ( \"Not exists\" ); } this . categoryRepository . deleteById ( id ); } } package com.ccsw.tutorialcategory.category ; import com.ccsw.tutorialcategory.category.model.Category ; import com.ccsw.tutorialcategory.category.model.CategoryDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; import org.modelmapper.ModelMapper ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.* ; import java.util.List ; import java.util.stream.Collectors ; /** * @author ccsw * */ @Tag ( name = \"Category\" , description = \"API of Category\" ) @RequestMapping ( value = \"/category\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class CategoryController { @Autowired CategoryService categoryService ; @Autowired ModelMapper mapper ; /** * M\u00e9todo para recuperar todas las {@link Category} * * @return {@link List} de {@link CategoryDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a list of Categories\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { List < Category > categories = this . categoryService . findAll (); return categories . stream (). map ( e -> mapper . map ( e , CategoryDto . class )). collect ( Collectors . toList ()); } /** * M\u00e9todo para crear o actualizar una {@link Category} * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Category\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody CategoryDto dto ) { this . categoryService . save ( id , dto ); } /** * M\u00e9todo para borrar una {@link Category} * * @param id PK de la entidad */ @Operation ( summary = \"Delete\" , description = \"Method that deletes a Category\" ) @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) throws Exception { this . categoryService . delete ( id ); } }","title":"Repository, Service y Controller"},{"location":"appendix/springcloud/basic/#sql-y-configuracion","text":"Finalmente, debemos crear el mismo fichero de inicializaci\u00f3n de base de datos con solo los datos de categor\u00edas y modificar ligeramente la configuraci\u00f3n inicial para a\u00f1adir un puerto manualmente. Esto es necesario ya que vamos a levantar varios servicios simult\u00e1neamente y necesitaremos levantarlos en puertos diferentes para que no colisionen entre ellos. data.sql application.properties INSERT INTO category ( name ) VALUES ( 'Eurogames' ); INSERT INTO category ( name ) VALUES ( 'Ameritrash' ); INSERT INTO category ( name ) VALUES ( 'Familiar' ); server.port = 8091 #Database spring.datasource.url = jdbc:h2:mem:testdb spring.datasource.username = sa spring.datasource.password = sa spring.datasource.driver-class-name = org.h2.Driver spring.jpa.database-platform = org.hibernate.dialect.H2Dialect spring.jpa.defer-datasource-initialization = true spring.jpa.show-sql = true spring.h2.console.enabled = true","title":"SQL y Configuraci\u00f3n"},{"location":"appendix/springcloud/basic/#pruebas","text":"Ahora si arrancamos la aplicaci\u00f3n server y abrimos el Postman podemos realizar las mismas pruebas del apartado de Listado simple pero esta vez apuntado al puerto 8091 .","title":"Pruebas"},{"location":"appendix/springcloud/basic/#siguientes-pasos","text":"Con esto ya tendr\u00edamos nuestro primer servicio separado. Podr\u00edamos conectar el frontend a este servicio, pero a medida que nuestra aplicaci\u00f3n creciera en n\u00famero de servicios ser\u00eda un poco engorroso todo, as\u00ed que todav\u00eda no lo vamos a conectar hasta que no tengamos toda la infraestructura. Vamos a convertir en micro servicio el siguiente listado.","title":"Siguientes pasos"},{"location":"appendix/springcloud/filtered/","text":"Listado filtrado - Spring Boot Al igual que en los caos anteriores vamos a crear un nuevo proyecto que contendr\u00e1 un nuevo micro servicio. Para la creaci\u00f3n de proyecto nos remitimos a la gu\u00eda de instalaci\u00f3n donde se detalla el proceso de creaci\u00f3n de nuevo proyecto Entorno de desarrollo Todos los pasos son exactamente iguales, lo \u00fanico que va a variar, es el nombre de nuestro proyecto, que en este caso se va a llamar tutorial-game . El campo que debemos modificar es artifact en Spring Initilizr, el resto de campos se cambiaran autom\u00e1ticamente. C\u00f3digo Dado de vamos a implementar el micro servicio Spring Boot de Juegos , vamos a respetar la misma estructura del Listado filtrado de la version monol\u00edtica. Criteria En primer lugar, vamos a a\u00f1adir la clase que necesitamos para realizar el filtrado y vimos en la version monol\u00edtica del tutorial en el package com.ccsw.tutorialgame.common.criteria . SearchCriteria.java package com.ccsw.tutorialgame.common.criteria ; public class SearchCriteria { private String key ; private String operation ; private Object value ; public SearchCriteria ( String key , String operation , Object value ) { this . key = key ; this . operation = operation ; this . value = value ; } public String getKey () { return key ; } public void setKey ( String key ) { this . key = key ; } public String getOperation () { return operation ; } public void setOperation ( String operation ) { this . operation = operation ; } public Object getValue () { return value ; } public void setValue ( Object value ) { this . value = value ; } } Entity y Dto Seguimos con la entidad y el DTO dentro del package com.ccsw.tutorialgame.game.model . En este punto, f\u00edjate que nuestro modelo de Entity no tiene relaci\u00f3n con la tabla Author ni Category ya que estos dos objetos no pertenecen a nuestro dominio y se gestionan desde otro micro servicio. Lo que tendremos ahora ser\u00e1 el identificador del registro que hace referencia a esos objetos. Ya no usaremos @JoinColumn porque en nuestro modelo no existen esas tablas relacionadas. Sin embargo el Dto si que utiliza relaciones, ya que son relaciones de negocio (en el Service ) y no son relaciones de dominio (en BBDD o Repository ) Game.java GameDto.java package com.ccsw.tutorialgame.game.model ; import jakarta.persistence.* ; /** * @author ccsw * */ @Entity @Table ( name = \"game\" ) public class Game { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"title\" , nullable = false ) private String title ; @Column ( name = \"age\" , nullable = false ) private String age ; @Column ( name = \"category_id\" , nullable = false ) private Long idCategory ; @Column ( name = \"author_id\" , nullable = false ) private Long idAuthor ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return age */ public String getAge () { return this . age ; } /** * @param age new value of {@link #getAge}. */ public void setAge ( String age ) { this . age = age ; } /** * @return idCategory */ public Long getIdCategory () { return this . idCategory ; } /** * @param idCategory new value of {@link #getIdCategory}. */ public void setIdCategory ( Long idCategory ) { this . idCategory = idCategory ; } /** * @return idAuthor */ public Long getIdAuthor () { return this . idAuthor ; } /** * @param idAuthor new value of {@link #getIdAuthor}. */ public void setIdAuthor ( Long idAuthor ) { this . idAuthor = idAuthor ; } } package com.ccsw.tutorialgame.game.model ; import com.ccsw.tutorialgame.author.model.AuthorDto ; import com.ccsw.tutorialgame.category.model.CategoryDto ; /** * @author ccsw * */ public class GameDto { private Long id ; private String title ; private String age ; private Long idCategory ; private Long idAuthor ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return age */ public String getAge () { return this . age ; } /** * @param age new value of {@link #getAge}. */ public void setAge ( String age ) { this . age = age ; } /** * @return idCategory */ public Long getIdCategory () { return this . idCategory ; } /** * @param idCategory new value of {@link #getIdCategory}. */ public void setIdCategory ( Long idCategory ) { this . idCategory = idCategory ; } /** * @return idAuthor */ public Long getIdAuthor () { return this . idAuthor ; } /** * @param idAuthor new value of {@link #getIdAuthor}. */ public void setIdAuthor ( Long idAuthor ) { this . idAuthor = idAuthor ; } } Repository, Service, Controller Posteriormente, emplazamos el resto de clases dentro del package com.ccsw.tutorialgame.game . GameRepository.java GameService.java GameSpecification.java GameServiceImpl.java GameController.java package com.ccsw.tutorialgame.game ; import com.ccsw.tutorialgame.game.model.Game ; import org.springframework.data.jpa.repository.JpaSpecificationExecutor ; import org.springframework.data.repository.CrudRepository ; /** * @author ccsw * */ public interface GameRepository extends CrudRepository < Game , Long > , JpaSpecificationExecutor < Game > { } package com.ccsw.tutorialgame.game ; import com.ccsw.tutorialgame.game.model.Game ; import com.ccsw.tutorialgame.game.model.GameDto ; import java.util.List ; /** * @author ccsw * */ public interface GameService { /** * Recupera los juegos filtrando opcionalmente por t\u00edtulo y/o categor\u00eda * * @param title t\u00edtulo del juego * @param idCategory PK de la categor\u00eda * @return {@link List} de {@link Game} */ List < Game > find ( String title , Long idCategory ); /** * Guarda o modifica un juego, dependiendo de si el identificador est\u00e1 o no informado * * @param id PK de la entidad * @param dto datos de la entidad */ void save ( Long id , GameDto dto ); } package com.ccsw.tutorialgame.game ; import com.ccsw.tutorialgame.common.criteria.SearchCriteria ; import com.ccsw.tutorialgame.game.model.Game ; import jakarta.persistence.criteria.* ; import org.springframework.data.jpa.domain.Specification ; public class GameSpecification implements Specification < Game > { private static final long serialVersionUID = 1L ; private final SearchCriteria criteria ; public GameSpecification ( SearchCriteria criteria ) { this . criteria = criteria ; } @Override public Predicate toPredicate ( Root < Game > root , CriteriaQuery <?> query , CriteriaBuilder builder ) { if ( criteria . getOperation (). equalsIgnoreCase ( \":\" ) && criteria . getValue () != null ) { Path < String > path = getPath ( root ); if ( path . getJavaType () == String . class ) { return builder . like ( path , \"%\" + criteria . getValue () + \"%\" ); } else { return builder . equal ( path , criteria . getValue ()); } } return null ; } private Path < String > getPath ( Root < Game > root ) { String key = criteria . getKey (); String [] split = key . split ( \"[.]\" , 0 ); Path < String > expression = root . get ( split [ 0 ] ); for ( int i = 1 ; i < split . length ; i ++ ) { expression = expression . get ( split [ i ] ); } return expression ; } } package com.ccsw.tutorialgame.game ; import com.ccsw.tutorialgame.common.criteria.SearchCriteria ; import com.ccsw.tutorialgame.game.model.Game ; import com.ccsw.tutorialgame.game.model.GameDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.jpa.domain.Specification ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class GameServiceImpl implements GameService { @Autowired GameRepository gameRepository ; /** * {@inheritDoc} */ @Override public List < Game > find ( String title , Long idCategory ) { GameSpecification titleSpec = new GameSpecification ( new SearchCriteria ( \"title\" , \":\" , title )); GameSpecification categorySpec = new GameSpecification ( new SearchCriteria ( \"idCategory\" , \":\" , idCategory )); Specification < Game > spec = Specification . where ( titleSpec ). and ( categorySpec ); return this . gameRepository . findAll ( spec ); } /** * {@inheritDoc} */ @Override public void save ( Long id , GameDto dto ) { Game game ; if ( id == null ) { game = new Game (); } else { game = this . gameRepository . findById ( id ). orElse ( null ); } BeanUtils . copyProperties ( dto , game , \"id\" ); game . setIdAuthor ( dto . getIdAuthor ()); game . setIdCategory ( dto . getIdCategory ()); this . gameRepository . save ( game ); } } package com.ccsw.tutorialgame.game ; import com.ccsw.tutorialgame.game.model.Game ; import com.ccsw.tutorialgame.game.model.GameDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; import org.modelmapper.ModelMapper ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.* ; import java.util.List ; import java.util.stream.Collectors ; /** * @author ccsw * */ @Tag ( name = \"Game\" , description = \"API of Game\" ) @RequestMapping ( value = \"/game\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class GameController { @Autowired GameService gameService ; @Autowired ModelMapper mapper ; /** * M\u00e9todo para recuperar una lista de {@link Game} * * @param title t\u00edtulo del juego * @param idCategory PK de la categor\u00eda * @return {@link List} de {@link GameDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a filtered list of Games\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < GameDto > find ( @RequestParam ( value = \"title\" , required = false ) String title , @RequestParam ( value = \"idCategory\" , required = false ) Long idCategory ) { List < Game > game = this . gameService . find ( title , idCategory ); return game . stream (). map ( e -> mapper . map ( e , GameDto . class )). collect ( Collectors . toList ()); } /** * M\u00e9todo para crear o actualizar un {@link Game} * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Game\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody GameDto dto ) { gameService . save ( id , dto ); } } SQL y Configuraci\u00f3n Finalmente, debemos crear el script de inicializaci\u00f3n de base de datos con solo los datos de juegos y modificar ligeramente la configuraci\u00f3n inicial para a\u00f1adir un puerto manualmente para poder tener multiples micro servicios funcionando simult\u00e1neamente. data.sql application.properties INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'On Mars' , '14' , 1 , 2 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'Aventureros al tren' , '8' , 3 , 1 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( '1920: Wall Street' , '12' , 1 , 4 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'Barrage' , '14' , 1 , 3 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'Los viajes de Marco Polo' , '12' , 1 , 3 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'Azul' , '8' , 3 , 5 ); server.port = 8093 #Database spring.datasource.url = jdbc:h2:mem:testdb spring.datasource.username = sa spring.datasource.password = sa spring.datasource.driver-class-name = org.h2.Driver spring.jpa.database-platform = org.hibernate.dialect.H2Dialect spring.jpa.defer-datasource-initialization = true spring.jpa.show-sql = true spring.h2.console.enabled = true Pruebas Ahora si arrancamos la aplicaci\u00f3n server y abrimos el Postman podemos realizar las mismas pruebas del apartado de Listado filtrado pero esta vez apuntado al puerto 8093 . F\u00edjate que cuando probemos el listado de juegos, devolver\u00e1 identificadores en idAuthor y idCategory , y no objetos como funcionaba hasta ahora en la aplicaci\u00f3n monol\u00edtica. As\u00ed que las pruebas que realices para insertar tambi\u00e9n deben utilizar esas propiedades y NO objetos. Siguientes pasos En este punto ya tenemos un micro servicio de categor\u00edas en el puerto 8091 , un micro servicio de autores en el puerto 8092 y un \u00faltimo micro servicio de juegos en el puerto 8093 . Si ahora fueramos a conectarlo con el frontend tendr\u00edamos dos problemas: Por un lado, el frontend debe recordar la IP y el puerto en el que se encuentra cada servicio. Adem\u00e1s, este podr\u00eda cambiar si lo desplegamos en nube o lo movemos de servidor, y el frontend deber\u00eda ser capaz de refrescarse para actualizar la informaci\u00f3n. Por otro lado, como hemos comentado, se ha cambiado el contrato del endpoint de juegos. Ahora ya no devuelve la informaci\u00f3n de author y category sino que devuelve su ID. Esto obliga al frontend a tener que hacer dos llamadas extra para completar la informaci\u00f3n. Estar\u00edamos llevando l\u00f3gica de negocio al frontend y esto no nos convence. Para poder solverntar ambos problemas, necesitamos conectar todos nuestros micro servicios con una infraestructura que nos ayudar\u00e1 a gestionar todo el ecosistema de micro servicios. Vamos all\u00e1 con el \u00faltimo punto.","title":"Listado filtrado"},{"location":"appendix/springcloud/filtered/#listado-filtrado-spring-boot","text":"Al igual que en los caos anteriores vamos a crear un nuevo proyecto que contendr\u00e1 un nuevo micro servicio. Para la creaci\u00f3n de proyecto nos remitimos a la gu\u00eda de instalaci\u00f3n donde se detalla el proceso de creaci\u00f3n de nuevo proyecto Entorno de desarrollo Todos los pasos son exactamente iguales, lo \u00fanico que va a variar, es el nombre de nuestro proyecto, que en este caso se va a llamar tutorial-game . El campo que debemos modificar es artifact en Spring Initilizr, el resto de campos se cambiaran autom\u00e1ticamente.","title":"Listado filtrado - Spring Boot"},{"location":"appendix/springcloud/filtered/#codigo","text":"Dado de vamos a implementar el micro servicio Spring Boot de Juegos , vamos a respetar la misma estructura del Listado filtrado de la version monol\u00edtica.","title":"C\u00f3digo"},{"location":"appendix/springcloud/filtered/#criteria","text":"En primer lugar, vamos a a\u00f1adir la clase que necesitamos para realizar el filtrado y vimos en la version monol\u00edtica del tutorial en el package com.ccsw.tutorialgame.common.criteria . SearchCriteria.java package com.ccsw.tutorialgame.common.criteria ; public class SearchCriteria { private String key ; private String operation ; private Object value ; public SearchCriteria ( String key , String operation , Object value ) { this . key = key ; this . operation = operation ; this . value = value ; } public String getKey () { return key ; } public void setKey ( String key ) { this . key = key ; } public String getOperation () { return operation ; } public void setOperation ( String operation ) { this . operation = operation ; } public Object getValue () { return value ; } public void setValue ( Object value ) { this . value = value ; } }","title":"Criteria"},{"location":"appendix/springcloud/filtered/#entity-y-dto","text":"Seguimos con la entidad y el DTO dentro del package com.ccsw.tutorialgame.game.model . En este punto, f\u00edjate que nuestro modelo de Entity no tiene relaci\u00f3n con la tabla Author ni Category ya que estos dos objetos no pertenecen a nuestro dominio y se gestionan desde otro micro servicio. Lo que tendremos ahora ser\u00e1 el identificador del registro que hace referencia a esos objetos. Ya no usaremos @JoinColumn porque en nuestro modelo no existen esas tablas relacionadas. Sin embargo el Dto si que utiliza relaciones, ya que son relaciones de negocio (en el Service ) y no son relaciones de dominio (en BBDD o Repository ) Game.java GameDto.java package com.ccsw.tutorialgame.game.model ; import jakarta.persistence.* ; /** * @author ccsw * */ @Entity @Table ( name = \"game\" ) public class Game { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"title\" , nullable = false ) private String title ; @Column ( name = \"age\" , nullable = false ) private String age ; @Column ( name = \"category_id\" , nullable = false ) private Long idCategory ; @Column ( name = \"author_id\" , nullable = false ) private Long idAuthor ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return age */ public String getAge () { return this . age ; } /** * @param age new value of {@link #getAge}. */ public void setAge ( String age ) { this . age = age ; } /** * @return idCategory */ public Long getIdCategory () { return this . idCategory ; } /** * @param idCategory new value of {@link #getIdCategory}. */ public void setIdCategory ( Long idCategory ) { this . idCategory = idCategory ; } /** * @return idAuthor */ public Long getIdAuthor () { return this . idAuthor ; } /** * @param idAuthor new value of {@link #getIdAuthor}. */ public void setIdAuthor ( Long idAuthor ) { this . idAuthor = idAuthor ; } } package com.ccsw.tutorialgame.game.model ; import com.ccsw.tutorialgame.author.model.AuthorDto ; import com.ccsw.tutorialgame.category.model.CategoryDto ; /** * @author ccsw * */ public class GameDto { private Long id ; private String title ; private String age ; private Long idCategory ; private Long idAuthor ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return age */ public String getAge () { return this . age ; } /** * @param age new value of {@link #getAge}. */ public void setAge ( String age ) { this . age = age ; } /** * @return idCategory */ public Long getIdCategory () { return this . idCategory ; } /** * @param idCategory new value of {@link #getIdCategory}. */ public void setIdCategory ( Long idCategory ) { this . idCategory = idCategory ; } /** * @return idAuthor */ public Long getIdAuthor () { return this . idAuthor ; } /** * @param idAuthor new value of {@link #getIdAuthor}. */ public void setIdAuthor ( Long idAuthor ) { this . idAuthor = idAuthor ; } }","title":"Entity y Dto"},{"location":"appendix/springcloud/filtered/#repository-service-controller","text":"Posteriormente, emplazamos el resto de clases dentro del package com.ccsw.tutorialgame.game . GameRepository.java GameService.java GameSpecification.java GameServiceImpl.java GameController.java package com.ccsw.tutorialgame.game ; import com.ccsw.tutorialgame.game.model.Game ; import org.springframework.data.jpa.repository.JpaSpecificationExecutor ; import org.springframework.data.repository.CrudRepository ; /** * @author ccsw * */ public interface GameRepository extends CrudRepository < Game , Long > , JpaSpecificationExecutor < Game > { } package com.ccsw.tutorialgame.game ; import com.ccsw.tutorialgame.game.model.Game ; import com.ccsw.tutorialgame.game.model.GameDto ; import java.util.List ; /** * @author ccsw * */ public interface GameService { /** * Recupera los juegos filtrando opcionalmente por t\u00edtulo y/o categor\u00eda * * @param title t\u00edtulo del juego * @param idCategory PK de la categor\u00eda * @return {@link List} de {@link Game} */ List < Game > find ( String title , Long idCategory ); /** * Guarda o modifica un juego, dependiendo de si el identificador est\u00e1 o no informado * * @param id PK de la entidad * @param dto datos de la entidad */ void save ( Long id , GameDto dto ); } package com.ccsw.tutorialgame.game ; import com.ccsw.tutorialgame.common.criteria.SearchCriteria ; import com.ccsw.tutorialgame.game.model.Game ; import jakarta.persistence.criteria.* ; import org.springframework.data.jpa.domain.Specification ; public class GameSpecification implements Specification < Game > { private static final long serialVersionUID = 1L ; private final SearchCriteria criteria ; public GameSpecification ( SearchCriteria criteria ) { this . criteria = criteria ; } @Override public Predicate toPredicate ( Root < Game > root , CriteriaQuery <?> query , CriteriaBuilder builder ) { if ( criteria . getOperation (). equalsIgnoreCase ( \":\" ) && criteria . getValue () != null ) { Path < String > path = getPath ( root ); if ( path . getJavaType () == String . class ) { return builder . like ( path , \"%\" + criteria . getValue () + \"%\" ); } else { return builder . equal ( path , criteria . getValue ()); } } return null ; } private Path < String > getPath ( Root < Game > root ) { String key = criteria . getKey (); String [] split = key . split ( \"[.]\" , 0 ); Path < String > expression = root . get ( split [ 0 ] ); for ( int i = 1 ; i < split . length ; i ++ ) { expression = expression . get ( split [ i ] ); } return expression ; } } package com.ccsw.tutorialgame.game ; import com.ccsw.tutorialgame.common.criteria.SearchCriteria ; import com.ccsw.tutorialgame.game.model.Game ; import com.ccsw.tutorialgame.game.model.GameDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.jpa.domain.Specification ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class GameServiceImpl implements GameService { @Autowired GameRepository gameRepository ; /** * {@inheritDoc} */ @Override public List < Game > find ( String title , Long idCategory ) { GameSpecification titleSpec = new GameSpecification ( new SearchCriteria ( \"title\" , \":\" , title )); GameSpecification categorySpec = new GameSpecification ( new SearchCriteria ( \"idCategory\" , \":\" , idCategory )); Specification < Game > spec = Specification . where ( titleSpec ). and ( categorySpec ); return this . gameRepository . findAll ( spec ); } /** * {@inheritDoc} */ @Override public void save ( Long id , GameDto dto ) { Game game ; if ( id == null ) { game = new Game (); } else { game = this . gameRepository . findById ( id ). orElse ( null ); } BeanUtils . copyProperties ( dto , game , \"id\" ); game . setIdAuthor ( dto . getIdAuthor ()); game . setIdCategory ( dto . getIdCategory ()); this . gameRepository . save ( game ); } } package com.ccsw.tutorialgame.game ; import com.ccsw.tutorialgame.game.model.Game ; import com.ccsw.tutorialgame.game.model.GameDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; import org.modelmapper.ModelMapper ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.* ; import java.util.List ; import java.util.stream.Collectors ; /** * @author ccsw * */ @Tag ( name = \"Game\" , description = \"API of Game\" ) @RequestMapping ( value = \"/game\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class GameController { @Autowired GameService gameService ; @Autowired ModelMapper mapper ; /** * M\u00e9todo para recuperar una lista de {@link Game} * * @param title t\u00edtulo del juego * @param idCategory PK de la categor\u00eda * @return {@link List} de {@link GameDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a filtered list of Games\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < GameDto > find ( @RequestParam ( value = \"title\" , required = false ) String title , @RequestParam ( value = \"idCategory\" , required = false ) Long idCategory ) { List < Game > game = this . gameService . find ( title , idCategory ); return game . stream (). map ( e -> mapper . map ( e , GameDto . class )). collect ( Collectors . toList ()); } /** * M\u00e9todo para crear o actualizar un {@link Game} * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Game\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody GameDto dto ) { gameService . save ( id , dto ); } }","title":"Repository, Service, Controller"},{"location":"appendix/springcloud/filtered/#sql-y-configuracion","text":"Finalmente, debemos crear el script de inicializaci\u00f3n de base de datos con solo los datos de juegos y modificar ligeramente la configuraci\u00f3n inicial para a\u00f1adir un puerto manualmente para poder tener multiples micro servicios funcionando simult\u00e1neamente. data.sql application.properties INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'On Mars' , '14' , 1 , 2 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'Aventureros al tren' , '8' , 3 , 1 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( '1920: Wall Street' , '12' , 1 , 4 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'Barrage' , '14' , 1 , 3 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'Los viajes de Marco Polo' , '12' , 1 , 3 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'Azul' , '8' , 3 , 5 ); server.port = 8093 #Database spring.datasource.url = jdbc:h2:mem:testdb spring.datasource.username = sa spring.datasource.password = sa spring.datasource.driver-class-name = org.h2.Driver spring.jpa.database-platform = org.hibernate.dialect.H2Dialect spring.jpa.defer-datasource-initialization = true spring.jpa.show-sql = true spring.h2.console.enabled = true","title":"SQL y Configuraci\u00f3n"},{"location":"appendix/springcloud/filtered/#pruebas","text":"Ahora si arrancamos la aplicaci\u00f3n server y abrimos el Postman podemos realizar las mismas pruebas del apartado de Listado filtrado pero esta vez apuntado al puerto 8093 . F\u00edjate que cuando probemos el listado de juegos, devolver\u00e1 identificadores en idAuthor y idCategory , y no objetos como funcionaba hasta ahora en la aplicaci\u00f3n monol\u00edtica. As\u00ed que las pruebas que realices para insertar tambi\u00e9n deben utilizar esas propiedades y NO objetos.","title":"Pruebas"},{"location":"appendix/springcloud/filtered/#siguientes-pasos","text":"En este punto ya tenemos un micro servicio de categor\u00edas en el puerto 8091 , un micro servicio de autores en el puerto 8092 y un \u00faltimo micro servicio de juegos en el puerto 8093 . Si ahora fueramos a conectarlo con el frontend tendr\u00edamos dos problemas: Por un lado, el frontend debe recordar la IP y el puerto en el que se encuentra cada servicio. Adem\u00e1s, este podr\u00eda cambiar si lo desplegamos en nube o lo movemos de servidor, y el frontend deber\u00eda ser capaz de refrescarse para actualizar la informaci\u00f3n. Por otro lado, como hemos comentado, se ha cambiado el contrato del endpoint de juegos. Ahora ya no devuelve la informaci\u00f3n de author y category sino que devuelve su ID. Esto obliga al frontend a tener que hacer dos llamadas extra para completar la informaci\u00f3n. Estar\u00edamos llevando l\u00f3gica de negocio al frontend y esto no nos convence. Para poder solverntar ambos problemas, necesitamos conectar todos nuestros micro servicios con una infraestructura que nos ayudar\u00e1 a gestionar todo el ecosistema de micro servicios. Vamos all\u00e1 con el \u00faltimo punto.","title":"Siguientes pasos"},{"location":"appendix/springcloud/infra/","text":"Infraestructura - Spring Cloud Creados los tres micro servicios que compondr\u00e1n nuestro aplicativo, ya podemos empezar con la creaci\u00f3n de las piezas de infraestructura que ser\u00e1n las encargadas de realizar la orquestaci\u00f3n. Service Discovery - Eureka Para esta pieza hay muchas aplicaciones de mercado, incluso los propios proveedores de cloud tiene la suya propia, pero en este caso, vamos a utilizar la que ofrece Spring Cloud, as\u00ed que vamos a crear un proyecto de una forma similar a la que estamos acostumbrados. Crear el servicio Volviendo una vez m\u00e1s a Spring Initializr seleccionaremos los siguientes datos: Tipo de proyecto: Maven Lenguage: Java Versi\u00f3n Spring boot: 3.0.4 (o alguna similar) Group: com.ccsw ArtifactId: tutorial-eureka Versi\u00f3n Java: 19 Dependencias: Eureka Server Es importante que a\u00f1adamos la dependencia de Eureka Server para que sea capaz de ejecutar el proyecto como si fuera un servidor Eureka. Configurar el servicio Importamos el proyecto dentro del IDE y ya solo nos queda activar el servidor y configurarlo. En primer lugar, a\u00f1adimos la anotaci\u00f3n que habilita el servidor de Eureka. TutorialEurekaApplication.java package com.ccsw.tutorialeureka ; import org.springframework.boot.SpringApplication ; import org.springframework.boot.autoconfigure.SpringBootApplication ; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer ; @SpringBootApplication @EnableEurekaServer public class TutorialEurekaApplication { public static void main ( String [] args ) { SpringApplication . run ( TutorialEurekaApplication . class , args ); } } Ahora debemos a\u00f1adir las configuraciones necesarias. En primer lugar para facilitar la visualizaci\u00f3n de las propiedades vamos a renombrar nuestro fichero application.properties a application.yml . Hecho esto, a\u00f1adimos la configuraci\u00f3n de puerto que ya conocemos y a\u00f1adimos directivas sobre que Eureka no se registre a s\u00ed mismo dentro del cat\u00e1logo de servicios. application.yml server: port: 8761 eureka: client: registerWithEureka: false fetchRegistry: false Probar el servicio Hechas estas sencillas configuraciones y arrancando el proyecto, nos dirigimos a la http://localhost/8761 donde podemos ver la interfaz de Eureka y si miramos con detenimiento, vemos que el cat\u00e1logo de servicios aparece vac\u00edo, ya que a\u00fan no se ha registrado ninguno de ellos. Micro servicios Ahora que ya tenemos disponible Eureka, ya podemos proceder a registrar nuestros micro servicios dentro del cat\u00e1logo. Para ello vamos a realizar las mismas modificaciones sobre los tres micro servicios. Recuerda que hay que realizarlo sobre los tres para que se registren todos. Configurar micro servicios Para este fin debemos a\u00f1adir una nueva dependencia dentro del pom.xml y modificar la configuraci\u00f3n del proyecto. pom.xml application.properties <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <parent> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-parent </artifactId> <version> 3.0.4 </version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId> com.ccsw </groupId> <artifactId> tutorial-XXX </artifactId> <!-- Cada proyecto tiene su configaci\u00f3n propia, NO modificar --> <version> 0.0.1-SNAPSHOT </version> <name> tutorial-XXX </name> <!-- Cada proyecto tiene su configaci\u00f3n propia, NO modificar --> <description> Demo project for Spring Boot </description> <properties> <java.version> 19 </java.version> <spring-cloud.version> 2022.0.1 </spring-cloud.version> </properties> <dependencies> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-data-jpa </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-web </artifactId> </dependency> <dependency> <groupId> org.springdoc </groupId> <artifactId> springdoc-openapi-starter-webmvc-ui </artifactId> <version> 2.0.3 </version> </dependency> <dependency> <groupId> org.hibernate </groupId> <artifactId> hibernate-validator </artifactId> <version> 8.0.0.Final </version> </dependency> <dependency> <groupId> net.sf.dozer </groupId> <artifactId> dozer </artifactId> <version> 5.5.1 </version> </dependency> <dependency> <groupId> org.springframework.cloud </groupId> <artifactId> spring-cloud-starter-netflix-eureka-client </artifactId> </dependency> <dependency> <groupId> com.h2database </groupId> <artifactId> h2 </artifactId> <scope> runtime </scope> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-test </artifactId> <scope> test </scope> </dependency> </dependencies> <dependencyManagement> <dependencies> <dependency> <groupId> org.springframework.cloud </groupId> <artifactId> spring-cloud-dependencies </artifactId> <version> ${spring-cloud.version} </version> <type> pom </type> <scope> import </scope> </dependency> </dependencies> </dependencyManagement> <build> <plugins> <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> </plugin> </plugins> </build> </project> spring.application.name = spring-cloud-eureka-client-XXX server.port = 809X #Database spring.datasource.url = jdbc:h2:mem:testdb spring.datasource.username = sa spring.datasource.password = sa spring.datasource.driver-class-name = org.h2.Driver spring.jpa.database-platform = org.hibernate.dialect.H2Dialect spring.jpa.defer-datasource-initialization = true spring.jpa.show-sql = true spring.h2.console.enabled = true #Eureka eureka.client.serviceUrl.defaultZone = ${EUREKA_URI:http://localhost:8761/eureka} eureka.instance.preferIpAddress = true Como podemos observar, lo que hemos hecho, es a\u00f1adir la dependencia de Eureka Client y le hemos comunicado a cada micro servicio donde tenemos arrancado Eureka. De este modo al arrancar cada micro servicio, este se registrar\u00e1 autom\u00e1ticamente dentro de Eureka. Para poder diferenciar cada micro servicio, estos tienen su configuraci\u00f3n de nombre y puerto (mantenemos el puerto que hab\u00edamos configurado en pasos previos): Categor\u00edas: spring.application.name=spring-cloud-eureka-client-category Autores: spring.application.name=spring-cloud-eureka-client-author Juegos: spring.application.name=spring-cloud-eureka-client-game Nombres en vez de rutas Estos nombres ser\u00e1n por los que vamos a identificar cada micro servicio dentro de Eureka que ser\u00e1 quien conozca las rutas de los mismos, asi cuando queramos realizar redirecciones a estos no necesitaremos conocerlas rutas ni los puertos de los mismos, con proporcionar los nombres tendremos la informaci\u00f3n completa de como llegar a ellos. Probar micro servicios Hechas estas configuraciones y arrancados los micro servicios, volvemos a dirigirnos a Eureka en http://localhost/8761 donde podemos ver que estos aparecen en el listado de servicios registrados. Gateway Para esta pieza, de nuevo, hay muchas implementaciones y aplicaciones de mercado, pero nosotros vamos a utilizar la de Spring Cloud, as\u00ed que vamos a crear un nuevo proyecto de una forma similar a la de Eureka. Crear el servicio Volviendo una vez m\u00e1s a Spring Initializr seleccionaremos los siguientes datos: Tipo de proyecto: Maven Lenguage: Java Versi\u00f3n Spring boot: 3.0.4 (o alguna similar) Group: com.ccsw ArtifactId: tutorial-gateway Versi\u00f3n Java: 19 Dependencias: Gateway, Eureka Client Ojo con las dependencias de Gateway y de Eureka Client que debemos a\u00f1adir. Configurar el servicio De nuevo lo importamos en nuestro IDE y pasamos a a\u00f1adir las configuraciones pertinentes. Al igual que en el caso de Eureka vamos a renombrar nuestro fichero application.properties a application.yml . application.yml server: port: 8080 eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka spring: application: name: spring-cloud-eureka-client-gateway cloud: gateway: default-filters: - DedupeResponseHeader=Access-Control-Allow-Credentials Access-Control-Allow-Origin globalcors: corsConfigurations: '[/**]': allowedOrigins: \"*\" allowedMethods: \"*\" allowedHeaders: \"*\" routes: - id: category uri: lb://SPRING-CLOUD-EUREKA-CLIENT-CATEGORY predicates: - Path=/category/** - id: author uri: lb://SPRING-CLOUD-EUREKA-CLIENT-AUTHOR predicates: - Path=/author/** - id: game uri: lb://SPRING-CLOUD-EUREKA-CLIENT-GAME predicates: - Path=/game/** Lo que hemos hecho aqu\u00ed es configurar el puerto como 8080 ya que el Gateway va a ser nuestro punto de acceso y el encargado de redirigir cada petici\u00f3n al micro servicio correcto. Posteriormente hemos configurado el cliente de Eureka para que el Gateway establezca comunicaci\u00f3n con Eureka que hemos configurado previamente para, en primer lugar, registrarse como un cliente y seguidamente obtener informaci\u00f3n del cat\u00e1logo de servicios existentes. El paso siguiente es darle un nombre a la aplicaci\u00f3n para que se registre en Eureka y a\u00f1adir configuraci\u00f3n de CORS para que cuando realicemos las llamadas desde navegador pueda realizar la redirecci\u00f3n correctamente. Finalmente a\u00f1adimos las directrices de redirecci\u00f3n al Gateway indic\u00e1ndole los nombres de los micro servicios con los que estos se han registrado en Eureka junto a los predicados que incluyen las rutas parciales que queremos que sean redirigidas a cada micro servicio. Con esto nos queda la siguiente configuraci\u00f3n: Las rutas que incluyan en su path category redirigir\u00e1n al micro servicio de Categorias Las rutas que incluyan en su path author redirigir\u00e1n al micro servicio de Autores Las rutas que incluyan en su path game redirigir\u00e1n al micro servicio de Juegos Probar el servicio Hechas esto y arrancado el proyecto, volvemos a dirigirnos a Eureka en http://localhost/8761 donde podemos ver que el Gateway se ha registrado correctamente junto al resto de clientes. Feign Client El \u00faltimo paso es la implementaci\u00f3n de la comunicaci\u00f3n entre los micro servicios, en este caso necesitamos que nuestro micro servicio de Game obtenga datos de Category y Author para poder servir informaci\u00f3n completa de los Game ya que en su modelo solo posee los identificadores. Si record\u00e1is, est\u00e1bamos respondiendo solamente con los id . Configurar el servicio Para la comunicaci\u00f3n entre los distintos servicios, Spring Cloud nos prove de Feign Clients que ofrecen una interfaz muy sencilla de comunicaci\u00f3n y que utiliza a la perfecci\u00f3n la infraestructura que ya hemos construido. En primer lugar debemos a\u00f1adir la dependencia necesaria dentro de nuestro pom.xml del micro servicio de Game . pom.xml ... <dependency> <groupId> org.springframework.cloud </groupId> <artifactId> spring-cloud-starter-netflix-eureka-client </artifactId> </dependency> <dependency> <groupId> org.springframework.cloud </groupId> <artifactId> spring-cloud-starter-openfeign </artifactId> </dependency> <dependency> <groupId> com.h2database </groupId> <artifactId> h2 </artifactId> <scope> runtime </scope> </dependency> ... El siguiente paso es habilitar el uso de los Feign Clients mediante la anotaci\u00f3n de SpringCloud. TutorialGameApplication.java package com.ccsw.tutorialgame ; import org.springframework.boot.SpringApplication ; import org.springframework.boot.autoconfigure.SpringBootApplication ; import org.springframework.cloud.openfeign.EnableFeignClients ; @SpringBootApplication @EnableFeignClients public class TutorialGameApplication { public static void main ( String [] args ) { SpringApplication . run ( TutorialGameApplication . class , args ); } } Configurar los clientes Realizadas las configuraciones ya podemos realizar los cambios necesarios en nuestro c\u00f3digo para implementar la comunicaci\u00f3n. En primer lugar vamos a crear los clientes de Categor\u00edas y Autores . CategoryClient.java AuthorClient.java package com.ccsw.tutorialgame.category ; import com.ccsw.tutorialgame.category.model.CategoryDto ; import org.springframework.cloud.openfeign.FeignClient ; import org.springframework.web.bind.annotation.GetMapping ; import java.util.List ; @FeignClient ( value = \"SPRING-CLOUD-EUREKA-CLIENT-CATEGORY\" , url = \"http://localhost:8080\" ) public interface CategoryClient { @GetMapping ( value = \"/category\" ) List < CategoryDto > findAll (); } package com.ccsw.tutorialgame.author ; import com.ccsw.tutorialgame.author.model.AuthorDto ; import org.springframework.cloud.openfeign.FeignClient ; import org.springframework.web.bind.annotation.GetMapping ; import java.util.List ; @FeignClient ( value = \"SPRING-CLOUD-EUREKA-CLIENT-AUTHOR\" , url = \"http://localhost:8080\" ) public interface AuthorClient { @GetMapping ( value = \"/author\" ) List < AuthorDto > findAll (); } Lo que hacemos aqu\u00ed es crear una simple interfaz donde a\u00f1adimos la configuraci\u00f3n del Feign Client con la url del Gateway a trav\u00e9s del cual vamos a realizar todas las comunicaciones y creamos un m\u00e9todo abstracto con la anotaci\u00f3n pertinente para hacer referencia al endpoint de obtenci\u00f3n del listado. Invocar los clientes Con esto ya podemos inyectar estas interfaces dentro de nuestro controlador para obtener todos los datos necesarios que completaran la informaci\u00f3n de la Category y Author de cada Game . Adem\u00e1s, vamos a cambiar el Dto de respuesta, para que en vez de devolver ids, devuelva los objetos correspondientes, que son los que est\u00e1 esperando nuestro frontend. Para ello, primero crearemos los Dtos que necesitamos. Los crearemos en: com.ccsw.tutorialgame.category.model com.ccsw.tutorialgame.author.model CategoryDto.java AuthorDto.java package com.ccsw.tutorialgame.category.model ; /** * @author ccsw * */ public class CategoryDto { private Long id ; private String name ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } } package com.ccsw.tutorialgame.author.model ; /** * @author ccsw * */ public class AuthorDto { private Long id ; private String name ; private String nationality ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } /** * @return nationality */ public String getNationality () { return this . nationality ; } /** * @param nationality new value of {@link #getNationality}. */ public void setNationality ( String nationality ) { this . nationality = nationality ; } } Adem\u00e1s, modificaremos nuestro GameDto para hacer uso de esos objetos. GameDto.java package com.ccsw.tutorialgame.game.model ; import com.ccsw.tutorialgame.author.model.AuthorDto ; import com.ccsw.tutorialgame.category.model.CategoryDto ; /** * @author ccsw * */ public class GameDto { private Long id ; private String title ; private String age ; private CategoryDto category ; private AuthorDto author ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return age */ public String getAge () { return this . age ; } /** * @param age new value of {@link #getAge}. */ public void setAge ( String age ) { this . age = age ; } /** * @return category */ public CategoryDto getCategory () { return this . category ; } /** * @param category new value of {@link #getCategory}. */ public void setCategory ( CategoryDto category ) { this . category = category ; } /** * @return author */ public AuthorDto getAuthor () { return this . author ; } /** * @param author new value of {@link #getAuthor}. */ public void setAuthor ( AuthorDto author ) { this . author = author ; } } Y por \u00faltimo implementaremos el c\u00f3digo necesario para transformar los ids en objetos dto. Aqu\u00ed lo que haremos ser\u00e1 recuperar todos los autores y categor\u00edas, haciendo uso de los Feign Client , y cuando ejecutemos el mapeo de los juegos, ir sustituyendo sus valores por los dtos correspondientes. GameController.java package com.ccsw.tutorialgame.game ; import com.ccsw.tutorialgame.author.AuthorClient ; import com.ccsw.tutorialgame.author.model.AuthorDto ; import com.ccsw.tutorialgame.category.CategoryClient ; import com.ccsw.tutorialgame.category.model.CategoryDto ; import com.ccsw.tutorialgame.game.model.Game ; import com.ccsw.tutorialgame.game.model.GameDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.* ; import java.util.List ; import java.util.stream.Collectors ; /** * @author ccsw * */ @Tag ( name = \"Game\" , description = \"API of Game\" ) @RequestMapping ( value = \"/game\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class GameController { @Autowired GameService gameService ; @Autowired CategoryClient categoryClient ; @Autowired AuthorClient authorClient ; /** * M\u00e9todo para recuperar una lista de {@link Game} * * @param title t\u00edtulo del juego * @param idCategory PK de la categor\u00eda * @return {@link List} de {@link GameDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a filtered list of Games\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < GameDto > find ( @RequestParam ( value = \"title\" , required = false ) String title , @RequestParam ( value = \"idCategory\" , required = false ) Long idCategory ) { List < CategoryDto > categories = categoryClient . findAll (); List < AuthorDto > authors = authorClient . findAll (); return gameService . find ( title , idCategory ). stream (). map ( game -> { GameDto gameDto = new GameDto (); gameDto . setId ( game . getId ()); gameDto . setTitle ( game . getTitle ()); gameDto . setAge ( game . getAge ()); gameDto . setCategory ( categories . stream (). filter ( category -> category . getId (). equals ( game . getIdCategory ())). findFirst (). orElse ( null )); gameDto . setAuthor ( authors . stream (). filter ( author -> author . getId (). equals ( game . getIdAuthor ())). findFirst (). orElse ( null )); return gameDto ; }). collect ( Collectors . toList ()); } /** * M\u00e9todo para crear o actualizar un {@link Game} * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Game\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody GameDto dto ) { gameService . save ( id , dto ); } } Con todo esto, ya tenemos construido nuestro aplicativo de micro servicios con la arquitectura Spring Cloud. Podemos proceder a realizar las mismas pruebas tanto manuales como a trav\u00e9s de los frontales. Escalado Una de las principales ventajas de las arquitecturas de micro servicios, es la posibilidad de escalar partes de los aplicativos sin tener que escalar el sistema completo. Para confirmar que esto es asi, podemos levantar multiples instancias de cada servicio en puertos diferentes y veremos que esto se refleja en Eureka y el Gateway balancear\u00e1 autom\u00e1ticamente entre las distintas instancias.","title":"Infraestructura"},{"location":"appendix/springcloud/infra/#infraestructura-spring-cloud","text":"Creados los tres micro servicios que compondr\u00e1n nuestro aplicativo, ya podemos empezar con la creaci\u00f3n de las piezas de infraestructura que ser\u00e1n las encargadas de realizar la orquestaci\u00f3n.","title":"Infraestructura - Spring Cloud"},{"location":"appendix/springcloud/infra/#service-discovery-eureka","text":"Para esta pieza hay muchas aplicaciones de mercado, incluso los propios proveedores de cloud tiene la suya propia, pero en este caso, vamos a utilizar la que ofrece Spring Cloud, as\u00ed que vamos a crear un proyecto de una forma similar a la que estamos acostumbrados.","title":"Service Discovery - Eureka"},{"location":"appendix/springcloud/infra/#crear-el-servicio","text":"Volviendo una vez m\u00e1s a Spring Initializr seleccionaremos los siguientes datos: Tipo de proyecto: Maven Lenguage: Java Versi\u00f3n Spring boot: 3.0.4 (o alguna similar) Group: com.ccsw ArtifactId: tutorial-eureka Versi\u00f3n Java: 19 Dependencias: Eureka Server Es importante que a\u00f1adamos la dependencia de Eureka Server para que sea capaz de ejecutar el proyecto como si fuera un servidor Eureka.","title":"Crear el servicio"},{"location":"appendix/springcloud/infra/#configurar-el-servicio","text":"Importamos el proyecto dentro del IDE y ya solo nos queda activar el servidor y configurarlo. En primer lugar, a\u00f1adimos la anotaci\u00f3n que habilita el servidor de Eureka. TutorialEurekaApplication.java package com.ccsw.tutorialeureka ; import org.springframework.boot.SpringApplication ; import org.springframework.boot.autoconfigure.SpringBootApplication ; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer ; @SpringBootApplication @EnableEurekaServer public class TutorialEurekaApplication { public static void main ( String [] args ) { SpringApplication . run ( TutorialEurekaApplication . class , args ); } } Ahora debemos a\u00f1adir las configuraciones necesarias. En primer lugar para facilitar la visualizaci\u00f3n de las propiedades vamos a renombrar nuestro fichero application.properties a application.yml . Hecho esto, a\u00f1adimos la configuraci\u00f3n de puerto que ya conocemos y a\u00f1adimos directivas sobre que Eureka no se registre a s\u00ed mismo dentro del cat\u00e1logo de servicios. application.yml server: port: 8761 eureka: client: registerWithEureka: false fetchRegistry: false","title":"Configurar el servicio"},{"location":"appendix/springcloud/infra/#probar-el-servicio","text":"Hechas estas sencillas configuraciones y arrancando el proyecto, nos dirigimos a la http://localhost/8761 donde podemos ver la interfaz de Eureka y si miramos con detenimiento, vemos que el cat\u00e1logo de servicios aparece vac\u00edo, ya que a\u00fan no se ha registrado ninguno de ellos.","title":"Probar el servicio"},{"location":"appendix/springcloud/infra/#micro-servicios","text":"Ahora que ya tenemos disponible Eureka, ya podemos proceder a registrar nuestros micro servicios dentro del cat\u00e1logo. Para ello vamos a realizar las mismas modificaciones sobre los tres micro servicios. Recuerda que hay que realizarlo sobre los tres para que se registren todos.","title":"Micro servicios"},{"location":"appendix/springcloud/infra/#configurar-micro-servicios","text":"Para este fin debemos a\u00f1adir una nueva dependencia dentro del pom.xml y modificar la configuraci\u00f3n del proyecto. pom.xml application.properties <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <parent> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-parent </artifactId> <version> 3.0.4 </version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId> com.ccsw </groupId> <artifactId> tutorial-XXX </artifactId> <!-- Cada proyecto tiene su configaci\u00f3n propia, NO modificar --> <version> 0.0.1-SNAPSHOT </version> <name> tutorial-XXX </name> <!-- Cada proyecto tiene su configaci\u00f3n propia, NO modificar --> <description> Demo project for Spring Boot </description> <properties> <java.version> 19 </java.version> <spring-cloud.version> 2022.0.1 </spring-cloud.version> </properties> <dependencies> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-data-jpa </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-web </artifactId> </dependency> <dependency> <groupId> org.springdoc </groupId> <artifactId> springdoc-openapi-starter-webmvc-ui </artifactId> <version> 2.0.3 </version> </dependency> <dependency> <groupId> org.hibernate </groupId> <artifactId> hibernate-validator </artifactId> <version> 8.0.0.Final </version> </dependency> <dependency> <groupId> net.sf.dozer </groupId> <artifactId> dozer </artifactId> <version> 5.5.1 </version> </dependency> <dependency> <groupId> org.springframework.cloud </groupId> <artifactId> spring-cloud-starter-netflix-eureka-client </artifactId> </dependency> <dependency> <groupId> com.h2database </groupId> <artifactId> h2 </artifactId> <scope> runtime </scope> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-test </artifactId> <scope> test </scope> </dependency> </dependencies> <dependencyManagement> <dependencies> <dependency> <groupId> org.springframework.cloud </groupId> <artifactId> spring-cloud-dependencies </artifactId> <version> ${spring-cloud.version} </version> <type> pom </type> <scope> import </scope> </dependency> </dependencies> </dependencyManagement> <build> <plugins> <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> </plugin> </plugins> </build> </project> spring.application.name = spring-cloud-eureka-client-XXX server.port = 809X #Database spring.datasource.url = jdbc:h2:mem:testdb spring.datasource.username = sa spring.datasource.password = sa spring.datasource.driver-class-name = org.h2.Driver spring.jpa.database-platform = org.hibernate.dialect.H2Dialect spring.jpa.defer-datasource-initialization = true spring.jpa.show-sql = true spring.h2.console.enabled = true #Eureka eureka.client.serviceUrl.defaultZone = ${EUREKA_URI:http://localhost:8761/eureka} eureka.instance.preferIpAddress = true Como podemos observar, lo que hemos hecho, es a\u00f1adir la dependencia de Eureka Client y le hemos comunicado a cada micro servicio donde tenemos arrancado Eureka. De este modo al arrancar cada micro servicio, este se registrar\u00e1 autom\u00e1ticamente dentro de Eureka. Para poder diferenciar cada micro servicio, estos tienen su configuraci\u00f3n de nombre y puerto (mantenemos el puerto que hab\u00edamos configurado en pasos previos): Categor\u00edas: spring.application.name=spring-cloud-eureka-client-category Autores: spring.application.name=spring-cloud-eureka-client-author Juegos: spring.application.name=spring-cloud-eureka-client-game Nombres en vez de rutas Estos nombres ser\u00e1n por los que vamos a identificar cada micro servicio dentro de Eureka que ser\u00e1 quien conozca las rutas de los mismos, asi cuando queramos realizar redirecciones a estos no necesitaremos conocerlas rutas ni los puertos de los mismos, con proporcionar los nombres tendremos la informaci\u00f3n completa de como llegar a ellos.","title":"Configurar micro servicios"},{"location":"appendix/springcloud/infra/#probar-micro-servicios","text":"Hechas estas configuraciones y arrancados los micro servicios, volvemos a dirigirnos a Eureka en http://localhost/8761 donde podemos ver que estos aparecen en el listado de servicios registrados.","title":"Probar micro servicios"},{"location":"appendix/springcloud/infra/#gateway","text":"Para esta pieza, de nuevo, hay muchas implementaciones y aplicaciones de mercado, pero nosotros vamos a utilizar la de Spring Cloud, as\u00ed que vamos a crear un nuevo proyecto de una forma similar a la de Eureka.","title":"Gateway"},{"location":"appendix/springcloud/infra/#crear-el-servicio_1","text":"Volviendo una vez m\u00e1s a Spring Initializr seleccionaremos los siguientes datos: Tipo de proyecto: Maven Lenguage: Java Versi\u00f3n Spring boot: 3.0.4 (o alguna similar) Group: com.ccsw ArtifactId: tutorial-gateway Versi\u00f3n Java: 19 Dependencias: Gateway, Eureka Client Ojo con las dependencias de Gateway y de Eureka Client que debemos a\u00f1adir.","title":"Crear el servicio"},{"location":"appendix/springcloud/infra/#configurar-el-servicio_1","text":"De nuevo lo importamos en nuestro IDE y pasamos a a\u00f1adir las configuraciones pertinentes. Al igual que en el caso de Eureka vamos a renombrar nuestro fichero application.properties a application.yml . application.yml server: port: 8080 eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka spring: application: name: spring-cloud-eureka-client-gateway cloud: gateway: default-filters: - DedupeResponseHeader=Access-Control-Allow-Credentials Access-Control-Allow-Origin globalcors: corsConfigurations: '[/**]': allowedOrigins: \"*\" allowedMethods: \"*\" allowedHeaders: \"*\" routes: - id: category uri: lb://SPRING-CLOUD-EUREKA-CLIENT-CATEGORY predicates: - Path=/category/** - id: author uri: lb://SPRING-CLOUD-EUREKA-CLIENT-AUTHOR predicates: - Path=/author/** - id: game uri: lb://SPRING-CLOUD-EUREKA-CLIENT-GAME predicates: - Path=/game/** Lo que hemos hecho aqu\u00ed es configurar el puerto como 8080 ya que el Gateway va a ser nuestro punto de acceso y el encargado de redirigir cada petici\u00f3n al micro servicio correcto. Posteriormente hemos configurado el cliente de Eureka para que el Gateway establezca comunicaci\u00f3n con Eureka que hemos configurado previamente para, en primer lugar, registrarse como un cliente y seguidamente obtener informaci\u00f3n del cat\u00e1logo de servicios existentes. El paso siguiente es darle un nombre a la aplicaci\u00f3n para que se registre en Eureka y a\u00f1adir configuraci\u00f3n de CORS para que cuando realicemos las llamadas desde navegador pueda realizar la redirecci\u00f3n correctamente. Finalmente a\u00f1adimos las directrices de redirecci\u00f3n al Gateway indic\u00e1ndole los nombres de los micro servicios con los que estos se han registrado en Eureka junto a los predicados que incluyen las rutas parciales que queremos que sean redirigidas a cada micro servicio. Con esto nos queda la siguiente configuraci\u00f3n: Las rutas que incluyan en su path category redirigir\u00e1n al micro servicio de Categorias Las rutas que incluyan en su path author redirigir\u00e1n al micro servicio de Autores Las rutas que incluyan en su path game redirigir\u00e1n al micro servicio de Juegos","title":"Configurar el servicio"},{"location":"appendix/springcloud/infra/#probar-el-servicio_1","text":"Hechas esto y arrancado el proyecto, volvemos a dirigirnos a Eureka en http://localhost/8761 donde podemos ver que el Gateway se ha registrado correctamente junto al resto de clientes.","title":"Probar el servicio"},{"location":"appendix/springcloud/infra/#feign-client","text":"El \u00faltimo paso es la implementaci\u00f3n de la comunicaci\u00f3n entre los micro servicios, en este caso necesitamos que nuestro micro servicio de Game obtenga datos de Category y Author para poder servir informaci\u00f3n completa de los Game ya que en su modelo solo posee los identificadores. Si record\u00e1is, est\u00e1bamos respondiendo solamente con los id .","title":"Feign Client"},{"location":"appendix/springcloud/infra/#configurar-el-servicio_2","text":"Para la comunicaci\u00f3n entre los distintos servicios, Spring Cloud nos prove de Feign Clients que ofrecen una interfaz muy sencilla de comunicaci\u00f3n y que utiliza a la perfecci\u00f3n la infraestructura que ya hemos construido. En primer lugar debemos a\u00f1adir la dependencia necesaria dentro de nuestro pom.xml del micro servicio de Game . pom.xml ... <dependency> <groupId> org.springframework.cloud </groupId> <artifactId> spring-cloud-starter-netflix-eureka-client </artifactId> </dependency> <dependency> <groupId> org.springframework.cloud </groupId> <artifactId> spring-cloud-starter-openfeign </artifactId> </dependency> <dependency> <groupId> com.h2database </groupId> <artifactId> h2 </artifactId> <scope> runtime </scope> </dependency> ... El siguiente paso es habilitar el uso de los Feign Clients mediante la anotaci\u00f3n de SpringCloud. TutorialGameApplication.java package com.ccsw.tutorialgame ; import org.springframework.boot.SpringApplication ; import org.springframework.boot.autoconfigure.SpringBootApplication ; import org.springframework.cloud.openfeign.EnableFeignClients ; @SpringBootApplication @EnableFeignClients public class TutorialGameApplication { public static void main ( String [] args ) { SpringApplication . run ( TutorialGameApplication . class , args ); } }","title":"Configurar el servicio"},{"location":"appendix/springcloud/infra/#configurar-los-clientes","text":"Realizadas las configuraciones ya podemos realizar los cambios necesarios en nuestro c\u00f3digo para implementar la comunicaci\u00f3n. En primer lugar vamos a crear los clientes de Categor\u00edas y Autores . CategoryClient.java AuthorClient.java package com.ccsw.tutorialgame.category ; import com.ccsw.tutorialgame.category.model.CategoryDto ; import org.springframework.cloud.openfeign.FeignClient ; import org.springframework.web.bind.annotation.GetMapping ; import java.util.List ; @FeignClient ( value = \"SPRING-CLOUD-EUREKA-CLIENT-CATEGORY\" , url = \"http://localhost:8080\" ) public interface CategoryClient { @GetMapping ( value = \"/category\" ) List < CategoryDto > findAll (); } package com.ccsw.tutorialgame.author ; import com.ccsw.tutorialgame.author.model.AuthorDto ; import org.springframework.cloud.openfeign.FeignClient ; import org.springframework.web.bind.annotation.GetMapping ; import java.util.List ; @FeignClient ( value = \"SPRING-CLOUD-EUREKA-CLIENT-AUTHOR\" , url = \"http://localhost:8080\" ) public interface AuthorClient { @GetMapping ( value = \"/author\" ) List < AuthorDto > findAll (); } Lo que hacemos aqu\u00ed es crear una simple interfaz donde a\u00f1adimos la configuraci\u00f3n del Feign Client con la url del Gateway a trav\u00e9s del cual vamos a realizar todas las comunicaciones y creamos un m\u00e9todo abstracto con la anotaci\u00f3n pertinente para hacer referencia al endpoint de obtenci\u00f3n del listado.","title":"Configurar los clientes"},{"location":"appendix/springcloud/infra/#invocar-los-clientes","text":"Con esto ya podemos inyectar estas interfaces dentro de nuestro controlador para obtener todos los datos necesarios que completaran la informaci\u00f3n de la Category y Author de cada Game . Adem\u00e1s, vamos a cambiar el Dto de respuesta, para que en vez de devolver ids, devuelva los objetos correspondientes, que son los que est\u00e1 esperando nuestro frontend. Para ello, primero crearemos los Dtos que necesitamos. Los crearemos en: com.ccsw.tutorialgame.category.model com.ccsw.tutorialgame.author.model CategoryDto.java AuthorDto.java package com.ccsw.tutorialgame.category.model ; /** * @author ccsw * */ public class CategoryDto { private Long id ; private String name ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } } package com.ccsw.tutorialgame.author.model ; /** * @author ccsw * */ public class AuthorDto { private Long id ; private String name ; private String nationality ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } /** * @return nationality */ public String getNationality () { return this . nationality ; } /** * @param nationality new value of {@link #getNationality}. */ public void setNationality ( String nationality ) { this . nationality = nationality ; } } Adem\u00e1s, modificaremos nuestro GameDto para hacer uso de esos objetos. GameDto.java package com.ccsw.tutorialgame.game.model ; import com.ccsw.tutorialgame.author.model.AuthorDto ; import com.ccsw.tutorialgame.category.model.CategoryDto ; /** * @author ccsw * */ public class GameDto { private Long id ; private String title ; private String age ; private CategoryDto category ; private AuthorDto author ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return age */ public String getAge () { return this . age ; } /** * @param age new value of {@link #getAge}. */ public void setAge ( String age ) { this . age = age ; } /** * @return category */ public CategoryDto getCategory () { return this . category ; } /** * @param category new value of {@link #getCategory}. */ public void setCategory ( CategoryDto category ) { this . category = category ; } /** * @return author */ public AuthorDto getAuthor () { return this . author ; } /** * @param author new value of {@link #getAuthor}. */ public void setAuthor ( AuthorDto author ) { this . author = author ; } } Y por \u00faltimo implementaremos el c\u00f3digo necesario para transformar los ids en objetos dto. Aqu\u00ed lo que haremos ser\u00e1 recuperar todos los autores y categor\u00edas, haciendo uso de los Feign Client , y cuando ejecutemos el mapeo de los juegos, ir sustituyendo sus valores por los dtos correspondientes. GameController.java package com.ccsw.tutorialgame.game ; import com.ccsw.tutorialgame.author.AuthorClient ; import com.ccsw.tutorialgame.author.model.AuthorDto ; import com.ccsw.tutorialgame.category.CategoryClient ; import com.ccsw.tutorialgame.category.model.CategoryDto ; import com.ccsw.tutorialgame.game.model.Game ; import com.ccsw.tutorialgame.game.model.GameDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.* ; import java.util.List ; import java.util.stream.Collectors ; /** * @author ccsw * */ @Tag ( name = \"Game\" , description = \"API of Game\" ) @RequestMapping ( value = \"/game\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class GameController { @Autowired GameService gameService ; @Autowired CategoryClient categoryClient ; @Autowired AuthorClient authorClient ; /** * M\u00e9todo para recuperar una lista de {@link Game} * * @param title t\u00edtulo del juego * @param idCategory PK de la categor\u00eda * @return {@link List} de {@link GameDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a filtered list of Games\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < GameDto > find ( @RequestParam ( value = \"title\" , required = false ) String title , @RequestParam ( value = \"idCategory\" , required = false ) Long idCategory ) { List < CategoryDto > categories = categoryClient . findAll (); List < AuthorDto > authors = authorClient . findAll (); return gameService . find ( title , idCategory ). stream (). map ( game -> { GameDto gameDto = new GameDto (); gameDto . setId ( game . getId ()); gameDto . setTitle ( game . getTitle ()); gameDto . setAge ( game . getAge ()); gameDto . setCategory ( categories . stream (). filter ( category -> category . getId (). equals ( game . getIdCategory ())). findFirst (). orElse ( null )); gameDto . setAuthor ( authors . stream (). filter ( author -> author . getId (). equals ( game . getIdAuthor ())). findFirst (). orElse ( null )); return gameDto ; }). collect ( Collectors . toList ()); } /** * M\u00e9todo para crear o actualizar un {@link Game} * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Game\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody GameDto dto ) { gameService . save ( id , dto ); } } Con todo esto, ya tenemos construido nuestro aplicativo de micro servicios con la arquitectura Spring Cloud. Podemos proceder a realizar las mismas pruebas tanto manuales como a trav\u00e9s de los frontales. Escalado Una de las principales ventajas de las arquitecturas de micro servicios, es la posibilidad de escalar partes de los aplicativos sin tener que escalar el sistema completo. Para confirmar que esto es asi, podemos levantar multiples instancias de cada servicio en puertos diferentes y veremos que esto se refleja en Eureka y el Gateway balancear\u00e1 autom\u00e1ticamente entre las distintas instancias.","title":"Invocar los clientes"},{"location":"appendix/springcloud/intro/","text":"Introducci\u00f3n Micro Servicios - Spring Cloud Que son los micro servicios? Pues como su nombre indica, son servicios peque\u00f1itos Aunque si nos vamos a una definici\u00f3n m\u00e1s t\u00e9cnica (seg\u00fan ChatGPT): Los micro servicios son una arquitectura de software en la que una aplicaci\u00f3n est\u00e1 compuesta por peque\u00f1os servicios independientes que se comunican entre s\u00ed a trav\u00e9s de interfaces bien definidas. Cada servicio se enfoca en realizar una tarea espec\u00edfica dentro de la aplicaci\u00f3n y se ejecuta de manera aut\u00f3noma. Cada micro servicio es responsable de un dominio del negocio y puede ser desarrollado, probado, implementado y escalado de manera independiente. Esto permite una mayor flexibilidad y agilidad en el desarrollo y la implementaci\u00f3n de aplicaciones, ya que los cambios en un servicio no afectan a otros servicios. Adem\u00e1s, los micro servicios son escalables y resistentes a fallos, ya que si un servicio falla, los dem\u00e1s servicios pueden seguir funcionando. Tambi\u00e9n permiten la utilizaci\u00f3n de diferentes tecnolog\u00edas para cada servicio, lo que ayuda a optimizar el rendimiento y la eficiencia en la aplicaci\u00f3n en general. Spring Cloud Existente multiples soluciones para implementar micro servicios, en nuestro caso vamos a utilizar la soluci\u00f3n que nos ofrece Spring Framework y que est\u00e1 incluido dentro del m\u00f3dulo Spring Cloud . Esta soluci\u00f3n nace hace ya varios a\u00f1os como parte de la infraestructura de Netflix para dar soluci\u00f3n a sus propias necesidades. Con el tiempo este c\u00f3digo opensource ha sido adquirido por Spring Framework y se ha incluido dentro de su ecosistema, evolucionandolo con nuevas funcionalidades. Todo ello ha sido publicado bajo el m\u00f3dulo de Spring Cloud. Contexto de la aplicaci\u00f3n Llegados a este punto, \u00bfqu\u00e9 es lo que vamos a hacer en los siguientes puntos?. Pues vamos a coger nuestra aplicaci\u00f3n monol\u00edtica que ya tenemos implementada durante todo el tutorial, y vamos a proceder a trocearla e implementarla con una metodolog\u00eda de micro servicios. Pero, adem\u00e1s de trocear la aplicaci\u00f3n en peque\u00f1os servicios, nos va a hacer falta una serie de servicios / utilidades para conectar todo el ecosistema. Nos har\u00e1 falta una infraestructura. Infraestructura A diferencia de una aplicaci\u00f3n monol\u00edtica, en un enfoque de micro servicios, ya no basta \u00fanicamente con la aplicaci\u00f3n desplegada en su servidor, sino que ser\u00e1n necesarios varios actores que se responsabilizar\u00e1n de darle consistencia al sistema, permitir la comunicaci\u00f3n entre ellos, y ayudar\u00e1n a solventar ciertos problemas que nos surgir\u00e1n al trocear nuestras aplicaciones. Las principales piezas que vamos a utilizar para la implementaci\u00f3n de nuestra infraestructura, ser\u00e1n: Service Discovery / Eureka Server : Como vamos a tener varios servicios distribuidos por nuestra red, necesitaremos conocer donde est\u00e1 funcionando cada uno de ellos, su IP, su puerto e incluso sus m\u00e9tricas de acceso (localizaci\u00f3n, zona, estado de carga, etc.). Vamos a necesitar un Service Discovery que no es m\u00e1s que un cat\u00e1logo de todos los servicios que componen el ecosistema al cual cada servicio debe informar de forma proactiva, de su localizaci\u00f3n y disponibilidad. Client-side Service Discovery / Eureka Client : Como hemos mencionado en el punto anterior, todos los servicios del ecosistema (incluidos nuestros micro servicios) deben conectarse con el Service Discovery e informar peri\u00f3dicamente a este cat\u00e1logo de su estado y sus m\u00e9tricas para que en caso de perdida de servicio, el resto de elementos lo sepan y puedan tomar decisiones al respecto. Tambi\u00e9n nos servir\u00e1 para que cada elemento pueda guardar en local una cach\u00e9 del cat\u00e1logo publicado, que se ir\u00e1 refrescando cada vez que lance un health check . Edge Server / Gateway / Proxy : Se trata de un servicio que har\u00e1 de intermediario entre el mundo exterior y el mundo de microservicios. Adem\u00e1s permitir\u00e1 hacer redirecci\u00f3n y balanceo entre todos los elementos registrados en el Service Discovery . Es altamente configurable (rutas, redirecciones, carga, etc.) y es una pieza fundamental para unificar todas las llamadas en un \u00fanico punto del ecosistema. Feign Client : Esta utilidad que provee directamente Spring Cloud nos permite comunicarnos entre los diferentes micro servicios de Spring, de una forma muy sencilla y sin tener que estar gestionando llamadas API Rest. Diagrama de la arquitectura Con las piezas identificadas anteriormente y con el Contexto de la aplicaci\u00f3n en mente, lo que vamos a hacer en los siguientes puntos es trocear el sistema y generar la siguiente arquitectura: Ya deber\u00edamos tener claros los conceptos y los actores que compondr\u00e1n nuestro sistema, as\u00ed que, all\u00e1 vamos!!!","title":"Introducci\u00f3n"},{"location":"appendix/springcloud/intro/#introduccion-micro-servicios-spring-cloud","text":"","title":"Introducci\u00f3n Micro Servicios - Spring Cloud"},{"location":"appendix/springcloud/intro/#que-son-los-micro-servicios","text":"Pues como su nombre indica, son servicios peque\u00f1itos Aunque si nos vamos a una definici\u00f3n m\u00e1s t\u00e9cnica (seg\u00fan ChatGPT): Los micro servicios son una arquitectura de software en la que una aplicaci\u00f3n est\u00e1 compuesta por peque\u00f1os servicios independientes que se comunican entre s\u00ed a trav\u00e9s de interfaces bien definidas. Cada servicio se enfoca en realizar una tarea espec\u00edfica dentro de la aplicaci\u00f3n y se ejecuta de manera aut\u00f3noma. Cada micro servicio es responsable de un dominio del negocio y puede ser desarrollado, probado, implementado y escalado de manera independiente. Esto permite una mayor flexibilidad y agilidad en el desarrollo y la implementaci\u00f3n de aplicaciones, ya que los cambios en un servicio no afectan a otros servicios. Adem\u00e1s, los micro servicios son escalables y resistentes a fallos, ya que si un servicio falla, los dem\u00e1s servicios pueden seguir funcionando. Tambi\u00e9n permiten la utilizaci\u00f3n de diferentes tecnolog\u00edas para cada servicio, lo que ayuda a optimizar el rendimiento y la eficiencia en la aplicaci\u00f3n en general.","title":"Que son los micro servicios?"},{"location":"appendix/springcloud/intro/#spring-cloud","text":"Existente multiples soluciones para implementar micro servicios, en nuestro caso vamos a utilizar la soluci\u00f3n que nos ofrece Spring Framework y que est\u00e1 incluido dentro del m\u00f3dulo Spring Cloud . Esta soluci\u00f3n nace hace ya varios a\u00f1os como parte de la infraestructura de Netflix para dar soluci\u00f3n a sus propias necesidades. Con el tiempo este c\u00f3digo opensource ha sido adquirido por Spring Framework y se ha incluido dentro de su ecosistema, evolucionandolo con nuevas funcionalidades. Todo ello ha sido publicado bajo el m\u00f3dulo de Spring Cloud.","title":"Spring Cloud"},{"location":"appendix/springcloud/intro/#contexto-de-la-aplicacion","text":"Llegados a este punto, \u00bfqu\u00e9 es lo que vamos a hacer en los siguientes puntos?. Pues vamos a coger nuestra aplicaci\u00f3n monol\u00edtica que ya tenemos implementada durante todo el tutorial, y vamos a proceder a trocearla e implementarla con una metodolog\u00eda de micro servicios. Pero, adem\u00e1s de trocear la aplicaci\u00f3n en peque\u00f1os servicios, nos va a hacer falta una serie de servicios / utilidades para conectar todo el ecosistema. Nos har\u00e1 falta una infraestructura.","title":"Contexto de la aplicaci\u00f3n"},{"location":"appendix/springcloud/intro/#infraestructura","text":"A diferencia de una aplicaci\u00f3n monol\u00edtica, en un enfoque de micro servicios, ya no basta \u00fanicamente con la aplicaci\u00f3n desplegada en su servidor, sino que ser\u00e1n necesarios varios actores que se responsabilizar\u00e1n de darle consistencia al sistema, permitir la comunicaci\u00f3n entre ellos, y ayudar\u00e1n a solventar ciertos problemas que nos surgir\u00e1n al trocear nuestras aplicaciones. Las principales piezas que vamos a utilizar para la implementaci\u00f3n de nuestra infraestructura, ser\u00e1n: Service Discovery / Eureka Server : Como vamos a tener varios servicios distribuidos por nuestra red, necesitaremos conocer donde est\u00e1 funcionando cada uno de ellos, su IP, su puerto e incluso sus m\u00e9tricas de acceso (localizaci\u00f3n, zona, estado de carga, etc.). Vamos a necesitar un Service Discovery que no es m\u00e1s que un cat\u00e1logo de todos los servicios que componen el ecosistema al cual cada servicio debe informar de forma proactiva, de su localizaci\u00f3n y disponibilidad. Client-side Service Discovery / Eureka Client : Como hemos mencionado en el punto anterior, todos los servicios del ecosistema (incluidos nuestros micro servicios) deben conectarse con el Service Discovery e informar peri\u00f3dicamente a este cat\u00e1logo de su estado y sus m\u00e9tricas para que en caso de perdida de servicio, el resto de elementos lo sepan y puedan tomar decisiones al respecto. Tambi\u00e9n nos servir\u00e1 para que cada elemento pueda guardar en local una cach\u00e9 del cat\u00e1logo publicado, que se ir\u00e1 refrescando cada vez que lance un health check . Edge Server / Gateway / Proxy : Se trata de un servicio que har\u00e1 de intermediario entre el mundo exterior y el mundo de microservicios. Adem\u00e1s permitir\u00e1 hacer redirecci\u00f3n y balanceo entre todos los elementos registrados en el Service Discovery . Es altamente configurable (rutas, redirecciones, carga, etc.) y es una pieza fundamental para unificar todas las llamadas en un \u00fanico punto del ecosistema. Feign Client : Esta utilidad que provee directamente Spring Cloud nos permite comunicarnos entre los diferentes micro servicios de Spring, de una forma muy sencilla y sin tener que estar gestionando llamadas API Rest.","title":"Infraestructura"},{"location":"appendix/springcloud/intro/#diagrama-de-la-arquitectura","text":"Con las piezas identificadas anteriormente y con el Contexto de la aplicaci\u00f3n en mente, lo que vamos a hacer en los siguientes puntos es trocear el sistema y generar la siguiente arquitectura: Ya deber\u00edamos tener claros los conceptos y los actores que compondr\u00e1n nuestro sistema, as\u00ed que, all\u00e1 vamos!!!","title":"Diagrama de la arquitectura"},{"location":"appendix/springcloud/paginated/","text":"Listado paginado - Spring Boot Al igual que en el caso anterior vamos a crear un nuevo proyecto que contendr\u00e1 un nuevo micro servicio. Para la creaci\u00f3n de proyecto nos remitimos a la gu\u00eda de instalaci\u00f3n donde se detalla el proceso de creaci\u00f3n de nuevo proyecto Entorno de desarrollo Todos los pasos son exactamente iguales, lo \u00fanico que va a variar, es el nombre de nuestro proyecto, que en este caso se va a llamar tutorial-author . El campo que debemos modificar es artifact en Spring Initilizr, el resto de campos se cambiaran autom\u00e1ticamente. C\u00f3digo Dado de vamos a implementar el micro servicio Spring Boot de Autores , vamos a respetar la misma estructura del Listado paginado de la version monol\u00edtica. Paginaci\u00f3n En primer lugar, vamos a a\u00f1adir la clase que necesitamos para realizar la paginaci\u00f3n y vimos en la version monol\u00edtica del tutorial en el package com.ccsw.tutorialauthor.common.pagination . Ojo al package que lo hemos renombrado con respecto al listado monol\u00edtico. PageableRequest.java package com.ccsw.tutorialauthor.common.pagination ; import com.fasterxml.jackson.annotation.JsonIgnore ; import org.springframework.data.domain.* ; import java.io.Serializable ; import java.util.ArrayList ; import java.util.List ; import java.util.stream.Collectors ; public class PageableRequest implements Serializable { private static final long serialVersionUID = 1L ; private int pageNumber ; private int pageSize ; private List < SortRequest > sort ; public PageableRequest () { sort = new ArrayList <> (); } public PageableRequest ( int pageNumber , int pageSize ) { this (); this . pageNumber = pageNumber ; this . pageSize = pageSize ; } public PageableRequest ( int pageNumber , int pageSize , List < SortRequest > sort ) { this (); this . pageNumber = pageNumber ; this . pageSize = pageSize ; this . sort = sort ; } public int getPageNumber () { return pageNumber ; } public void setPageNumber ( int pageNumber ) { this . pageNumber = pageNumber ; } public int getPageSize () { return pageSize ; } public void setPageSize ( int pageSize ) { this . pageSize = pageSize ; } public List < SortRequest > getSort () { return sort ; } public void setSort ( List < SortRequest > sort ) { this . sort = sort ; } @JsonIgnore public Pageable getPageable () { return PageRequest . of ( this . pageNumber , this . pageSize , Sort . by ( sort . stream (). map ( e -> new Sort . Order ( e . getDirection (), e . getProperty ())). collect ( Collectors . toList ()))); } public static class SortRequest implements Serializable { private static final long serialVersionUID = 1L ; private String property ; private Sort . Direction direction ; protected String getProperty () { return property ; } protected void setProperty ( String property ) { this . property = property ; } protected Sort . Direction getDirection () { return direction ; } protected void setDirection ( Sort . Direction direction ) { this . direction = direction ; } } } Entity y Dto Seguimos con la entidad y los DTOs dentro del package com.ccsw.tutorialauthor.author.model . Author.java AuthorDto.java AuthorSearchDto.java package com.ccsw.tutorialauthor.author.model ; import jakarta.persistence.* ; /** * @author ccsw * */ @Entity @Table ( name = \"author\" ) public class Author { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"name\" , nullable = false ) private String name ; @Column ( name = \"nationality\" ) private String nationality ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } /** * @return nationality */ public String getNationality () { return this . nationality ; } /** * @param nationality new value of {@link #getNationality}. */ public void setNationality ( String nationality ) { this . nationality = nationality ; } } package com.ccsw.tutorialauthor.author.model ; /** * @author ccsw * */ public class AuthorDto { private Long id ; private String name ; private String nationality ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } /** * @return nationality */ public String getNationality () { return this . nationality ; } /** * @param nationality new value of {@link #getNationality}. */ public void setNationality ( String nationality ) { this . nationality = nationality ; } } package com.ccsw.tutorialauthor.author.model ; import com.ccsw.tutorialauthor.common.pagination.PageableRequest ; /** * @author ccsw * */ public class AuthorSearchDto { private PageableRequest pageable ; public PageableRequest getPageable () { return pageable ; } public void setPageable ( PageableRequest pageable ) { this . pageable = pageable ; } } Repository, Service y Controller Posteriormente, emplazamos el resto de clases dentro del package com.ccsw.tutorialauthor.author . AuthorRepository.java AuthorService.java AuthorServiceImpl.java AuthorController.java package com.ccsw.tutorialauthor.author ; import com.ccsw.tutorialauthor.author.model.Author ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.Pageable ; import org.springframework.data.repository.CrudRepository ; /** * @author ccsw * */ public interface AuthorRepository extends CrudRepository < Author , Long > { /** * M\u00e9todo para recuperar un listado paginado de {@link Author} * * @param pageable pageable * @return {@link Page} de {@link Author} */ Page < Author > findAll ( Pageable pageable ); } package com.ccsw.tutorialauthor.author ; import com.ccsw.tutorialauthor.author.model.Author ; import com.ccsw.tutorialauthor.author.model.AuthorDto ; import com.ccsw.tutorialauthor.author.model.AuthorSearchDto ; import org.springframework.data.domain.Page ; import java.util.List ; /** * @author ccsw * */ public interface AuthorService { /** * Recupera un {@link Author} a trav\u00e9s de su ID * * @param id PK de la entidad * @return {@link Author} */ Author get ( Long id ); /** * M\u00e9todo para recuperar un listado paginado de {@link Author} * * @param dto dto de b\u00fasqueda * @return {@link Page} de {@link Author} */ Page < Author > findPage ( AuthorSearchDto dto ); /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad * @param dto datos de la entidad */ void save ( Long id , AuthorDto dto ); /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad */ void delete ( Long id ) throws Exception ; /** * Recupera un listado de autores {@link Author} * * @return {@link List} de {@link Author} */ List < Author > findAll (); } package com.ccsw.tutorialauthor.author ; import com.ccsw.tutorialauthor.author.model.Author ; import com.ccsw.tutorialauthor.author.model.AuthorDto ; import com.ccsw.tutorialauthor.author.model.AuthorSearchDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class AuthorServiceImpl implements AuthorService { @Autowired AuthorRepository authorRepository ; /** * {@inheritDoc} * @return */ @Override public Author get ( Long id ) { return this . authorRepository . findById ( id ). orElse ( null ); } /** * {@inheritDoc} */ @Override public Page < Author > findPage ( AuthorSearchDto dto ) { return this . authorRepository . findAll ( dto . getPageable (). getPageable ()); } /** * {@inheritDoc} */ @Override public void save ( Long id , AuthorDto data ) { Author author ; if ( id == null ) { author = new Author (); } else { author = this . get ( id ); } BeanUtils . copyProperties ( data , author , \"id\" ); this . authorRepository . save ( author ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) throws Exception { if ( this . get ( id ) == null ){ throw new Exception ( \"Not exists\" ); } this . authorRepository . deleteById ( id ); } /** * {@inheritDoc} */ @Override public List < Author > findAll () { return ( List < Author > ) this . authorRepository . findAll (); } } package com.ccsw.tutorialauthor.author ; import com.ccsw.tutorialauthor.author.model.Author ; import com.ccsw.tutorialauthor.author.model.AuthorDto ; import com.ccsw.tutorialauthor.author.model.AuthorSearchDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; import org.modelmapper.ModelMapper ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.PageImpl ; import org.springframework.web.bind.annotation.* ; import java.util.List ; import java.util.stream.Collectors ; /** * @author ccsw * */ @Tag ( name = \"Author\" , description = \"API of Author\" ) @RequestMapping ( value = \"/author\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class AuthorController { @Autowired AuthorService authorService ; @Autowired ModelMapper mapper ; /** * M\u00e9todo para recuperar un listado paginado de {@link Author} * * @param dto dto de b\u00fasqueda * @return {@link Page} de {@link AuthorDto} */ @Operation ( summary = \"Find Page\" , description = \"Method that return a page of Authors\" ) @RequestMapping ( path = \"\" , method = RequestMethod . POST ) public Page < AuthorDto > findPage ( @RequestBody AuthorSearchDto dto ) { Page < Author > page = this . authorService . findPage ( dto ); return new PageImpl <> ( page . getContent (). stream (). map ( e -> mapper . map ( e , AuthorDto . class )). collect ( Collectors . toList ()), page . getPageable (), page . getTotalElements ()); } /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Author\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody AuthorDto dto ) { this . authorService . save ( id , dto ); } /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad */ @Operation ( summary = \"Delete\" , description = \"Method that deletes a Author\" ) @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) throws Exception { this . authorService . delete ( id ); } /** * Recupera un listado de autores {@link Author} * * @return {@link List} de {@link AuthorDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a list of Authors\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < AuthorDto > findAll () { List < Author > authors = this . authorService . findAll (); return authors . stream (). map ( e -> mapper . map ( e , AuthorDto . class )). collect ( Collectors . toList ()); } } SQL y Configuraci\u00f3n Finalmente, debemos crear el script de inicializaci\u00f3n de base de datos con solo los datos de author y modificar ligeramente la configuraci\u00f3n inicial para a\u00f1adir un puerto manualmente para poder tener multiples micro servicios funcionando simult\u00e1neamente. data.sql application.properties INSERT INTO author ( name , nationality ) VALUES ( 'Alan R. Moon' , 'US' ); INSERT INTO author ( name , nationality ) VALUES ( 'Vital Lacerda' , 'PT' ); INSERT INTO author ( name , nationality ) VALUES ( 'Simone Luciani' , 'IT' ); INSERT INTO author ( name , nationality ) VALUES ( 'Perepau Llistosella' , 'ES' ); INSERT INTO author ( name , nationality ) VALUES ( 'Michael Kiesling' , 'DE' ); INSERT INTO author ( name , nationality ) VALUES ( 'Phil Walker-Harding' , 'US' ); server.port = 8092 #Database spring.datasource.url = jdbc:h2:mem:testdb spring.datasource.username = sa spring.datasource.password = sa spring.datasource.driver-class-name = org.h2.Driver spring.jpa.database-platform = org.hibernate.dialect.H2Dialect spring.jpa.defer-datasource-initialization = true spring.jpa.show-sql = true spring.h2.console.enabled = true Pruebas Ahora si arrancamos la aplicaci\u00f3n server y abrimos el Postman podemos realizar las mismas pruebas del apartado de Listado paginado pero esta vez apuntado al puerto 8092 . Siguientes pasos En este punto ya tenemos un micro servicio de categor\u00edas en el puerto 8091 y un micro servicio de autores en el puerto 8092 . Al igual que antes, con estos datos ya podr\u00edamos conectar el frontend a estos servicios, pero vamos a esperar un poquito m\u00e1s a tener toda la infraestructura, para que sea m\u00e1s sencillo. Vamos a convertir en micro servicio el \u00faltimo listado.","title":"Listado paginado"},{"location":"appendix/springcloud/paginated/#listado-paginado-spring-boot","text":"Al igual que en el caso anterior vamos a crear un nuevo proyecto que contendr\u00e1 un nuevo micro servicio. Para la creaci\u00f3n de proyecto nos remitimos a la gu\u00eda de instalaci\u00f3n donde se detalla el proceso de creaci\u00f3n de nuevo proyecto Entorno de desarrollo Todos los pasos son exactamente iguales, lo \u00fanico que va a variar, es el nombre de nuestro proyecto, que en este caso se va a llamar tutorial-author . El campo que debemos modificar es artifact en Spring Initilizr, el resto de campos se cambiaran autom\u00e1ticamente.","title":"Listado paginado - Spring Boot"},{"location":"appendix/springcloud/paginated/#codigo","text":"Dado de vamos a implementar el micro servicio Spring Boot de Autores , vamos a respetar la misma estructura del Listado paginado de la version monol\u00edtica.","title":"C\u00f3digo"},{"location":"appendix/springcloud/paginated/#paginacion","text":"En primer lugar, vamos a a\u00f1adir la clase que necesitamos para realizar la paginaci\u00f3n y vimos en la version monol\u00edtica del tutorial en el package com.ccsw.tutorialauthor.common.pagination . Ojo al package que lo hemos renombrado con respecto al listado monol\u00edtico. PageableRequest.java package com.ccsw.tutorialauthor.common.pagination ; import com.fasterxml.jackson.annotation.JsonIgnore ; import org.springframework.data.domain.* ; import java.io.Serializable ; import java.util.ArrayList ; import java.util.List ; import java.util.stream.Collectors ; public class PageableRequest implements Serializable { private static final long serialVersionUID = 1L ; private int pageNumber ; private int pageSize ; private List < SortRequest > sort ; public PageableRequest () { sort = new ArrayList <> (); } public PageableRequest ( int pageNumber , int pageSize ) { this (); this . pageNumber = pageNumber ; this . pageSize = pageSize ; } public PageableRequest ( int pageNumber , int pageSize , List < SortRequest > sort ) { this (); this . pageNumber = pageNumber ; this . pageSize = pageSize ; this . sort = sort ; } public int getPageNumber () { return pageNumber ; } public void setPageNumber ( int pageNumber ) { this . pageNumber = pageNumber ; } public int getPageSize () { return pageSize ; } public void setPageSize ( int pageSize ) { this . pageSize = pageSize ; } public List < SortRequest > getSort () { return sort ; } public void setSort ( List < SortRequest > sort ) { this . sort = sort ; } @JsonIgnore public Pageable getPageable () { return PageRequest . of ( this . pageNumber , this . pageSize , Sort . by ( sort . stream (). map ( e -> new Sort . Order ( e . getDirection (), e . getProperty ())). collect ( Collectors . toList ()))); } public static class SortRequest implements Serializable { private static final long serialVersionUID = 1L ; private String property ; private Sort . Direction direction ; protected String getProperty () { return property ; } protected void setProperty ( String property ) { this . property = property ; } protected Sort . Direction getDirection () { return direction ; } protected void setDirection ( Sort . Direction direction ) { this . direction = direction ; } } }","title":"Paginaci\u00f3n"},{"location":"appendix/springcloud/paginated/#entity-y-dto","text":"Seguimos con la entidad y los DTOs dentro del package com.ccsw.tutorialauthor.author.model . Author.java AuthorDto.java AuthorSearchDto.java package com.ccsw.tutorialauthor.author.model ; import jakarta.persistence.* ; /** * @author ccsw * */ @Entity @Table ( name = \"author\" ) public class Author { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"name\" , nullable = false ) private String name ; @Column ( name = \"nationality\" ) private String nationality ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } /** * @return nationality */ public String getNationality () { return this . nationality ; } /** * @param nationality new value of {@link #getNationality}. */ public void setNationality ( String nationality ) { this . nationality = nationality ; } } package com.ccsw.tutorialauthor.author.model ; /** * @author ccsw * */ public class AuthorDto { private Long id ; private String name ; private String nationality ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } /** * @return nationality */ public String getNationality () { return this . nationality ; } /** * @param nationality new value of {@link #getNationality}. */ public void setNationality ( String nationality ) { this . nationality = nationality ; } } package com.ccsw.tutorialauthor.author.model ; import com.ccsw.tutorialauthor.common.pagination.PageableRequest ; /** * @author ccsw * */ public class AuthorSearchDto { private PageableRequest pageable ; public PageableRequest getPageable () { return pageable ; } public void setPageable ( PageableRequest pageable ) { this . pageable = pageable ; } }","title":"Entity y Dto"},{"location":"appendix/springcloud/paginated/#repository-service-y-controller","text":"Posteriormente, emplazamos el resto de clases dentro del package com.ccsw.tutorialauthor.author . AuthorRepository.java AuthorService.java AuthorServiceImpl.java AuthorController.java package com.ccsw.tutorialauthor.author ; import com.ccsw.tutorialauthor.author.model.Author ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.Pageable ; import org.springframework.data.repository.CrudRepository ; /** * @author ccsw * */ public interface AuthorRepository extends CrudRepository < Author , Long > { /** * M\u00e9todo para recuperar un listado paginado de {@link Author} * * @param pageable pageable * @return {@link Page} de {@link Author} */ Page < Author > findAll ( Pageable pageable ); } package com.ccsw.tutorialauthor.author ; import com.ccsw.tutorialauthor.author.model.Author ; import com.ccsw.tutorialauthor.author.model.AuthorDto ; import com.ccsw.tutorialauthor.author.model.AuthorSearchDto ; import org.springframework.data.domain.Page ; import java.util.List ; /** * @author ccsw * */ public interface AuthorService { /** * Recupera un {@link Author} a trav\u00e9s de su ID * * @param id PK de la entidad * @return {@link Author} */ Author get ( Long id ); /** * M\u00e9todo para recuperar un listado paginado de {@link Author} * * @param dto dto de b\u00fasqueda * @return {@link Page} de {@link Author} */ Page < Author > findPage ( AuthorSearchDto dto ); /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad * @param dto datos de la entidad */ void save ( Long id , AuthorDto dto ); /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad */ void delete ( Long id ) throws Exception ; /** * Recupera un listado de autores {@link Author} * * @return {@link List} de {@link Author} */ List < Author > findAll (); } package com.ccsw.tutorialauthor.author ; import com.ccsw.tutorialauthor.author.model.Author ; import com.ccsw.tutorialauthor.author.model.AuthorDto ; import com.ccsw.tutorialauthor.author.model.AuthorSearchDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class AuthorServiceImpl implements AuthorService { @Autowired AuthorRepository authorRepository ; /** * {@inheritDoc} * @return */ @Override public Author get ( Long id ) { return this . authorRepository . findById ( id ). orElse ( null ); } /** * {@inheritDoc} */ @Override public Page < Author > findPage ( AuthorSearchDto dto ) { return this . authorRepository . findAll ( dto . getPageable (). getPageable ()); } /** * {@inheritDoc} */ @Override public void save ( Long id , AuthorDto data ) { Author author ; if ( id == null ) { author = new Author (); } else { author = this . get ( id ); } BeanUtils . copyProperties ( data , author , \"id\" ); this . authorRepository . save ( author ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) throws Exception { if ( this . get ( id ) == null ){ throw new Exception ( \"Not exists\" ); } this . authorRepository . deleteById ( id ); } /** * {@inheritDoc} */ @Override public List < Author > findAll () { return ( List < Author > ) this . authorRepository . findAll (); } } package com.ccsw.tutorialauthor.author ; import com.ccsw.tutorialauthor.author.model.Author ; import com.ccsw.tutorialauthor.author.model.AuthorDto ; import com.ccsw.tutorialauthor.author.model.AuthorSearchDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; import org.modelmapper.ModelMapper ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.PageImpl ; import org.springframework.web.bind.annotation.* ; import java.util.List ; import java.util.stream.Collectors ; /** * @author ccsw * */ @Tag ( name = \"Author\" , description = \"API of Author\" ) @RequestMapping ( value = \"/author\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class AuthorController { @Autowired AuthorService authorService ; @Autowired ModelMapper mapper ; /** * M\u00e9todo para recuperar un listado paginado de {@link Author} * * @param dto dto de b\u00fasqueda * @return {@link Page} de {@link AuthorDto} */ @Operation ( summary = \"Find Page\" , description = \"Method that return a page of Authors\" ) @RequestMapping ( path = \"\" , method = RequestMethod . POST ) public Page < AuthorDto > findPage ( @RequestBody AuthorSearchDto dto ) { Page < Author > page = this . authorService . findPage ( dto ); return new PageImpl <> ( page . getContent (). stream (). map ( e -> mapper . map ( e , AuthorDto . class )). collect ( Collectors . toList ()), page . getPageable (), page . getTotalElements ()); } /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Author\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody AuthorDto dto ) { this . authorService . save ( id , dto ); } /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad */ @Operation ( summary = \"Delete\" , description = \"Method that deletes a Author\" ) @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) throws Exception { this . authorService . delete ( id ); } /** * Recupera un listado de autores {@link Author} * * @return {@link List} de {@link AuthorDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a list of Authors\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < AuthorDto > findAll () { List < Author > authors = this . authorService . findAll (); return authors . stream (). map ( e -> mapper . map ( e , AuthorDto . class )). collect ( Collectors . toList ()); } }","title":"Repository, Service y Controller"},{"location":"appendix/springcloud/paginated/#sql-y-configuracion","text":"Finalmente, debemos crear el script de inicializaci\u00f3n de base de datos con solo los datos de author y modificar ligeramente la configuraci\u00f3n inicial para a\u00f1adir un puerto manualmente para poder tener multiples micro servicios funcionando simult\u00e1neamente. data.sql application.properties INSERT INTO author ( name , nationality ) VALUES ( 'Alan R. Moon' , 'US' ); INSERT INTO author ( name , nationality ) VALUES ( 'Vital Lacerda' , 'PT' ); INSERT INTO author ( name , nationality ) VALUES ( 'Simone Luciani' , 'IT' ); INSERT INTO author ( name , nationality ) VALUES ( 'Perepau Llistosella' , 'ES' ); INSERT INTO author ( name , nationality ) VALUES ( 'Michael Kiesling' , 'DE' ); INSERT INTO author ( name , nationality ) VALUES ( 'Phil Walker-Harding' , 'US' ); server.port = 8092 #Database spring.datasource.url = jdbc:h2:mem:testdb spring.datasource.username = sa spring.datasource.password = sa spring.datasource.driver-class-name = org.h2.Driver spring.jpa.database-platform = org.hibernate.dialect.H2Dialect spring.jpa.defer-datasource-initialization = true spring.jpa.show-sql = true spring.h2.console.enabled = true","title":"SQL y Configuraci\u00f3n"},{"location":"appendix/springcloud/paginated/#pruebas","text":"Ahora si arrancamos la aplicaci\u00f3n server y abrimos el Postman podemos realizar las mismas pruebas del apartado de Listado paginado pero esta vez apuntado al puerto 8092 .","title":"Pruebas"},{"location":"appendix/springcloud/paginated/#siguientes-pasos","text":"En este punto ya tenemos un micro servicio de categor\u00edas en el puerto 8091 y un micro servicio de autores en el puerto 8092 . Al igual que antes, con estos datos ya podr\u00edamos conectar el frontend a estos servicios, pero vamos a esperar un poquito m\u00e1s a tener toda la infraestructura, para que sea m\u00e1s sencillo. Vamos a convertir en micro servicio el \u00faltimo listado.","title":"Siguientes pasos"},{"location":"appendix/springcloud/summary/","text":"Resumen Micro Servicios - Spring Cloud \u00bfQu\u00e9 hemos hecho? Llegados a este punto, ya has podido comprobar que implementar una aplicaci\u00f3n orientada a micro servicios es bastante similar a una aplicaci\u00f3n monol\u00edtica, con la salvedad de que tienes que tener en cuenta la distribuci\u00f3n de estos, y por tanto su gesti\u00f3n y coordinaci\u00f3n. En definitiva, lo que hemos implementado ha sido: Service Discovery : Que ayudar\u00e1 a tener un cat\u00e1logo de todos las piezas de mi infraestructura, su IP, su puerto y ciertas m\u00e9tricas que ayuden luego en la elecci\u00f3n de servicio. Gateway : Que centraliza las peticiones en un \u00fanico punto y permite hacer de balanceo de carga, seguridad, etc. Ser\u00e1 el punto de entrada a nuestro ecosistema. Micro servicio Category : Contiene las operaciones sobre el \u00e1mbito funcional de categor\u00edas, guarda y recupera informaci\u00f3n de ese \u00e1mbito funcional. Micro servicio Author : Contiene las operaciones sobre el \u00e1mbito funcional de autores, guarda y recupera informaci\u00f3n de ese \u00e1mbito funcional. Micro servicio Game : Contiene las operaciones sobre el \u00e1mbito funcional de autores, guarda y recupera informaci\u00f3n de ese \u00e1mbito funcional. Adem\u00e1s, realiza llamadas entre los otros dos micro servicios para nutrir de m\u00e1s informaci\u00f3n sus endpoints. El diagrama de nuestra aplicaci\u00f3n ahora es as\u00ed: Siguientes pasos Bueno, el siguiente paso m\u00e1s evidente, ser\u00e1 ver que si conectas el frontend sigue funcionando exactamente igual que lo estaba haciendo antes. Ahora te propongo hacer el mismo ejercicio con los otros dos m\u00f3dulos Cliente y Pr\u00e9stamo que has tenido que implementar en el punto Ahora hazlo tu! . Ten en cuenta que Cliente no depende de nadie, pero Pr\u00e9stamo si que depende de Cliente y de Game . A ver como solucionas los cruces y sobre todo los filtros M\u00e1s formaci\u00f3n, m\u00e1s informaci\u00f3n Pues ya estar\u00eda todo, ahora solo te puedo dar la enhorabuena y pasar algo de informaci\u00f3n extra / cursos / formaciones por si quieres seguir aprendiendo. Por un lado tienes el itinerario avanzado de Springboot donde se puede m\u00e1s detalle de micro servicios. Por otro lado tambi\u00e9n tienes los itinerarios de Cloud ya que no todo va a ser micro servicios con Spring Cloud, tambi\u00e9n existen micro servicios con otras tecnolog\u00edas, aunque el concepto es muy similar.","title":"Resumen"},{"location":"appendix/springcloud/summary/#resumen-micro-servicios-spring-cloud","text":"","title":"Resumen Micro Servicios - Spring Cloud"},{"location":"appendix/springcloud/summary/#que-hemos-hecho","text":"Llegados a este punto, ya has podido comprobar que implementar una aplicaci\u00f3n orientada a micro servicios es bastante similar a una aplicaci\u00f3n monol\u00edtica, con la salvedad de que tienes que tener en cuenta la distribuci\u00f3n de estos, y por tanto su gesti\u00f3n y coordinaci\u00f3n. En definitiva, lo que hemos implementado ha sido: Service Discovery : Que ayudar\u00e1 a tener un cat\u00e1logo de todos las piezas de mi infraestructura, su IP, su puerto y ciertas m\u00e9tricas que ayuden luego en la elecci\u00f3n de servicio. Gateway : Que centraliza las peticiones en un \u00fanico punto y permite hacer de balanceo de carga, seguridad, etc. Ser\u00e1 el punto de entrada a nuestro ecosistema. Micro servicio Category : Contiene las operaciones sobre el \u00e1mbito funcional de categor\u00edas, guarda y recupera informaci\u00f3n de ese \u00e1mbito funcional. Micro servicio Author : Contiene las operaciones sobre el \u00e1mbito funcional de autores, guarda y recupera informaci\u00f3n de ese \u00e1mbito funcional. Micro servicio Game : Contiene las operaciones sobre el \u00e1mbito funcional de autores, guarda y recupera informaci\u00f3n de ese \u00e1mbito funcional. Adem\u00e1s, realiza llamadas entre los otros dos micro servicios para nutrir de m\u00e1s informaci\u00f3n sus endpoints. El diagrama de nuestra aplicaci\u00f3n ahora es as\u00ed:","title":"\u00bfQu\u00e9 hemos hecho?"},{"location":"appendix/springcloud/summary/#siguientes-pasos","text":"Bueno, el siguiente paso m\u00e1s evidente, ser\u00e1 ver que si conectas el frontend sigue funcionando exactamente igual que lo estaba haciendo antes. Ahora te propongo hacer el mismo ejercicio con los otros dos m\u00f3dulos Cliente y Pr\u00e9stamo que has tenido que implementar en el punto Ahora hazlo tu! . Ten en cuenta que Cliente no depende de nadie, pero Pr\u00e9stamo si que depende de Cliente y de Game . A ver como solucionas los cruces y sobre todo los filtros","title":"Siguientes pasos"},{"location":"appendix/springcloud/summary/#mas-formacion-mas-informacion","text":"Pues ya estar\u00eda todo, ahora solo te puedo dar la enhorabuena y pasar algo de informaci\u00f3n extra / cursos / formaciones por si quieres seguir aprendiendo. Por un lado tienes el itinerario avanzado de Springboot donde se puede m\u00e1s detalle de micro servicios. Por otro lado tambi\u00e9n tienes los itinerarios de Cloud ya que no todo va a ser micro servicios con Spring Cloud, tambi\u00e9n existen micro servicios con otras tecnolog\u00edas, aunque el concepto es muy similar.","title":"M\u00e1s formaci\u00f3n, m\u00e1s informaci\u00f3n"},{"location":"cleancode/angular/","text":"Estructura y Buenas pr\u00e1cticas - Angular Nota Antes de empezar y para puntualizar, Angular se considera un framework SPA Single-page application. En esta parte vamos a explicar los fundamentos de un proyecto en Angular y las recomendaciones existentes. Estructura y funcionamiento Ciclo de vida de Angular El comportamiento de ciclo de vida de un componente Angular pasa por diferentes etapas que podemos ver en el esquema que mostramos a continuaci\u00f3n: Es importante tenerlo claro para saber que m\u00e9todos podemos utilizar para realizar operaciones con el componente. Carpetas creadas por Angular Al crear una aplicaci\u00f3n Angular, tendremos los siguientes directorios: node_modules: Todos los m\u00f3dulos de librar\u00edas usado por el proyecto. \\src\\app: Contiene todo el c\u00f3digo asociado al proyecto. \\src\\assets: Normalmente la carpeta usada para los recursos. \\src\\environments: Aqu\u00ed ir\u00e1n los ficheros relacionados con los entornos de desarrollos. Otros ficheros importantes de un proyecto de Angular Otros archivos que debemos tener en cuenta dentro del proyecto son: angular.json: Configuraci\u00f3n del propio CLI. La madre de todos los configuradores package.json: Dependencias de librer\u00edas y scripts Estructura de m\u00f3dulos Existe m\u00faltiples consensos al respecto de como estructurar un proyecto en Angular, pero al final, depende de los requisitos del proyecto. Una sugerencia de como hacerlo es la siguiente: - src\\app - core /* Componentes y utilidades comunes */ - header /* Estructura del header */ - footer /* Estructura del footer */ - domain1 /* M\u00f3dulo con los componentes del dominio1 */ - services /* Servicios con operaciones del dominio1 */ - models /* Modelos de datos del dominio1 */ - component1 /* Componente1 del dominio1 */ - componentX /* ComponenteX del dominio1 */ - domainX /* As\u00ed para el resto de dominios de la aplicaci\u00f3n */ Recordar, que esto es una sugerencia para una estructura de carpetas y componentes. No existe un estandar. ATENCI\u00d3N: Componentes gen\u00e9ricos Debemos tener en cuenta que a la hora de programar un componente core , lo ideal es pensar que sea un componente plug & play, es decir que si lo copias y lo llevas a otro proyecto funcione sin la necesidad de adaptarlo. Buenas pr\u00e1cticas A continuaci\u00f3n veremos un listado de buenas pr\u00e1cticas de Angular y de c\u00f3digo limpio que deber\u00edamos intentar seguir en nuestro desarrollo. Estructura de archivos Antes de empezar con un proyecto lo ideal, es pararse y pensar en los requerimientos de una buena estructura, en un futuro lo agradecer\u00e1s. Nombres claros Utilizar la S de los principios S.O.L.I.D para los nombres de variables, m\u00e9todos y dem\u00e1s c\u00f3digo. El efecto que produce este principio son clases con nombres muy descriptivos y por tanto largos. Tambi\u00e9n se recomienta utilizar kebab-case para los nombres de ficheros. Ej. hero-button.component.ts Organiza tu c\u00f3digo Intenta organizar tu c\u00f3digo fuente: Lo m\u00e1s importante debe ir arriba. Primero propiedades, despu\u00e9s m\u00e9todos. Un Item para un archivo : cada archivo deber\u00eda contener solamente un componente, al igual que los servicios. Solo una responsabilidad : Cada clase o modulo deber\u00eda tener solamente una responsabilidad. El nombre correcto : las propiedades y m\u00e9todos deber\u00edan usar el sistema de camel case (ej: getUserByName) , al contrario, las clases (componentes, servicios, etc) deben usar upper camel case (ej: UserComponent) . Los componentes y servicios deben tener su respectivo sufijo: UserComponent, UserService. Imports : los archivos externos van primero. Usar linters Prettier & ESLint Un linter es una herramienta que nos ayuda a seguir las buenas pr\u00e1cticas o gu\u00edas de estilo de nuestro c\u00f3digo fuente. En este caso, para JavaScript, proveeremos de unos muy famosos. Una de las m\u00e1s famosas es la combinaci\u00f3n de Angular app to ESLint with Prettier, AirBnB Styleguide Recordar que a\u00f1adir este tipo de configuraci\u00f3n es opcional, pero necesaria para tener un buen c\u00f3digo de calidad. Git Hooks Los Git Hooks son scripts de shell que se ejecutan autom\u00e1ticamente antes o despu\u00e9s de que Git ejecute un comando importante como Commit o Push. Para hacer uso de el es tan sencillo como: npm install husky --save-dev Y a\u00f1adir en el fichero lo siguiente: // package.json { \"husky\" : { \"hooks\" : { \"pre-commit\" : \"npm test\" , \"pre-push\" : \"npm test\" , \"...\" : \"...\" } } } Usar husky para el preformateo de c\u00f3digo antes de subirlo Es una buena pr\u00e1ctica que todo el equipo use el mismo est\u00e1ndar de formateo de codigo, con husky se puede solucionar. Utilizar Banana in the Box Como el nombre sugiere banana in the box se debe a la forma que tiene lo siguiente: [{}] Esto es una forma muy sencilla de trabajar los cambios en la forma de Two ways binding. Es decir, el padre informa de un valor u objeto y el hijo lo manipula y actualiza el estado/valor al padre inmediatamente. La forma de implementarlo es sencillo Padre: HTML: <my-input [(text)]=\"text\"></my-input> Hijo @ Input () value : string ; @ Output () valueChange = new EventEmitter < string > (); updateValue ( value ){ this . value = value ; this . valueChange . emit ( value ); } Prefijo Change Destacar que el prefijo 'Change' es necesario incluirlo en el Hijo para que funcione Correcto uso de los servicios Una buena practica es aconsejable no declarar los servicios en el provides, sino usar un decorador que forma parte de las ultimas versiones de Angular @ Injectable ({ providedIn : 'root' , }) export class HeroService { constructor () { } } Lazy Load Lazy Load es un patr\u00f3n de dise\u00f1o que consiste en retrasar la carga o inicializaci\u00f3n desde el app-routing.module.ts A\u00f1adiremos un codigo parecido a este { path : 'customers' , loadChildren : () => import ( './customers/customers.module' ). then ( m => m . CustomersModule ) }, Con esto veremos que el m\u00f3dulo se cargar\u00e1 seg\u00fan se necesite.","title":"\ud83d\udd35 Angular"},{"location":"cleancode/angular/#estructura-y-buenas-practicas-angular","text":"Nota Antes de empezar y para puntualizar, Angular se considera un framework SPA Single-page application. En esta parte vamos a explicar los fundamentos de un proyecto en Angular y las recomendaciones existentes.","title":"Estructura y Buenas pr\u00e1cticas - Angular"},{"location":"cleancode/angular/#estructura-y-funcionamiento","text":"","title":"Estructura y funcionamiento"},{"location":"cleancode/angular/#ciclo-de-vida-de-angular","text":"El comportamiento de ciclo de vida de un componente Angular pasa por diferentes etapas que podemos ver en el esquema que mostramos a continuaci\u00f3n: Es importante tenerlo claro para saber que m\u00e9todos podemos utilizar para realizar operaciones con el componente.","title":"Ciclo de vida de Angular"},{"location":"cleancode/angular/#carpetas-creadas-por-angular","text":"Al crear una aplicaci\u00f3n Angular, tendremos los siguientes directorios: node_modules: Todos los m\u00f3dulos de librar\u00edas usado por el proyecto. \\src\\app: Contiene todo el c\u00f3digo asociado al proyecto. \\src\\assets: Normalmente la carpeta usada para los recursos. \\src\\environments: Aqu\u00ed ir\u00e1n los ficheros relacionados con los entornos de desarrollos. Otros ficheros importantes de un proyecto de Angular Otros archivos que debemos tener en cuenta dentro del proyecto son: angular.json: Configuraci\u00f3n del propio CLI. La madre de todos los configuradores package.json: Dependencias de librer\u00edas y scripts","title":"Carpetas creadas por Angular"},{"location":"cleancode/angular/#estructura-de-modulos","text":"Existe m\u00faltiples consensos al respecto de como estructurar un proyecto en Angular, pero al final, depende de los requisitos del proyecto. Una sugerencia de como hacerlo es la siguiente: - src\\app - core /* Componentes y utilidades comunes */ - header /* Estructura del header */ - footer /* Estructura del footer */ - domain1 /* M\u00f3dulo con los componentes del dominio1 */ - services /* Servicios con operaciones del dominio1 */ - models /* Modelos de datos del dominio1 */ - component1 /* Componente1 del dominio1 */ - componentX /* ComponenteX del dominio1 */ - domainX /* As\u00ed para el resto de dominios de la aplicaci\u00f3n */ Recordar, que esto es una sugerencia para una estructura de carpetas y componentes. No existe un estandar. ATENCI\u00d3N: Componentes gen\u00e9ricos Debemos tener en cuenta que a la hora de programar un componente core , lo ideal es pensar que sea un componente plug & play, es decir que si lo copias y lo llevas a otro proyecto funcione sin la necesidad de adaptarlo.","title":"Estructura de m\u00f3dulos"},{"location":"cleancode/angular/#buenas-practicas","text":"A continuaci\u00f3n veremos un listado de buenas pr\u00e1cticas de Angular y de c\u00f3digo limpio que deber\u00edamos intentar seguir en nuestro desarrollo.","title":"Buenas pr\u00e1cticas"},{"location":"cleancode/angular/#estructura-de-archivos","text":"Antes de empezar con un proyecto lo ideal, es pararse y pensar en los requerimientos de una buena estructura, en un futuro lo agradecer\u00e1s.","title":"Estructura de archivos"},{"location":"cleancode/angular/#nombres-claros","text":"Utilizar la S de los principios S.O.L.I.D para los nombres de variables, m\u00e9todos y dem\u00e1s c\u00f3digo. El efecto que produce este principio son clases con nombres muy descriptivos y por tanto largos. Tambi\u00e9n se recomienta utilizar kebab-case para los nombres de ficheros. Ej. hero-button.component.ts","title":"Nombres claros"},{"location":"cleancode/angular/#organiza-tu-codigo","text":"Intenta organizar tu c\u00f3digo fuente: Lo m\u00e1s importante debe ir arriba. Primero propiedades, despu\u00e9s m\u00e9todos. Un Item para un archivo : cada archivo deber\u00eda contener solamente un componente, al igual que los servicios. Solo una responsabilidad : Cada clase o modulo deber\u00eda tener solamente una responsabilidad. El nombre correcto : las propiedades y m\u00e9todos deber\u00edan usar el sistema de camel case (ej: getUserByName) , al contrario, las clases (componentes, servicios, etc) deben usar upper camel case (ej: UserComponent) . Los componentes y servicios deben tener su respectivo sufijo: UserComponent, UserService. Imports : los archivos externos van primero.","title":"Organiza tu c\u00f3digo"},{"location":"cleancode/angular/#usar-linters-prettier-eslint","text":"Un linter es una herramienta que nos ayuda a seguir las buenas pr\u00e1cticas o gu\u00edas de estilo de nuestro c\u00f3digo fuente. En este caso, para JavaScript, proveeremos de unos muy famosos. Una de las m\u00e1s famosas es la combinaci\u00f3n de Angular app to ESLint with Prettier, AirBnB Styleguide Recordar que a\u00f1adir este tipo de configuraci\u00f3n es opcional, pero necesaria para tener un buen c\u00f3digo de calidad.","title":"Usar linters Prettier &amp; ESLint"},{"location":"cleancode/angular/#git-hooks","text":"Los Git Hooks son scripts de shell que se ejecutan autom\u00e1ticamente antes o despu\u00e9s de que Git ejecute un comando importante como Commit o Push. Para hacer uso de el es tan sencillo como: npm install husky --save-dev Y a\u00f1adir en el fichero lo siguiente: // package.json { \"husky\" : { \"hooks\" : { \"pre-commit\" : \"npm test\" , \"pre-push\" : \"npm test\" , \"...\" : \"...\" } } } Usar husky para el preformateo de c\u00f3digo antes de subirlo Es una buena pr\u00e1ctica que todo el equipo use el mismo est\u00e1ndar de formateo de codigo, con husky se puede solucionar.","title":"Git Hooks"},{"location":"cleancode/angular/#utilizar-banana-in-the-box","text":"Como el nombre sugiere banana in the box se debe a la forma que tiene lo siguiente: [{}] Esto es una forma muy sencilla de trabajar los cambios en la forma de Two ways binding. Es decir, el padre informa de un valor u objeto y el hijo lo manipula y actualiza el estado/valor al padre inmediatamente. La forma de implementarlo es sencillo Padre: HTML: <my-input [(text)]=\"text\"></my-input> Hijo @ Input () value : string ; @ Output () valueChange = new EventEmitter < string > (); updateValue ( value ){ this . value = value ; this . valueChange . emit ( value ); } Prefijo Change Destacar que el prefijo 'Change' es necesario incluirlo en el Hijo para que funcione","title":"Utilizar Banana in the Box"},{"location":"cleancode/angular/#correcto-uso-de-los-servicios","text":"Una buena practica es aconsejable no declarar los servicios en el provides, sino usar un decorador que forma parte de las ultimas versiones de Angular @ Injectable ({ providedIn : 'root' , }) export class HeroService { constructor () { } }","title":"Correcto uso de los servicios"},{"location":"cleancode/angular/#lazy-load","text":"Lazy Load es un patr\u00f3n de dise\u00f1o que consiste en retrasar la carga o inicializaci\u00f3n desde el app-routing.module.ts A\u00f1adiremos un codigo parecido a este { path : 'customers' , loadChildren : () => import ( './customers/customers.module' ). then ( m => m . CustomersModule ) }, Con esto veremos que el m\u00f3dulo se cargar\u00e1 seg\u00fan se necesite.","title":"Lazy Load"},{"location":"cleancode/nodejs/","text":"Estructura y Buenas pr\u00e1cticas - Nodejs Estructura y funcionamiento En los proyectos Nodejs no existe nada estandarizado y oficial que hable sobre estructura de proyectos y nomenclatura de Nodejs. Tan solo existen algunas sugerencias y buenas pr\u00e1cticas a la hora de desarrollar que te recomiendo que utilices en la medida de lo posible. Tip Piensa que el c\u00f3digo fuente que escribes hoy, es como un libro que se leer\u00e1 durante a\u00f1os. Alguien tendr\u00e1 que coger tu c\u00f3digo y leerlo en unos meses o a\u00f1os para hacer alguna modificaci\u00f3n y, como buenos desarrolladores que somos, tenemos la obligaci\u00f3n de facilitarle en todo lo posible la comprensi\u00f3n de ese c\u00f3digo fuente. Quiz\u00e1 esa persona futura podr\u00edas ser tu en unos meses y quedar\u00eda muy mal que no entendieras ni tu propio c\u00f3digo Estructura en capas Todos los proyectos para crear una Rest API con node y express est\u00e1n divididos en capas. Como m\u00ednimo estar\u00e1 la capa de rutas, controlador y modelo. En nuestro caso vamos a a\u00f1adir una capa mas de servicios para quitarle trabajo al controlador y desacoplarlo de la capa de datos. As\u00ed si en el futuro queremos cambiar nuestra base de datos no romperemos tanto \ud83d\ude0a Rutas En nuestro proyecto una ruta ser\u00e1 una secci\u00f3n de c\u00f3digo express que asociar\u00e1 un verbo http, una ruta o patr\u00f3n de url y una funci\u00f3n perteneciente al controlador para manejar esa petici\u00f3n. Controladores En nuestros controladores tendremos los m\u00e9todos que obtendr\u00e1n las solicitudes de las rutas, se comunicar\u00e1n con la capa de servicio y convertir\u00e1n estas solicitudes en respuestas http. Servicio Nuestra capa de servicio incluir\u00e1 toda la l\u00f3gica de negocio de nuestra aplicaci\u00f3n. Para realizar sus operaciones puede realizar llamadas tanto a otras clases dentro de esta capa, como a clases de la capa inferior. Modelo Como su nombre indica esta capa representa los modelos de datos de nuestra aplicaci\u00f3n. En nuestro caso, al usar un ODM, solo tendremos modelos de datos definidos seg\u00fan sus requisitos. Buenas pr\u00e1cticas Accesos entre capas En base a la divisi\u00f3n por capas que hemos comentado arriba, y el resto de entidades implicadas, hay una serie de reglas important\u00edsimas que debes seguir muy de cerca: Un Controlador NO debe contener l\u00f3gica en su clase. Solo est\u00e1 permitido que ejecute l\u00f3gica a trav\u00e9s de una llamada al objeto de la capa L\u00f3gica. NO puede ejecutar directamente operaciones de la capa Acceso a Datos, siempre debe pasar por la capa de servicios. Debemos seguir una coherencia entre todas las URL de las operaciones. Por ejemplo, si elegimos save para guardar, usemos esa palabra en todas las operaciones que sean de ese tipo. Evitad utilizar diferentes palabras save, guardar, persistir, actualizar para la misma acci\u00f3n. Un Servicio NO puede llamar a objetos de la capa Controlador. NO debe llamar a Acceso a Datos que NO sean de su \u00e1mbito / competencia. Si es necesario puede llamar a otros Servicios para recuperar cierta informaci\u00f3n que no sea de su \u00e1mbito / competencia. Es un buen lugar para implementar la l\u00f3gica de negocio. Usar linters Prettier & ESLint (Se recomienda encarecidamente) Un linter es una herramienta que nos ayuda a seguir las buenas pr\u00e1cticas o gu\u00edas de estilo de nuestro c\u00f3digo fuente. En este caso, para JavaScript, proveeremos de unos muy famosos. Una de las m\u00e1s famosas es la combinaci\u00f3n de Angular app to ESLint with Prettier, AirBnB Styleguide Recordar que a\u00f1adir este tipo de configuraci\u00f3n es opcional, pero necesaria para tener un buen c\u00f3digo de calidad.","title":"\ud83d\udfe2 Nodejs"},{"location":"cleancode/nodejs/#estructura-y-buenas-practicas-nodejs","text":"","title":"Estructura y Buenas pr\u00e1cticas - Nodejs"},{"location":"cleancode/nodejs/#estructura-y-funcionamiento","text":"En los proyectos Nodejs no existe nada estandarizado y oficial que hable sobre estructura de proyectos y nomenclatura de Nodejs. Tan solo existen algunas sugerencias y buenas pr\u00e1cticas a la hora de desarrollar que te recomiendo que utilices en la medida de lo posible. Tip Piensa que el c\u00f3digo fuente que escribes hoy, es como un libro que se leer\u00e1 durante a\u00f1os. Alguien tendr\u00e1 que coger tu c\u00f3digo y leerlo en unos meses o a\u00f1os para hacer alguna modificaci\u00f3n y, como buenos desarrolladores que somos, tenemos la obligaci\u00f3n de facilitarle en todo lo posible la comprensi\u00f3n de ese c\u00f3digo fuente. Quiz\u00e1 esa persona futura podr\u00edas ser tu en unos meses y quedar\u00eda muy mal que no entendieras ni tu propio c\u00f3digo","title":"Estructura y funcionamiento"},{"location":"cleancode/nodejs/#estructura-en-capas","text":"Todos los proyectos para crear una Rest API con node y express est\u00e1n divididos en capas. Como m\u00ednimo estar\u00e1 la capa de rutas, controlador y modelo. En nuestro caso vamos a a\u00f1adir una capa mas de servicios para quitarle trabajo al controlador y desacoplarlo de la capa de datos. As\u00ed si en el futuro queremos cambiar nuestra base de datos no romperemos tanto \ud83d\ude0a Rutas En nuestro proyecto una ruta ser\u00e1 una secci\u00f3n de c\u00f3digo express que asociar\u00e1 un verbo http, una ruta o patr\u00f3n de url y una funci\u00f3n perteneciente al controlador para manejar esa petici\u00f3n. Controladores En nuestros controladores tendremos los m\u00e9todos que obtendr\u00e1n las solicitudes de las rutas, se comunicar\u00e1n con la capa de servicio y convertir\u00e1n estas solicitudes en respuestas http. Servicio Nuestra capa de servicio incluir\u00e1 toda la l\u00f3gica de negocio de nuestra aplicaci\u00f3n. Para realizar sus operaciones puede realizar llamadas tanto a otras clases dentro de esta capa, como a clases de la capa inferior. Modelo Como su nombre indica esta capa representa los modelos de datos de nuestra aplicaci\u00f3n. En nuestro caso, al usar un ODM, solo tendremos modelos de datos definidos seg\u00fan sus requisitos.","title":"Estructura en capas"},{"location":"cleancode/nodejs/#buenas-practicas","text":"","title":"Buenas pr\u00e1cticas"},{"location":"cleancode/nodejs/#accesos-entre-capas","text":"En base a la divisi\u00f3n por capas que hemos comentado arriba, y el resto de entidades implicadas, hay una serie de reglas important\u00edsimas que debes seguir muy de cerca: Un Controlador NO debe contener l\u00f3gica en su clase. Solo est\u00e1 permitido que ejecute l\u00f3gica a trav\u00e9s de una llamada al objeto de la capa L\u00f3gica. NO puede ejecutar directamente operaciones de la capa Acceso a Datos, siempre debe pasar por la capa de servicios. Debemos seguir una coherencia entre todas las URL de las operaciones. Por ejemplo, si elegimos save para guardar, usemos esa palabra en todas las operaciones que sean de ese tipo. Evitad utilizar diferentes palabras save, guardar, persistir, actualizar para la misma acci\u00f3n. Un Servicio NO puede llamar a objetos de la capa Controlador. NO debe llamar a Acceso a Datos que NO sean de su \u00e1mbito / competencia. Si es necesario puede llamar a otros Servicios para recuperar cierta informaci\u00f3n que no sea de su \u00e1mbito / competencia. Es un buen lugar para implementar la l\u00f3gica de negocio.","title":"Accesos entre capas"},{"location":"cleancode/nodejs/#usar-linters-prettier-eslint-se-recomienda-encarecidamente","text":"Un linter es una herramienta que nos ayuda a seguir las buenas pr\u00e1cticas o gu\u00edas de estilo de nuestro c\u00f3digo fuente. En este caso, para JavaScript, proveeremos de unos muy famosos. Una de las m\u00e1s famosas es la combinaci\u00f3n de Angular app to ESLint with Prettier, AirBnB Styleguide Recordar que a\u00f1adir este tipo de configuraci\u00f3n es opcional, pero necesaria para tener un buen c\u00f3digo de calidad.","title":"Usar linters Prettier &amp; ESLint (Se recomienda encarecidamente)"},{"location":"cleancode/springboot/","text":"Estructura y Buenas pr\u00e1cticas - Spring Boot Estructura y funcionamiento En Springboot no existe nada estandarizado y oficial que hable sobre estructura de proyectos y nomenclatura. Tan solo existen algunas sugerencias y buenas pr\u00e1cticas a la hora de desarrollar que te recomiendo que utilices en la medida de lo posible. Tip Piensa que el c\u00f3digo fuente que escribes hoy, es como un libro que se leer\u00e1 durante a\u00f1os. Alguien tendr\u00e1 que coger tu c\u00f3digo y leerlo en unos meses o a\u00f1os para hacer alguna modificaci\u00f3n y, como buenos desarrolladores que somos, tenemos la obligaci\u00f3n de facilitarle en todo lo posible la comprensi\u00f3n de ese c\u00f3digo fuente. Quiz\u00e1 esa persona futura podr\u00edas ser tu en unos meses y quedar\u00eda muy mal que no entendieras ni tu propio c\u00f3digo Estructura en capas Todos los proyectos web que construimos basados en Springboot se caracterizan por estar divididos en tres capas (a menos que utilicemos DDD para desarrollar que entonces existen infinitas capas ). Controlador . Es la capa m\u00e1s alta, la que tiene acceso directo con el cliente. En esta capa es donde se exponen las operaciones que queremos publicar y que el cliente puede consumir. Para realizar sus operaciones lo m\u00e1s normal es que realice llamadas a las clases de la capa inmediatamente inferior. L\u00f3gica . Tambi\u00e9n llamada capa de Servicios . Es la capa intermedia que da soporte a las operaciones que est\u00e1n expuestas y ejecutan toda la l\u00f3gica de negocio de la aplicaci\u00f3n. Para realizar sus operaciones puede realizar llamadas tanto a otras clases dentro de esta capa, como a clases de la capa inferior. Acceso a Datos . Como su nombre indica, es la capa que accede a datos. T\u00edpicamente es la capa que ejecuta las consultas contra BBDD, pero esto no tiene por qu\u00e9 ser obligadamente as\u00ed. Tambi\u00e9n entrar\u00edan en esa capa aquellas clases que consumen datos externos, por ejemplo de un servidor externo. Las clases de esta capa deben ser nodos finales , no pueden llamar a ninguna otra clase para ejecutar sus operaciones, ni siquiera de su misma capa. Estructura de proyecto En proyectos medianos o grandes, estructurar los directorios del proyecto en base a la estructura anteriormente descrita ser\u00eda muy complejo, ya que en cada uno de los niveles tendr\u00edamos muchas clases. As\u00ed que lo normal es diferenciar por \u00e1mbito funcional y dentro de cada package realizar la separaci\u00f3n en Controlador , L\u00f3gica y Acceso a datos . Tened en cuenta en un mismo \u00e1mbito funcional puede tener varios controladores o varios servicios de l\u00f3gica uno por cada entidad que estemos tratando. Siempre que se pueda, agruparemos entidades que intervengan dentro de una misma funcionalidad. En nuestro caso del tutorial, tendremos tres \u00e1mbitos funcionales Categor\u00eda , Autor , y Juego que diferenciaremos cada uno con su propia estructura. Buenas pr\u00e1cticas Nomenclatura de las clases @TODO: En construcci\u00f3n Accesos entre capas En base a la divisi\u00f3n por capas que hemos comentado arriba, y el resto de entidades implicadas, hay una serie de reglas important\u00edsimas que debes seguir muy de cerca: Un Controlador NO debe contener l\u00f3gica en su clase. Solo est\u00e1 permitido que ejecute l\u00f3gica a trav\u00e9s de una llamada al objeto de la capa L\u00f3gica . NO puede ejecutar directamente operaciones de la capa Acceso a Datos , siempre debe pasar por la capa L\u00f3gica . NO debe enviar ni recibir del cliente objetos de tipo Entity . Es un buen lugar para realizar las conversiones de datos entre Entity y Dto . En teor\u00eda cada operaci\u00f3n deber\u00eda tener su propio Dto, aunque los podemos reutilizar entre operaciones similares. Debemos seguir una coherencia entre todas las URL de las operaciones. Por ejemplo si elegimos save para guardar, usemos esa palabra en todas las operaciones que sean de ese tipo. Evitad utilizar diferentes palabras save , guardar , persistir , actualizar para la misma acci\u00f3n. Un Servicio NO puede llamar a objetos de la la capa Controlador . NO puede ejecutar directamente queries contra la BBDD, siempre debe pasar por la capa Acceso a Datos . NO debe llamar a Acceso a Datos que NO sean de su \u00e1mbito / competencia. Si es necesario puede llamar a otros Servicios para recuperar cierta informaci\u00f3n que no sea de su \u00e1mbito / competencia. Debe trabajar en la medida de lo posible con objetos de tipo Entity . Es un buen lugar para implementar la l\u00f3gica de negocio. Un Acceso a Datos NO puede llamar a ninguna otra capa. Ni Controlador , ni Servicios , ni Acceso a Datos . NO debe contener l\u00f3gica en su clase. Esta capa solo debe resolver el dato que se le ha solicitado y devolverlo a la capa de Servicios .","title":"\ud83d\udfe2 Spring Boot"},{"location":"cleancode/springboot/#estructura-y-buenas-practicas-spring-boot","text":"","title":"Estructura y Buenas pr\u00e1cticas - Spring Boot"},{"location":"cleancode/springboot/#estructura-y-funcionamiento","text":"En Springboot no existe nada estandarizado y oficial que hable sobre estructura de proyectos y nomenclatura. Tan solo existen algunas sugerencias y buenas pr\u00e1cticas a la hora de desarrollar que te recomiendo que utilices en la medida de lo posible. Tip Piensa que el c\u00f3digo fuente que escribes hoy, es como un libro que se leer\u00e1 durante a\u00f1os. Alguien tendr\u00e1 que coger tu c\u00f3digo y leerlo en unos meses o a\u00f1os para hacer alguna modificaci\u00f3n y, como buenos desarrolladores que somos, tenemos la obligaci\u00f3n de facilitarle en todo lo posible la comprensi\u00f3n de ese c\u00f3digo fuente. Quiz\u00e1 esa persona futura podr\u00edas ser tu en unos meses y quedar\u00eda muy mal que no entendieras ni tu propio c\u00f3digo","title":"Estructura y funcionamiento"},{"location":"cleancode/springboot/#estructura-en-capas","text":"Todos los proyectos web que construimos basados en Springboot se caracterizan por estar divididos en tres capas (a menos que utilicemos DDD para desarrollar que entonces existen infinitas capas ). Controlador . Es la capa m\u00e1s alta, la que tiene acceso directo con el cliente. En esta capa es donde se exponen las operaciones que queremos publicar y que el cliente puede consumir. Para realizar sus operaciones lo m\u00e1s normal es que realice llamadas a las clases de la capa inmediatamente inferior. L\u00f3gica . Tambi\u00e9n llamada capa de Servicios . Es la capa intermedia que da soporte a las operaciones que est\u00e1n expuestas y ejecutan toda la l\u00f3gica de negocio de la aplicaci\u00f3n. Para realizar sus operaciones puede realizar llamadas tanto a otras clases dentro de esta capa, como a clases de la capa inferior. Acceso a Datos . Como su nombre indica, es la capa que accede a datos. T\u00edpicamente es la capa que ejecuta las consultas contra BBDD, pero esto no tiene por qu\u00e9 ser obligadamente as\u00ed. Tambi\u00e9n entrar\u00edan en esa capa aquellas clases que consumen datos externos, por ejemplo de un servidor externo. Las clases de esta capa deben ser nodos finales , no pueden llamar a ninguna otra clase para ejecutar sus operaciones, ni siquiera de su misma capa.","title":"Estructura en capas"},{"location":"cleancode/springboot/#estructura-de-proyecto","text":"En proyectos medianos o grandes, estructurar los directorios del proyecto en base a la estructura anteriormente descrita ser\u00eda muy complejo, ya que en cada uno de los niveles tendr\u00edamos muchas clases. As\u00ed que lo normal es diferenciar por \u00e1mbito funcional y dentro de cada package realizar la separaci\u00f3n en Controlador , L\u00f3gica y Acceso a datos . Tened en cuenta en un mismo \u00e1mbito funcional puede tener varios controladores o varios servicios de l\u00f3gica uno por cada entidad que estemos tratando. Siempre que se pueda, agruparemos entidades que intervengan dentro de una misma funcionalidad. En nuestro caso del tutorial, tendremos tres \u00e1mbitos funcionales Categor\u00eda , Autor , y Juego que diferenciaremos cada uno con su propia estructura.","title":"Estructura de proyecto"},{"location":"cleancode/springboot/#buenas-practicas","text":"","title":"Buenas pr\u00e1cticas"},{"location":"cleancode/springboot/#nomenclatura-de-las-clases","text":"@TODO: En construcci\u00f3n","title":"Nomenclatura de las clases"},{"location":"cleancode/springboot/#accesos-entre-capas","text":"En base a la divisi\u00f3n por capas que hemos comentado arriba, y el resto de entidades implicadas, hay una serie de reglas important\u00edsimas que debes seguir muy de cerca: Un Controlador NO debe contener l\u00f3gica en su clase. Solo est\u00e1 permitido que ejecute l\u00f3gica a trav\u00e9s de una llamada al objeto de la capa L\u00f3gica . NO puede ejecutar directamente operaciones de la capa Acceso a Datos , siempre debe pasar por la capa L\u00f3gica . NO debe enviar ni recibir del cliente objetos de tipo Entity . Es un buen lugar para realizar las conversiones de datos entre Entity y Dto . En teor\u00eda cada operaci\u00f3n deber\u00eda tener su propio Dto, aunque los podemos reutilizar entre operaciones similares. Debemos seguir una coherencia entre todas las URL de las operaciones. Por ejemplo si elegimos save para guardar, usemos esa palabra en todas las operaciones que sean de ese tipo. Evitad utilizar diferentes palabras save , guardar , persistir , actualizar para la misma acci\u00f3n. Un Servicio NO puede llamar a objetos de la la capa Controlador . NO puede ejecutar directamente queries contra la BBDD, siempre debe pasar por la capa Acceso a Datos . NO debe llamar a Acceso a Datos que NO sean de su \u00e1mbito / competencia. Si es necesario puede llamar a otros Servicios para recuperar cierta informaci\u00f3n que no sea de su \u00e1mbito / competencia. Debe trabajar en la medida de lo posible con objetos de tipo Entity . Es un buen lugar para implementar la l\u00f3gica de negocio. Un Acceso a Datos NO puede llamar a ninguna otra capa. Ni Controlador , ni Servicios , ni Acceso a Datos . NO debe contener l\u00f3gica en su clase. Esta capa solo debe resolver el dato que se le ha solicitado y devolverlo a la capa de Servicios .","title":"Accesos entre capas"},{"location":"cleancode/vuejs/","text":"Estructura y Buenas pr\u00e1cticas - Vue.js Nota Antes de empezar y para puntualizar, Vue.js es un framework progresivo para construir interfaces de usuario. A diferencia de otros frameworks monol\u00edticos, Vue.js est\u00e1 dise\u00f1ado desde cero para ser utilizado incrementalmente. La librer\u00eda central est\u00e1 enfocada solo en la capa de visualizaci\u00f3n, y es f\u00e1cil de utilizar e integrar con otras librer\u00edas o proyectos existentes. Por otro lado, Vue.js tambi\u00e9n es perfectamente capaz de impulsar sofisticadas Single-Page Applications cuando se utiliza en combinaci\u00f3n con herramientas modernas y librer\u00edas de apoyo. En esta parte vamos a explicar los fundamentos de un proyecto en Vue.js y las recomendaciones existentes. Estructura y funcionamiento Instancia de la Aplicaci\u00f3n Cada aplicaci\u00f3n de Vue.js se comienza creando una nueva Instancia de Vue con la funci\u00f3n createApp() Componente ra\u00edz El componente ra\u00edz es el objeto que pasamos a la funci\u00f3n createApp. Toda aplicaci\u00f3n requiere un \"componente ra\u00edz\" que pueda contener otros componentes como sus hijos. Si est\u00e1s usando Single-File Components, normalmente importamos el componente ra\u00edz desde otro archivo. Ciclos de vida de Vue.js Vue.js 3 cuenta con un conjunto de ciclos de vida que permiten a los desarrolladores controlar y personalizar el comportamiento de sus componentes en diferentes momentos. Estos ciclos de vida se pueden agrupar en tres fases principales: creaci\u00f3n, actualizaci\u00f3n y eliminaci\u00f3n. A continuaci\u00f3n, te explicar\u00e9 cada uno de los ciclos de vida disponibles en Vue.js 3 junto con la Options API: beforeCreate: Este ciclo de vida se ejecuta inmediatamente despu\u00e9s de que se haya creado una instancia de componente, pero antes de que se haya creado su DOM. En este punto, a\u00fan no es posible acceder a las propiedades del componente y a\u00fan no se han establecido las observaciones reactivas. created: Este ciclo de vida se ejecuta despu\u00e9s de que se haya creado una instancia de componente y se hayan establecido las observaciones reactivas. En este punto, el componente ya puede acceder a sus propiedades y m\u00e9todos. beforeMount: Este ciclo de vida se ejecuta justo antes de que el componente se monte en el DOM. En este punto, el componente ya est\u00e1 preparado para ser renderizado, pero a\u00fan no se ha agregado al \u00e1rbol de elementos del DOM. mounted: Este ciclo de vida se ejecuta despu\u00e9s de que el componente se ha montado en el DOM. En este punto, el componente ya est\u00e1 en el \u00e1rbol de elementos del DOM y se puede acceder a sus elementos hijos y a los elementos del DOM que lo rodean. beforeUpdate: Este ciclo de vida se ejecuta justo antes de que el componente se actualice en respuesta a un cambio en sus propiedades o estado. En este punto, el componente a\u00fan no se ha actualizado en el DOM. updated: Este ciclo de vida se ejecuta despu\u00e9s de que el componente se haya actualizado en el DOM en respuesta a un cambio en sus propiedades o estado. En este punto, el componente ya se ha actualizado en el DOM y se puede acceder a sus elementos hijos y a los elementos del DOM que lo rodean. beforeUnmount: Este ciclo de vida se ejecuta justo antes de que el componente se elimine del DOM. En este punto, el componente a\u00fan est\u00e1 en el \u00e1rbol de elementos del DOM. unmounted: Este ciclo de vida se ejecuta despu\u00e9s de que el componente se haya eliminado del DOM. En este punto, el componente ya no est\u00e1 en el \u00e1rbol de elementos del DOM y no se puede acceder a sus elementos hijos. errorCaptured: Este ciclo de vida se ejecuta cuando se produce un error en cualquier descendiente del componente y se captura en el componente actual. Esto permite que el componente maneje el error de forma personalizada en lugar de propagarse hacia arriba en la cadena de componentes. activated: Este ciclo de vida se ejecuta cuando un componente que se encuentra en un \u00e1rbol de componentes inactivo (por ejemplo, un componente en una pesta\u00f1a inactiva) se activa. deactivated: Este ciclo de vida se ejecuta cuando un componente que se encuentra en un \u00e1rbol de componentes activo (por ejemplo, un componente en una pesta\u00f1a activa) se desactiva y se vuelve inactivo. renderTracked: Este ciclo de vida se ejecuta cuando se observa una dependencia en el proceso de renderizado del componente. Esto se utiliza principalmente para fines de depuraci\u00f3n. renderTriggered: Este ciclo de vida se ejecuta cuando se desencadena un nuevo renderizado del componente. Esto se utiliza principalmente para fines de depuraci\u00f3n. serverPrefetch: Este ciclo de vida se utiliza en el contexto de renderizado del lado del servidor (SSR). Se ejecuta cuando el componente se preprocesa en el servidor antes de enviarse al cliente. En este punto, el componente a\u00fan no se ha montado en el DOM y no se pueden realizar operaciones que dependan del DOM. Esto se utiliza principalmente para cargar datos de forma as\u00edncrona antes de que se renderice el componente en el servidor. Os dejo un peque\u00f1o esquema de los ciclos de vida mas importantes y en que momento se ejecutan: Es importante tenerlo claro para saber que m\u00e9todos podemos utilizar para realizar operaciones con el componente. Carpetas creadas por Vue.js node_modules: Todos los m\u00f3dulos de librar\u00edas usado por el proyecto. \\src: Contiene todo el c\u00f3digo asociado al proyecto. \\src\\assets: Normalmente la carpeta usada para los recursos. \\src\\components: Aqu\u00ed ir\u00e1n los diferentes componentes que iremos creando para la aplicaci\u00f3n. \\src\\router: Es la carpeta donde el scafolding nos mete el router con sus diferentes rutas. \\src\\views: Aqu\u00ed iran las diferentes vistas de la aplicaci\u00f3n. Otros ficheros importantes de un proyecto de Vue.js Otros archivos que debemos tener en cuenta dentro del proyecto son: main.ts: Es la puerta de entrada a la aplicaci\u00f3n package.json: Dependencias de librer\u00edas y scripts Estructura de m\u00f3dulos Existe m\u00faltiples consensos al respecto de como estructurar un proyecto en VUE, pero al final, depende de los requisitos del proyecto y de la gente que este trabajando en el. Lo que si seria muy importante es que todos usemos la misma estructura, por internet podemos encontrar diferentes sugerencias y quedarnos con la que nos guste mas, nosotros siempre recomendamos intentar desacoplar todo al m\u00e1ximo y a medida de lo posible seguir los principios de la Clean Architecture del TIO BOB . ATENCI\u00d3N: Componentes gen\u00e9ricos Debemos tener en cuenta que a la hora de programar un componente core , lo ideal es pensar que sea un componente plug & play, es decir que si lo copias y lo llevas a otro proyecto funcione sin la necesidad de adaptarlo. Buenas pr\u00e1cticas A continuaci\u00f3n veremos un listado de buenas pr\u00e1cticas de Vue.js y de c\u00f3digo limpio que deber\u00edamos intentar seguir en nuestro desarrollo. Estructura de archivos Antes de empezar con un proyecto lo ideal, es pararse y pensar en los requerimientos de una buena estructura, en un futuro lo agradecer\u00e1s. Nombres claros Utilizar la S de los principios S.O.L.I.D para los nombres de variables, m\u00e9todos y dem\u00e1s c\u00f3digo. El efecto que produce este principio son clases con nombres muy descriptivos y por tanto largos. Organiza tu c\u00f3digo Intenta organizar tu c\u00f3digo fuente: Lo m\u00e1s importante debe ir arriba. Primero propiedades, despu\u00e9s m\u00e9todos. Un Item para un archivo : cada archivo deber\u00eda contener solamente un componente, al igual que los servicios. Solo una responsabilidad : Cada clase o modulo deber\u00eda tener solamente una responsabilidad. El nombre correcto : las propiedades y m\u00e9todos deber\u00edan usar el sistema de camel case (ej: getUserByName) , al contrario, las clases (componentes, servicios, etc) deben usar upper camel case (ej: UserComponent) . Los componentes y servicios deben tener su respectivo sufijo: UserComponent, UserService. Imports : los archivos externos van primero. Usar linters Prettier & ESLint Un linter es una herramienta que nos ayuda a seguir las buenas pr\u00e1cticas o gu\u00edas de estilo de nuestro c\u00f3digo fuente. En este caso, para JavaScript, proveeremos de unos muy famosos. Una de las m\u00e1s famosas es la combinaci\u00f3n de ESLint with Prettier . Recordad que a\u00f1adir este tipo de configuraci\u00f3n es opcional, pero necesaria para tener un buen c\u00f3digo de calidad. Git Hooks Los Git Hooks son scripts de shell que se ejecutan autom\u00e1ticamente antes o despu\u00e9s de que Git ejecute un comando importante como Commit o Push. Para hacer uso de el es tan sencillo como: npm install husky --save-dev Y a\u00f1adir en el fichero lo siguiente: // package.json { \"husky\" : { \"hooks\" : { \"pre-commit\" : \"npm test\" , \"pre-push\" : \"npm test\" , \"...\" : \"...\" } } } Usar husky para el preformateo de c\u00f3digo antes de subirlo Es una buena pr\u00e1ctica que todo el equipo use el mismo est\u00e1ndar de formateo de codigo, con husky se puede solucionar. Lazy Load Lazy Load es un patr\u00f3n de dise\u00f1o que consiste en retrasar la carga o inicializaci\u00f3n. Desde el router a\u00f1adiremos un codigo parecido a este para hacer que la carga de rutas sea lazy: { path : '/about' , name : 'about' , // route level code-splitting // this generates a separate chunk (About.[hash].js) for this route // which is lazy-loaded when the route is visited. component : () => import ( '../views/AboutView.vue' ) }, Con esto veremos que el m\u00f3dulo se cargar\u00e1 seg\u00fan se necesite.","title":"Estructura y Buenas pr\u00e1cticas - Vue.js"},{"location":"cleancode/vuejs/#estructura-y-buenas-practicas-vuejs","text":"Nota Antes de empezar y para puntualizar, Vue.js es un framework progresivo para construir interfaces de usuario. A diferencia de otros frameworks monol\u00edticos, Vue.js est\u00e1 dise\u00f1ado desde cero para ser utilizado incrementalmente. La librer\u00eda central est\u00e1 enfocada solo en la capa de visualizaci\u00f3n, y es f\u00e1cil de utilizar e integrar con otras librer\u00edas o proyectos existentes. Por otro lado, Vue.js tambi\u00e9n es perfectamente capaz de impulsar sofisticadas Single-Page Applications cuando se utiliza en combinaci\u00f3n con herramientas modernas y librer\u00edas de apoyo. En esta parte vamos a explicar los fundamentos de un proyecto en Vue.js y las recomendaciones existentes.","title":"Estructura y Buenas pr\u00e1cticas - Vue.js"},{"location":"cleancode/vuejs/#estructura-y-funcionamiento","text":"","title":"Estructura y funcionamiento"},{"location":"cleancode/vuejs/#instancia-de-la-aplicacion","text":"Cada aplicaci\u00f3n de Vue.js se comienza creando una nueva Instancia de Vue con la funci\u00f3n createApp()","title":"Instancia de la Aplicaci\u00f3n"},{"location":"cleancode/vuejs/#componente-raiz","text":"El componente ra\u00edz es el objeto que pasamos a la funci\u00f3n createApp. Toda aplicaci\u00f3n requiere un \"componente ra\u00edz\" que pueda contener otros componentes como sus hijos. Si est\u00e1s usando Single-File Components, normalmente importamos el componente ra\u00edz desde otro archivo.","title":"Componente ra\u00edz"},{"location":"cleancode/vuejs/#ciclos-de-vida-de-vuejs","text":"Vue.js 3 cuenta con un conjunto de ciclos de vida que permiten a los desarrolladores controlar y personalizar el comportamiento de sus componentes en diferentes momentos. Estos ciclos de vida se pueden agrupar en tres fases principales: creaci\u00f3n, actualizaci\u00f3n y eliminaci\u00f3n. A continuaci\u00f3n, te explicar\u00e9 cada uno de los ciclos de vida disponibles en Vue.js 3 junto con la Options API: beforeCreate: Este ciclo de vida se ejecuta inmediatamente despu\u00e9s de que se haya creado una instancia de componente, pero antes de que se haya creado su DOM. En este punto, a\u00fan no es posible acceder a las propiedades del componente y a\u00fan no se han establecido las observaciones reactivas. created: Este ciclo de vida se ejecuta despu\u00e9s de que se haya creado una instancia de componente y se hayan establecido las observaciones reactivas. En este punto, el componente ya puede acceder a sus propiedades y m\u00e9todos. beforeMount: Este ciclo de vida se ejecuta justo antes de que el componente se monte en el DOM. En este punto, el componente ya est\u00e1 preparado para ser renderizado, pero a\u00fan no se ha agregado al \u00e1rbol de elementos del DOM. mounted: Este ciclo de vida se ejecuta despu\u00e9s de que el componente se ha montado en el DOM. En este punto, el componente ya est\u00e1 en el \u00e1rbol de elementos del DOM y se puede acceder a sus elementos hijos y a los elementos del DOM que lo rodean. beforeUpdate: Este ciclo de vida se ejecuta justo antes de que el componente se actualice en respuesta a un cambio en sus propiedades o estado. En este punto, el componente a\u00fan no se ha actualizado en el DOM. updated: Este ciclo de vida se ejecuta despu\u00e9s de que el componente se haya actualizado en el DOM en respuesta a un cambio en sus propiedades o estado. En este punto, el componente ya se ha actualizado en el DOM y se puede acceder a sus elementos hijos y a los elementos del DOM que lo rodean. beforeUnmount: Este ciclo de vida se ejecuta justo antes de que el componente se elimine del DOM. En este punto, el componente a\u00fan est\u00e1 en el \u00e1rbol de elementos del DOM. unmounted: Este ciclo de vida se ejecuta despu\u00e9s de que el componente se haya eliminado del DOM. En este punto, el componente ya no est\u00e1 en el \u00e1rbol de elementos del DOM y no se puede acceder a sus elementos hijos. errorCaptured: Este ciclo de vida se ejecuta cuando se produce un error en cualquier descendiente del componente y se captura en el componente actual. Esto permite que el componente maneje el error de forma personalizada en lugar de propagarse hacia arriba en la cadena de componentes. activated: Este ciclo de vida se ejecuta cuando un componente que se encuentra en un \u00e1rbol de componentes inactivo (por ejemplo, un componente en una pesta\u00f1a inactiva) se activa. deactivated: Este ciclo de vida se ejecuta cuando un componente que se encuentra en un \u00e1rbol de componentes activo (por ejemplo, un componente en una pesta\u00f1a activa) se desactiva y se vuelve inactivo. renderTracked: Este ciclo de vida se ejecuta cuando se observa una dependencia en el proceso de renderizado del componente. Esto se utiliza principalmente para fines de depuraci\u00f3n. renderTriggered: Este ciclo de vida se ejecuta cuando se desencadena un nuevo renderizado del componente. Esto se utiliza principalmente para fines de depuraci\u00f3n. serverPrefetch: Este ciclo de vida se utiliza en el contexto de renderizado del lado del servidor (SSR). Se ejecuta cuando el componente se preprocesa en el servidor antes de enviarse al cliente. En este punto, el componente a\u00fan no se ha montado en el DOM y no se pueden realizar operaciones que dependan del DOM. Esto se utiliza principalmente para cargar datos de forma as\u00edncrona antes de que se renderice el componente en el servidor. Os dejo un peque\u00f1o esquema de los ciclos de vida mas importantes y en que momento se ejecutan: Es importante tenerlo claro para saber que m\u00e9todos podemos utilizar para realizar operaciones con el componente.","title":"Ciclos de vida de Vue.js"},{"location":"cleancode/vuejs/#carpetas-creadas-por-vuejs","text":"node_modules: Todos los m\u00f3dulos de librar\u00edas usado por el proyecto. \\src: Contiene todo el c\u00f3digo asociado al proyecto. \\src\\assets: Normalmente la carpeta usada para los recursos. \\src\\components: Aqu\u00ed ir\u00e1n los diferentes componentes que iremos creando para la aplicaci\u00f3n. \\src\\router: Es la carpeta donde el scafolding nos mete el router con sus diferentes rutas. \\src\\views: Aqu\u00ed iran las diferentes vistas de la aplicaci\u00f3n. Otros ficheros importantes de un proyecto de Vue.js Otros archivos que debemos tener en cuenta dentro del proyecto son: main.ts: Es la puerta de entrada a la aplicaci\u00f3n package.json: Dependencias de librer\u00edas y scripts","title":"Carpetas creadas por Vue.js"},{"location":"cleancode/vuejs/#estructura-de-modulos","text":"Existe m\u00faltiples consensos al respecto de como estructurar un proyecto en VUE, pero al final, depende de los requisitos del proyecto y de la gente que este trabajando en el. Lo que si seria muy importante es que todos usemos la misma estructura, por internet podemos encontrar diferentes sugerencias y quedarnos con la que nos guste mas, nosotros siempre recomendamos intentar desacoplar todo al m\u00e1ximo y a medida de lo posible seguir los principios de la Clean Architecture del TIO BOB . ATENCI\u00d3N: Componentes gen\u00e9ricos Debemos tener en cuenta que a la hora de programar un componente core , lo ideal es pensar que sea un componente plug & play, es decir que si lo copias y lo llevas a otro proyecto funcione sin la necesidad de adaptarlo.","title":"Estructura de m\u00f3dulos"},{"location":"cleancode/vuejs/#buenas-practicas","text":"A continuaci\u00f3n veremos un listado de buenas pr\u00e1cticas de Vue.js y de c\u00f3digo limpio que deber\u00edamos intentar seguir en nuestro desarrollo.","title":"Buenas pr\u00e1cticas"},{"location":"cleancode/vuejs/#estructura-de-archivos","text":"Antes de empezar con un proyecto lo ideal, es pararse y pensar en los requerimientos de una buena estructura, en un futuro lo agradecer\u00e1s.","title":"Estructura de archivos"},{"location":"cleancode/vuejs/#nombres-claros","text":"Utilizar la S de los principios S.O.L.I.D para los nombres de variables, m\u00e9todos y dem\u00e1s c\u00f3digo. El efecto que produce este principio son clases con nombres muy descriptivos y por tanto largos.","title":"Nombres claros"},{"location":"cleancode/vuejs/#organiza-tu-codigo","text":"Intenta organizar tu c\u00f3digo fuente: Lo m\u00e1s importante debe ir arriba. Primero propiedades, despu\u00e9s m\u00e9todos. Un Item para un archivo : cada archivo deber\u00eda contener solamente un componente, al igual que los servicios. Solo una responsabilidad : Cada clase o modulo deber\u00eda tener solamente una responsabilidad. El nombre correcto : las propiedades y m\u00e9todos deber\u00edan usar el sistema de camel case (ej: getUserByName) , al contrario, las clases (componentes, servicios, etc) deben usar upper camel case (ej: UserComponent) . Los componentes y servicios deben tener su respectivo sufijo: UserComponent, UserService. Imports : los archivos externos van primero.","title":"Organiza tu c\u00f3digo"},{"location":"cleancode/vuejs/#usar-linters-prettier-eslint","text":"Un linter es una herramienta que nos ayuda a seguir las buenas pr\u00e1cticas o gu\u00edas de estilo de nuestro c\u00f3digo fuente. En este caso, para JavaScript, proveeremos de unos muy famosos. Una de las m\u00e1s famosas es la combinaci\u00f3n de ESLint with Prettier . Recordad que a\u00f1adir este tipo de configuraci\u00f3n es opcional, pero necesaria para tener un buen c\u00f3digo de calidad.","title":"Usar linters Prettier &amp; ESLint"},{"location":"cleancode/vuejs/#git-hooks","text":"Los Git Hooks son scripts de shell que se ejecutan autom\u00e1ticamente antes o despu\u00e9s de que Git ejecute un comando importante como Commit o Push. Para hacer uso de el es tan sencillo como: npm install husky --save-dev Y a\u00f1adir en el fichero lo siguiente: // package.json { \"husky\" : { \"hooks\" : { \"pre-commit\" : \"npm test\" , \"pre-push\" : \"npm test\" , \"...\" : \"...\" } } } Usar husky para el preformateo de c\u00f3digo antes de subirlo Es una buena pr\u00e1ctica que todo el equipo use el mismo est\u00e1ndar de formateo de codigo, con husky se puede solucionar.","title":"Git Hooks"},{"location":"cleancode/vuejs/#lazy-load","text":"Lazy Load es un patr\u00f3n de dise\u00f1o que consiste en retrasar la carga o inicializaci\u00f3n. Desde el router a\u00f1adiremos un codigo parecido a este para hacer que la carga de rutas sea lazy: { path : '/about' , name : 'about' , // route level code-splitting // this generates a separate chunk (About.[hash].js) for this route // which is lazy-loaded when the route is visited. component : () => import ( '../views/AboutView.vue' ) }, Con esto veremos que el m\u00f3dulo se cargar\u00e1 seg\u00fan se necesite.","title":"Lazy Load"},{"location":"develop/basic/angular/","text":"Listado simple - Angular Ahora que ya tenemos listo el proyecto frontend de Angular (en el puerto 4200), ya podemos empezar a codificar la soluci\u00f3n. Primeros pasos Antes de empezar Quiero hacer hincapi\u00e9 que Angular tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. Tanto en la propia web de documentaci\u00f3n de Angular como en la web de componentes Angular Material puedes buscar casi cualquier ejemplo que necesites. Si abrimos el proyecto con el IDE que tengamos (Visual Studio Code en el caso del tutorial) podemos ver que en la carpeta src/app existen unos ficheros ya creados por defecto. Estos ficheros son: app.component.ts \u2192 contiene el c\u00f3digo inicial del proyecto escrito en TypeScript. app.component.html \u2192 contiene la plantilla inicial del proyecto escrita en HTML. app.component.scss \u2192 contiene los estilos CSS privados de la plantilla inicial. Vamos a modificar este c\u00f3digo inicial para ver como funciona. Abrimos el fichero app.component.ts y modificamos la l\u00ednea donde se asigna un valor a la variable title . app.component.ts ... title = 'Tutorial de Angular' ; ... Ahora abrimos el fichero app.component.html , borramos todo el c\u00f3digo de la plantilla y a\u00f1adimos el siguiente c\u00f3digo: app.component.html < h1 > {{title}} </ h1 > Las llaves dobles permiten hacen un binding entre el c\u00f3digo del componente y la plantilla. Es decir, en este caso ir\u00e1 al c\u00f3digo TypeScript y buscar\u00e1 el valor de la variable title . Consejo El binding tambi\u00e9n nos sirve para ejecutar los m\u00e9todos de TypeScript desde el c\u00f3digo HTML. Adem\u00e1s si el valor que contiene la variable se modificara durante la ejecuci\u00f3n de alg\u00fan m\u00e9todo, autom\u00e1ticamente el c\u00f3digo HTML refrescar\u00eda el nuevo valor de la variable title Si abrimos el navegador y accedemos a http://localhost:4200/ podremos ver el resultado del c\u00f3digo. Layout general Crear componente Lo primero que vamos a hacer es escoger un tema y una paleta de componentes para trabajar. Lo m\u00e1s c\u00f3modo es trabajar con Material que ya viene perfectamente integrado en Angular. Ejecutamos el comando y elegimos la paleta de colores que m\u00e1s nos guste o bien creamos una custom: ng add @angular/material Recuerda Al a\u00f1adir una nueva librer\u00eda tenemos que parar el servidor y volver a arrancarlo para que compile y precargue las nuevas dependencias. Una vez a\u00f1adida la dependencia, lo que queremos es crear una primera estructura inicial a la p\u00e1gina. Si te acuerdas cual era la estructura (y si no te acuerdas, vuelve a la secci\u00f3n Contexto de la aplicaci\u00f3n y lo revisas), ten\u00edamos una cabecera superior con un logo y t\u00edtulo y unas opciones de men\u00fa. Pues vamos a ello, crearemos esa estructura com\u00fan para toda la aplicaci\u00f3n. Este componente al ser algo core para toda la aplicaci\u00f3n deber\u00edamos crearlo dentro del m\u00f3dulo core como ya vimos anteriormente. Pero antes de todo, vamos a crear los m\u00f3dulos generales de la aplicaci\u00f3n, as\u00ed que ejecutamos en consola el comando que nos permite crear un m\u00f3dulo nuevo: ng generate module core Y a\u00f1adimos esos m\u00f3dulos al m\u00f3dulo padre de la aplicaci\u00f3n: app.module.ts import { BrowserModule } from '@angular/platform-browser' ; import { NgModule } from '@angular/core' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { BrowserAnimationsModule } from '@angular/platform-browser/animations' ; import { CoreModule } from './core/core.module' ; @NgModule ({ declarations : [ AppComponent ], imports : [ BrowserModule , AppRoutingModule , CoreModule , BrowserAnimationsModule , ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { } Y despu\u00e9s crearemos el componente header, dentro del m\u00f3dulo core. Para eso ejecutaremos el comando: ng generate component core/header C\u00f3digo de la pantalla Esto nos crear\u00e1 una carpeta con los ficheros del componente, donde tendremos que copiar el siguiente contenido: header.component.html header.component.scss < mat-toolbar > < mat-toolbar-row > < div class = \"header_container\" > < div class = \"header_title\" > < mat-icon > storefront </ mat-icon > Ludoteca Tan </ div > < div class = \"header_separator\" > | </ div > < div class = \"header_menu\" > < div class = \"header_button\" > < a routerLink = \"/games\" routerLinkActive = \"active\" > Cat\u00e1logo </ a > </ div > < div class = \"header_button\" > < a routerLink = \"/categories\" routerLinkActive = \"active\" > Categor\u00edas </ a > </ div > < div class = \"header_button\" > < a routerLink = \"/authors\" routerLinkActive = \"active\" > Autores </ a > </ div > </ div > < div class = \"header_login\" > < mat-icon > account_circle </ mat-icon > Sign in </ div > </ div > </ mat-toolbar-row > </ mat-toolbar > . mat-toolbar { background-color : blue ; color : white ; } . header_container { display : flex ; width : 100 % ; .header_title { .mat-icon { vertical-align : sub ; } } . header_separator { margin-left : 30 px ; margin-right : 30 px ; } . header_menu { flex-grow : 4 ; display : flex ; flex-direction : row ; .header_button { margin-left : 1 em ; margin-right : 1 em ; font-size : 16 px ; a { font-weight : lighter ; text-decoration : none ; cursor : pointer ; color : white ; } a : hover { color : grey ; } a . active { font-weight : normal ; text-decoration : underline ; color : lightyellow ; } } } . header_login { font-size : 16 px ; cursor : pointer ; .mat-icon { vertical-align : sub ; } } } Al utilizar etiquetas de material como mat-toolbar o mat-icon y routerLink necesitaremos importar las dependencias. Esto lo podemos hacer directamente en el m\u00f3dulo del que depende, es decir en el fichero core.module.ts core.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { MatIconModule } from '@angular/material/icon' ; import { MatToolbarModule } from '@angular/material/toolbar' ; import { HeaderComponent } from './header/header.component' ; import { RouterModule } from '@angular/router' ; @NgModule ({ declarations : [ HeaderComponent ], imports : [ CommonModule , RouterModule , MatIconModule , MatToolbarModule , ], exports : [ HeaderComponent ] }) export class CoreModule { } Adem\u00e1s de a\u00f1adir las dependencias, diremos que este m\u00f3dulo va a exportar el componente HeaderComponent para poder utilizarlo desde otras p\u00e1ginas. Ya por \u00faltimo solo nos queda modificar la p\u00e1gina general de la aplicaci\u00f3n app.component.html para a\u00f1adirle el componente HeaderComponent . app.component.html < div > < app-header ></ app-header > < div > < router-outlet ></ router-outlet > </ div > </ div > Vamos al navegador y refrescamos la p\u00e1gina, deber\u00eda aparecer una barra superior (Header) con las opciones de men\u00fa. Algo similar a esto: Recuerda Cuando se a\u00f1aden componentes a los ficheros html , siempre se deben utilizar los selectores definidos para el componente. En el caso anterior hemos a\u00f1adido app-header que es el mismo nombre selector que tiene el componente en el fichero header.component.ts . Adem\u00e1s, recuerda que para poder utilizar componentes de otros m\u00f3dulos, los debes exportar ya que de lo contrario tan solo podr\u00e1n utilizarse dentro del m\u00f3dulo donde se declaran. Creando un listado b\u00e1sico Crear componente Ya tenemos la estructura principal, ahora vamos a crear nuestra primera pantalla. Vamos a empezar por la de Categor\u00edas que es la m\u00e1s sencilla, ya que se trata de un listado, que muestra datos sin filtrar ni paginar. Como categor\u00edas es un dominio funcional de la aplicaci\u00f3n, vamos a crear un m\u00f3dulo que contenga toda la funcionalidad de ese dominio. Ejecutamos en consola: ng generate module category Y por tanto, al igual que hicimos anteriormente, hay que a\u00f1adir el m\u00f3dulo al fichero app.module.ts app.module.ts import { BrowserModule } from '@angular/platform-browser' ; import { NgModule } from '@angular/core' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { BrowserAnimationsModule } from '@angular/platform-browser/animations' ; import { CoreModule } from './core/core.module' ; import { CategoryModule } from './category/category.module' ; @NgModule ({ declarations : [ AppComponent ], imports : [ BrowserModule , AppRoutingModule , CoreModule , CategoryModule , BrowserAnimationsModule , ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { } Ahora todas las pantallas, componentes y servicios que creemos, referidos a este dominio funcional, deber\u00e1n ir dentro del modulo cagegory . Vamos a crear un primer componente que ser\u00e1 un listado de categor\u00edas. Para ello vamos a ejecutar el siguiente comando: ng generate component category/category-list Para terminar de configurar la aplicaci\u00f3n, vamos a a\u00f1adir la ruta del componente dentro del componente routing de Angular, para poder acceder a \u00e9l, para ello modificamos el fichero app-routing.module.ts app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { CategoryListComponent } from './category/category-list/category-list.component' ; const routes : Routes = [ { path : 'categories' , component : CategoryListComponent }, ]; @NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } Si abrimos el navegador y accedemos a http://localhost:4200/ podremos navegar mediante el men\u00fa Categor\u00edas el cual abrir\u00e1 el componente que acabamos de crear. C\u00f3digo de la pantalla Ahora vamos a construir la pantalla. Para manejar la informaci\u00f3n del listado, necesitamos almacenar los datos en un objeto de tipo model . Para ello crearemos un fichero en category\\model\\Category.ts donde implementaremos la clase necesaria. Esta clase ser\u00e1 la que utilizaremos en el c\u00f3digo html y ts de nuestro componente. Category.ts export class Category { id : number ; name : string ; } Tambi\u00e9n, escribiremos el c\u00f3digo de la pantalla de listado. category-list.component.html category-list.component.scss category-list.component.ts < div class = \"container\" > < h1 > Listado de Categor\u00edas </ h1 > < mat-table [ dataSource ]=\" dataSource \" > < ng-container matColumnDef = \"id\" > < mat-header-cell * matHeaderCellDef > Identificador </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.id}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"name\" > < mat-header-cell * matHeaderCellDef > Nombre categor\u00eda </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.name}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" >< mat-icon > edit </ mat-icon ></ button > < button mat-icon-button color = \"accent\" >< mat-icon > clear </ mat-icon ></ button > </ mat-cell > </ ng-container > < mat-header-row * matHeaderRowDef = \"displayedColumns; sticky: true\" ></ mat-header-row > < mat-row * matRowDef = \"let row; columns: displayedColumns;\" ></ mat-row > </ mat-table > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" > Nueva categor\u00eda </ button > </ div > </ div > . container { margin : 20 px ; mat-table { margin-top : 10 px ; margin-bottom : 20 px ; .mat-header-row { background-color : #f5f5f5 ; .mat-header-cell { text-transform : uppercase ; font-weight : bold ; color : #838383 ; } } . mat-column-id { flex : 0 0 20 % ; justify-content : center ; } . mat-column-action { flex : 0 0 10 % ; justify-content : center ; } } . buttons { text-align : right ; } } import { Component , OnInit } from '@angular/core' ; import { MatTableDataSource } from '@angular/material/table' ; import { Category } from '../model/Category' ; @Component ({ selector : 'app-category-list' , templateUrl : './category-list.component.html' , styleUrls : [ './category-list.component.scss' ] }) export class CategoryListComponent implements OnInit { dataSource = new MatTableDataSource < Category > (); displayedColumns : string [] = [ 'id' , 'name' , 'action' ]; constructor () { } ngOnInit () : void { } } El c\u00f3digo HTML es f\u00e1cil de seguir pero por si acaso: L\u00ednea 4: Creamos la tabla con la variable dataSource definida en el fichero .ts L\u00ednea 5: Definici\u00f3n de la primera columna, su cabecera y el dato que va a contener L\u00ednea 10: Definici\u00f3n de la segunda columna, su cabecera y el dato que va a contener L\u00ednea 15: Definici\u00f3n de la tercera columna, su cabecera vac\u00eda y los dos botones de acci\u00f3n L\u00ednea 23 y 24: Construcci\u00f3n de la cabecera y las filas Y ya por \u00faltimo, a\u00f1adimos los componentes que se han utilizado de Angular Material a las dependencias del m\u00f3dulo donde est\u00e1 definido el componente en este caso category\\category.module.ts : category.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { MatTableModule } from '@angular/material/table' ; import { MatIconModule } from '@angular/material/icon' ; import { MatButtonModule } from '@angular/material/button' ; import { CategoryListComponent } from './category-list/category-list.component' ; @NgModule ({ declarations : [ CategoryListComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule ], }) export class CategoryModule { } Si abrimos el navegador y accedemos a http://localhost:4200/ y pulsamos en el men\u00fa de Categor\u00edas obtendremos una pantalla con un listado vac\u00edo (solo con cabeceras) y un bot\u00f3n de crear Nueva Categor\u00eda que aun no hace nada. A\u00f1adiendo datos En este punto y para ver como responde el listado, vamos a a\u00f1adir datos. Si tuvieramos el backend implementado podr\u00edamos consultar los datos directamente de una operaci\u00f3n de negocio de backend, pero ahora mismo no lo tenemos implementado as\u00ed que para no bloquear el desarrollo vamos a mockear los datos. Creando un servicio En angular, cualquier acceso a datos debe pasar por un service , as\u00ed que vamos a crearnos uno para todas las operaciones de categor\u00edas. Vamos a la consola y ejecutamos: ng generate service category/category Esto nos crear\u00e1 un servicio, que adem\u00e1s podemos utilizarlo inyect\u00e1ndolo en cualquier componente que lo necesite. Implementando un servicio Vamos a implementar una operaci\u00f3n de negocio que recupere el listado de categor\u00edas y lo vamos a hacer de forma reactiva (as\u00edncrona) para simular una petici\u00f3n a backend. Modificamos los siguientes ficheros: category.service.ts category-list.component.ts import { Injectable } from '@angular/core' ; import { Observable } from 'rxjs' ; import { Category } from './model/Category' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor () { } getCategories () : Observable < Category [] > { return new Observable (); } } import { Component , OnInit } from '@angular/core' ; import { MatTableDataSource } from '@angular/material/table' ; import { Category } from '../model/Category' ; import { CategoryService } from '../category.service' ; @Component ({ selector : 'app-category-list' , templateUrl : './category-list.component.html' , styleUrls : [ './category-list.component.scss' ] }) export class CategoryListComponent implements OnInit { dataSource = new MatTableDataSource < Category > (); displayedColumns : string [] = [ 'id' , 'name' , 'action' ]; constructor ( private categoryService : CategoryService , ) { } ngOnInit () : void { this . categoryService . getCategories (). subscribe ( categories => this . dataSource . data = categories ); } } Mockeando datos Como hemos comentado anteriormente, el backend todav\u00eda no est\u00e1 implementado as\u00ed que vamos a mockear datos. Nos crearemos un fichero mock-categories.ts dentro de model, con datos ficticios y modificaremos el servicio para que devuelva esos datos. De esta forma, cuando tengamos implementada la operaci\u00f3n de negocio en backend, tan solo tenemos que sustuir el c\u00f3digo que devuelve datos est\u00e1ticos por una llamada http. mock-categories.ts category.service.ts import { Category } from \"./Category\" ; export const CATEGORY_DATA : Category [] = [ { id : 1 , name : 'Dados' }, { id : 2 , name : 'Fichas' }, { id : 3 , name : 'Cartas' }, { id : 4 , name : 'Rol' }, { id : 5 , name : 'Tableros' }, { id : 6 , name : 'Tem\u00e1ticos' }, { id : 7 , name : 'Europeos' }, { id : 8 , name : 'Guerra' }, { id : 9 , name : 'Abstractos' }, ] import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; import { CATEGORY_DATA } from './model/mock-categories' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor () { } getCategories () : Observable < Category [] > { return of ( CATEGORY_DATA ); } } Si ahora refrescamos la p\u00e1gina web, veremos que el listado ya tiene datos con los que vamos a interactuar. Simulando las otras peticiones Para terminar, vamos a simular las otras dos peticiones, la de editar y la de borrar para cuando tengamos que utilizarlas. El servicio debe quedar m\u00e1s o menos as\u00ed: category.service.ts import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; import { CATEGORY_DATA } from './model/mock-categories' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor () { } getCategories () : Observable < Category [] > { return of ( CATEGORY_DATA ); } saveCategory ( category : Category ) : Observable < Category > { return of ( null ); } deleteCategory ( idCategory : number ) : Observable < any > { return of ( null ); } } A\u00f1adiendo acciones al listado Crear componente Ahora nos queda a\u00f1adir las acciones al listado: crear, editar y eliminar. Empezaremos primero por las acciones de crear y editar, que ambas deber\u00edan abrir una ventana modal con un formulario para poder modificar datos de la entidad Categor\u00eda . Como siempre, para crear un componente usamos el asistente de Angular, esta vez al tratarse de una pantalla que solo vamos a utilizar dentro del dominio de categor\u00edas, tiene sentido que lo creemos dentro de ese m\u00f3dulo: ng generate component category/category-edit Ahora vamos a hacer que se abra al pulsar el bot\u00f3n Nueva categor\u00eda . Para eso, vamos al fichero category-list.component.ts y a\u00f1adimos un nuevo m\u00e9todo: category-list.component.ts ... import { MatDialog } from '@angular/material/dialog' ; import { CategoryEditComponent } from '../category-edit/category-edit.component' ; ... constructor ( private categoryService : CategoryService , public dialog : MatDialog , ) { } ... createCategory () { const dialogRef = this . dialog . open ( CategoryEditComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } ... Para poder abrir un componente dentro de un dialogo necesitamos obtener en el constructor un MatDialog. De ah\u00ed que hayamos tenido que a\u00f1adirlo como import y en el constructor. Dentro del m\u00e9todo createCategory lo que hacemos es crear un dialogo con el componente CategoryEditComponent en su interior, pasarle unos datos de creaci\u00f3n, donde podemos poner estilos del dialog y un objeto data donde pondremos los datos que queremos pasar entre los componentes. Por \u00faltimo, nos suscribimos al evento afterClosed para ejecutar las acciones que creamos oportunas, en nuestro caso volveremos a cargar el listado inicial. Como hemos utilizado un MatDialog en el componente, necesitamos a\u00f1adirlo tambi\u00e9n al m\u00f3dulo, as\u00ed que abrimos el fichero category.module.ts y a\u00f1adimos: category.module.ts ... import { MAT_DIALOG_DATA , MatDialogModule } from '@angular/material/dialog' ; @NgModule ({ declarations : [ CategoryListComponent , CategoryEditComponent ], imports : [ ... MatDialogModule ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class CategoryModule { } Y ya por \u00faltimo enlazamos el click en el bot\u00f3n con el m\u00e9todo que acabamos de crear para abrir el dialogo. Modificamos el fichero category-list.component.html y a\u00f1adimos el evento click: category-list.component.html ... < div class = \"buttons\" > < button mat - flat - button color = \"primary\" ( click ) = \"createCategory()\" > Nueva categor\u00eda < /button> < /div> < /div> Si refrescamos el navegador y pulsamos el bot\u00f3n Nueva categor\u00eda veremos como se abre una ventana modal de tipo Dialog con el componente nuevo que hemos creado, aunque solo se leer\u00e1 category-edit works! que es el contenido por defecto del componente. C\u00f3digo del dialogo Ahora vamos a darle forma al formulario de editar y crear. Para ello vamos al html, ts y css del componente y pegamos el siguiente contenido: category-edit.component.html category-edit.component.scss category-edit.component.ts < div class = \"container\" > < h1 > Crear categor\u00eda </ h1 > < form > < mat-form-field > < mat-label > Identificador </ mat-label > < input type = \"text\" matInput placeholder = \"Identificador\" [( ngModel )]=\" category . id \" name = \"id\" disabled > </ mat-form-field > < mat-form-field > < mat-label > Nombre </ mat-label > < input type = \"text\" matInput placeholder = \"Nombre de categor\u00eda\" [( ngModel )]=\" category . name \" name = \"name\" required > < mat-error > El nombre no puede estar vac\u00edo </ mat-error > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onClose ()\" > Cerrar </ button > < button mat-flat-button color = \"primary\" ( click )=\" onSave ()\" > Guardar </ button > </ div > </ div > . container { min-width : 350 px ; max-width : 500 px ; padding : 20 px ; form { display : flex ; flex-direction : column ; margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } import { Component , OnInit } from '@angular/core' ; import { MatDialogRef } from '@angular/material/dialog' ; import { CategoryService } from '../category.service' ; import { Category } from '../model/Category' ; @Component ({ selector : 'app-category-edit' , templateUrl : './category-edit.component.html' , styleUrls : [ './category-edit.component.scss' ] }) export class CategoryEditComponent implements OnInit { category : Category ; constructor ( public dialogRef : MatDialogRef < CategoryEditComponent > , private categoryService : CategoryService ) { } ngOnInit () : void { this . category = new Category (); } onSave () { this . categoryService . saveCategory ( this . category ). subscribe ( result => { this . dialogRef . close (); }); } onClose () { this . dialogRef . close (); } } Si te fijas en el c\u00f3digo TypeScript, hemos a\u00f1adido en el m\u00e9todo onSave una llamada al servicio de CategoryService que aunque no realice ninguna operaci\u00f3n de momento, por lo menos lo dejamos preparado para conectar con el servidor. Adem\u00e1s, como siempre, al utilizar componentes matInput , matForm , matError hay que a\u00f1adirlos como dependencias en el m\u00f3dulo category.module.ts : category.module.ts ... import { MAT_DIALOG_DATA , MatDialogModule } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatInputModule } from '@angular/material/input' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; @NgModule ({ declarations : [ CategoryListComponent , CategoryEditComponent ], imports : [ ... MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class CategoryModule { } Ahora podemos navegar y abrir el cuadro de dialogo mediante el bot\u00f3n Nueva categor\u00eda para ver como queda nuestro formulario. Utilizar el dialogo para editar El mismo componente que hemos utilizado para crear una nueva categor\u00eda, nos sirve tambi\u00e9n para editar una categor\u00eda existente. Tan solo tenemos que utilizar la funcionalidad que Angular nos proporciona y pasarle los datos a editar en la llamada de apertura del Dialog. Vamos a implementar funcionalidad sobre el icono editar , tendremos que modificar unos cuantos ficheros: category-list.component.html category-list.component.ts < div class = \"container\" > < h1 > Listado de Categor\u00edas </ h1 > < mat-table [ dataSource ]=\" dataSource \" > < ng-container matColumnDef = \"id\" > < mat-header-cell * matHeaderCellDef > Identificador </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.id}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"name\" > < mat-header-cell * matHeaderCellDef > Nombre categor\u00eda </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.name}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" ( click )=\" editCategory ( element )\" > < mat-icon > edit </ mat-icon > </ button > < button mat-icon-button color = \"accent\" >< mat-icon > clear </ mat-icon ></ button > </ mat-cell > </ ng-container > < mat-header-row * matHeaderRowDef = \"displayedColumns; sticky: true\" ></ mat-header-row > < mat-row * matRowDef = \"let row; columns: displayedColumns;\" ></ mat-row > </ mat-table > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createCategory ()\" > Nueva categor\u00eda </ button > </ div > </ div > export class CategoryListComponent implements OnInit { dataSource = new MatTableDataSource < Category > (); displayedColumns : string [] = [ 'id' , 'name' , 'action' ]; constructor ( private categoryService : CategoryService , public dialog : MatDialog , ) { } ngOnInit () : void { this . categoryService . getCategories (). subscribe ( categories => this . dataSource . data = categories ); } createCategory () { const dialogRef = this . dialog . open ( CategoryEditComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } editCategory ( category : Category ) { const dialogRef = this . dialog . open ( CategoryEditComponent , { data : { category : category } }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } } Y los Dialog: category-edit.component.html category-edit.component.ts < div class = \"container\" > < h1 * ngIf = \"category.id == null\" > Crear categor\u00eda < /h1> < h1 * ngIf = \"category.id != null\" > Modificar categor\u00eda < /h1> < form > < mat - form - field > ... import { Component , OnInit , Inject } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { CategoryService } from '../category.service' ; import { Category } from '../model/Category' ; @Component ({ selector : 'app-category-edit' , templateUrl : './category-edit.component.html' , styleUrls : [ './category-edit.component.scss' ] }) export class CategoryEditComponent implements OnInit { category : Category ; constructor ( public dialogRef : MatDialogRef < CategoryEditComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any , private categoryService : CategoryService ) { } ngOnInit () : void { if ( this . data . category != null ) { this . category = this . data . category ; } else { this . category = new Category (); } } onSave () { this . categoryService . saveCategory ( this . category ). subscribe ( result => { this . dialogRef . close (); }); } onClose () { this . dialogRef . close (); } } Navegando ahora por la p\u00e1gina y pulsando en el icono de editar, se deber\u00eda abrir una ventana con los datos que hemos seleccionado, similar a esta imagen: Si te fijas, al modificar los datos dentro de la ventana de di\u00e1logo se modifica tambi\u00e9n en el listado. Esto es porque estamos pasando el mismo objeto desde el listado a la ventana dialogo y al ser el listado y el formulario reactivos los dos, cualquier cambio sobre los datos se refresca directamente en la pantalla. Hay veces en la que este comportamiento nos interesa, pero en este caso no queremos que se modifique el listado. Para solucionarlo debemos hacer una copia del objeto, para que ambos modelos (formulario y listado) utilicen objetos diferentes. Es tan sencillo como modificar category-edit.component.ts y a\u00f1adirle una copia del dato category-edit.component.ts ... ngOnInit () : void { if ( this . data . category != null ) { this . category = Object . assign ({}, this . data . category ); } else { this . category = new Category (); } } ... Cuidado Hay que tener mucho cuidado con el binding de los objetos. Hay veces que al modificar un objeto NO queremos que se modifique en todas sus instancias y tenemos que poner especial cuidado en esos aspectos. Acci\u00f3n de borrado Por norma general, toda acci\u00f3n de borrado de un dato de pantalla requiere una confirmaci\u00f3n previa por parte del usuario. Es decir, para evitar que el dato se borre accidentalmente el usuario tendr\u00e1 que confirmar su acci\u00f3n. Por tanto vamos a crear un componente que nos permita pedir una confirmaci\u00f3n al usuario. Como esta pantalla de confirmaci\u00f3n va a ser algo com\u00fan a muchas acciones de borrado de nuestra aplicaci\u00f3n, vamos a crearla dentro del m\u00f3dulo core . Como siempre, ejecutamos el comando en consola: ng generate component core/dialog-confirmation E implementamos el c\u00f3digo que queremos que tenga el componente. Al ser un componente gen\u00e9rico vamos a aprovechar y leeremos las variables que le pasemos en data . dialog-confirmation.component.html dialog-confirmation.component.scss dialog-confirmation.component.ts < div class = \"container\" > < h1 > {{title}} </ h1 > < div [ innerHTML ]=\" description \" class = \"description\" ></ div > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onNo ()\" > No </ button > < button mat-flat-button color = \"primary\" ( click )=\" onYes ()\" > S\u00ed </ button > </ div > </ div > . container { min-width : 350 px ; max-width : 500 px ; padding : 20 px ; .description { margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } import { Component , OnInit , Inject } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; @Component ({ selector : 'app-dialog-confirmation' , templateUrl : './dialog-confirmation.component.html' , styleUrls : [ './dialog-confirmation.component.scss' ] }) export class DialogConfirmationComponent implements OnInit { title : string ; description : string ; constructor ( public dialogRef : MatDialogRef < DialogConfirmationComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any ) { } ngOnInit () : void { this . title = this . data . title ; this . description = this . data . description ; } onYes () { this . dialogRef . close ( true ); } onNo () { this . dialogRef . close ( false ); } } Recuerda Recuerda que los componentes utilizados en el di\u00e1logo de confirmaci\u00f3n se deben a\u00f1adir al m\u00f3dulo padre al que pertenecen, en este caso a core.module.ts imports: [ CommonModule, RouterModule, MatIconModule, MatToolbarModule, MatDialogModule, MatButtonModule, ], providers: [ { provide: MAT_DIALOG_DATA, useValue: {}, }, ], Ya por \u00faltimo, una vez tenemos el componente gen\u00e9rico de dialogo, vamos a utilizarlo en nuestro listado al pulsar el bot\u00f3n eliminar: category-list.component.html category-list.component.ts ... < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" ( click )=\" editCategory ( element )\" > < mat-icon > edit </ mat-icon > </ button > < button mat-icon-button color = \"accent\" ( click )=\" deleteCategory ( element )\" > < mat-icon > clear </ mat-icon > </ button > </ mat-cell > </ ng-container > ... ... deleteCategory ( category : Category ) { const dialogRef = this . dialog . open ( DialogConfirmationComponent , { data : { title : \"Eliminar categor\u00eda\" , description : \"Atenci\u00f3n si borra la categor\u00eda se perder\u00e1n sus datos.<br> \u00bfDesea eliminar la categor\u00eda?\" } }); dialogRef . afterClosed (). subscribe ( result => { if ( result ) { this . categoryService . deleteCategory ( category . id ). subscribe ( result => { this . ngOnInit (); }); } }); } ... Aqu\u00ed tambi\u00e9n hemos realizado la llamada a categoryService , aunque no se realice ninguna acci\u00f3n, pero as\u00ed lo dejamos listo para enlazarlo. Llegados a este punto, ya solo nos queda enlazar las acciones de la pantalla con las operaciones de negocio del backend. Conectar con Backend Antes de seguir Antes de seguir con este punto, debes implementar el c\u00f3digo de backend en la tecnolog\u00eda que quieras ( Springboot o Nodejs ). Si has empezado este cap\u00edtulo implementando el frontend, por favor accede a la secci\u00f3n correspondiente de backend para poder continuar con el tutorial. Una vez tengas implementadas todas las operaciones para este listado, puedes volver a este punto y continuar con Angular. El siguiente paso, como es obvio ser\u00e1 hacer que Angular llame directamente al servidor backend para leer y escribir datos y eliminar los datos mockeados en Angular. Manos a la obra! Llamada del listado La idea es que el m\u00e9todo getCategories() de category.service.ts en lugar de devolver datos est\u00e1ticos, realice una llamada al servidor a la ruta http://localhost:8080/category . Abrimos el fichero y susituimos la l\u00ednea que antes devolv\u00eda los datos est\u00e1ticos por esto: category.service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor ( private http : HttpClient ) { } getCategories () : Observable < Category [] > { return this . http . get < Category [] > ( 'http://localhost:8080/category' ); } saveCategory ( category : Category ) : Observable < Category > { return of ( null ); } deleteCategory ( idCategory : number ) : Observable < any > { return of ( null ); } } Como hemos a\u00f1adido un componente nuevo HttpClient tenemos que a\u00f1adir la dependencia al m\u00f3dulo padre. category.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { MatTableModule } from '@angular/material/table' ; import { MatIconModule } from '@angular/material/icon' ; import { MatButtonModule } from '@angular/material/button' ; import { CategoryListComponent } from './category-list/category-list.component' ; import { CategoryEditComponent } from './category-edit/category-edit.component' ; import { MAT_DIALOG_DATA , MatDialogModule } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatInputModule } from '@angular/material/input' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; import { HttpClientModule } from '@angular/common/http' ; @NgModule ({ declarations : [ CategoryListComponent , CategoryEditComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule , MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , HttpClientModule , ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class CategoryModule { } Si ahora refrescas el navegador (recuerda tener arrancado tambi\u00e9n el servidor) y accedes a la pantalla de Categor\u00edas deber\u00eda aparecer el listado con los datos que vienen del servidor. Llamada de guardado / edici\u00f3n Para la llamada de guardado har\u00edamos lo mismo, pero invocando la operaci\u00f3n de negocio put . category.service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor ( private http : HttpClient ) { } getCategories () : Observable < Category [] > { return this . http . get < Category [] > ( 'http://localhost:8080/category' ); } saveCategory ( category : Category ) : Observable < Category > { let url = 'http://localhost:8080/category' ; if ( category . id != null ) url += '/' + category . id ; return this . http . put < Category > ( url , category ); } deleteCategory ( idCategory : number ) : Observable < any > { return of ( null ); } } Ahora podemos probar a modificar o a\u00f1adir una nueva categor\u00eda desde la pantalla y deber\u00eda aparecer los nuevos datos en el listado. Llamada de borrado Y ya por \u00faltimo, la llamada de borrado, deber\u00edamos cambiarla e invocar a la operaci\u00f3n de negocio delete . category.service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor ( private http : HttpClient ) { } getCategories () : Observable < Category [] > { return this . http . get < Category [] > ( 'http://localhost:8080/category' ); } saveCategory ( category : Category ) : Observable < Category > { let url = 'http://localhost:8080/category' ; if ( category . id != null ) url += '/' + category . id ; return this . http . put < Category > ( url , category ); } deleteCategory ( idCategory : number ) : Observable < any > { return this . http . delete ( 'http://localhost:8080/category/' + idCategory ); } } Ahora podemos probar a modificar o a\u00f1adir una nueva categor\u00eda desde la pantalla y deber\u00eda aparecer los nuevos datos en el listado. Como ves, es bastante sencillo conectar server y client. Depuraci\u00f3n Una parte muy importante del desarrollo es tener la capacidad de depurar nuestro c\u00f3digo, en este apartado vamos a explicar como se realiza debug en Front. Esta parte se puede realizar con nuestro navegador favorito, en este caso vamos a utilizar Chrome. El primer paso es abrir las herramientas del desarrollador del navegador presionando F12 . En esta herramienta tenemos varias partes importantes: Elements: Inspector de los elementos del DOM de nuestra aplicaci\u00f3n que nos ayuda identificar el c\u00f3digo generado. Console: Consola donde podemos ver mensajes importantes que nos ayudan a identificar posibles problemas. Source: El navegador de ficheros que componen nuestra aplicaci\u00f3n. Network: El registro de peticiones que realiza nuestra aplicaci\u00f3n. Identificados los elementos importantes, vamos a depurar la operaci\u00f3n de crear categor\u00eda. Para ello nos dirigimos a la pesta\u00f1a de Source , en el \u00e1rbol de carpetas nos dirigimos a la ruta donde est\u00e1 localizado el c\u00f3digo de nuestra aplicaci\u00f3n webpack://src/app . Dentro de esta carpeta est\u00e9 localizado todo el c\u00f3digo fuente de la aplicaci\u00f3n, en nuestro caso vamos a localizar componente category-edit.component que crea una nueva categor\u00eda. Dentro del fichero ya podemos a\u00f1adir puntos de ruptura (breakpoint), en nuestro caso queremos comprobar que el nombre introducido se captura bien y se env\u00eda al service correctamente. Colocamos el breakpoint en la l\u00ednea de invocaci\u00f3n del service (click sobre el n\u00famero de la l\u00ednea) y desde la interfaz creamos una nueva categor\u00eda. Hecho esto, podemos observar que a nivel de interfaz, la aplicaci\u00f3n se detiene y aparece un panel de manejo de los puntos de interrupci\u00f3n: En cuanto a la herramienta del desarrollador nos lleva al punto exacto donde hemos a\u00f1adido el breakpoint y se para en este punto ofreci\u00e9ndonos la posibilidad de explorar el contenido de las variables del c\u00f3digo: Aqu\u00ed podemos comprobar que efectivamente la variable category tiene el valor que hemos introducido por pantalla y se propaga correctamente hacia el service. Para continuar con la ejecuci\u00f3n basta con darle al bot\u00f3n de play del panel de manejo de interrupci\u00f3n o al que aparece dentro de la herramienta de desarrollo (parte superior derecha). Por \u00faltimo, vamos a revisar que la petici\u00f3n REST se ha realizado correctamente al backend, para ello nos dirigimos a la pesta\u00f1a Network y comprobamos las peticiones realizadas: Aqu\u00ed podemos observar el registro de todas las peticiones y haciendo click sobre una de ellas, obtenemos el detalle de esta. Header: Informaci\u00f3n de las cabeceras enviadas (aqu\u00ed podemos ver que se ha hecho un PUT a la ruta correcta). Payload: El cuerpo de la petici\u00f3n (vemos el cuerpo del mensaje con el nombre enviado). Preview: Respuesta de la petici\u00f3n normalizada (vemos la respuesta con el identificador creado para la nueva categor\u00eda).","title":"\ud83d\udd35 Angular"},{"location":"develop/basic/angular/#listado-simple-angular","text":"Ahora que ya tenemos listo el proyecto frontend de Angular (en el puerto 4200), ya podemos empezar a codificar la soluci\u00f3n.","title":"Listado simple - Angular"},{"location":"develop/basic/angular/#primeros-pasos","text":"Antes de empezar Quiero hacer hincapi\u00e9 que Angular tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. Tanto en la propia web de documentaci\u00f3n de Angular como en la web de componentes Angular Material puedes buscar casi cualquier ejemplo que necesites. Si abrimos el proyecto con el IDE que tengamos (Visual Studio Code en el caso del tutorial) podemos ver que en la carpeta src/app existen unos ficheros ya creados por defecto. Estos ficheros son: app.component.ts \u2192 contiene el c\u00f3digo inicial del proyecto escrito en TypeScript. app.component.html \u2192 contiene la plantilla inicial del proyecto escrita en HTML. app.component.scss \u2192 contiene los estilos CSS privados de la plantilla inicial. Vamos a modificar este c\u00f3digo inicial para ver como funciona. Abrimos el fichero app.component.ts y modificamos la l\u00ednea donde se asigna un valor a la variable title . app.component.ts ... title = 'Tutorial de Angular' ; ... Ahora abrimos el fichero app.component.html , borramos todo el c\u00f3digo de la plantilla y a\u00f1adimos el siguiente c\u00f3digo: app.component.html < h1 > {{title}} </ h1 > Las llaves dobles permiten hacen un binding entre el c\u00f3digo del componente y la plantilla. Es decir, en este caso ir\u00e1 al c\u00f3digo TypeScript y buscar\u00e1 el valor de la variable title . Consejo El binding tambi\u00e9n nos sirve para ejecutar los m\u00e9todos de TypeScript desde el c\u00f3digo HTML. Adem\u00e1s si el valor que contiene la variable se modificara durante la ejecuci\u00f3n de alg\u00fan m\u00e9todo, autom\u00e1ticamente el c\u00f3digo HTML refrescar\u00eda el nuevo valor de la variable title Si abrimos el navegador y accedemos a http://localhost:4200/ podremos ver el resultado del c\u00f3digo.","title":"Primeros pasos"},{"location":"develop/basic/angular/#layout-general","text":"","title":"Layout general"},{"location":"develop/basic/angular/#crear-componente","text":"Lo primero que vamos a hacer es escoger un tema y una paleta de componentes para trabajar. Lo m\u00e1s c\u00f3modo es trabajar con Material que ya viene perfectamente integrado en Angular. Ejecutamos el comando y elegimos la paleta de colores que m\u00e1s nos guste o bien creamos una custom: ng add @angular/material Recuerda Al a\u00f1adir una nueva librer\u00eda tenemos que parar el servidor y volver a arrancarlo para que compile y precargue las nuevas dependencias. Una vez a\u00f1adida la dependencia, lo que queremos es crear una primera estructura inicial a la p\u00e1gina. Si te acuerdas cual era la estructura (y si no te acuerdas, vuelve a la secci\u00f3n Contexto de la aplicaci\u00f3n y lo revisas), ten\u00edamos una cabecera superior con un logo y t\u00edtulo y unas opciones de men\u00fa. Pues vamos a ello, crearemos esa estructura com\u00fan para toda la aplicaci\u00f3n. Este componente al ser algo core para toda la aplicaci\u00f3n deber\u00edamos crearlo dentro del m\u00f3dulo core como ya vimos anteriormente. Pero antes de todo, vamos a crear los m\u00f3dulos generales de la aplicaci\u00f3n, as\u00ed que ejecutamos en consola el comando que nos permite crear un m\u00f3dulo nuevo: ng generate module core Y a\u00f1adimos esos m\u00f3dulos al m\u00f3dulo padre de la aplicaci\u00f3n: app.module.ts import { BrowserModule } from '@angular/platform-browser' ; import { NgModule } from '@angular/core' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { BrowserAnimationsModule } from '@angular/platform-browser/animations' ; import { CoreModule } from './core/core.module' ; @NgModule ({ declarations : [ AppComponent ], imports : [ BrowserModule , AppRoutingModule , CoreModule , BrowserAnimationsModule , ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { } Y despu\u00e9s crearemos el componente header, dentro del m\u00f3dulo core. Para eso ejecutaremos el comando: ng generate component core/header","title":"Crear componente"},{"location":"develop/basic/angular/#codigo-de-la-pantalla","text":"Esto nos crear\u00e1 una carpeta con los ficheros del componente, donde tendremos que copiar el siguiente contenido: header.component.html header.component.scss < mat-toolbar > < mat-toolbar-row > < div class = \"header_container\" > < div class = \"header_title\" > < mat-icon > storefront </ mat-icon > Ludoteca Tan </ div > < div class = \"header_separator\" > | </ div > < div class = \"header_menu\" > < div class = \"header_button\" > < a routerLink = \"/games\" routerLinkActive = \"active\" > Cat\u00e1logo </ a > </ div > < div class = \"header_button\" > < a routerLink = \"/categories\" routerLinkActive = \"active\" > Categor\u00edas </ a > </ div > < div class = \"header_button\" > < a routerLink = \"/authors\" routerLinkActive = \"active\" > Autores </ a > </ div > </ div > < div class = \"header_login\" > < mat-icon > account_circle </ mat-icon > Sign in </ div > </ div > </ mat-toolbar-row > </ mat-toolbar > . mat-toolbar { background-color : blue ; color : white ; } . header_container { display : flex ; width : 100 % ; .header_title { .mat-icon { vertical-align : sub ; } } . header_separator { margin-left : 30 px ; margin-right : 30 px ; } . header_menu { flex-grow : 4 ; display : flex ; flex-direction : row ; .header_button { margin-left : 1 em ; margin-right : 1 em ; font-size : 16 px ; a { font-weight : lighter ; text-decoration : none ; cursor : pointer ; color : white ; } a : hover { color : grey ; } a . active { font-weight : normal ; text-decoration : underline ; color : lightyellow ; } } } . header_login { font-size : 16 px ; cursor : pointer ; .mat-icon { vertical-align : sub ; } } } Al utilizar etiquetas de material como mat-toolbar o mat-icon y routerLink necesitaremos importar las dependencias. Esto lo podemos hacer directamente en el m\u00f3dulo del que depende, es decir en el fichero core.module.ts core.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { MatIconModule } from '@angular/material/icon' ; import { MatToolbarModule } from '@angular/material/toolbar' ; import { HeaderComponent } from './header/header.component' ; import { RouterModule } from '@angular/router' ; @NgModule ({ declarations : [ HeaderComponent ], imports : [ CommonModule , RouterModule , MatIconModule , MatToolbarModule , ], exports : [ HeaderComponent ] }) export class CoreModule { } Adem\u00e1s de a\u00f1adir las dependencias, diremos que este m\u00f3dulo va a exportar el componente HeaderComponent para poder utilizarlo desde otras p\u00e1ginas. Ya por \u00faltimo solo nos queda modificar la p\u00e1gina general de la aplicaci\u00f3n app.component.html para a\u00f1adirle el componente HeaderComponent . app.component.html < div > < app-header ></ app-header > < div > < router-outlet ></ router-outlet > </ div > </ div > Vamos al navegador y refrescamos la p\u00e1gina, deber\u00eda aparecer una barra superior (Header) con las opciones de men\u00fa. Algo similar a esto: Recuerda Cuando se a\u00f1aden componentes a los ficheros html , siempre se deben utilizar los selectores definidos para el componente. En el caso anterior hemos a\u00f1adido app-header que es el mismo nombre selector que tiene el componente en el fichero header.component.ts . Adem\u00e1s, recuerda que para poder utilizar componentes de otros m\u00f3dulos, los debes exportar ya que de lo contrario tan solo podr\u00e1n utilizarse dentro del m\u00f3dulo donde se declaran.","title":"C\u00f3digo de la pantalla"},{"location":"develop/basic/angular/#creando-un-listado-basico","text":"","title":"Creando un listado b\u00e1sico"},{"location":"develop/basic/angular/#crear-componente_1","text":"Ya tenemos la estructura principal, ahora vamos a crear nuestra primera pantalla. Vamos a empezar por la de Categor\u00edas que es la m\u00e1s sencilla, ya que se trata de un listado, que muestra datos sin filtrar ni paginar. Como categor\u00edas es un dominio funcional de la aplicaci\u00f3n, vamos a crear un m\u00f3dulo que contenga toda la funcionalidad de ese dominio. Ejecutamos en consola: ng generate module category Y por tanto, al igual que hicimos anteriormente, hay que a\u00f1adir el m\u00f3dulo al fichero app.module.ts app.module.ts import { BrowserModule } from '@angular/platform-browser' ; import { NgModule } from '@angular/core' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { BrowserAnimationsModule } from '@angular/platform-browser/animations' ; import { CoreModule } from './core/core.module' ; import { CategoryModule } from './category/category.module' ; @NgModule ({ declarations : [ AppComponent ], imports : [ BrowserModule , AppRoutingModule , CoreModule , CategoryModule , BrowserAnimationsModule , ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { } Ahora todas las pantallas, componentes y servicios que creemos, referidos a este dominio funcional, deber\u00e1n ir dentro del modulo cagegory . Vamos a crear un primer componente que ser\u00e1 un listado de categor\u00edas. Para ello vamos a ejecutar el siguiente comando: ng generate component category/category-list Para terminar de configurar la aplicaci\u00f3n, vamos a a\u00f1adir la ruta del componente dentro del componente routing de Angular, para poder acceder a \u00e9l, para ello modificamos el fichero app-routing.module.ts app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { CategoryListComponent } from './category/category-list/category-list.component' ; const routes : Routes = [ { path : 'categories' , component : CategoryListComponent }, ]; @NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } Si abrimos el navegador y accedemos a http://localhost:4200/ podremos navegar mediante el men\u00fa Categor\u00edas el cual abrir\u00e1 el componente que acabamos de crear.","title":"Crear componente"},{"location":"develop/basic/angular/#codigo-de-la-pantalla_1","text":"Ahora vamos a construir la pantalla. Para manejar la informaci\u00f3n del listado, necesitamos almacenar los datos en un objeto de tipo model . Para ello crearemos un fichero en category\\model\\Category.ts donde implementaremos la clase necesaria. Esta clase ser\u00e1 la que utilizaremos en el c\u00f3digo html y ts de nuestro componente. Category.ts export class Category { id : number ; name : string ; } Tambi\u00e9n, escribiremos el c\u00f3digo de la pantalla de listado. category-list.component.html category-list.component.scss category-list.component.ts < div class = \"container\" > < h1 > Listado de Categor\u00edas </ h1 > < mat-table [ dataSource ]=\" dataSource \" > < ng-container matColumnDef = \"id\" > < mat-header-cell * matHeaderCellDef > Identificador </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.id}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"name\" > < mat-header-cell * matHeaderCellDef > Nombre categor\u00eda </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.name}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" >< mat-icon > edit </ mat-icon ></ button > < button mat-icon-button color = \"accent\" >< mat-icon > clear </ mat-icon ></ button > </ mat-cell > </ ng-container > < mat-header-row * matHeaderRowDef = \"displayedColumns; sticky: true\" ></ mat-header-row > < mat-row * matRowDef = \"let row; columns: displayedColumns;\" ></ mat-row > </ mat-table > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" > Nueva categor\u00eda </ button > </ div > </ div > . container { margin : 20 px ; mat-table { margin-top : 10 px ; margin-bottom : 20 px ; .mat-header-row { background-color : #f5f5f5 ; .mat-header-cell { text-transform : uppercase ; font-weight : bold ; color : #838383 ; } } . mat-column-id { flex : 0 0 20 % ; justify-content : center ; } . mat-column-action { flex : 0 0 10 % ; justify-content : center ; } } . buttons { text-align : right ; } } import { Component , OnInit } from '@angular/core' ; import { MatTableDataSource } from '@angular/material/table' ; import { Category } from '../model/Category' ; @Component ({ selector : 'app-category-list' , templateUrl : './category-list.component.html' , styleUrls : [ './category-list.component.scss' ] }) export class CategoryListComponent implements OnInit { dataSource = new MatTableDataSource < Category > (); displayedColumns : string [] = [ 'id' , 'name' , 'action' ]; constructor () { } ngOnInit () : void { } } El c\u00f3digo HTML es f\u00e1cil de seguir pero por si acaso: L\u00ednea 4: Creamos la tabla con la variable dataSource definida en el fichero .ts L\u00ednea 5: Definici\u00f3n de la primera columna, su cabecera y el dato que va a contener L\u00ednea 10: Definici\u00f3n de la segunda columna, su cabecera y el dato que va a contener L\u00ednea 15: Definici\u00f3n de la tercera columna, su cabecera vac\u00eda y los dos botones de acci\u00f3n L\u00ednea 23 y 24: Construcci\u00f3n de la cabecera y las filas Y ya por \u00faltimo, a\u00f1adimos los componentes que se han utilizado de Angular Material a las dependencias del m\u00f3dulo donde est\u00e1 definido el componente en este caso category\\category.module.ts : category.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { MatTableModule } from '@angular/material/table' ; import { MatIconModule } from '@angular/material/icon' ; import { MatButtonModule } from '@angular/material/button' ; import { CategoryListComponent } from './category-list/category-list.component' ; @NgModule ({ declarations : [ CategoryListComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule ], }) export class CategoryModule { } Si abrimos el navegador y accedemos a http://localhost:4200/ y pulsamos en el men\u00fa de Categor\u00edas obtendremos una pantalla con un listado vac\u00edo (solo con cabeceras) y un bot\u00f3n de crear Nueva Categor\u00eda que aun no hace nada.","title":"C\u00f3digo de la pantalla"},{"location":"develop/basic/angular/#anadiendo-datos","text":"En este punto y para ver como responde el listado, vamos a a\u00f1adir datos. Si tuvieramos el backend implementado podr\u00edamos consultar los datos directamente de una operaci\u00f3n de negocio de backend, pero ahora mismo no lo tenemos implementado as\u00ed que para no bloquear el desarrollo vamos a mockear los datos.","title":"A\u00f1adiendo datos"},{"location":"develop/basic/angular/#creando-un-servicio","text":"En angular, cualquier acceso a datos debe pasar por un service , as\u00ed que vamos a crearnos uno para todas las operaciones de categor\u00edas. Vamos a la consola y ejecutamos: ng generate service category/category Esto nos crear\u00e1 un servicio, que adem\u00e1s podemos utilizarlo inyect\u00e1ndolo en cualquier componente que lo necesite.","title":"Creando un servicio"},{"location":"develop/basic/angular/#implementando-un-servicio","text":"Vamos a implementar una operaci\u00f3n de negocio que recupere el listado de categor\u00edas y lo vamos a hacer de forma reactiva (as\u00edncrona) para simular una petici\u00f3n a backend. Modificamos los siguientes ficheros: category.service.ts category-list.component.ts import { Injectable } from '@angular/core' ; import { Observable } from 'rxjs' ; import { Category } from './model/Category' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor () { } getCategories () : Observable < Category [] > { return new Observable (); } } import { Component , OnInit } from '@angular/core' ; import { MatTableDataSource } from '@angular/material/table' ; import { Category } from '../model/Category' ; import { CategoryService } from '../category.service' ; @Component ({ selector : 'app-category-list' , templateUrl : './category-list.component.html' , styleUrls : [ './category-list.component.scss' ] }) export class CategoryListComponent implements OnInit { dataSource = new MatTableDataSource < Category > (); displayedColumns : string [] = [ 'id' , 'name' , 'action' ]; constructor ( private categoryService : CategoryService , ) { } ngOnInit () : void { this . categoryService . getCategories (). subscribe ( categories => this . dataSource . data = categories ); } }","title":"Implementando un servicio"},{"location":"develop/basic/angular/#mockeando-datos","text":"Como hemos comentado anteriormente, el backend todav\u00eda no est\u00e1 implementado as\u00ed que vamos a mockear datos. Nos crearemos un fichero mock-categories.ts dentro de model, con datos ficticios y modificaremos el servicio para que devuelva esos datos. De esta forma, cuando tengamos implementada la operaci\u00f3n de negocio en backend, tan solo tenemos que sustuir el c\u00f3digo que devuelve datos est\u00e1ticos por una llamada http. mock-categories.ts category.service.ts import { Category } from \"./Category\" ; export const CATEGORY_DATA : Category [] = [ { id : 1 , name : 'Dados' }, { id : 2 , name : 'Fichas' }, { id : 3 , name : 'Cartas' }, { id : 4 , name : 'Rol' }, { id : 5 , name : 'Tableros' }, { id : 6 , name : 'Tem\u00e1ticos' }, { id : 7 , name : 'Europeos' }, { id : 8 , name : 'Guerra' }, { id : 9 , name : 'Abstractos' }, ] import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; import { CATEGORY_DATA } from './model/mock-categories' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor () { } getCategories () : Observable < Category [] > { return of ( CATEGORY_DATA ); } } Si ahora refrescamos la p\u00e1gina web, veremos que el listado ya tiene datos con los que vamos a interactuar.","title":"Mockeando datos"},{"location":"develop/basic/angular/#simulando-las-otras-peticiones","text":"Para terminar, vamos a simular las otras dos peticiones, la de editar y la de borrar para cuando tengamos que utilizarlas. El servicio debe quedar m\u00e1s o menos as\u00ed: category.service.ts import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; import { CATEGORY_DATA } from './model/mock-categories' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor () { } getCategories () : Observable < Category [] > { return of ( CATEGORY_DATA ); } saveCategory ( category : Category ) : Observable < Category > { return of ( null ); } deleteCategory ( idCategory : number ) : Observable < any > { return of ( null ); } }","title":"Simulando las otras peticiones"},{"location":"develop/basic/angular/#anadiendo-acciones-al-listado","text":"","title":"A\u00f1adiendo acciones al listado"},{"location":"develop/basic/angular/#crear-componente_2","text":"Ahora nos queda a\u00f1adir las acciones al listado: crear, editar y eliminar. Empezaremos primero por las acciones de crear y editar, que ambas deber\u00edan abrir una ventana modal con un formulario para poder modificar datos de la entidad Categor\u00eda . Como siempre, para crear un componente usamos el asistente de Angular, esta vez al tratarse de una pantalla que solo vamos a utilizar dentro del dominio de categor\u00edas, tiene sentido que lo creemos dentro de ese m\u00f3dulo: ng generate component category/category-edit Ahora vamos a hacer que se abra al pulsar el bot\u00f3n Nueva categor\u00eda . Para eso, vamos al fichero category-list.component.ts y a\u00f1adimos un nuevo m\u00e9todo: category-list.component.ts ... import { MatDialog } from '@angular/material/dialog' ; import { CategoryEditComponent } from '../category-edit/category-edit.component' ; ... constructor ( private categoryService : CategoryService , public dialog : MatDialog , ) { } ... createCategory () { const dialogRef = this . dialog . open ( CategoryEditComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } ... Para poder abrir un componente dentro de un dialogo necesitamos obtener en el constructor un MatDialog. De ah\u00ed que hayamos tenido que a\u00f1adirlo como import y en el constructor. Dentro del m\u00e9todo createCategory lo que hacemos es crear un dialogo con el componente CategoryEditComponent en su interior, pasarle unos datos de creaci\u00f3n, donde podemos poner estilos del dialog y un objeto data donde pondremos los datos que queremos pasar entre los componentes. Por \u00faltimo, nos suscribimos al evento afterClosed para ejecutar las acciones que creamos oportunas, en nuestro caso volveremos a cargar el listado inicial. Como hemos utilizado un MatDialog en el componente, necesitamos a\u00f1adirlo tambi\u00e9n al m\u00f3dulo, as\u00ed que abrimos el fichero category.module.ts y a\u00f1adimos: category.module.ts ... import { MAT_DIALOG_DATA , MatDialogModule } from '@angular/material/dialog' ; @NgModule ({ declarations : [ CategoryListComponent , CategoryEditComponent ], imports : [ ... MatDialogModule ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class CategoryModule { } Y ya por \u00faltimo enlazamos el click en el bot\u00f3n con el m\u00e9todo que acabamos de crear para abrir el dialogo. Modificamos el fichero category-list.component.html y a\u00f1adimos el evento click: category-list.component.html ... < div class = \"buttons\" > < button mat - flat - button color = \"primary\" ( click ) = \"createCategory()\" > Nueva categor\u00eda < /button> < /div> < /div> Si refrescamos el navegador y pulsamos el bot\u00f3n Nueva categor\u00eda veremos como se abre una ventana modal de tipo Dialog con el componente nuevo que hemos creado, aunque solo se leer\u00e1 category-edit works! que es el contenido por defecto del componente.","title":"Crear componente"},{"location":"develop/basic/angular/#codigo-del-dialogo","text":"Ahora vamos a darle forma al formulario de editar y crear. Para ello vamos al html, ts y css del componente y pegamos el siguiente contenido: category-edit.component.html category-edit.component.scss category-edit.component.ts < div class = \"container\" > < h1 > Crear categor\u00eda </ h1 > < form > < mat-form-field > < mat-label > Identificador </ mat-label > < input type = \"text\" matInput placeholder = \"Identificador\" [( ngModel )]=\" category . id \" name = \"id\" disabled > </ mat-form-field > < mat-form-field > < mat-label > Nombre </ mat-label > < input type = \"text\" matInput placeholder = \"Nombre de categor\u00eda\" [( ngModel )]=\" category . name \" name = \"name\" required > < mat-error > El nombre no puede estar vac\u00edo </ mat-error > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onClose ()\" > Cerrar </ button > < button mat-flat-button color = \"primary\" ( click )=\" onSave ()\" > Guardar </ button > </ div > </ div > . container { min-width : 350 px ; max-width : 500 px ; padding : 20 px ; form { display : flex ; flex-direction : column ; margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } import { Component , OnInit } from '@angular/core' ; import { MatDialogRef } from '@angular/material/dialog' ; import { CategoryService } from '../category.service' ; import { Category } from '../model/Category' ; @Component ({ selector : 'app-category-edit' , templateUrl : './category-edit.component.html' , styleUrls : [ './category-edit.component.scss' ] }) export class CategoryEditComponent implements OnInit { category : Category ; constructor ( public dialogRef : MatDialogRef < CategoryEditComponent > , private categoryService : CategoryService ) { } ngOnInit () : void { this . category = new Category (); } onSave () { this . categoryService . saveCategory ( this . category ). subscribe ( result => { this . dialogRef . close (); }); } onClose () { this . dialogRef . close (); } } Si te fijas en el c\u00f3digo TypeScript, hemos a\u00f1adido en el m\u00e9todo onSave una llamada al servicio de CategoryService que aunque no realice ninguna operaci\u00f3n de momento, por lo menos lo dejamos preparado para conectar con el servidor. Adem\u00e1s, como siempre, al utilizar componentes matInput , matForm , matError hay que a\u00f1adirlos como dependencias en el m\u00f3dulo category.module.ts : category.module.ts ... import { MAT_DIALOG_DATA , MatDialogModule } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatInputModule } from '@angular/material/input' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; @NgModule ({ declarations : [ CategoryListComponent , CategoryEditComponent ], imports : [ ... MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class CategoryModule { } Ahora podemos navegar y abrir el cuadro de dialogo mediante el bot\u00f3n Nueva categor\u00eda para ver como queda nuestro formulario.","title":"C\u00f3digo del dialogo"},{"location":"develop/basic/angular/#utilizar-el-dialogo-para-editar","text":"El mismo componente que hemos utilizado para crear una nueva categor\u00eda, nos sirve tambi\u00e9n para editar una categor\u00eda existente. Tan solo tenemos que utilizar la funcionalidad que Angular nos proporciona y pasarle los datos a editar en la llamada de apertura del Dialog. Vamos a implementar funcionalidad sobre el icono editar , tendremos que modificar unos cuantos ficheros: category-list.component.html category-list.component.ts < div class = \"container\" > < h1 > Listado de Categor\u00edas </ h1 > < mat-table [ dataSource ]=\" dataSource \" > < ng-container matColumnDef = \"id\" > < mat-header-cell * matHeaderCellDef > Identificador </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.id}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"name\" > < mat-header-cell * matHeaderCellDef > Nombre categor\u00eda </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.name}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" ( click )=\" editCategory ( element )\" > < mat-icon > edit </ mat-icon > </ button > < button mat-icon-button color = \"accent\" >< mat-icon > clear </ mat-icon ></ button > </ mat-cell > </ ng-container > < mat-header-row * matHeaderRowDef = \"displayedColumns; sticky: true\" ></ mat-header-row > < mat-row * matRowDef = \"let row; columns: displayedColumns;\" ></ mat-row > </ mat-table > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createCategory ()\" > Nueva categor\u00eda </ button > </ div > </ div > export class CategoryListComponent implements OnInit { dataSource = new MatTableDataSource < Category > (); displayedColumns : string [] = [ 'id' , 'name' , 'action' ]; constructor ( private categoryService : CategoryService , public dialog : MatDialog , ) { } ngOnInit () : void { this . categoryService . getCategories (). subscribe ( categories => this . dataSource . data = categories ); } createCategory () { const dialogRef = this . dialog . open ( CategoryEditComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } editCategory ( category : Category ) { const dialogRef = this . dialog . open ( CategoryEditComponent , { data : { category : category } }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } } Y los Dialog: category-edit.component.html category-edit.component.ts < div class = \"container\" > < h1 * ngIf = \"category.id == null\" > Crear categor\u00eda < /h1> < h1 * ngIf = \"category.id != null\" > Modificar categor\u00eda < /h1> < form > < mat - form - field > ... import { Component , OnInit , Inject } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { CategoryService } from '../category.service' ; import { Category } from '../model/Category' ; @Component ({ selector : 'app-category-edit' , templateUrl : './category-edit.component.html' , styleUrls : [ './category-edit.component.scss' ] }) export class CategoryEditComponent implements OnInit { category : Category ; constructor ( public dialogRef : MatDialogRef < CategoryEditComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any , private categoryService : CategoryService ) { } ngOnInit () : void { if ( this . data . category != null ) { this . category = this . data . category ; } else { this . category = new Category (); } } onSave () { this . categoryService . saveCategory ( this . category ). subscribe ( result => { this . dialogRef . close (); }); } onClose () { this . dialogRef . close (); } } Navegando ahora por la p\u00e1gina y pulsando en el icono de editar, se deber\u00eda abrir una ventana con los datos que hemos seleccionado, similar a esta imagen: Si te fijas, al modificar los datos dentro de la ventana de di\u00e1logo se modifica tambi\u00e9n en el listado. Esto es porque estamos pasando el mismo objeto desde el listado a la ventana dialogo y al ser el listado y el formulario reactivos los dos, cualquier cambio sobre los datos se refresca directamente en la pantalla. Hay veces en la que este comportamiento nos interesa, pero en este caso no queremos que se modifique el listado. Para solucionarlo debemos hacer una copia del objeto, para que ambos modelos (formulario y listado) utilicen objetos diferentes. Es tan sencillo como modificar category-edit.component.ts y a\u00f1adirle una copia del dato category-edit.component.ts ... ngOnInit () : void { if ( this . data . category != null ) { this . category = Object . assign ({}, this . data . category ); } else { this . category = new Category (); } } ... Cuidado Hay que tener mucho cuidado con el binding de los objetos. Hay veces que al modificar un objeto NO queremos que se modifique en todas sus instancias y tenemos que poner especial cuidado en esos aspectos.","title":"Utilizar el dialogo para editar"},{"location":"develop/basic/angular/#accion-de-borrado","text":"Por norma general, toda acci\u00f3n de borrado de un dato de pantalla requiere una confirmaci\u00f3n previa por parte del usuario. Es decir, para evitar que el dato se borre accidentalmente el usuario tendr\u00e1 que confirmar su acci\u00f3n. Por tanto vamos a crear un componente que nos permita pedir una confirmaci\u00f3n al usuario. Como esta pantalla de confirmaci\u00f3n va a ser algo com\u00fan a muchas acciones de borrado de nuestra aplicaci\u00f3n, vamos a crearla dentro del m\u00f3dulo core . Como siempre, ejecutamos el comando en consola: ng generate component core/dialog-confirmation E implementamos el c\u00f3digo que queremos que tenga el componente. Al ser un componente gen\u00e9rico vamos a aprovechar y leeremos las variables que le pasemos en data . dialog-confirmation.component.html dialog-confirmation.component.scss dialog-confirmation.component.ts < div class = \"container\" > < h1 > {{title}} </ h1 > < div [ innerHTML ]=\" description \" class = \"description\" ></ div > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onNo ()\" > No </ button > < button mat-flat-button color = \"primary\" ( click )=\" onYes ()\" > S\u00ed </ button > </ div > </ div > . container { min-width : 350 px ; max-width : 500 px ; padding : 20 px ; .description { margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } import { Component , OnInit , Inject } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; @Component ({ selector : 'app-dialog-confirmation' , templateUrl : './dialog-confirmation.component.html' , styleUrls : [ './dialog-confirmation.component.scss' ] }) export class DialogConfirmationComponent implements OnInit { title : string ; description : string ; constructor ( public dialogRef : MatDialogRef < DialogConfirmationComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any ) { } ngOnInit () : void { this . title = this . data . title ; this . description = this . data . description ; } onYes () { this . dialogRef . close ( true ); } onNo () { this . dialogRef . close ( false ); } } Recuerda Recuerda que los componentes utilizados en el di\u00e1logo de confirmaci\u00f3n se deben a\u00f1adir al m\u00f3dulo padre al que pertenecen, en este caso a core.module.ts imports: [ CommonModule, RouterModule, MatIconModule, MatToolbarModule, MatDialogModule, MatButtonModule, ], providers: [ { provide: MAT_DIALOG_DATA, useValue: {}, }, ], Ya por \u00faltimo, una vez tenemos el componente gen\u00e9rico de dialogo, vamos a utilizarlo en nuestro listado al pulsar el bot\u00f3n eliminar: category-list.component.html category-list.component.ts ... < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" ( click )=\" editCategory ( element )\" > < mat-icon > edit </ mat-icon > </ button > < button mat-icon-button color = \"accent\" ( click )=\" deleteCategory ( element )\" > < mat-icon > clear </ mat-icon > </ button > </ mat-cell > </ ng-container > ... ... deleteCategory ( category : Category ) { const dialogRef = this . dialog . open ( DialogConfirmationComponent , { data : { title : \"Eliminar categor\u00eda\" , description : \"Atenci\u00f3n si borra la categor\u00eda se perder\u00e1n sus datos.<br> \u00bfDesea eliminar la categor\u00eda?\" } }); dialogRef . afterClosed (). subscribe ( result => { if ( result ) { this . categoryService . deleteCategory ( category . id ). subscribe ( result => { this . ngOnInit (); }); } }); } ... Aqu\u00ed tambi\u00e9n hemos realizado la llamada a categoryService , aunque no se realice ninguna acci\u00f3n, pero as\u00ed lo dejamos listo para enlazarlo. Llegados a este punto, ya solo nos queda enlazar las acciones de la pantalla con las operaciones de negocio del backend.","title":"Acci\u00f3n de borrado"},{"location":"develop/basic/angular/#conectar-con-backend","text":"Antes de seguir Antes de seguir con este punto, debes implementar el c\u00f3digo de backend en la tecnolog\u00eda que quieras ( Springboot o Nodejs ). Si has empezado este cap\u00edtulo implementando el frontend, por favor accede a la secci\u00f3n correspondiente de backend para poder continuar con el tutorial. Una vez tengas implementadas todas las operaciones para este listado, puedes volver a este punto y continuar con Angular. El siguiente paso, como es obvio ser\u00e1 hacer que Angular llame directamente al servidor backend para leer y escribir datos y eliminar los datos mockeados en Angular. Manos a la obra!","title":"Conectar con Backend"},{"location":"develop/basic/angular/#llamada-del-listado","text":"La idea es que el m\u00e9todo getCategories() de category.service.ts en lugar de devolver datos est\u00e1ticos, realice una llamada al servidor a la ruta http://localhost:8080/category . Abrimos el fichero y susituimos la l\u00ednea que antes devolv\u00eda los datos est\u00e1ticos por esto: category.service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor ( private http : HttpClient ) { } getCategories () : Observable < Category [] > { return this . http . get < Category [] > ( 'http://localhost:8080/category' ); } saveCategory ( category : Category ) : Observable < Category > { return of ( null ); } deleteCategory ( idCategory : number ) : Observable < any > { return of ( null ); } } Como hemos a\u00f1adido un componente nuevo HttpClient tenemos que a\u00f1adir la dependencia al m\u00f3dulo padre. category.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { MatTableModule } from '@angular/material/table' ; import { MatIconModule } from '@angular/material/icon' ; import { MatButtonModule } from '@angular/material/button' ; import { CategoryListComponent } from './category-list/category-list.component' ; import { CategoryEditComponent } from './category-edit/category-edit.component' ; import { MAT_DIALOG_DATA , MatDialogModule } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatInputModule } from '@angular/material/input' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; import { HttpClientModule } from '@angular/common/http' ; @NgModule ({ declarations : [ CategoryListComponent , CategoryEditComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule , MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , HttpClientModule , ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class CategoryModule { } Si ahora refrescas el navegador (recuerda tener arrancado tambi\u00e9n el servidor) y accedes a la pantalla de Categor\u00edas deber\u00eda aparecer el listado con los datos que vienen del servidor.","title":"Llamada del listado"},{"location":"develop/basic/angular/#llamada-de-guardado-edicion","text":"Para la llamada de guardado har\u00edamos lo mismo, pero invocando la operaci\u00f3n de negocio put . category.service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor ( private http : HttpClient ) { } getCategories () : Observable < Category [] > { return this . http . get < Category [] > ( 'http://localhost:8080/category' ); } saveCategory ( category : Category ) : Observable < Category > { let url = 'http://localhost:8080/category' ; if ( category . id != null ) url += '/' + category . id ; return this . http . put < Category > ( url , category ); } deleteCategory ( idCategory : number ) : Observable < any > { return of ( null ); } } Ahora podemos probar a modificar o a\u00f1adir una nueva categor\u00eda desde la pantalla y deber\u00eda aparecer los nuevos datos en el listado.","title":"Llamada de guardado / edici\u00f3n"},{"location":"develop/basic/angular/#llamada-de-borrado","text":"Y ya por \u00faltimo, la llamada de borrado, deber\u00edamos cambiarla e invocar a la operaci\u00f3n de negocio delete . category.service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor ( private http : HttpClient ) { } getCategories () : Observable < Category [] > { return this . http . get < Category [] > ( 'http://localhost:8080/category' ); } saveCategory ( category : Category ) : Observable < Category > { let url = 'http://localhost:8080/category' ; if ( category . id != null ) url += '/' + category . id ; return this . http . put < Category > ( url , category ); } deleteCategory ( idCategory : number ) : Observable < any > { return this . http . delete ( 'http://localhost:8080/category/' + idCategory ); } } Ahora podemos probar a modificar o a\u00f1adir una nueva categor\u00eda desde la pantalla y deber\u00eda aparecer los nuevos datos en el listado. Como ves, es bastante sencillo conectar server y client.","title":"Llamada de borrado"},{"location":"develop/basic/angular/#depuracion","text":"Una parte muy importante del desarrollo es tener la capacidad de depurar nuestro c\u00f3digo, en este apartado vamos a explicar como se realiza debug en Front. Esta parte se puede realizar con nuestro navegador favorito, en este caso vamos a utilizar Chrome. El primer paso es abrir las herramientas del desarrollador del navegador presionando F12 . En esta herramienta tenemos varias partes importantes: Elements: Inspector de los elementos del DOM de nuestra aplicaci\u00f3n que nos ayuda identificar el c\u00f3digo generado. Console: Consola donde podemos ver mensajes importantes que nos ayudan a identificar posibles problemas. Source: El navegador de ficheros que componen nuestra aplicaci\u00f3n. Network: El registro de peticiones que realiza nuestra aplicaci\u00f3n. Identificados los elementos importantes, vamos a depurar la operaci\u00f3n de crear categor\u00eda. Para ello nos dirigimos a la pesta\u00f1a de Source , en el \u00e1rbol de carpetas nos dirigimos a la ruta donde est\u00e1 localizado el c\u00f3digo de nuestra aplicaci\u00f3n webpack://src/app . Dentro de esta carpeta est\u00e9 localizado todo el c\u00f3digo fuente de la aplicaci\u00f3n, en nuestro caso vamos a localizar componente category-edit.component que crea una nueva categor\u00eda. Dentro del fichero ya podemos a\u00f1adir puntos de ruptura (breakpoint), en nuestro caso queremos comprobar que el nombre introducido se captura bien y se env\u00eda al service correctamente. Colocamos el breakpoint en la l\u00ednea de invocaci\u00f3n del service (click sobre el n\u00famero de la l\u00ednea) y desde la interfaz creamos una nueva categor\u00eda. Hecho esto, podemos observar que a nivel de interfaz, la aplicaci\u00f3n se detiene y aparece un panel de manejo de los puntos de interrupci\u00f3n: En cuanto a la herramienta del desarrollador nos lleva al punto exacto donde hemos a\u00f1adido el breakpoint y se para en este punto ofreci\u00e9ndonos la posibilidad de explorar el contenido de las variables del c\u00f3digo: Aqu\u00ed podemos comprobar que efectivamente la variable category tiene el valor que hemos introducido por pantalla y se propaga correctamente hacia el service. Para continuar con la ejecuci\u00f3n basta con darle al bot\u00f3n de play del panel de manejo de interrupci\u00f3n o al que aparece dentro de la herramienta de desarrollo (parte superior derecha). Por \u00faltimo, vamos a revisar que la petici\u00f3n REST se ha realizado correctamente al backend, para ello nos dirigimos a la pesta\u00f1a Network y comprobamos las peticiones realizadas: Aqu\u00ed podemos observar el registro de todas las peticiones y haciendo click sobre una de ellas, obtenemos el detalle de esta. Header: Informaci\u00f3n de las cabeceras enviadas (aqu\u00ed podemos ver que se ha hecho un PUT a la ruta correcta). Payload: El cuerpo de la petici\u00f3n (vemos el cuerpo del mensaje con el nombre enviado). Preview: Respuesta de la petici\u00f3n normalizada (vemos la respuesta con el identificador creado para la nueva categor\u00eda).","title":"Depuraci\u00f3n"},{"location":"develop/basic/nodejs/","text":"Listado simple - Nodejs Ahora que ya tenemos listo el proyecto backend de nodejs (en el puerto 8080) ya podemos empezar a codificar la soluci\u00f3n. Primeros pasos Antes de empezar Quiero hacer hincapi\u00e9 en Node tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. Tanto en la web de node como de express encontrar\u00e1s informaci\u00f3n detallada del proceso que vamos a seguir. Estructurar el c\u00f3digo La estructura de nuestro proyecto ser\u00e1 la siguiente: Vamos a aplicar una separaci\u00f3n por capas. En primer lugar, tendremos una capa de rutas para reenviar las solicitudes admitidas y cualquier informaci\u00f3n codificada en las urls de solicitud a la siguiente capa de controladores. La capa de control procesar\u00e1 las peticiones de las rutas y se comunicar\u00e1 con la capa de servicios devolviendo la respuesta de esta mediante respuestas http. En la capa de servicio se ejecutar\u00e1 toda la l\u00f3gica de la petici\u00f3n y se comunicar\u00e1 con los modelos de base de datos En nuestro caso una ruta es una secci\u00f3n de c\u00f3digo Express que asocia un verbo HTTP (GET, POST, PUT, DELETE, etc.), una ruta/patr\u00f3n de URL y una funci\u00f3n que se llama para manejar ese patr\u00f3n. \u00a1Ahora s\u00ed, vamos a programar! Capa de Routes Lo primero de vamos a crear es la carpeta principal de nuestra aplicaci\u00f3n donde estar\u00e1n contenidos los distintos elementos de la misma. Para ello creamos una carpeta llamada src en la ra\u00edz de nuestra aplicaci\u00f3n. El primero elemento que vamos a crear va a ser el fichero de rutas para la categor\u00eda. Para ello creamos una carpeta llamada routes en la carpeta src y dentro de esta carpeta crearemos un archivo llamado category.routes.js : category.routes.js import { Router } from 'express' ; import { createCategory } from '../controllers/category.controller.js' ; const categoryRouter = Router (); categoryRouter . put ( '/' , createCategory ); export default categoryRouter ; En este archivo estamos creando una ruta de tipo PUT que llamara al m\u00e9todo createCategory de nuestro futuro controlador de categor\u00edas (aunque todav\u00eda no lo hemos creado y por tanto fallar\u00e1). Ahora en nuestro archivo index.js vamos a a\u00f1adir lo siguiente justo despu\u00e9s de declarar la constante app: index.js ... import categoryRouter from './src/routes/category.routes.js' ; ... ... app . use ( cors ({ origin : '*' })); app . use ( express . json ()); app . use ( '/category' , categoryRouter ); ... De este modo estamos asociando la url http://localhost:8080/category a nuestro router. Tambi\u00e9n usaremos express.json() para parsear las peticiones entrantes a formato json. Capa de Controller Lo siguiente ser\u00e1 crear el m\u00e9todo createCategory en nuestro controller. Para ello lo primero ser\u00e1 crear una carpeta controllers en la carpeta src de nuestro proyecto y dentro de esta un archivo llamado category.controller.js : category.controller.js export const createCategory = async ( req , res ) => { console . log ( req . body ); res . status ( 200 ). json ( 1 ); } Hemos creado la funci\u00f3n createCategory que recibir\u00e1 una request y una response. Estos par\u00e1metros vienen de la ruta de express y son la request y response de la petici\u00f3n HTTP. De momento simplemente vamos a hacer un console.log de req.body para ver el body de la petici\u00f3n y vamos a hacer una response 200 para indicar que todo ha ido correctamente. Si arrancamos el servidor y hacemos una petici\u00f3n PUT con Postman a http://localhost:8080/category con un body que pongamos formado correctamente podremos ver la salida que hemos programado en nuestro controller y en la consola de node podemos ver el contenido de req.body . Capa de Modelo Ahora para que los datos que pasemos en el body los podamos guardar en BBDD necesitaremos un modelo y un esquema para la entidad Category . Vamos a crear una carpeta llamada schemas en la carpeta src de nuestro proyecto. Un schema no es m\u00e1s que un modelo de BBDD que especifica que campos estar\u00e1n presentes y cu\u00e1les ser\u00e1n sus tipos. Dentro de la carpeta de schemas creamos un archivo con el nombre category.schema.js : category.schema.js import mongoose from \"mongoose\" ; const { Schema , model } = mongoose ; import normalize from 'normalize-mongoose' ; const categorySchema = new Schema ({ name : { type : String , require : true } }); categorySchema . plugin ( normalize ); const CategoryModel = model ( 'Category' , categorySchema ); export default CategoryModel ; En este archivo estamos definiendo nuestro schema indicando sus propiedades y tipos, en nuestro caso \u00fanicamente name . Adem\u00e1s del tipo tambi\u00e9n indicaremos que el campo es obligatorio con la validation require para indicar que ese campo es obligatorio. Si quieres conocer otras validaciones aqu\u00ed tienes m\u00e1s info . Aparte de definir nuestro schema tambi\u00e9n lo estamos transformado en un modelo para poder trabajar con \u00e9l. En el constructor de model le pasamos el nombre del modelo y el schema que vamos a utilizar. Capa de Servicio Como hemos visto en nuestra estructura la capa controller no puede comunicarse con la capa modelo, debe de haber una capa intermedia, para ello vamos a crear una carpeta services en la carpeta src de nuestro proyecto y dentro un archivo category.service.js : category.service.js import CategoryModel from '../schemas/category.schema.js' ; export const createCategory = async function ( name ) { try { const category = new CategoryModel ({ name }); return await category . save (); } catch ( e ) { throw Error ( 'Error creating category' ); } } Hemos importado el modelo de categor\u00eda para poder realizar acciones sobre la BBDD y hemos creado una funci\u00f3n que recoger\u00e1 el nombre de la categor\u00eda y crear\u00e1 una nueva categor\u00eda con \u00e9l. Llamamos al m\u00e9todo save para guardar nuestra categor\u00eda y devolvemos el resultado. Ahora en nuestro m\u00e9todo del controller solo tenemos que llamar al servicio pas\u00e1ndole los par\u00e1metros que nos llegan en la petici\u00f3n: category.controller.js import * as CategoryService from '../services/category.service.js' ; export const createCategory = async ( req , res ) => { const { name } = req . body ; try { const category = await CategoryService . createCategory ( name ); res . status ( 200 ). json ({ category }); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } Si todo ha ido correctamente llamaremos al m\u00e9todo de respuesta con el c\u00f3digo 200 y la categor\u00eda creada. En caso contrario mandaremos un c\u00f3digo de error. Si ahora de nuevo vamos a postman y volvemos a lanzar nuestra petici\u00f3n podemos ver como nos devuelve una nueva categor\u00eda: Resto de Operaciones Recuperaci\u00f3n categor\u00edas Ahora que ya podemos crear categor\u00edas lo siguiente ser\u00e1 crear un endpoint para recuperar las categor\u00edas creadas en nuestra base de datos. Podemos empezar a\u00f1adiendo un nuevo m\u00e9todo en nuestro servicio: category.service.js export const getCategories = async function () { try { return await CategoryModel . find (). sort ( 'name' ); } catch ( e ) { throw Error ( 'Error fetching categories' ); } } Al igual que en el anterior m\u00e9todo haremos uso del modelo, pero esta vez para hacer un find y ordenando los resultados por el campo name . Al m\u00e9todo find se le pueden pasar queries , projections y options . Te dejo por aqu\u00ed m\u00e1s info. En nuestro caso simplemente queremos que nos devuelva todas las categor\u00edas por lo que no le pasaremos nada. Creamos tambi\u00e9n un m\u00e9todo en el controlador para recuperar las categor\u00edas y que har\u00e1 uso del servicio: category.controller.js export const getCategories = async ( req , res ) => { try { const categories = await CategoryService . getCategories (); res . status ( 200 ). json ( categories ); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } Y ahora que ya tenemos el m\u00e9todo creado en el controlador lo siguiente ser\u00e1 relacionar este m\u00e9todo con una ruta. Para ello en nuestro archivo category.routes.js tendremos que a\u00f1adir una nueva l\u00ednea: category.routes.js import { Router } from 'express' ; import { createCategory , getCategories } from '../controllers/category.controller.js' ; const categoryRouter = Router (); categoryRouter . put ( '/' , createCategory ); categoryRouter . get ( '/' , getCategories ); export default categoryRouter ; De este modo cuando hagamos una petici\u00f3n GET a http://localhost:8080/category nos devolver\u00e1 el listado de categor\u00edas existentes: Actualizar categor\u00eda Ahora vamos a por el m\u00e9todo para actualizar nuestras categor\u00edas. En el servicio creamos el siguiente m\u00e9todo: category.service.js export const updateCategory = async ( id , name ) => { try { const category = await CategoryModel . findById ( id ); if ( ! category ) { throw Error ( 'There is no category with that Id' ); } return await CategoryModel . findByIdAndUpdate ( id , { name }); } catch ( e ) { throw Error ( e ); } } A este m\u00e9todo le pasaremos de entrada el id y el nombre . Con ese id realizaremos una b\u00fasqueda para asegurarnos que esa categor\u00eda existe en nuestra base de datos. Si existe la categor\u00eda haremos una petici\u00f3n con findByIdAndUpdate donde el primer par\u00e1metro es el id y el segundo es el resto de los campos de nuestra entidad. En el controlador creamos el m\u00e9todo correspondiente: category.controller.js export const updateCategory = async ( req , res ) => { const categoryId = req . params . id ; const { name } = req . body ; try { await CategoryService . updateCategory ( categoryId , name ); res . status ( 200 ). json ( 1 ); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } Aqu\u00ed recogeremos el par\u00e1metro id que nos vendr\u00e1 en la url, por ejemplo: http://localhost:8080/category/1 . Esto lo hacemos con req.params.id . El id es el nombre de la variable que le daremos en el router como veremos m\u00e1s adelante. Y una vez creado el m\u00e9todo en el controlador tendremos que a\u00f1adir la ruta en nuestro fichero de rutas correspondiente, pero como ya hemos dicho tendremos que indicar que nuestra ruta espera un par\u00e1metro id, lo haremos de la siguiente forma: category.routes.js import { Router } from 'express' ; import { createCategory , getCategories , updateCategory } from '../controllers/category.controller.js' ; const categoryRouter = Router (); categoryRouter . put ( '/' , createCategory ); categoryRouter . get ( '/' , getCategories ); categoryRouter . put ( '/:id' , updateCategory ); export default categoryRouter ; Y volvemos a probar en Postman: Y si hacemos de nuevo un GET vemos como la categor\u00eda se ha modificado correctamente: Borrado categor\u00eda Ya solo nos faltar\u00eda la operaci\u00f3n de delete para completar nuestro CRUD, en el servicio a\u00f1adimos un nuevo m\u00e9todo: category.service.js export const deleteCategory = async ( id ) => { try { const category = await CategoryModel . findById ( id ); if ( ! category ) { throw Error ( 'There is no category with that Id' ); } return await CategoryModel . findByIdAndDelete ( id ); } catch ( e ) { throw Error ( 'Error deleting category' ); } } Como vemos es muy parecido al update, recuperamos el id de los par\u00e1metros de la ruta y en este caso llamaremos al m\u00e9todo findByIdAndDelete . En nuestro controlador creamos el m\u00e9todo correspondiente: category.controller.js export const deleteCategory = async ( req , res ) => { const categoryId = req . params . id ; try { const deletedCategory = await CategoryService . deleteCategory ( categoryId ); res . status ( 200 ). json ({ category : deletedCategory }); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } Y de nuevo a\u00f1adimos la ruta correspondiente al archivo de rutas: category.routes.js import { Router } from 'express' ; import { createCategory , getCategories , updateCategory , deleteCategory } from '../controllers/category.controller.js' ; const categoryRouter = Router (); categoryRouter . put ( '/' , createCategory ); categoryRouter . get ( '/' , getCategories ); categoryRouter . put ( '/:id' , updateCategory ); categoryRouter . delete ( '/:id' , deleteCategory ); export default categoryRouter ; Y de nuevo, probamos en postman: Hacemos un get para comprobar que se ha borrado de nuestra base de datos: Capa de Middleware (Validaciones) Antes de pasar a nuestro siguiente CRUD vamos a ver en que consiste la Capa de Middleware . Un middleware es un c\u00f3digo que se ejecuta antes de que una petici\u00f3n http llegue a nuestro manejador de rutas o antes de que el cliente reciba una respuesta. En nuestro caso vamos a crear un middleware para asegurarnos que todos los campos que necesitamos en nuestras entidades vienen en el body de la petici\u00f3n. Vamos a crear una carpeta middlewares en la carpeta src de nuestro proyecto y dentro crearemos el fichero validateFields.js : validateFields.js import { response } from 'express' ; import { validationResult } from 'express-validator' ; const validateFields = ( req , res = response , next ) => { const errors = validationResult ( req ); if ( ! errors . isEmpty ()) { return res . status ( 400 ). json ({ errors : errors . mapped () }); } next (); } export default validateFields ; En este m\u00e9todo nos ayudaremos de la librer\u00eda express-validator para ver los errores que tenemos en nuestras rutas. Para ello llamaremos a la funci\u00f3n validationResult que nos devolver\u00e1 un array de errores que m\u00e1s tarde definiremos. Si el array no va vac\u00edo es porque se ha producido alg\u00fan error en las validaciones y ejecutara la response con un c\u00f3digo de error. Ahora definiremos las validaciones en nuestro archivo de rutas, deber\u00eda quedar de la siguiente manera: category.routes.js import { Router } from 'express' ; import { check } from 'express-validator' ; import validateFields from '../middlewares/validateFields.js' ; import { getCategories , createCategory , deleteCategory , updateCategory } from '../controllers/category.controller.js' ; const categoryRouter = Router (); categoryRouter . put ( '/:id' , [ check ( 'name' ). not (). isEmpty (), validateFields ], updateCategory ); categoryRouter . put ( '/' , [ check ( 'name' ). not (). isEmpty (), validateFields ], createCategory ); categoryRouter . get ( '/' , getCategories ); categoryRouter . delete ( '/:id' , deleteCategory ); export default categoryRouter ; Aqu\u00ed nos ayudamos de nuevo de express-validator y de su m\u00e9todo check . Para las rutas en las que necesitemos validaciones, a\u00f1adimos un array como segundo par\u00e1metro. En este array vamos a\u00f1adiendo todas las validaciones que necesitemos. En nuestro caso solo queremos que el campo name no sea vac\u00edo, pero existen muchas m\u00e1s validaciones que puedes encontrar en la documentaci\u00f3n de express-validator . Importamos nuestro middleware y lo a\u00f1adimos en la \u00faltima posici\u00f3n de este array. De este modo no se realizar\u00e1n las peticiones que no pasen las validaciones: Y con esto habremos terminado nuestro primer CRUD. Depuraci\u00f3n Una parte muy importante del desarrollo es tener la capacidad de depurar nuestro c\u00f3digo, en este apartado vamos a explicar como se realiza debug en Backend. Esta parte se realiza con las herramientas incluidas dentro de nuestro IDE favorito, en este caso vamos a utilizar el Visual Estudio. Lo primero que debemos hacer es configurar el modo Debug de nuestro proyecto. Para ello nos dirigimos a la opci\u00f3n Run and Debug y creamos el fichero de launch necesario: Esto nos crear\u00e1 el fichero necesario y ya podremos arrancar la aplicaci\u00f3n mediante esta herramienta presionando el bot\u00f3n Launch Program (seleccionamos tipo de aplicaci\u00f3n Node y el script de arranque que ser\u00e1 el que hemos utilizado en el desarrollo): Arrancada la aplicaci\u00f3n de este modo, vamos a depurar la operaci\u00f3n de crear categor\u00eda. Para ello vamos a abrir nuestro fichero donde tenemos la implementaci\u00f3n del servicio de creaci\u00f3n de la capa de la l\u00f3gica de negocio category.service.js . Dentro del fichero ya podemos a\u00f1adir puntos de ruptura (breakpoint), en nuestro caso queremos comprobar que el nombre introducido se recibe correctamente. Colocamos el breakpoint en la primera l\u00ednea del m\u00e9todo (click sobre el n\u00famero de la l\u00ednea) y desde la interfaz/postman creamos una nueva categor\u00eda. Hecho esto, podemos observar que a nivel de interfaz/postman, la petici\u00f3n se queda esperando y el IDE mostrar\u00e1 un panel de manejo de los puntos de interrupci\u00f3n: El IDE nos lleva al punto exacto donde hemos a\u00f1adido el breakpoint y se para en este punto ofreci\u00e9ndonos la posibilidad de explorar el contenido de las variables del c\u00f3digo: Aqu\u00ed podemos comprobar que efectivamente la variable name tiene el valor que hemos introducido por pantalla/postman. Para continuar con la ejecuci\u00f3n basta con darle al bot\u00f3n de play del panel de manejo de los puntos de interrupci\u00f3n.","title":"\ud83d\udfe2 Nodejs"},{"location":"develop/basic/nodejs/#listado-simple-nodejs","text":"Ahora que ya tenemos listo el proyecto backend de nodejs (en el puerto 8080) ya podemos empezar a codificar la soluci\u00f3n.","title":"Listado simple - Nodejs"},{"location":"develop/basic/nodejs/#primeros-pasos","text":"Antes de empezar Quiero hacer hincapi\u00e9 en Node tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. Tanto en la web de node como de express encontrar\u00e1s informaci\u00f3n detallada del proceso que vamos a seguir.","title":"Primeros pasos"},{"location":"develop/basic/nodejs/#estructurar-el-codigo","text":"La estructura de nuestro proyecto ser\u00e1 la siguiente: Vamos a aplicar una separaci\u00f3n por capas. En primer lugar, tendremos una capa de rutas para reenviar las solicitudes admitidas y cualquier informaci\u00f3n codificada en las urls de solicitud a la siguiente capa de controladores. La capa de control procesar\u00e1 las peticiones de las rutas y se comunicar\u00e1 con la capa de servicios devolviendo la respuesta de esta mediante respuestas http. En la capa de servicio se ejecutar\u00e1 toda la l\u00f3gica de la petici\u00f3n y se comunicar\u00e1 con los modelos de base de datos En nuestro caso una ruta es una secci\u00f3n de c\u00f3digo Express que asocia un verbo HTTP (GET, POST, PUT, DELETE, etc.), una ruta/patr\u00f3n de URL y una funci\u00f3n que se llama para manejar ese patr\u00f3n. \u00a1Ahora s\u00ed, vamos a programar!","title":"Estructurar el c\u00f3digo"},{"location":"develop/basic/nodejs/#capa-de-routes","text":"Lo primero de vamos a crear es la carpeta principal de nuestra aplicaci\u00f3n donde estar\u00e1n contenidos los distintos elementos de la misma. Para ello creamos una carpeta llamada src en la ra\u00edz de nuestra aplicaci\u00f3n. El primero elemento que vamos a crear va a ser el fichero de rutas para la categor\u00eda. Para ello creamos una carpeta llamada routes en la carpeta src y dentro de esta carpeta crearemos un archivo llamado category.routes.js : category.routes.js import { Router } from 'express' ; import { createCategory } from '../controllers/category.controller.js' ; const categoryRouter = Router (); categoryRouter . put ( '/' , createCategory ); export default categoryRouter ; En este archivo estamos creando una ruta de tipo PUT que llamara al m\u00e9todo createCategory de nuestro futuro controlador de categor\u00edas (aunque todav\u00eda no lo hemos creado y por tanto fallar\u00e1). Ahora en nuestro archivo index.js vamos a a\u00f1adir lo siguiente justo despu\u00e9s de declarar la constante app: index.js ... import categoryRouter from './src/routes/category.routes.js' ; ... ... app . use ( cors ({ origin : '*' })); app . use ( express . json ()); app . use ( '/category' , categoryRouter ); ... De este modo estamos asociando la url http://localhost:8080/category a nuestro router. Tambi\u00e9n usaremos express.json() para parsear las peticiones entrantes a formato json.","title":"Capa de Routes"},{"location":"develop/basic/nodejs/#capa-de-controller","text":"Lo siguiente ser\u00e1 crear el m\u00e9todo createCategory en nuestro controller. Para ello lo primero ser\u00e1 crear una carpeta controllers en la carpeta src de nuestro proyecto y dentro de esta un archivo llamado category.controller.js : category.controller.js export const createCategory = async ( req , res ) => { console . log ( req . body ); res . status ( 200 ). json ( 1 ); } Hemos creado la funci\u00f3n createCategory que recibir\u00e1 una request y una response. Estos par\u00e1metros vienen de la ruta de express y son la request y response de la petici\u00f3n HTTP. De momento simplemente vamos a hacer un console.log de req.body para ver el body de la petici\u00f3n y vamos a hacer una response 200 para indicar que todo ha ido correctamente. Si arrancamos el servidor y hacemos una petici\u00f3n PUT con Postman a http://localhost:8080/category con un body que pongamos formado correctamente podremos ver la salida que hemos programado en nuestro controller y en la consola de node podemos ver el contenido de req.body .","title":"Capa de Controller"},{"location":"develop/basic/nodejs/#capa-de-modelo","text":"Ahora para que los datos que pasemos en el body los podamos guardar en BBDD necesitaremos un modelo y un esquema para la entidad Category . Vamos a crear una carpeta llamada schemas en la carpeta src de nuestro proyecto. Un schema no es m\u00e1s que un modelo de BBDD que especifica que campos estar\u00e1n presentes y cu\u00e1les ser\u00e1n sus tipos. Dentro de la carpeta de schemas creamos un archivo con el nombre category.schema.js : category.schema.js import mongoose from \"mongoose\" ; const { Schema , model } = mongoose ; import normalize from 'normalize-mongoose' ; const categorySchema = new Schema ({ name : { type : String , require : true } }); categorySchema . plugin ( normalize ); const CategoryModel = model ( 'Category' , categorySchema ); export default CategoryModel ; En este archivo estamos definiendo nuestro schema indicando sus propiedades y tipos, en nuestro caso \u00fanicamente name . Adem\u00e1s del tipo tambi\u00e9n indicaremos que el campo es obligatorio con la validation require para indicar que ese campo es obligatorio. Si quieres conocer otras validaciones aqu\u00ed tienes m\u00e1s info . Aparte de definir nuestro schema tambi\u00e9n lo estamos transformado en un modelo para poder trabajar con \u00e9l. En el constructor de model le pasamos el nombre del modelo y el schema que vamos a utilizar.","title":"Capa de Modelo"},{"location":"develop/basic/nodejs/#capa-de-servicio","text":"Como hemos visto en nuestra estructura la capa controller no puede comunicarse con la capa modelo, debe de haber una capa intermedia, para ello vamos a crear una carpeta services en la carpeta src de nuestro proyecto y dentro un archivo category.service.js : category.service.js import CategoryModel from '../schemas/category.schema.js' ; export const createCategory = async function ( name ) { try { const category = new CategoryModel ({ name }); return await category . save (); } catch ( e ) { throw Error ( 'Error creating category' ); } } Hemos importado el modelo de categor\u00eda para poder realizar acciones sobre la BBDD y hemos creado una funci\u00f3n que recoger\u00e1 el nombre de la categor\u00eda y crear\u00e1 una nueva categor\u00eda con \u00e9l. Llamamos al m\u00e9todo save para guardar nuestra categor\u00eda y devolvemos el resultado. Ahora en nuestro m\u00e9todo del controller solo tenemos que llamar al servicio pas\u00e1ndole los par\u00e1metros que nos llegan en la petici\u00f3n: category.controller.js import * as CategoryService from '../services/category.service.js' ; export const createCategory = async ( req , res ) => { const { name } = req . body ; try { const category = await CategoryService . createCategory ( name ); res . status ( 200 ). json ({ category }); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } Si todo ha ido correctamente llamaremos al m\u00e9todo de respuesta con el c\u00f3digo 200 y la categor\u00eda creada. En caso contrario mandaremos un c\u00f3digo de error. Si ahora de nuevo vamos a postman y volvemos a lanzar nuestra petici\u00f3n podemos ver como nos devuelve una nueva categor\u00eda:","title":"Capa de Servicio"},{"location":"develop/basic/nodejs/#resto-de-operaciones","text":"","title":"Resto de Operaciones"},{"location":"develop/basic/nodejs/#recuperacion-categorias","text":"Ahora que ya podemos crear categor\u00edas lo siguiente ser\u00e1 crear un endpoint para recuperar las categor\u00edas creadas en nuestra base de datos. Podemos empezar a\u00f1adiendo un nuevo m\u00e9todo en nuestro servicio: category.service.js export const getCategories = async function () { try { return await CategoryModel . find (). sort ( 'name' ); } catch ( e ) { throw Error ( 'Error fetching categories' ); } } Al igual que en el anterior m\u00e9todo haremos uso del modelo, pero esta vez para hacer un find y ordenando los resultados por el campo name . Al m\u00e9todo find se le pueden pasar queries , projections y options . Te dejo por aqu\u00ed m\u00e1s info. En nuestro caso simplemente queremos que nos devuelva todas las categor\u00edas por lo que no le pasaremos nada. Creamos tambi\u00e9n un m\u00e9todo en el controlador para recuperar las categor\u00edas y que har\u00e1 uso del servicio: category.controller.js export const getCategories = async ( req , res ) => { try { const categories = await CategoryService . getCategories (); res . status ( 200 ). json ( categories ); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } Y ahora que ya tenemos el m\u00e9todo creado en el controlador lo siguiente ser\u00e1 relacionar este m\u00e9todo con una ruta. Para ello en nuestro archivo category.routes.js tendremos que a\u00f1adir una nueva l\u00ednea: category.routes.js import { Router } from 'express' ; import { createCategory , getCategories } from '../controllers/category.controller.js' ; const categoryRouter = Router (); categoryRouter . put ( '/' , createCategory ); categoryRouter . get ( '/' , getCategories ); export default categoryRouter ; De este modo cuando hagamos una petici\u00f3n GET a http://localhost:8080/category nos devolver\u00e1 el listado de categor\u00edas existentes:","title":"Recuperaci\u00f3n categor\u00edas"},{"location":"develop/basic/nodejs/#actualizar-categoria","text":"Ahora vamos a por el m\u00e9todo para actualizar nuestras categor\u00edas. En el servicio creamos el siguiente m\u00e9todo: category.service.js export const updateCategory = async ( id , name ) => { try { const category = await CategoryModel . findById ( id ); if ( ! category ) { throw Error ( 'There is no category with that Id' ); } return await CategoryModel . findByIdAndUpdate ( id , { name }); } catch ( e ) { throw Error ( e ); } } A este m\u00e9todo le pasaremos de entrada el id y el nombre . Con ese id realizaremos una b\u00fasqueda para asegurarnos que esa categor\u00eda existe en nuestra base de datos. Si existe la categor\u00eda haremos una petici\u00f3n con findByIdAndUpdate donde el primer par\u00e1metro es el id y el segundo es el resto de los campos de nuestra entidad. En el controlador creamos el m\u00e9todo correspondiente: category.controller.js export const updateCategory = async ( req , res ) => { const categoryId = req . params . id ; const { name } = req . body ; try { await CategoryService . updateCategory ( categoryId , name ); res . status ( 200 ). json ( 1 ); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } Aqu\u00ed recogeremos el par\u00e1metro id que nos vendr\u00e1 en la url, por ejemplo: http://localhost:8080/category/1 . Esto lo hacemos con req.params.id . El id es el nombre de la variable que le daremos en el router como veremos m\u00e1s adelante. Y una vez creado el m\u00e9todo en el controlador tendremos que a\u00f1adir la ruta en nuestro fichero de rutas correspondiente, pero como ya hemos dicho tendremos que indicar que nuestra ruta espera un par\u00e1metro id, lo haremos de la siguiente forma: category.routes.js import { Router } from 'express' ; import { createCategory , getCategories , updateCategory } from '../controllers/category.controller.js' ; const categoryRouter = Router (); categoryRouter . put ( '/' , createCategory ); categoryRouter . get ( '/' , getCategories ); categoryRouter . put ( '/:id' , updateCategory ); export default categoryRouter ; Y volvemos a probar en Postman: Y si hacemos de nuevo un GET vemos como la categor\u00eda se ha modificado correctamente:","title":"Actualizar categor\u00eda"},{"location":"develop/basic/nodejs/#borrado-categoria","text":"Ya solo nos faltar\u00eda la operaci\u00f3n de delete para completar nuestro CRUD, en el servicio a\u00f1adimos un nuevo m\u00e9todo: category.service.js export const deleteCategory = async ( id ) => { try { const category = await CategoryModel . findById ( id ); if ( ! category ) { throw Error ( 'There is no category with that Id' ); } return await CategoryModel . findByIdAndDelete ( id ); } catch ( e ) { throw Error ( 'Error deleting category' ); } } Como vemos es muy parecido al update, recuperamos el id de los par\u00e1metros de la ruta y en este caso llamaremos al m\u00e9todo findByIdAndDelete . En nuestro controlador creamos el m\u00e9todo correspondiente: category.controller.js export const deleteCategory = async ( req , res ) => { const categoryId = req . params . id ; try { const deletedCategory = await CategoryService . deleteCategory ( categoryId ); res . status ( 200 ). json ({ category : deletedCategory }); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } Y de nuevo a\u00f1adimos la ruta correspondiente al archivo de rutas: category.routes.js import { Router } from 'express' ; import { createCategory , getCategories , updateCategory , deleteCategory } from '../controllers/category.controller.js' ; const categoryRouter = Router (); categoryRouter . put ( '/' , createCategory ); categoryRouter . get ( '/' , getCategories ); categoryRouter . put ( '/:id' , updateCategory ); categoryRouter . delete ( '/:id' , deleteCategory ); export default categoryRouter ; Y de nuevo, probamos en postman: Hacemos un get para comprobar que se ha borrado de nuestra base de datos:","title":"Borrado categor\u00eda"},{"location":"develop/basic/nodejs/#capa-de-middleware-validaciones","text":"Antes de pasar a nuestro siguiente CRUD vamos a ver en que consiste la Capa de Middleware . Un middleware es un c\u00f3digo que se ejecuta antes de que una petici\u00f3n http llegue a nuestro manejador de rutas o antes de que el cliente reciba una respuesta. En nuestro caso vamos a crear un middleware para asegurarnos que todos los campos que necesitamos en nuestras entidades vienen en el body de la petici\u00f3n. Vamos a crear una carpeta middlewares en la carpeta src de nuestro proyecto y dentro crearemos el fichero validateFields.js : validateFields.js import { response } from 'express' ; import { validationResult } from 'express-validator' ; const validateFields = ( req , res = response , next ) => { const errors = validationResult ( req ); if ( ! errors . isEmpty ()) { return res . status ( 400 ). json ({ errors : errors . mapped () }); } next (); } export default validateFields ; En este m\u00e9todo nos ayudaremos de la librer\u00eda express-validator para ver los errores que tenemos en nuestras rutas. Para ello llamaremos a la funci\u00f3n validationResult que nos devolver\u00e1 un array de errores que m\u00e1s tarde definiremos. Si el array no va vac\u00edo es porque se ha producido alg\u00fan error en las validaciones y ejecutara la response con un c\u00f3digo de error. Ahora definiremos las validaciones en nuestro archivo de rutas, deber\u00eda quedar de la siguiente manera: category.routes.js import { Router } from 'express' ; import { check } from 'express-validator' ; import validateFields from '../middlewares/validateFields.js' ; import { getCategories , createCategory , deleteCategory , updateCategory } from '../controllers/category.controller.js' ; const categoryRouter = Router (); categoryRouter . put ( '/:id' , [ check ( 'name' ). not (). isEmpty (), validateFields ], updateCategory ); categoryRouter . put ( '/' , [ check ( 'name' ). not (). isEmpty (), validateFields ], createCategory ); categoryRouter . get ( '/' , getCategories ); categoryRouter . delete ( '/:id' , deleteCategory ); export default categoryRouter ; Aqu\u00ed nos ayudamos de nuevo de express-validator y de su m\u00e9todo check . Para las rutas en las que necesitemos validaciones, a\u00f1adimos un array como segundo par\u00e1metro. En este array vamos a\u00f1adiendo todas las validaciones que necesitemos. En nuestro caso solo queremos que el campo name no sea vac\u00edo, pero existen muchas m\u00e1s validaciones que puedes encontrar en la documentaci\u00f3n de express-validator . Importamos nuestro middleware y lo a\u00f1adimos en la \u00faltima posici\u00f3n de este array. De este modo no se realizar\u00e1n las peticiones que no pasen las validaciones: Y con esto habremos terminado nuestro primer CRUD.","title":"Capa de Middleware (Validaciones)"},{"location":"develop/basic/nodejs/#depuracion","text":"Una parte muy importante del desarrollo es tener la capacidad de depurar nuestro c\u00f3digo, en este apartado vamos a explicar como se realiza debug en Backend. Esta parte se realiza con las herramientas incluidas dentro de nuestro IDE favorito, en este caso vamos a utilizar el Visual Estudio. Lo primero que debemos hacer es configurar el modo Debug de nuestro proyecto. Para ello nos dirigimos a la opci\u00f3n Run and Debug y creamos el fichero de launch necesario: Esto nos crear\u00e1 el fichero necesario y ya podremos arrancar la aplicaci\u00f3n mediante esta herramienta presionando el bot\u00f3n Launch Program (seleccionamos tipo de aplicaci\u00f3n Node y el script de arranque que ser\u00e1 el que hemos utilizado en el desarrollo): Arrancada la aplicaci\u00f3n de este modo, vamos a depurar la operaci\u00f3n de crear categor\u00eda. Para ello vamos a abrir nuestro fichero donde tenemos la implementaci\u00f3n del servicio de creaci\u00f3n de la capa de la l\u00f3gica de negocio category.service.js . Dentro del fichero ya podemos a\u00f1adir puntos de ruptura (breakpoint), en nuestro caso queremos comprobar que el nombre introducido se recibe correctamente. Colocamos el breakpoint en la primera l\u00ednea del m\u00e9todo (click sobre el n\u00famero de la l\u00ednea) y desde la interfaz/postman creamos una nueva categor\u00eda. Hecho esto, podemos observar que a nivel de interfaz/postman, la petici\u00f3n se queda esperando y el IDE mostrar\u00e1 un panel de manejo de los puntos de interrupci\u00f3n: El IDE nos lleva al punto exacto donde hemos a\u00f1adido el breakpoint y se para en este punto ofreci\u00e9ndonos la posibilidad de explorar el contenido de las variables del c\u00f3digo: Aqu\u00ed podemos comprobar que efectivamente la variable name tiene el valor que hemos introducido por pantalla/postman. Para continuar con la ejecuci\u00f3n basta con darle al bot\u00f3n de play del panel de manejo de los puntos de interrupci\u00f3n.","title":"Depuraci\u00f3n"},{"location":"develop/basic/springboot/","text":"Listado simple - Spring Boot Ahora que ya tenemos listo el proyecto backend de Spring Boot (en el puerto 8080) ya podemos empezar a codificar la soluci\u00f3n. Primeros pasos Antes de empezar Quiero hacer hincapi\u00e9 en Spring Boot tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. Tanto la propia web de Spring como en el portal de tutoriales de Baeldung puedes buscar casi cualquier ejemplo que necesites. Estructurar el c\u00f3digo Vamos a hacer un breve refresco de la estructura del c\u00f3digo que ya se ha visto en puntos anteriores. Las clases deben estar agrupadas por \u00e1mbito funcional, en nuestro caso como vamos a hacer la funcionalidad de Categor\u00edas pues deber\u00eda estar todo dentro de un package del tipo com.ccsw.tutorial.category . Adem\u00e1s, deber\u00edamos aplicar la separaci\u00f3n por capas como ya se vi\u00f3 en el esquema: La primera capa, la de Controlador , se encargar\u00e1 de procesar las peticiones y transformar datos. Esta capa llamar\u00e1 a la capa de L\u00f3gica de negocio que ejecutar\u00e1 las operaciones, ayud\u00e1ndose de otros objetos de esa misma capa de L\u00f3gica o bien de llamadas a datos a trav\u00e9s de la capa de Acceso a Datos Ahora s\u00ed, vamos a programar!. Capa de operaciones: Controller En esta capa es donde se definen las operaciones que pueden ser consumidas por los clientes. Se caracterizan por estar anotadas con las anotaciones @Controller o @RestController y por las anotaciones @RequestMapping que nos permiten definir las rutas de acceso. Recomendaci\u00f3n: Breve detalle REST Antes de continuar te recomiendo encarecidamente que leas el Anexo: Detalle REST donde se explica brevemente como estructurar los servicios REST que veremos a continuaci\u00f3n. Controller de ejemplo Vamos a crear una clase CategoryController.java dentro del package com.ccsw.tutorial.category para definir las rutas de las operaciones. CategoryController.java package com.ccsw.tutorial.category ; import java.util.List ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import io.swagger.v3.oas.annotations.tags.Tag ; /** * @author ccsw * */ @Tag ( name = \"Category\" , description = \"API of Category\" ) @RequestMapping ( value = \"/category\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class CategoryController { /** * M\u00e9todo para probar el servicio * */ @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public String prueba () { return \"Probando el Controller\" ; } } Ahora si arrancamos la aplicaci\u00f3n server, abrimos el Postman y creamos una petici\u00f3n GET a la url http://localhost:8080/category nos responder\u00e1 con el mensaje que hemos programado. Implementar operaciones Ahora que ya tenemos un controlador y una operaci\u00f3n de negocio ficticia, vamos a borrarla y a\u00f1adir las operaciones reales que consumir\u00e1 nuestra pantalla. Deberemos a\u00f1adir una operaci\u00f3n para listar, una para actualizar, una para guardar y una para borrar. Aunque para hacerlo m\u00e1s c\u00f3modo, utilizaremos la misma operaci\u00f3n para guardar y para actualizar. Adem\u00e1s, no vamos a trabajar directamente con datos simples, sino que usaremos objetos para recibir informaci\u00f3n y para enviar informaci\u00f3n. Estos objetos t\u00edpicamente se denominan DTO (Data Transfer Object) y nos sirven justamente para encapsular informaci\u00f3n que queremos transportar. En realidad no son m\u00e1s que clases pojo sencillas con propiedades, getters y setters. Para nuestro ejemplo crearemos una clase CategoryDto dentro del package com.ccsw.tutorial.category.model con el siguiente contenido: CategoryDto.java package com.ccsw.tutorial.category.model ; /** * @author ccsw * */ public class CategoryDto { private Long id ; private String name ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } } A continuaci\u00f3n utilizaremos esta clase en nuestro Controller para implementar las tres operaciones de negocio. CategoryController.java package com.ccsw.tutorial.category ; import java.util.ArrayList ; import java.util.HashMap ; import java.util.List ; import java.util.Map ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.ccsw.tutorial.category.model.CategoryDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; /** * @author ccsw * */ @Tag ( name = \"Category\" , description = \"API of Category\" ) @RequestMapping ( value = \"/category\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class CategoryController { private long SEQUENCE = 1 ; private Map < Long , CategoryDto > categories = new HashMap < Long , CategoryDto > (); /** * M\u00e9todo para recuperar todas las categorias * * @return {@link List} de {@link CategoryDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a list of Categories\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { return new ArrayList < CategoryDto > ( this . categories . values ()); } /** * M\u00e9todo para crear o actualizar una categoria * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Category\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody CategoryDto dto ) { CategoryDto category ; if ( id == null ) { category = new CategoryDto (); category . setId ( this . SEQUENCE ++ ); this . categories . put ( category . getId (), category ); } else { category = this . categories . get ( id ); } category . setName ( dto . getName ()); } /** * M\u00e9todo para borrar una categoria * * @param id PK de la entidad */ @Operation ( summary = \"Delete\" , description = \"Method that deletes a Category\" ) @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . categories . remove ( id ); } } Como todav\u00eda no tenemos acceso a BD, hemos creado una variable tipo HashMap y una variable Long, que simular\u00e1n una BD y una secuencia. Tambi\u00e9n hemos implementado tres operaciones GET, PUT y DELETE que realizan las acciones necesarias por nuestra pantalla. Ahora podr\u00edamos probarlo desde el Postman con cuatro ejemplo sencillos. F\u00edjate que el m\u00e9todo save tiene dos rutas. La ruta normal category/ y la ruta informada category/3 . Esto es porque hemos juntado la acci\u00f3n create y update en un mismo m\u00e9todo para facilitar el desarrollo. Es totalmente v\u00e1lido y funcional. Atenci\u00f3n Los datos que se reciben pueden venir informados como un par\u00e1metro en la URL Get, como una variable en el propio path o dentro del body de la petici\u00f3n. Cada uno de ellos se recupera con una anotaci\u00f3n especial: @RequestParam , @PathVariable y @RequestBody respectivamente. Como no tenemos ning\u00fan dato dado de alta, podemos probar en primer lugar a realizar una inserci\u00f3n de datos con el m\u00e9todo PUT. PUT /category nos sirve para insertar Categor\u00edas nuevas (si no tienen el id informado) o para actualizar Categor\u00edas (si tienen el id informado). F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no env\u00edas datos, te dar\u00e1 un error. GET /category nos devuelve un listado de Categor\u00edas , siempre que hayamos insertado algo antes. DELETE /category nos sirve eliminar Categor\u00edas . F\u00edjate que el dato del ID que se env\u00eda est\u00e1 en el path. Prueba a jugar borrando categor\u00edas que no existen o modificando categor\u00edas que no existen. Tal y como est\u00e1 programado, el borrado no dar\u00e1 error, pero la modificaci\u00f3n deber\u00eda dar un NullPointerException al no existir el dato a modificar. Documentaci\u00f3n (OpenAPI) Si te acuerdas, en el punto de Entorno de desarrollo , a\u00f1adimos el m\u00f3dulo de OpenAPI a nuestro proyecto, y en el desarrollo de nuestro Controller hemos anotado tanto la clase como los m\u00e9todos con sus correspondientes etiquetas @Tag y @Operation . Esto nos va a ayudar a generar documentaci\u00f3n autom\u00e1tica de nuestras APIs haciendo que nuestro c\u00f3digo sea m\u00e1s mantenible y nuestra documentaci\u00f3n mucho m\u00e1s fiable. Para ver el resultado, con el proyecto arrancado nos dirigimos a la ruta por defecto de OpenAPI: http://localhost:8080/swagger-ui/index.html Aqu\u00ed podemos observar el cat\u00e1logo de endpoints generados, ver los tipos de entrada y salida e incluso realizar peticiones a los mismos. Este ser\u00e1 el contrato de nuestros endpoints, que nos ayudar\u00e1 a integrarnos con el equipo frontend (en el caso del tutorial seguramente seremos nosotros mismos). Aspectos importantes Los aspectos importantes de la capa Controller son: La clase debe estar anotada con @Controller o @RestController . Mejor usar la \u00faltima anotaci\u00f3n, ya que est\u00e1s diciendo que las operaciones son de tipo Rest y no har\u00e1 falta configurar nada La ruta general al controlador se define con el @RequestMapping global de la clase, aunque tambi\u00e9n se puede obviar esta anotaci\u00f3n y a\u00f1adir a cada una de las operaciones la ruta ra\u00edz. Los m\u00e9todos que queramos exponer como operaciones deben ir anotados tambi\u00e9n con @RequestMapping con la info: path \u2192 Que nos permite definir un path para la operaci\u00f3n, siempre sum\u00e1ndole el path de la clase (si es que tuviera) method \u2192 Que nos permite definir el verbo de http que vamos a atender. Podemos tener el mismo path con diferente method, sin problema. Por lo general utilizaremos: GET \u2192 Generalmente se usa para recuperar informaci\u00f3n POST \u2192 Se utiliza para hacer update y filtrados complejos de informaci\u00f3n PUT \u2192 Se utiliza para hacer save de informaci\u00f3n DELETE \u2192 Se utiliza para hacer borrados de informaci\u00f3n Capa de Servicio: Service Pero en realidad la cosa no funciona as\u00ed. Hemos implementado parte de la l\u00f3gica de negocio (las operaciones/acciones de guardado, borrado y listado) dentro de lo que ser\u00eda la capa de operaciones o servicios al cliente. Esta capa no debe ejecutar l\u00f3gica de negocio, tan solo debe hacer transformaciones de datos y enrutar peticiones, toda la l\u00f3gica deber\u00eda ir en la capa de servicio. Implementar servicios Pues vamos a arreglarlo. Vamos a crear un servicio y vamos a mover la l\u00f3gica de negocio al servicio. CategoryService.java CategoryServiceImpl.java CategoryController.java package com.ccsw.tutorial.category ; import com.ccsw.tutorial.category.model.CategoryDto ; import java.util.List ; /** * @author ccsw * */ public interface CategoryService { /** * M\u00e9todo para recuperar todas las categor\u00edas * * @return {@link List} de {@link Category} */ List < CategoryDto > findAll (); /** * M\u00e9todo para crear o actualizar una categor\u00eda * * @param id PK de la entidad * @param dto datos de la entidad */ void save ( Long id , CategoryDto dto ); /** * M\u00e9todo para borrar una categor\u00eda * * @param id PK de la entidad */ void delete ( Long id ); } package com.ccsw.tutorial.category ; import java.util.ArrayList ; import java.util.HashMap ; import java.util.List ; import java.util.Map ; import org.springframework.stereotype.Service ; import com.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw * */ @Service public class CategoryServiceImpl implements CategoryService { private long SEQUENCE = 1 ; private Map < Long , CategoryDto > categories = new HashMap < Long , CategoryDto > (); /** * {@inheritDoc} */ public List < CategoryDto > findAll () { return new ArrayList < CategoryDto > ( this . categories . values ()); } /** * {@inheritDoc} */ public void save ( Long id , CategoryDto dto ) { CategoryDto category ; if ( id == null ) { category = new CategoryDto (); category . setId ( this . SEQUENCE ++ ); this . categories . put ( category . getId (), category ); } else { category = this . categories . get ( id ); } category . setName ( dto . getName ()); } /** * {@inheritDoc} */ public void delete ( Long id ) { this . categories . remove ( id ); } } package com.ccsw.tutorial.category ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.ccsw.tutorial.category.model.CategoryDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; /** * @author ccsw * */ @Tag ( name = \"Category\" , description = \"API of Category\" ) @RequestMapping ( value = \"/category\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class CategoryController { @Autowired private CategoryService categoryService ; /** * M\u00e9todo para recuperar todas las categorias * * @return {@link List} de {@link CategoryDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a list of Categories\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { return this . categoryService . findAll (); } /** * M\u00e9todo para crear o actualizar una categoria * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Category\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody CategoryDto dto ) { this . categoryService . save ( id , dto ); } /** * M\u00e9todo para borrar una categoria * * @param id PK de la entidad */ @Operation ( summary = \"Delete\" , description = \"Method that deletes a Category\" ) @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . categoryService . delete ( id ); } } Ahora ya tenemos bien estructurado nuestro proyecto. Ya tenemos las dos capas necesarias Controladores y Servicios y cada uno se encarga de llevar a cabo su cometido de forma correcta. Aspectos importantes Los aspectos importantes de la capa Service son: Toda la l\u00f3gica de negocio, operaciones y dem\u00e1s debe estar implementada en los servicios. Los controladores simplemente invocan servicios y transforman ciertos datos. Es buena pr\u00e1ctica que la capa de servicios se implemente usando el patr\u00f3n fachada, esto quiere decir que necesitamos tener una Interface y al menos una implementaci\u00f3n de esa Interface. Y siempre debemos interactuar con la Interface. Esto nos permitir\u00e1 a futuro poder sustituir la implementaci\u00f3n por otra diferente sin que el resto del c\u00f3digo se vea afectado. Especialmente \u00fatil cuando queremos mockear comportamientos en tests. La capa de servicio puede invocar a otros servicios en sus operaciones, pero nunca debe invocar a un controlador. Para crear un servicio se debe anotar mediante @Service y adem\u00e1s debe implementar la Interface del servicio. Un error muy com\u00fan al arrancar un proyecto y ver que no funcionan las llamadas, es porqu\u00e9 no existe la anotaci\u00f3n @Service o porqu\u00e9 no se ha implementado la Interface. La forma de inyectar y utilizar componentes manejados por Spring Boot es mediante la anotaci\u00f3n @Autowired . NO intentes crear un objeto de CategoryServiceImpl, ni hacer un new , ya que no estar\u00e1 manejado por Springboot y dar\u00e1 fallos de NullPointer. Lo mejor es dejar que Spring Boot lo gestione y utilizar las inyecciones de dependencias. Capa de Datos: Repository Pero no siempre vamos a acceder a los datos mediante un HasMap en memoria. En algunas ocasiones queremos que nuestro proyecto acceda a un servicio de datos como puede ser una BBDD, un servicio externo, un acceso a disco, etc. Estos accesos se deben hacer desde la capa de acceso a datos, y en concreto para nuestro ejemplo, lo haremos a trav\u00e9s de un Repository para que acceda a una BBDD. Para el tutorial no necesitamos configurar una BBDD externa ni complicarnos demasiado. Vamos a utilizar una librer\u00eda muy \u00fatil llamada H2 que nos permite levantar una BBDD en memoria persistiendo los datos en memoria o en disco, de hecho ya la configuramos en el apartado de Entorno de desarrollo . Implementar Entity Lo primero que haremos ser\u00e1 crear nuestra entity con la que vamos a persistir y recuperar informaci\u00f3n. Las entidades igual que los DTOs deber\u00edan estar agrupados dentro del package model de cada funcionalidad, as\u00ed que vamos a crear una nueva clase java. Category.java package com.ccsw.tutorial.category.model ; import jakarta.persistence.* ; /** * @author ccsw * */ @Entity @Table ( name = \"category\" ) public class Category { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"name\" , nullable = false ) private String name ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } } Si te fijas, la Entity suele ser muy similar a un DTO, tiene unas propiedades y sus getters y setters. Pero a diferencia de los DTOs, esta clase tiene una serie de anotaciones que permiten a JPA hacer su magia y generar consultas SQL a la BBDD. En este ejemplo vemos 4 anotaciones importantes: @Entity \u2192 Le indica a Springboot que se trata de una clase que implementa una Entidad de BBDD. Sin esta anotaci\u00f3n no es posible hacer queries. @Table \u2192 Le indica a JPA el nombre y el schema de la tabla que representa esta clase. Por claridad se deber\u00eda poner siempre, aunque si el nombre de la tabla es igual al nombre de la clase no es necesaria la anotaci\u00f3n. @Id y @GeneratedValue \u2192 Le indica a JPA que esta propiedad es la que mapea una Primary Key y adem\u00e1s que esta PK se genera con la estrategia que se le indique en la anotaci\u00f3n @GeneratedValue , que puede ser: Generaci\u00f3n de PK por Secuence , la que utiliza Oracle, en este caso habr\u00e1 que indicarle un nombre de secuencia. Generaci\u00f3n de PK por Indentity , la que utiliza MySql o SQLServer, el auto-incremental. Generaci\u00f3n de PK por Table , en algunas BBDD se permite tener una tabla donde se almacenan como registros todas las secuencias. Generaci\u00f3n de PK Auto , elige la mejor estrategia en funci\u00f3n de la BBDD que hemos seleccionado. @Column \u2192 Le indica a JPA que esta propiedad mapea una columna de la tabla y le especifica el nombre de la columna. Al igual que la anotaci\u00f3nd de Table , esta anotaci\u00f3n no es necesaria aunque si es muy recomendable. Por claridad se deber\u00eda poner siempre, aunque si el nombre de la columna es igual al nombre de la propiedad no es necesaria la anotaci\u00f3n. Hay muchas otras anotaciones, pero estas son las b\u00e1sicas, ya ir\u00e1s aprendiendo otras. Consejo Para definir las PK de las tablas, intenta evitar una PK compuesta de m\u00e1s de una columna. La programaci\u00f3n se hace muy compleja y las magias que hace JPA en la oscuridad se complican mucho. Mi recomendaci\u00f3n es que siempre utilices una PK n\u00famerica, en la medida de lo posible, y si es necesario, crees \u00edndices compuestos de b\u00fasqueda o checks compuestos para evitar duplicidades. Juego de datos de BBDD Spring Boot autom\u00e1ticamente cuando arranque el proyecto escaner\u00e1 todas las @Entity y crear\u00e1 las estructuras de las tablas en la BBDD en memoria, gracias a las anotaciones que hemos puesto. Adem\u00e1s de esto, lanzar\u00e1 los scripts de construcci\u00f3n de BBDD que tenemos en la carpeta src/main/resources/ . As\u00ed que, teniendo clara la estructura de la Entity podemos configurar los ficheros con los juegos de datos que queramos, y para ello vamos a utilizar el fichero data.sql que creamos en su momento. Sabemos que la tabla se llamar\u00e1 category y que tendr\u00e1 dos columnas, una columna id , que ser\u00e1 la PK autom\u00e1tica, y una columna name . Podemos escribir el siguiente script para rellenar datos: data.sql INSERT INTO category ( name ) VALUES ( 'Eurogames' ); INSERT INTO category ( name ) VALUES ( 'Ameritrash' ); INSERT INTO category ( name ) VALUES ( 'Familiar' ); Implementar Repository Ahora que ya tenemos el juego de datos y la entidad implementada, vamos a ver como acceder a BBDD desde Java. Esto lo haremos con un Repository . Existen varias formas de utilizar los repositories, desde el todo autom\u00e1tico y magia de JPA hasta el repositorio manual en el que hay que codificar todo. En el tutorial voy a explicar varias formas de implementarlo para este CRUD y los siguientes CRUDs. Como ya se dijo en puntos anteriores, el acceso a datos se debe hacer siempre a trav\u00e9s de un Repository , as\u00ed que vamos a implementar uno. En esta capa, al igual que pasaba con los services, es recomendable utilizar el patr\u00f3n fachada, para poder sustituir implementaciones sin afectar al c\u00f3digo. CategoryRepository.java package com.ccsw.tutorial.category ; import com.ccsw.tutorial.category.model.Category ; import org.springframework.data.repository.CrudRepository ; /** * @author ccsw * */ public interface CategoryRepository extends CrudRepository < Category , Long > { } \u00bfQu\u00e9 te parece?, sencillo, \u00bfno?. Spring ya tiene una implementaci\u00f3n por defecto de un CrudRepository, tan solo tenemos que crear una interface que extienda de la interface CrudRepository pas\u00e1ndole como tipos la Entity y el tipo de la Primary Key. Con eso Spring construye el resto y nos provee de los m\u00e9todos t\u00edpicos y necesarios para un CRUD. Ahora vamos a utilizarla en \u00e9l Service , pero hay un problema. \u00c9l Repository devuelve un objeto tipo Category y \u00e9l Service y Controller devuelven un objeto tipo CategoryDto . Esto es porque en cada capa se debe con un \u00e1mbito de modelos diferente. Podr\u00edamos hacer que todo el back trabajara con Category que son entidades de persistencia, pero no es lo correcto y nos podr\u00eda llevar a cometer errores, o modificar el objeto y que sin que nosotros lo orden\u00e1semos se persistiera ese cambio en BBDD. El \u00e1mbito de trabajo de las capas con el que solemos trabajar y est\u00e1 m\u00e1s extendido es el siguiente: Los datos que vienen y van al cliente, deber\u00edan ser en la mayor\u00eda de los casos datos en formato json Al entrar en un Controller esos datos json se transforman en un DTO. Al salir del Controller hacia el cliente, esos DTOs se transforman en formato json. Estas conversiones son autom\u00e1ticas, las hace Springboot (en realidad las hace la librer\u00eda de jackson codehaus). Cuando un Controller ejecuta una llamada a un Service , generalmente le pasa sus datos en DTO, y el Service se encarga de transformar esto a una Entity . A la inversa, cuando un Service responde a un Controller , \u00e9l responde con una Entity y el Controller ya se encargar\u00e1 de transformarlo a DTO. Por \u00faltimo, para los Repository , siempre se trabaja de entrada y salida con objetos tipo Entity Parece un l\u00edo, pero ya ver\u00e1s como es muy sencillo ahora que veremos el ejemplo. Una \u00faltima cosa, para hacer esas transformaciones, las podemos hacer a mano usando getters y setters o bien utilizar el objeto DozerBeanMapper que hemos configurado al principio. El c\u00f3digo deber\u00eda quedar as\u00ed: CategoryServiceImpl.java CategoryService.java CategoryController.java package com.ccsw.tutorial.category ; import com.ccsw.tutorial.category.model.Category ; import com.ccsw.tutorial.category.model.CategoryDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class CategoryServiceImpl implements CategoryService { @Autowired CategoryRepository categoryRepository ; /** * {@inheritDoc} */ @Override public List < Category > findAll () { return ( List < Category > ) this . categoryRepository . findAll (); } /** * {@inheritDoc} */ @Override public void save ( Long id , CategoryDto dto ) { Category category ; if ( id == null ) { category = new Category (); } else { category = this . categoryRepository . findById ( id ). orElse ( null ); } category . setName ( dto . getName ()); this . categoryRepository . save ( category ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) throws Exception { if ( this . categoryRepository . findById ( id ). orElse ( null ) == null ){ throw new Exception ( \"Not exists\" ); } this . categoryRepository . deleteById ( id ); } } package com.ccsw.tutorial.category ; import com.ccsw.tutorial.category.model.Category ; import com.ccsw.tutorial.category.model.CategoryDto ; import java.util.List ; /** * @author ccsw * */ public interface CategoryService { /** * M\u00e9todo para recuperar todas las {@link Category} * * @return {@link List} de {@link Category} */ List < Category > findAll (); /** * M\u00e9todo para crear o actualizar una {@link Category} * * @param id PK de la entidad * @param dto datos de la entidad */ void save ( Long id , CategoryDto dto ); /** * M\u00e9todo para borrar una {@link Category} * * @param id PK de la entidad */ void delete ( Long id ) throws Exception ; } package com.ccsw.tutorial.category ; import com.ccsw.tutorial.category.model.Category ; import com.ccsw.tutorial.category.model.CategoryDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; import org.modelmapper.ModelMapper ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.* ; import java.util.List ; import java.util.stream.Collectors ; /** * @author ccsw * */ @Tag ( name = \"Category\" , description = \"API of Category\" ) @RequestMapping ( value = \"/category\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class CategoryController { @Autowired CategoryService categoryService ; @Autowired ModelMapper mapper ; /** * M\u00e9todo para recuperar todas las {@link Category} * * @return {@link List} de {@link CategoryDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a list of Categories\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { List < Category > categories = this . categoryService . findAll (); return categories . stream (). map ( e -> mapper . map ( e , CategoryDto . class )). collect ( Collectors . toList ()); } /** * M\u00e9todo para crear o actualizar una {@link Category} * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Category\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody CategoryDto dto ) { this . categoryService . save ( id , dto ); } /** * M\u00e9todo para borrar una {@link Category} * * @param id PK de la entidad */ @Operation ( summary = \"Delete\" , description = \"Method that deletes a Category\" ) @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) throws Exception { this . categoryService . delete ( id ); } } El Service no tiene nada raro, simplemente accede al Repository (siempre anotado como @Autowired ) y recupera datos o los guarda. F\u00edjate en el caso especial del save que la \u00fanica diferencia es que en un caso tendr\u00e1 id != null y por tanto internamente har\u00e1 un update, y en otro caso tendr\u00e1 id == null y por tanto internamente har\u00e1 un save. En cuanto a la interface, lo \u00fanico que cambiamos fue los objetos de respuesta, que ahora pasan a ser de tipo Category . Los de entrada se mantienen como CategoryDto . Por \u00faltimo, en \u00e9l Controller se puede ver como se utiliza el conversor de DozerBeanMapper (siempre anotado como @Autowired ), que permite traducir una lista a un tipo concreto, o un objeto \u00fanico a un tipo concreto. La forma de hacer estas conversiones siempre es por nombre de propiedad. Las propiedades del objeto destino se deben llamar igual que las propiedades del objeto origen. En caso contrario se quedar\u00e1n a null. Ojo con el mapeo Ojo a esta \u00faltima frase, debe quedar meridianamente claro. La forma de mapear de un objeto origen a un objeto destino siempre es a trav\u00e9s del nombre. Los getters del origen deben ser iguales a los getters del destino. Si hay una letra diferente o unas may\u00fasculas o min\u00fasculas diferentes NO realizar\u00e1 el mapeo y se quedar\u00e1 la propiedad a null. Para terminar, cuando queramos realizar un mapeo masivo de los diferentes registros, tenemos que itulizar la API Stream de Java, que nos proporciona una forma sencilla de realizar estas operativas, sobre colecciones de elementos, mediante el uso del m\u00e9todo intermedio map y el reductor por defecto para listas. Te recomiendo echarle un ojo a la teor\u00eda de Introducci\u00f3n a API Java Streams . BBDD Si quires ver el contenido de la base de datos puedes acceder a un IDE web autopublicado por H2 en la ruta http://localhost:8080/h2-console Aspectos importantes Los aspectos importantes de la capa Repository son: Al igual que los Service , se debe utilizar el patr\u00f3n fachada, por lo que tendremos una Interface y posiblemente una implementaci\u00f3n. A menudo la implementaci\u00f3n la hace internamente Spring Boot, pero hay veces que podemos hacer una implementaci\u00f3n manual. Lo veremos en siguientes puntos. Los Repository trabajan siempre con Entity que no son m\u00e1s que mapeos de una tabla o de una vista que existe en BBDD. Los Repository no contienen l\u00f3gica de negocio, ni transformaciones, simplemente acceder a datos, persisten o devuelven informaci\u00f3n. Los Repository JAM\u00c1S deben llamar a otros Repository ni Service . Intenta que tus clases Entity sean lo m\u00e1s sencillas posible, sobre todo en cuanto a Primary Keys, se simplificar\u00e1 mucho el desarrollo. Capa de Testing: TDD Por \u00faltimo y aunque no deber\u00eda ser lo \u00faltimo que se desarrolla sino todo lo contrario, deber\u00eda ser lo primero en desarrollar, tenemos la bater\u00eda de pruebas. Con fines did\u00e1cticos, he querido ense\u00f1arte un ciclo de desarrollo para ir recorriendo las diferentes capas de una aplicaci\u00f3n, pero en realidad, para realizar el desarrollo deber\u00eda aplicar TDD (Test Driven Development) . Si quieres aprender las reglas b\u00e1sicas de como aplicar TDD al desarrollo diario, te recomiendo que leas el Anexo. TDD . En este caso, y sin que sirva de precedente, ya tenemos implementados los m\u00e9todos de la aplicaci\u00f3n, y ahora vamos a testearlos. Existen muchas formas de testing en funci\u00f3n del componente o la capa que se quiera testear. En realidad, a medida que vayas programando ir\u00e1s aprendiendo todas ellas, de momento realizaremos dos tipos de test simples que prueben las casu\u00edsticas de los m\u00e9todos. El enfoque que seguiremos en este tutorial ser\u00e1 realizar las pruebas mediante test unitarios y test de integraci\u00f3n. Test unitarios : Se trata de pruebas estrictamente relativas a la calidad est\u00e1tica del c\u00f3digo de una determinada operaci\u00f3n de la capa de la l\u00f3gica de negocio (Service). Estas pruebas no inicializan el contexto de Spring y deben simular todas las piezas ajenas a la funcionalidad testeada. Test de integraci\u00f3n : Se tratan de pruebas completas de un determinado endpoint que conlleva inicializar el contexto de Spring (base de datos incluida) y realizar una llama REST para comprobar el flujo completo de la API. Lo primero ser\u00e1 conocer que queremos probar y para ello nos vamos a hacer una lista: Test unitarios: Prueba de listado, debe probar la l\u00f3gica dentro de la operaci\u00f3n de negocio de consulta de Categor\u00eda Prueba de creaci\u00f3n, debe probar la l\u00f3gica dentro de la operaci\u00f3n de negocio de creaci\u00f3n una nueva Categor\u00eda Prueba de modificaci\u00f3n, debe probar la l\u00f3gica dentro de la operaci\u00f3n de negocio de modificaci\u00f3n una Categor\u00eda existente Prueba de borrado, debe probar la l\u00f3gica dentro de la operaci\u00f3n de negocio de borrado de una Categor\u00eda existente Test de integraci\u00f3n: Prueba de listado, debe recuperar los elementos de la tabla Categor\u00eda Prueba de creaci\u00f3n, debe crear una nueva Categor\u00eda Prueba de modificaci\u00f3n correcta, debe modificar una Categor\u00eda existente Prueba de modificaci\u00f3n incorrecta, debe dar error al modificar una Categor\u00eda que no existe Prueba de borrado correcta, debe borrar una Categor\u00eda existente Prueba de borrado incorrecta, debe dar error al borrar una Categor\u00eda que no existe Se podr\u00edan hacer muchos m\u00e1s tests, pero creo que con esos son suficientes para que entiendas como se comporta esta capa. Si te fijas, hay que probar tanto los resultados correctos como los resultados incorrectos. El usuario no siempre se va a comportar como nosotros pensamos. Pues vamos a ello. Pruebas de listado Vamos a empezar haciendo una clase de test dentro de la carpeta src/test/java . No queremos que los test formen parte del c\u00f3digo productivo de la aplicaci\u00f3n, por eso utilizamos esa ruta que queda fuera del scope general de la aplicaci\u00f3n (main). Crearemos las clases (en la package category ): Test unitarios: com.ccsw.tutorial.category.CategoryTest Test de integraci\u00f3n: com.ccsw.tutorial.category.CategoryIT CategoryTest.java CategoryIT.java package com.ccsw.tutorial.category ; import org.junit.jupiter.api.extension.ExtendWith ; import org.mockito.junit.jupiter.MockitoExtension ; @ExtendWith ( MockitoExtension . class ) public class CategoryTest { } package com.ccsw.tutorial.category ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.boot.test.web.client.TestRestTemplate ; import org.springframework.boot.test.web.server.LocalServerPort ; import org.springframework.test.annotation.DirtiesContext ; @SpringBootTest ( webEnvironment = SpringBootTest . WebEnvironment . RANDOM_PORT ) @DirtiesContext ( classMode = DirtiesContext . ClassMode . BEFORE_EACH_TEST_METHOD ) public class CategoryIT { @LocalServerPort private int port ; @Autowired private TestRestTemplate restTemplate ; } Estas clases son sencillas y tan solo tienen anotaciones espec\u00edficas de Spring Boot para cada tipo de test: @SpringBootTest . Esta anotaci\u00f3n lo que hace es inicializar el contexto de Spring cada vez que se inician los test de jUnit. Aunque el contexto tarda unos segundos en arrancar, lo bueno que tiene es que solo se inicializa una vez y se lanzan todos los jUnits en bater\u00eda con el mismo contexto. @DirtiesContext . Esta anotaci\u00f3n le indica a Spring que los test van a ser transaccionales, y por tanto cuando termine la ejecuci\u00f3n de cada uno de los test, autom\u00e1ticamente por la anotaci\u00f3n de arriba, Spring har\u00e1 un rearranque parcial del contexto y dejar\u00e1 el estado de la BBDD como estaba inicialmente. @ExtendWith . Esta anotaci\u00f3n le indica a Spring que no debe inicializar el contexto, ya que se trata de test est\u00e1ticos que no lo requieren. Para las pruebas de integraci\u00f3n nos faltar\u00e1 configurar la aplicaci\u00f3n de test, al igual que hicimos con la aplicaci\u00f3n 'productiva'. Deberemos abrir el fichero src/test/resources/application.properties y a\u00f1adir la configuraci\u00f3n de la BBDD. Para este tutorial vamos a utilizar la misma BBDD que la aplicaci\u00f3n productiva, pero de normal la aplicaci\u00f3n se conectar\u00e1 a una BBDD, generalmente f\u00edsica, mientras que los test jUnit se conectar\u00e1n a otra BBDD, generalmente en memoria. application.properties #Database spring.datasource.url = jdbc:h2:mem:testdb spring.datasource.username = sa spring.datasource.password = sa spring.datasource.driver-class-name = org.h2.Driver spring.jpa.database-platform = org.hibernate.dialect.H2Dialect spring.jpa.defer-datasource-initialization = true Con todo esto ya podemos crear nuestro primer test. Iremos a las clases CategoryIT y CategoryTest donde a\u00f1adiremos un m\u00e9todo p\u00fablico. Los test siempre tienen que ser m\u00e9todos p\u00fablicos que devuelvan el tipo void . CategoryTest.java CategoryIT.java package com.ccsw.tutorial.category ; import com.ccsw.tutorial.category.model.Category ; import com.ccsw.tutorial.category.model.CategoryDto ; import org.junit.jupiter.api.Test ; import org.junit.jupiter.api.extension.ExtendWith ; import org.mockito.InjectMocks ; import org.mockito.Mock ; import org.mockito.junit.jupiter.MockitoExtension ; import java.util.ArrayList ; import java.util.List ; import static org.junit.jupiter.api.Assertions.* ; import static org.mockito.Mockito.* ; @ExtendWith ( MockitoExtension . class ) public class CategoryTest { @Mock private CategoryRepository categoryRepository ; @InjectMocks private CategoryServiceImpl categoryService ; @Test public void findAllShouldReturnAllCategories () { List < Category > list = new ArrayList <> (); list . add ( mock ( Category . class )); when ( categoryRepository . findAll ()). thenReturn ( list ); List < Category > categories = categoryService . findAll (); assertNotNull ( categories ); assertEquals ( 1 , categories . size ()); } } package com.ccsw.tutorial.category ; import com.ccsw.tutorial.category.model.CategoryDto ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.boot.test.web.client.TestRestTemplate ; import org.springframework.boot.test.web.server.LocalServerPort ; import org.springframework.core.ParameterizedTypeReference ; import org.springframework.http.HttpMethod ; import org.springframework.http.ResponseEntity ; import org.springframework.test.annotation.DirtiesContext ; import java.util.List ; import static org.junit.jupiter.api.Assertions.* ; @SpringBootTest ( webEnvironment = SpringBootTest . WebEnvironment . RANDOM_PORT ) @DirtiesContext ( classMode = DirtiesContext . ClassMode . BEFORE_EACH_TEST_METHOD ) public class CategoryIT { public static final String LOCALHOST = \"http://localhost:\" ; public static final String SERVICE_PATH = \"/category\" ; @LocalServerPort private int port ; @Autowired private TestRestTemplate restTemplate ; ParameterizedTypeReference < List < CategoryDto >> responseType = new ParameterizedTypeReference < List < CategoryDto >> (){}; @Test public void findAllShouldReturnAllCategories () { ResponseEntity < List < CategoryDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . GET , null , responseType ); assertNotNull ( response ); assertEquals ( 3 , response . getBody (). size ()); } } Es muy importante marcar cada m\u00e9todo de prueba con la anotaci\u00f3n @Test , en caso contrario no se ejecutar\u00e1. Lo que se debe hacer en cada m\u00e9todo que implementemos es probar una y solo una acci\u00f3n. En los ejemplos anteriores (CategoryTest) , por un lado hemos comprobado el m\u00e9todo findAll() el cual por debajo invoca una llamada al repository de categor\u00eda, la cual hemos simulado con una respuesta ficticia limit\u00e1ndonos \u00fanicamente a la l\u00f3gica contenida en la operaci\u00f3n de negocio. Mientras que por otro lado (CategoryIT) , hemos probado la llamando al m\u00e9todo GET del endpoint http://localhost:XXXX/category comprobando que realmente nos devuelve 3 resultados, que son los que hay en BBDD inicialmente. Muy importante: Nomenclatura de los tests La nomenclatura de los m\u00e9todos de test debe sigue una estructura determinada. Hay muchas formas de nombrar a los m\u00e9todos, pero nosotros solemos utilizar la estructura 'should', para indicar lo que va a hacer. En el ejemplo anterior el m\u00e9todo 'findAll' debe devolver 'AllCategories'. De esta forma sabemos cu\u00e1l es la intenci\u00f3n del test, y si por cualquier motivo diera un fallo, sabemos que es lo que NO est\u00e1 funcionando de nuestra aplicaci\u00f3n. Para comprobar que el test funciona, podemos darle bot\u00f3n derecho sobre la clase de CategoryIT y pulsar en Run as -> JUnit Test . Si todo funciona correctamente, deber\u00e1 aparecer una pantalla de ejecuci\u00f3n y todos nuestros tests (en este caso solo uno) corriendo correctamente (en verde). El proceso es el mismo para la clase CategoryTest . Pruebas de creaci\u00f3n Vamos con los siguientes test, los que probar\u00e1n una creaci\u00f3n de una nueva Categor\u00eda . A\u00f1adimos el siguiente m\u00e9todo a la clase de test: CategoryTest.java CategoryIT.java public static final String CATEGORY_NAME = \"CAT1\" ; @Test public void saveNotExistsCategoryIdShouldInsert () { CategoryDto categoryDto = new CategoryDto (); categoryDto . setName ( CATEGORY_NAME ); ArgumentCaptor < Category > category = ArgumentCaptor . forClass ( Category . class ); categoryService . save ( null , categoryDto ); verify ( categoryRepository ). save ( category . capture ()); assertEquals ( CATEGORY_NAME , category . getValue (). getName ()); } public static final Long NEW_CATEGORY_ID = 4L ; public static final String NEW_CATEGORY_NAME = \"CAT4\" ; @Test public void saveWithoutIdShouldCreateNewCategory () { CategoryDto dto = new CategoryDto (); dto . setName ( NEW_CATEGORY_NAME ); restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . PUT , new HttpEntity <> ( dto ), Void . class ); ResponseEntity < List < CategoryDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . GET , null , responseType ); assertNotNull ( response ); assertEquals ( 4 , response . getBody (). size ()); CategoryDto categorySearch = response . getBody (). stream (). filter ( item -> item . getId (). equals ( NEW_CATEGORY_ID )). findFirst (). orElse ( null ); assertNotNull ( categorySearch ); assertEquals ( NEW_CATEGORY_NAME , categorySearch . getName ()); } En el primer caso, estamos construyendo un objeto CategoryDto para darle un nombre a la Categor\u00eda e invocamos a la operaci\u00f3n save pasandole un ID a nulo. Para identificar que el funcionamiento es el esperado, capturamos la categor\u00eda que se proporciona al repository al intentar realizar la acci\u00f3n ficticia de guardado y comprobamos que el valor es el que se proporciona en la invocaci\u00f3n. De forma similar en el segundo caso, estamos construyendo un objeto CategoryDto para darle un nombre a la Categor\u00eda e invocamos al m\u00e9todo PUT sin a\u00f1adir en la ruta referencia al identificador. Seguidamente, recuperamos de nuevo la lista de categor\u00edas y en este caso deber\u00eda tener 4 resultados. Hacemos un filtrado buscando la nueva Categor\u00eda que deber\u00eda tener un ID = 4 y deber\u00eda ser la que acabamos de crear. Si ejecutamos, veremos que ambos test ahora aparecen en verde. Pruebas de modificaci\u00f3n Para este caso de prueba, vamos a realizar varios test, como hemos comentado anteriormente. Tenemos que probar que es lo que pasa cuando intentamos modificar un elemento que existe, pero tambi\u00e9n debemos probar que es lo que pasa cuando intentamos modificar un elemento que no existe. Empezamos con el sencillo, un test que pruebe una modificaci\u00f3n existente. CategoryTest.java CategoryIT.java public static final Long EXISTS_CATEGORY_ID = 1L ; @Test public void saveExistsCategoryIdShouldUpdate () { CategoryDto categoryDto = new CategoryDto (); categoryDto . setName ( CATEGORY_NAME ); Category category = mock ( Category . class ); when ( categoryRepository . findById ( EXISTS_CATEGORY_ID )). thenReturn ( Optional . of ( category )); categoryService . save ( EXISTS_CATEGORY_ID , categoryDto ); verify ( categoryRepository ). save ( category ); } public static final Long MODIFY_CATEGORY_ID = 3L ; @Test public void modifyWithExistIdShouldModifyCategory () { CategoryDto dto = new CategoryDto (); dto . setName ( NEW_CATEGORY_NAME ); restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + MODIFY_CATEGORY_ID , HttpMethod . PUT , new HttpEntity <> ( dto ), Void . class ); ResponseEntity < List < CategoryDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . GET , null , responseType ); assertNotNull ( response ); assertEquals ( 3 , response . getBody (). size ()); CategoryDto categorySearch = response . getBody (). stream (). filter ( item -> item . getId (). equals ( MODIFY_CATEGORY_ID )). findFirst (). orElse ( null ); assertNotNull ( categorySearch ); assertEquals ( NEW_CATEGORY_NAME , categorySearch . getName ()); } En el caso de los test unitarios, comprobamos la l\u00f3gica de la modificaci\u00f3n simulando que el repository nos devuelve una categor\u00eda que modificar y verificado que se invoca el guardado sobre la misma. En el caso de los test de integraci\u00f3n, la misma filosof\u00eda que en el test anterior, pero esta vez modificamos la Categor\u00eda de ID = 3. Luego la filtramos y vemos que realmente se ha modificado. Adem\u00e1s comprobamos que el listado de todas los registros sigue siendo 3 y no se ha creado un nuevo registro. En el siguiente test, probaremos un resultado err\u00f3neo. CategoryIT.java @Test public void modifyWithNotExistIdShouldInternalError () { CategoryDto dto = new CategoryDto (); dto . setName ( NEW_CATEGORY_NAME ); ResponseEntity <?> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + NEW_CATEGORY_ID , HttpMethod . PUT , new HttpEntity <> ( dto ), Void . class ); assertEquals ( HttpStatus . INTERNAL_SERVER_ERROR , response . getStatusCode ()); } Intentamos modificar el ID = 4, que no deber\u00eda existir en BBDD y por tanto lo que se espera en el test es que lance un 500 Internal Server Error al llamar al m\u00e9todo PUT . Pruebas de borrado Ya por \u00faltimo implementamos las pruebas de borrado. CategoryTest.java CategoryIT.java @Test public void deleteExistsCategoryIdShouldDelete () throws Exception { Category category = mock ( Category . class ); when ( categoryRepository . findById ( EXISTS_CATEGORY_ID )). thenReturn ( Optional . of ( category )); categoryService . delete ( EXISTS_CATEGORY_ID ); verify ( categoryRepository ). deleteById ( EXISTS_CATEGORY_ID ); } public static final Long DELETE_CATEGORY_ID = 2L ; @Test public void deleteWithExistsIdShouldDeleteCategory () { restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + DELETE_CATEGORY_ID , HttpMethod . DELETE , null , Void . class ); ResponseEntity < List < CategoryDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . GET , null , responseType ); assertNotNull ( response ); assertEquals ( 2 , response . getBody (). size ()); } @Test public void deleteWithNotExistsIdShouldInternalError () { ResponseEntity <?> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + NEW_CATEGORY_ID , HttpMethod . DELETE , null , Void . class ); assertEquals ( HttpStatus . INTERNAL_SERVER_ERROR , response . getStatusCode ()); } En cuanto al test unitario, se invoca a la operaci\u00f3n delete y se verifica que la operaci\u00f3n requerida del repository es invocado con el atributo correcto. En lo relativo a las pruebas de integraci\u00f3n, en el primer test, se invoca el m\u00e9todo DELETE y posteriormente se comprueba que el listado tiene un tama\u00f1o de 2 (uno menos que el original). Mientras que en el segundo test, se comprueba que con ID no v\u00e1lido, devuelve un 500 Internal Server Error . Con esto tendr\u00edamos m\u00e1s o menos probados los casos b\u00e1sicos de nuestra aplicaci\u00f3n y tendr\u00edamos una peque\u00f1a red de seguridad que nos ayudar\u00eda por si a futuro necesitamos hacer alg\u00fan cambio o evolutivo. \u00bfQ\u00fae hemos aprendido? Resumiendo un poco los pasos que hemos seguido: Hay que definir y agrupar por \u00e1mbito funcional, hemos creado el package com.ccsw.tutorial.category para aglutinar todas las clases. Lo primero que debemos empezar a construir siempre son los test, aunque en este cap\u00edtulo del tutorial lo hemos hecho al rev\u00e9s solo con fines did\u00e1cticos. En los siguientes cap\u00edtulos lo haremos de forma correcta, y esto nos ayudar\u00e1 a pensar y dise\u00f1ar que es lo que queremos implementar realmente. La implementaci\u00f3n de la aplicaci\u00f3n se deber\u00eda separar por capas: Controller \u2192 Maneja las peticiones de entrada del cliente y realiza transformaciones. No ejecuta directamente l\u00f3gica de negocio, para eso utiliza llamadas a la siguiente capa. Service \u2192 Ejecuta la l\u00f3gica de negocio en sus m\u00e9todos o llamando a otros objetos de la misma capa. No ejecuta directamente accesos a datos, para eso utiliza la siguiente capa. Repository \u2192 Realiza los accesos a datos de lectura y escritura. NUNCA debe llamar a otros objetos de la misma capa ni de capas anteriores. Hay que tener en cuenta los objetos modelo que se mueven en cada capa. Generalmente son: Json \u2192 Los datos que vienen y van del cliente al Controller . DTO \u2192 Los datos se mueven dentro del Controller y sirven para invocar llamadas. Tambi\u00e9n son los datos que devuelve un Controller . Entity \u2192 Los datos que sirven para persistir y leer datos de una BBDD y que NUNCA deber\u00edan ir m\u00e1s all\u00e1 del Controller . Depuraci\u00f3n Una parte muy importante del desarrollo es tener la capacidad de depurar nuestro c\u00f3digo, en este apartado vamos a explicar como se realiza debug en Backend. Esta parte se realiza con las herramientas incluidas dentro de nuestro IDE favorito, en este caso vamos a utilizar el Eclipse. Lo primero que debemos hacer es arrancar la aplicaci\u00f3n en modo Debug : Arrancada la aplicaci\u00f3n en este modo, vamos a depurar la operaci\u00f3n de crear categor\u00eda. Para ello vamos a abrir nuestro fichero donde tenemos la implementaci\u00f3n del servicio de creaci\u00f3n de la capa de la l\u00f3gica de negocio CategoryServiceImpl . Dentro del fichero ya podemos a\u00f1adir puntos de ruptura (breakpoint), en nuestro caso queremos comprobar que el nombre introducido se recibe correctamente. Colocamos el breakpoint en la primera l\u00ednea del m\u00e9todo (click sobre el n\u00famero de la l\u00ednea) y desde la interfaz/postman creamos una nueva categor\u00eda. Hecho esto, podemos observar que a nivel de interfaz/postman, la petici\u00f3n se queda esperando y el IDE pasa modo Debug (la primera vez nos preguntar\u00e1 si queremos hacerlo, le decimos que si): El IDE nos lleva al punto exacto donde hemos a\u00f1adido el breakpoint y se para en este punto ofreci\u00e9ndonos la posibilidad de explorar el contenido de las variables del c\u00f3digo: Aqu\u00ed podemos comprobar que efectivamente el atributo name de la variable dto tiene el valor que hemos introducido por pantalla/postman. Para continuar con la ejecuci\u00f3n basta con darle al bot\u00f3n de play de la barra de herramientas superior. Nota: para volver al modo Java de Eclipse, presionamos el bot\u00f3n que se sit\u00faa a la izquierda del modo Debug en el que ha entrado el IDE autom\u00e1ticamente.","title":"\ud83d\udfe2 Spring Boot"},{"location":"develop/basic/springboot/#listado-simple-spring-boot","text":"Ahora que ya tenemos listo el proyecto backend de Spring Boot (en el puerto 8080) ya podemos empezar a codificar la soluci\u00f3n.","title":"Listado simple - Spring Boot"},{"location":"develop/basic/springboot/#primeros-pasos","text":"Antes de empezar Quiero hacer hincapi\u00e9 en Spring Boot tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. Tanto la propia web de Spring como en el portal de tutoriales de Baeldung puedes buscar casi cualquier ejemplo que necesites.","title":"Primeros pasos"},{"location":"develop/basic/springboot/#estructurar-el-codigo","text":"Vamos a hacer un breve refresco de la estructura del c\u00f3digo que ya se ha visto en puntos anteriores. Las clases deben estar agrupadas por \u00e1mbito funcional, en nuestro caso como vamos a hacer la funcionalidad de Categor\u00edas pues deber\u00eda estar todo dentro de un package del tipo com.ccsw.tutorial.category . Adem\u00e1s, deber\u00edamos aplicar la separaci\u00f3n por capas como ya se vi\u00f3 en el esquema: La primera capa, la de Controlador , se encargar\u00e1 de procesar las peticiones y transformar datos. Esta capa llamar\u00e1 a la capa de L\u00f3gica de negocio que ejecutar\u00e1 las operaciones, ayud\u00e1ndose de otros objetos de esa misma capa de L\u00f3gica o bien de llamadas a datos a trav\u00e9s de la capa de Acceso a Datos Ahora s\u00ed, vamos a programar!.","title":"Estructurar el c\u00f3digo"},{"location":"develop/basic/springboot/#capa-de-operaciones-controller","text":"En esta capa es donde se definen las operaciones que pueden ser consumidas por los clientes. Se caracterizan por estar anotadas con las anotaciones @Controller o @RestController y por las anotaciones @RequestMapping que nos permiten definir las rutas de acceso. Recomendaci\u00f3n: Breve detalle REST Antes de continuar te recomiendo encarecidamente que leas el Anexo: Detalle REST donde se explica brevemente como estructurar los servicios REST que veremos a continuaci\u00f3n.","title":"Capa de operaciones: Controller"},{"location":"develop/basic/springboot/#controller-de-ejemplo","text":"Vamos a crear una clase CategoryController.java dentro del package com.ccsw.tutorial.category para definir las rutas de las operaciones. CategoryController.java package com.ccsw.tutorial.category ; import java.util.List ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import io.swagger.v3.oas.annotations.tags.Tag ; /** * @author ccsw * */ @Tag ( name = \"Category\" , description = \"API of Category\" ) @RequestMapping ( value = \"/category\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class CategoryController { /** * M\u00e9todo para probar el servicio * */ @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public String prueba () { return \"Probando el Controller\" ; } } Ahora si arrancamos la aplicaci\u00f3n server, abrimos el Postman y creamos una petici\u00f3n GET a la url http://localhost:8080/category nos responder\u00e1 con el mensaje que hemos programado.","title":"Controller de ejemplo"},{"location":"develop/basic/springboot/#implementar-operaciones","text":"Ahora que ya tenemos un controlador y una operaci\u00f3n de negocio ficticia, vamos a borrarla y a\u00f1adir las operaciones reales que consumir\u00e1 nuestra pantalla. Deberemos a\u00f1adir una operaci\u00f3n para listar, una para actualizar, una para guardar y una para borrar. Aunque para hacerlo m\u00e1s c\u00f3modo, utilizaremos la misma operaci\u00f3n para guardar y para actualizar. Adem\u00e1s, no vamos a trabajar directamente con datos simples, sino que usaremos objetos para recibir informaci\u00f3n y para enviar informaci\u00f3n. Estos objetos t\u00edpicamente se denominan DTO (Data Transfer Object) y nos sirven justamente para encapsular informaci\u00f3n que queremos transportar. En realidad no son m\u00e1s que clases pojo sencillas con propiedades, getters y setters. Para nuestro ejemplo crearemos una clase CategoryDto dentro del package com.ccsw.tutorial.category.model con el siguiente contenido: CategoryDto.java package com.ccsw.tutorial.category.model ; /** * @author ccsw * */ public class CategoryDto { private Long id ; private String name ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } } A continuaci\u00f3n utilizaremos esta clase en nuestro Controller para implementar las tres operaciones de negocio. CategoryController.java package com.ccsw.tutorial.category ; import java.util.ArrayList ; import java.util.HashMap ; import java.util.List ; import java.util.Map ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.ccsw.tutorial.category.model.CategoryDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; /** * @author ccsw * */ @Tag ( name = \"Category\" , description = \"API of Category\" ) @RequestMapping ( value = \"/category\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class CategoryController { private long SEQUENCE = 1 ; private Map < Long , CategoryDto > categories = new HashMap < Long , CategoryDto > (); /** * M\u00e9todo para recuperar todas las categorias * * @return {@link List} de {@link CategoryDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a list of Categories\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { return new ArrayList < CategoryDto > ( this . categories . values ()); } /** * M\u00e9todo para crear o actualizar una categoria * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Category\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody CategoryDto dto ) { CategoryDto category ; if ( id == null ) { category = new CategoryDto (); category . setId ( this . SEQUENCE ++ ); this . categories . put ( category . getId (), category ); } else { category = this . categories . get ( id ); } category . setName ( dto . getName ()); } /** * M\u00e9todo para borrar una categoria * * @param id PK de la entidad */ @Operation ( summary = \"Delete\" , description = \"Method that deletes a Category\" ) @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . categories . remove ( id ); } } Como todav\u00eda no tenemos acceso a BD, hemos creado una variable tipo HashMap y una variable Long, que simular\u00e1n una BD y una secuencia. Tambi\u00e9n hemos implementado tres operaciones GET, PUT y DELETE que realizan las acciones necesarias por nuestra pantalla. Ahora podr\u00edamos probarlo desde el Postman con cuatro ejemplo sencillos. F\u00edjate que el m\u00e9todo save tiene dos rutas. La ruta normal category/ y la ruta informada category/3 . Esto es porque hemos juntado la acci\u00f3n create y update en un mismo m\u00e9todo para facilitar el desarrollo. Es totalmente v\u00e1lido y funcional. Atenci\u00f3n Los datos que se reciben pueden venir informados como un par\u00e1metro en la URL Get, como una variable en el propio path o dentro del body de la petici\u00f3n. Cada uno de ellos se recupera con una anotaci\u00f3n especial: @RequestParam , @PathVariable y @RequestBody respectivamente. Como no tenemos ning\u00fan dato dado de alta, podemos probar en primer lugar a realizar una inserci\u00f3n de datos con el m\u00e9todo PUT. PUT /category nos sirve para insertar Categor\u00edas nuevas (si no tienen el id informado) o para actualizar Categor\u00edas (si tienen el id informado). F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no env\u00edas datos, te dar\u00e1 un error. GET /category nos devuelve un listado de Categor\u00edas , siempre que hayamos insertado algo antes. DELETE /category nos sirve eliminar Categor\u00edas . F\u00edjate que el dato del ID que se env\u00eda est\u00e1 en el path. Prueba a jugar borrando categor\u00edas que no existen o modificando categor\u00edas que no existen. Tal y como est\u00e1 programado, el borrado no dar\u00e1 error, pero la modificaci\u00f3n deber\u00eda dar un NullPointerException al no existir el dato a modificar.","title":"Implementar operaciones"},{"location":"develop/basic/springboot/#documentacion-openapi","text":"Si te acuerdas, en el punto de Entorno de desarrollo , a\u00f1adimos el m\u00f3dulo de OpenAPI a nuestro proyecto, y en el desarrollo de nuestro Controller hemos anotado tanto la clase como los m\u00e9todos con sus correspondientes etiquetas @Tag y @Operation . Esto nos va a ayudar a generar documentaci\u00f3n autom\u00e1tica de nuestras APIs haciendo que nuestro c\u00f3digo sea m\u00e1s mantenible y nuestra documentaci\u00f3n mucho m\u00e1s fiable. Para ver el resultado, con el proyecto arrancado nos dirigimos a la ruta por defecto de OpenAPI: http://localhost:8080/swagger-ui/index.html Aqu\u00ed podemos observar el cat\u00e1logo de endpoints generados, ver los tipos de entrada y salida e incluso realizar peticiones a los mismos. Este ser\u00e1 el contrato de nuestros endpoints, que nos ayudar\u00e1 a integrarnos con el equipo frontend (en el caso del tutorial seguramente seremos nosotros mismos).","title":"Documentaci\u00f3n (OpenAPI)"},{"location":"develop/basic/springboot/#aspectos-importantes","text":"Los aspectos importantes de la capa Controller son: La clase debe estar anotada con @Controller o @RestController . Mejor usar la \u00faltima anotaci\u00f3n, ya que est\u00e1s diciendo que las operaciones son de tipo Rest y no har\u00e1 falta configurar nada La ruta general al controlador se define con el @RequestMapping global de la clase, aunque tambi\u00e9n se puede obviar esta anotaci\u00f3n y a\u00f1adir a cada una de las operaciones la ruta ra\u00edz. Los m\u00e9todos que queramos exponer como operaciones deben ir anotados tambi\u00e9n con @RequestMapping con la info: path \u2192 Que nos permite definir un path para la operaci\u00f3n, siempre sum\u00e1ndole el path de la clase (si es que tuviera) method \u2192 Que nos permite definir el verbo de http que vamos a atender. Podemos tener el mismo path con diferente method, sin problema. Por lo general utilizaremos: GET \u2192 Generalmente se usa para recuperar informaci\u00f3n POST \u2192 Se utiliza para hacer update y filtrados complejos de informaci\u00f3n PUT \u2192 Se utiliza para hacer save de informaci\u00f3n DELETE \u2192 Se utiliza para hacer borrados de informaci\u00f3n","title":"Aspectos importantes"},{"location":"develop/basic/springboot/#capa-de-servicio-service","text":"Pero en realidad la cosa no funciona as\u00ed. Hemos implementado parte de la l\u00f3gica de negocio (las operaciones/acciones de guardado, borrado y listado) dentro de lo que ser\u00eda la capa de operaciones o servicios al cliente. Esta capa no debe ejecutar l\u00f3gica de negocio, tan solo debe hacer transformaciones de datos y enrutar peticiones, toda la l\u00f3gica deber\u00eda ir en la capa de servicio.","title":"Capa de Servicio: Service"},{"location":"develop/basic/springboot/#implementar-servicios","text":"Pues vamos a arreglarlo. Vamos a crear un servicio y vamos a mover la l\u00f3gica de negocio al servicio. CategoryService.java CategoryServiceImpl.java CategoryController.java package com.ccsw.tutorial.category ; import com.ccsw.tutorial.category.model.CategoryDto ; import java.util.List ; /** * @author ccsw * */ public interface CategoryService { /** * M\u00e9todo para recuperar todas las categor\u00edas * * @return {@link List} de {@link Category} */ List < CategoryDto > findAll (); /** * M\u00e9todo para crear o actualizar una categor\u00eda * * @param id PK de la entidad * @param dto datos de la entidad */ void save ( Long id , CategoryDto dto ); /** * M\u00e9todo para borrar una categor\u00eda * * @param id PK de la entidad */ void delete ( Long id ); } package com.ccsw.tutorial.category ; import java.util.ArrayList ; import java.util.HashMap ; import java.util.List ; import java.util.Map ; import org.springframework.stereotype.Service ; import com.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw * */ @Service public class CategoryServiceImpl implements CategoryService { private long SEQUENCE = 1 ; private Map < Long , CategoryDto > categories = new HashMap < Long , CategoryDto > (); /** * {@inheritDoc} */ public List < CategoryDto > findAll () { return new ArrayList < CategoryDto > ( this . categories . values ()); } /** * {@inheritDoc} */ public void save ( Long id , CategoryDto dto ) { CategoryDto category ; if ( id == null ) { category = new CategoryDto (); category . setId ( this . SEQUENCE ++ ); this . categories . put ( category . getId (), category ); } else { category = this . categories . get ( id ); } category . setName ( dto . getName ()); } /** * {@inheritDoc} */ public void delete ( Long id ) { this . categories . remove ( id ); } } package com.ccsw.tutorial.category ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.ccsw.tutorial.category.model.CategoryDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; /** * @author ccsw * */ @Tag ( name = \"Category\" , description = \"API of Category\" ) @RequestMapping ( value = \"/category\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class CategoryController { @Autowired private CategoryService categoryService ; /** * M\u00e9todo para recuperar todas las categorias * * @return {@link List} de {@link CategoryDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a list of Categories\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { return this . categoryService . findAll (); } /** * M\u00e9todo para crear o actualizar una categoria * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Category\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody CategoryDto dto ) { this . categoryService . save ( id , dto ); } /** * M\u00e9todo para borrar una categoria * * @param id PK de la entidad */ @Operation ( summary = \"Delete\" , description = \"Method that deletes a Category\" ) @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . categoryService . delete ( id ); } } Ahora ya tenemos bien estructurado nuestro proyecto. Ya tenemos las dos capas necesarias Controladores y Servicios y cada uno se encarga de llevar a cabo su cometido de forma correcta.","title":"Implementar servicios"},{"location":"develop/basic/springboot/#aspectos-importantes_1","text":"Los aspectos importantes de la capa Service son: Toda la l\u00f3gica de negocio, operaciones y dem\u00e1s debe estar implementada en los servicios. Los controladores simplemente invocan servicios y transforman ciertos datos. Es buena pr\u00e1ctica que la capa de servicios se implemente usando el patr\u00f3n fachada, esto quiere decir que necesitamos tener una Interface y al menos una implementaci\u00f3n de esa Interface. Y siempre debemos interactuar con la Interface. Esto nos permitir\u00e1 a futuro poder sustituir la implementaci\u00f3n por otra diferente sin que el resto del c\u00f3digo se vea afectado. Especialmente \u00fatil cuando queremos mockear comportamientos en tests. La capa de servicio puede invocar a otros servicios en sus operaciones, pero nunca debe invocar a un controlador. Para crear un servicio se debe anotar mediante @Service y adem\u00e1s debe implementar la Interface del servicio. Un error muy com\u00fan al arrancar un proyecto y ver que no funcionan las llamadas, es porqu\u00e9 no existe la anotaci\u00f3n @Service o porqu\u00e9 no se ha implementado la Interface. La forma de inyectar y utilizar componentes manejados por Spring Boot es mediante la anotaci\u00f3n @Autowired . NO intentes crear un objeto de CategoryServiceImpl, ni hacer un new , ya que no estar\u00e1 manejado por Springboot y dar\u00e1 fallos de NullPointer. Lo mejor es dejar que Spring Boot lo gestione y utilizar las inyecciones de dependencias.","title":"Aspectos importantes"},{"location":"develop/basic/springboot/#capa-de-datos-repository","text":"Pero no siempre vamos a acceder a los datos mediante un HasMap en memoria. En algunas ocasiones queremos que nuestro proyecto acceda a un servicio de datos como puede ser una BBDD, un servicio externo, un acceso a disco, etc. Estos accesos se deben hacer desde la capa de acceso a datos, y en concreto para nuestro ejemplo, lo haremos a trav\u00e9s de un Repository para que acceda a una BBDD. Para el tutorial no necesitamos configurar una BBDD externa ni complicarnos demasiado. Vamos a utilizar una librer\u00eda muy \u00fatil llamada H2 que nos permite levantar una BBDD en memoria persistiendo los datos en memoria o en disco, de hecho ya la configuramos en el apartado de Entorno de desarrollo .","title":"Capa de Datos: Repository"},{"location":"develop/basic/springboot/#implementar-entity","text":"Lo primero que haremos ser\u00e1 crear nuestra entity con la que vamos a persistir y recuperar informaci\u00f3n. Las entidades igual que los DTOs deber\u00edan estar agrupados dentro del package model de cada funcionalidad, as\u00ed que vamos a crear una nueva clase java. Category.java package com.ccsw.tutorial.category.model ; import jakarta.persistence.* ; /** * @author ccsw * */ @Entity @Table ( name = \"category\" ) public class Category { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"name\" , nullable = false ) private String name ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } } Si te fijas, la Entity suele ser muy similar a un DTO, tiene unas propiedades y sus getters y setters. Pero a diferencia de los DTOs, esta clase tiene una serie de anotaciones que permiten a JPA hacer su magia y generar consultas SQL a la BBDD. En este ejemplo vemos 4 anotaciones importantes: @Entity \u2192 Le indica a Springboot que se trata de una clase que implementa una Entidad de BBDD. Sin esta anotaci\u00f3n no es posible hacer queries. @Table \u2192 Le indica a JPA el nombre y el schema de la tabla que representa esta clase. Por claridad se deber\u00eda poner siempre, aunque si el nombre de la tabla es igual al nombre de la clase no es necesaria la anotaci\u00f3n. @Id y @GeneratedValue \u2192 Le indica a JPA que esta propiedad es la que mapea una Primary Key y adem\u00e1s que esta PK se genera con la estrategia que se le indique en la anotaci\u00f3n @GeneratedValue , que puede ser: Generaci\u00f3n de PK por Secuence , la que utiliza Oracle, en este caso habr\u00e1 que indicarle un nombre de secuencia. Generaci\u00f3n de PK por Indentity , la que utiliza MySql o SQLServer, el auto-incremental. Generaci\u00f3n de PK por Table , en algunas BBDD se permite tener una tabla donde se almacenan como registros todas las secuencias. Generaci\u00f3n de PK Auto , elige la mejor estrategia en funci\u00f3n de la BBDD que hemos seleccionado. @Column \u2192 Le indica a JPA que esta propiedad mapea una columna de la tabla y le especifica el nombre de la columna. Al igual que la anotaci\u00f3nd de Table , esta anotaci\u00f3n no es necesaria aunque si es muy recomendable. Por claridad se deber\u00eda poner siempre, aunque si el nombre de la columna es igual al nombre de la propiedad no es necesaria la anotaci\u00f3n. Hay muchas otras anotaciones, pero estas son las b\u00e1sicas, ya ir\u00e1s aprendiendo otras. Consejo Para definir las PK de las tablas, intenta evitar una PK compuesta de m\u00e1s de una columna. La programaci\u00f3n se hace muy compleja y las magias que hace JPA en la oscuridad se complican mucho. Mi recomendaci\u00f3n es que siempre utilices una PK n\u00famerica, en la medida de lo posible, y si es necesario, crees \u00edndices compuestos de b\u00fasqueda o checks compuestos para evitar duplicidades.","title":"Implementar Entity"},{"location":"develop/basic/springboot/#juego-de-datos-de-bbdd","text":"Spring Boot autom\u00e1ticamente cuando arranque el proyecto escaner\u00e1 todas las @Entity y crear\u00e1 las estructuras de las tablas en la BBDD en memoria, gracias a las anotaciones que hemos puesto. Adem\u00e1s de esto, lanzar\u00e1 los scripts de construcci\u00f3n de BBDD que tenemos en la carpeta src/main/resources/ . As\u00ed que, teniendo clara la estructura de la Entity podemos configurar los ficheros con los juegos de datos que queramos, y para ello vamos a utilizar el fichero data.sql que creamos en su momento. Sabemos que la tabla se llamar\u00e1 category y que tendr\u00e1 dos columnas, una columna id , que ser\u00e1 la PK autom\u00e1tica, y una columna name . Podemos escribir el siguiente script para rellenar datos: data.sql INSERT INTO category ( name ) VALUES ( 'Eurogames' ); INSERT INTO category ( name ) VALUES ( 'Ameritrash' ); INSERT INTO category ( name ) VALUES ( 'Familiar' );","title":"Juego de datos de BBDD"},{"location":"develop/basic/springboot/#implementar-repository","text":"Ahora que ya tenemos el juego de datos y la entidad implementada, vamos a ver como acceder a BBDD desde Java. Esto lo haremos con un Repository . Existen varias formas de utilizar los repositories, desde el todo autom\u00e1tico y magia de JPA hasta el repositorio manual en el que hay que codificar todo. En el tutorial voy a explicar varias formas de implementarlo para este CRUD y los siguientes CRUDs. Como ya se dijo en puntos anteriores, el acceso a datos se debe hacer siempre a trav\u00e9s de un Repository , as\u00ed que vamos a implementar uno. En esta capa, al igual que pasaba con los services, es recomendable utilizar el patr\u00f3n fachada, para poder sustituir implementaciones sin afectar al c\u00f3digo. CategoryRepository.java package com.ccsw.tutorial.category ; import com.ccsw.tutorial.category.model.Category ; import org.springframework.data.repository.CrudRepository ; /** * @author ccsw * */ public interface CategoryRepository extends CrudRepository < Category , Long > { } \u00bfQu\u00e9 te parece?, sencillo, \u00bfno?. Spring ya tiene una implementaci\u00f3n por defecto de un CrudRepository, tan solo tenemos que crear una interface que extienda de la interface CrudRepository pas\u00e1ndole como tipos la Entity y el tipo de la Primary Key. Con eso Spring construye el resto y nos provee de los m\u00e9todos t\u00edpicos y necesarios para un CRUD. Ahora vamos a utilizarla en \u00e9l Service , pero hay un problema. \u00c9l Repository devuelve un objeto tipo Category y \u00e9l Service y Controller devuelven un objeto tipo CategoryDto . Esto es porque en cada capa se debe con un \u00e1mbito de modelos diferente. Podr\u00edamos hacer que todo el back trabajara con Category que son entidades de persistencia, pero no es lo correcto y nos podr\u00eda llevar a cometer errores, o modificar el objeto y que sin que nosotros lo orden\u00e1semos se persistiera ese cambio en BBDD. El \u00e1mbito de trabajo de las capas con el que solemos trabajar y est\u00e1 m\u00e1s extendido es el siguiente: Los datos que vienen y van al cliente, deber\u00edan ser en la mayor\u00eda de los casos datos en formato json Al entrar en un Controller esos datos json se transforman en un DTO. Al salir del Controller hacia el cliente, esos DTOs se transforman en formato json. Estas conversiones son autom\u00e1ticas, las hace Springboot (en realidad las hace la librer\u00eda de jackson codehaus). Cuando un Controller ejecuta una llamada a un Service , generalmente le pasa sus datos en DTO, y el Service se encarga de transformar esto a una Entity . A la inversa, cuando un Service responde a un Controller , \u00e9l responde con una Entity y el Controller ya se encargar\u00e1 de transformarlo a DTO. Por \u00faltimo, para los Repository , siempre se trabaja de entrada y salida con objetos tipo Entity Parece un l\u00edo, pero ya ver\u00e1s como es muy sencillo ahora que veremos el ejemplo. Una \u00faltima cosa, para hacer esas transformaciones, las podemos hacer a mano usando getters y setters o bien utilizar el objeto DozerBeanMapper que hemos configurado al principio. El c\u00f3digo deber\u00eda quedar as\u00ed: CategoryServiceImpl.java CategoryService.java CategoryController.java package com.ccsw.tutorial.category ; import com.ccsw.tutorial.category.model.Category ; import com.ccsw.tutorial.category.model.CategoryDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class CategoryServiceImpl implements CategoryService { @Autowired CategoryRepository categoryRepository ; /** * {@inheritDoc} */ @Override public List < Category > findAll () { return ( List < Category > ) this . categoryRepository . findAll (); } /** * {@inheritDoc} */ @Override public void save ( Long id , CategoryDto dto ) { Category category ; if ( id == null ) { category = new Category (); } else { category = this . categoryRepository . findById ( id ). orElse ( null ); } category . setName ( dto . getName ()); this . categoryRepository . save ( category ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) throws Exception { if ( this . categoryRepository . findById ( id ). orElse ( null ) == null ){ throw new Exception ( \"Not exists\" ); } this . categoryRepository . deleteById ( id ); } } package com.ccsw.tutorial.category ; import com.ccsw.tutorial.category.model.Category ; import com.ccsw.tutorial.category.model.CategoryDto ; import java.util.List ; /** * @author ccsw * */ public interface CategoryService { /** * M\u00e9todo para recuperar todas las {@link Category} * * @return {@link List} de {@link Category} */ List < Category > findAll (); /** * M\u00e9todo para crear o actualizar una {@link Category} * * @param id PK de la entidad * @param dto datos de la entidad */ void save ( Long id , CategoryDto dto ); /** * M\u00e9todo para borrar una {@link Category} * * @param id PK de la entidad */ void delete ( Long id ) throws Exception ; } package com.ccsw.tutorial.category ; import com.ccsw.tutorial.category.model.Category ; import com.ccsw.tutorial.category.model.CategoryDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; import org.modelmapper.ModelMapper ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.* ; import java.util.List ; import java.util.stream.Collectors ; /** * @author ccsw * */ @Tag ( name = \"Category\" , description = \"API of Category\" ) @RequestMapping ( value = \"/category\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class CategoryController { @Autowired CategoryService categoryService ; @Autowired ModelMapper mapper ; /** * M\u00e9todo para recuperar todas las {@link Category} * * @return {@link List} de {@link CategoryDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a list of Categories\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { List < Category > categories = this . categoryService . findAll (); return categories . stream (). map ( e -> mapper . map ( e , CategoryDto . class )). collect ( Collectors . toList ()); } /** * M\u00e9todo para crear o actualizar una {@link Category} * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Category\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody CategoryDto dto ) { this . categoryService . save ( id , dto ); } /** * M\u00e9todo para borrar una {@link Category} * * @param id PK de la entidad */ @Operation ( summary = \"Delete\" , description = \"Method that deletes a Category\" ) @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) throws Exception { this . categoryService . delete ( id ); } } El Service no tiene nada raro, simplemente accede al Repository (siempre anotado como @Autowired ) y recupera datos o los guarda. F\u00edjate en el caso especial del save que la \u00fanica diferencia es que en un caso tendr\u00e1 id != null y por tanto internamente har\u00e1 un update, y en otro caso tendr\u00e1 id == null y por tanto internamente har\u00e1 un save. En cuanto a la interface, lo \u00fanico que cambiamos fue los objetos de respuesta, que ahora pasan a ser de tipo Category . Los de entrada se mantienen como CategoryDto . Por \u00faltimo, en \u00e9l Controller se puede ver como se utiliza el conversor de DozerBeanMapper (siempre anotado como @Autowired ), que permite traducir una lista a un tipo concreto, o un objeto \u00fanico a un tipo concreto. La forma de hacer estas conversiones siempre es por nombre de propiedad. Las propiedades del objeto destino se deben llamar igual que las propiedades del objeto origen. En caso contrario se quedar\u00e1n a null. Ojo con el mapeo Ojo a esta \u00faltima frase, debe quedar meridianamente claro. La forma de mapear de un objeto origen a un objeto destino siempre es a trav\u00e9s del nombre. Los getters del origen deben ser iguales a los getters del destino. Si hay una letra diferente o unas may\u00fasculas o min\u00fasculas diferentes NO realizar\u00e1 el mapeo y se quedar\u00e1 la propiedad a null. Para terminar, cuando queramos realizar un mapeo masivo de los diferentes registros, tenemos que itulizar la API Stream de Java, que nos proporciona una forma sencilla de realizar estas operativas, sobre colecciones de elementos, mediante el uso del m\u00e9todo intermedio map y el reductor por defecto para listas. Te recomiendo echarle un ojo a la teor\u00eda de Introducci\u00f3n a API Java Streams . BBDD Si quires ver el contenido de la base de datos puedes acceder a un IDE web autopublicado por H2 en la ruta http://localhost:8080/h2-console","title":"Implementar Repository"},{"location":"develop/basic/springboot/#aspectos-importantes_2","text":"Los aspectos importantes de la capa Repository son: Al igual que los Service , se debe utilizar el patr\u00f3n fachada, por lo que tendremos una Interface y posiblemente una implementaci\u00f3n. A menudo la implementaci\u00f3n la hace internamente Spring Boot, pero hay veces que podemos hacer una implementaci\u00f3n manual. Lo veremos en siguientes puntos. Los Repository trabajan siempre con Entity que no son m\u00e1s que mapeos de una tabla o de una vista que existe en BBDD. Los Repository no contienen l\u00f3gica de negocio, ni transformaciones, simplemente acceder a datos, persisten o devuelven informaci\u00f3n. Los Repository JAM\u00c1S deben llamar a otros Repository ni Service . Intenta que tus clases Entity sean lo m\u00e1s sencillas posible, sobre todo en cuanto a Primary Keys, se simplificar\u00e1 mucho el desarrollo.","title":"Aspectos importantes"},{"location":"develop/basic/springboot/#capa-de-testing-tdd","text":"Por \u00faltimo y aunque no deber\u00eda ser lo \u00faltimo que se desarrolla sino todo lo contrario, deber\u00eda ser lo primero en desarrollar, tenemos la bater\u00eda de pruebas. Con fines did\u00e1cticos, he querido ense\u00f1arte un ciclo de desarrollo para ir recorriendo las diferentes capas de una aplicaci\u00f3n, pero en realidad, para realizar el desarrollo deber\u00eda aplicar TDD (Test Driven Development) . Si quieres aprender las reglas b\u00e1sicas de como aplicar TDD al desarrollo diario, te recomiendo que leas el Anexo. TDD . En este caso, y sin que sirva de precedente, ya tenemos implementados los m\u00e9todos de la aplicaci\u00f3n, y ahora vamos a testearlos. Existen muchas formas de testing en funci\u00f3n del componente o la capa que se quiera testear. En realidad, a medida que vayas programando ir\u00e1s aprendiendo todas ellas, de momento realizaremos dos tipos de test simples que prueben las casu\u00edsticas de los m\u00e9todos. El enfoque que seguiremos en este tutorial ser\u00e1 realizar las pruebas mediante test unitarios y test de integraci\u00f3n. Test unitarios : Se trata de pruebas estrictamente relativas a la calidad est\u00e1tica del c\u00f3digo de una determinada operaci\u00f3n de la capa de la l\u00f3gica de negocio (Service). Estas pruebas no inicializan el contexto de Spring y deben simular todas las piezas ajenas a la funcionalidad testeada. Test de integraci\u00f3n : Se tratan de pruebas completas de un determinado endpoint que conlleva inicializar el contexto de Spring (base de datos incluida) y realizar una llama REST para comprobar el flujo completo de la API. Lo primero ser\u00e1 conocer que queremos probar y para ello nos vamos a hacer una lista: Test unitarios: Prueba de listado, debe probar la l\u00f3gica dentro de la operaci\u00f3n de negocio de consulta de Categor\u00eda Prueba de creaci\u00f3n, debe probar la l\u00f3gica dentro de la operaci\u00f3n de negocio de creaci\u00f3n una nueva Categor\u00eda Prueba de modificaci\u00f3n, debe probar la l\u00f3gica dentro de la operaci\u00f3n de negocio de modificaci\u00f3n una Categor\u00eda existente Prueba de borrado, debe probar la l\u00f3gica dentro de la operaci\u00f3n de negocio de borrado de una Categor\u00eda existente Test de integraci\u00f3n: Prueba de listado, debe recuperar los elementos de la tabla Categor\u00eda Prueba de creaci\u00f3n, debe crear una nueva Categor\u00eda Prueba de modificaci\u00f3n correcta, debe modificar una Categor\u00eda existente Prueba de modificaci\u00f3n incorrecta, debe dar error al modificar una Categor\u00eda que no existe Prueba de borrado correcta, debe borrar una Categor\u00eda existente Prueba de borrado incorrecta, debe dar error al borrar una Categor\u00eda que no existe Se podr\u00edan hacer muchos m\u00e1s tests, pero creo que con esos son suficientes para que entiendas como se comporta esta capa. Si te fijas, hay que probar tanto los resultados correctos como los resultados incorrectos. El usuario no siempre se va a comportar como nosotros pensamos. Pues vamos a ello.","title":"Capa de Testing: TDD"},{"location":"develop/basic/springboot/#pruebas-de-listado","text":"Vamos a empezar haciendo una clase de test dentro de la carpeta src/test/java . No queremos que los test formen parte del c\u00f3digo productivo de la aplicaci\u00f3n, por eso utilizamos esa ruta que queda fuera del scope general de la aplicaci\u00f3n (main). Crearemos las clases (en la package category ): Test unitarios: com.ccsw.tutorial.category.CategoryTest Test de integraci\u00f3n: com.ccsw.tutorial.category.CategoryIT CategoryTest.java CategoryIT.java package com.ccsw.tutorial.category ; import org.junit.jupiter.api.extension.ExtendWith ; import org.mockito.junit.jupiter.MockitoExtension ; @ExtendWith ( MockitoExtension . class ) public class CategoryTest { } package com.ccsw.tutorial.category ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.boot.test.web.client.TestRestTemplate ; import org.springframework.boot.test.web.server.LocalServerPort ; import org.springframework.test.annotation.DirtiesContext ; @SpringBootTest ( webEnvironment = SpringBootTest . WebEnvironment . RANDOM_PORT ) @DirtiesContext ( classMode = DirtiesContext . ClassMode . BEFORE_EACH_TEST_METHOD ) public class CategoryIT { @LocalServerPort private int port ; @Autowired private TestRestTemplate restTemplate ; } Estas clases son sencillas y tan solo tienen anotaciones espec\u00edficas de Spring Boot para cada tipo de test: @SpringBootTest . Esta anotaci\u00f3n lo que hace es inicializar el contexto de Spring cada vez que se inician los test de jUnit. Aunque el contexto tarda unos segundos en arrancar, lo bueno que tiene es que solo se inicializa una vez y se lanzan todos los jUnits en bater\u00eda con el mismo contexto. @DirtiesContext . Esta anotaci\u00f3n le indica a Spring que los test van a ser transaccionales, y por tanto cuando termine la ejecuci\u00f3n de cada uno de los test, autom\u00e1ticamente por la anotaci\u00f3n de arriba, Spring har\u00e1 un rearranque parcial del contexto y dejar\u00e1 el estado de la BBDD como estaba inicialmente. @ExtendWith . Esta anotaci\u00f3n le indica a Spring que no debe inicializar el contexto, ya que se trata de test est\u00e1ticos que no lo requieren. Para las pruebas de integraci\u00f3n nos faltar\u00e1 configurar la aplicaci\u00f3n de test, al igual que hicimos con la aplicaci\u00f3n 'productiva'. Deberemos abrir el fichero src/test/resources/application.properties y a\u00f1adir la configuraci\u00f3n de la BBDD. Para este tutorial vamos a utilizar la misma BBDD que la aplicaci\u00f3n productiva, pero de normal la aplicaci\u00f3n se conectar\u00e1 a una BBDD, generalmente f\u00edsica, mientras que los test jUnit se conectar\u00e1n a otra BBDD, generalmente en memoria. application.properties #Database spring.datasource.url = jdbc:h2:mem:testdb spring.datasource.username = sa spring.datasource.password = sa spring.datasource.driver-class-name = org.h2.Driver spring.jpa.database-platform = org.hibernate.dialect.H2Dialect spring.jpa.defer-datasource-initialization = true Con todo esto ya podemos crear nuestro primer test. Iremos a las clases CategoryIT y CategoryTest donde a\u00f1adiremos un m\u00e9todo p\u00fablico. Los test siempre tienen que ser m\u00e9todos p\u00fablicos que devuelvan el tipo void . CategoryTest.java CategoryIT.java package com.ccsw.tutorial.category ; import com.ccsw.tutorial.category.model.Category ; import com.ccsw.tutorial.category.model.CategoryDto ; import org.junit.jupiter.api.Test ; import org.junit.jupiter.api.extension.ExtendWith ; import org.mockito.InjectMocks ; import org.mockito.Mock ; import org.mockito.junit.jupiter.MockitoExtension ; import java.util.ArrayList ; import java.util.List ; import static org.junit.jupiter.api.Assertions.* ; import static org.mockito.Mockito.* ; @ExtendWith ( MockitoExtension . class ) public class CategoryTest { @Mock private CategoryRepository categoryRepository ; @InjectMocks private CategoryServiceImpl categoryService ; @Test public void findAllShouldReturnAllCategories () { List < Category > list = new ArrayList <> (); list . add ( mock ( Category . class )); when ( categoryRepository . findAll ()). thenReturn ( list ); List < Category > categories = categoryService . findAll (); assertNotNull ( categories ); assertEquals ( 1 , categories . size ()); } } package com.ccsw.tutorial.category ; import com.ccsw.tutorial.category.model.CategoryDto ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.boot.test.web.client.TestRestTemplate ; import org.springframework.boot.test.web.server.LocalServerPort ; import org.springframework.core.ParameterizedTypeReference ; import org.springframework.http.HttpMethod ; import org.springframework.http.ResponseEntity ; import org.springframework.test.annotation.DirtiesContext ; import java.util.List ; import static org.junit.jupiter.api.Assertions.* ; @SpringBootTest ( webEnvironment = SpringBootTest . WebEnvironment . RANDOM_PORT ) @DirtiesContext ( classMode = DirtiesContext . ClassMode . BEFORE_EACH_TEST_METHOD ) public class CategoryIT { public static final String LOCALHOST = \"http://localhost:\" ; public static final String SERVICE_PATH = \"/category\" ; @LocalServerPort private int port ; @Autowired private TestRestTemplate restTemplate ; ParameterizedTypeReference < List < CategoryDto >> responseType = new ParameterizedTypeReference < List < CategoryDto >> (){}; @Test public void findAllShouldReturnAllCategories () { ResponseEntity < List < CategoryDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . GET , null , responseType ); assertNotNull ( response ); assertEquals ( 3 , response . getBody (). size ()); } } Es muy importante marcar cada m\u00e9todo de prueba con la anotaci\u00f3n @Test , en caso contrario no se ejecutar\u00e1. Lo que se debe hacer en cada m\u00e9todo que implementemos es probar una y solo una acci\u00f3n. En los ejemplos anteriores (CategoryTest) , por un lado hemos comprobado el m\u00e9todo findAll() el cual por debajo invoca una llamada al repository de categor\u00eda, la cual hemos simulado con una respuesta ficticia limit\u00e1ndonos \u00fanicamente a la l\u00f3gica contenida en la operaci\u00f3n de negocio. Mientras que por otro lado (CategoryIT) , hemos probado la llamando al m\u00e9todo GET del endpoint http://localhost:XXXX/category comprobando que realmente nos devuelve 3 resultados, que son los que hay en BBDD inicialmente. Muy importante: Nomenclatura de los tests La nomenclatura de los m\u00e9todos de test debe sigue una estructura determinada. Hay muchas formas de nombrar a los m\u00e9todos, pero nosotros solemos utilizar la estructura 'should', para indicar lo que va a hacer. En el ejemplo anterior el m\u00e9todo 'findAll' debe devolver 'AllCategories'. De esta forma sabemos cu\u00e1l es la intenci\u00f3n del test, y si por cualquier motivo diera un fallo, sabemos que es lo que NO est\u00e1 funcionando de nuestra aplicaci\u00f3n. Para comprobar que el test funciona, podemos darle bot\u00f3n derecho sobre la clase de CategoryIT y pulsar en Run as -> JUnit Test . Si todo funciona correctamente, deber\u00e1 aparecer una pantalla de ejecuci\u00f3n y todos nuestros tests (en este caso solo uno) corriendo correctamente (en verde). El proceso es el mismo para la clase CategoryTest .","title":"Pruebas de listado"},{"location":"develop/basic/springboot/#pruebas-de-creacion","text":"Vamos con los siguientes test, los que probar\u00e1n una creaci\u00f3n de una nueva Categor\u00eda . A\u00f1adimos el siguiente m\u00e9todo a la clase de test: CategoryTest.java CategoryIT.java public static final String CATEGORY_NAME = \"CAT1\" ; @Test public void saveNotExistsCategoryIdShouldInsert () { CategoryDto categoryDto = new CategoryDto (); categoryDto . setName ( CATEGORY_NAME ); ArgumentCaptor < Category > category = ArgumentCaptor . forClass ( Category . class ); categoryService . save ( null , categoryDto ); verify ( categoryRepository ). save ( category . capture ()); assertEquals ( CATEGORY_NAME , category . getValue (). getName ()); } public static final Long NEW_CATEGORY_ID = 4L ; public static final String NEW_CATEGORY_NAME = \"CAT4\" ; @Test public void saveWithoutIdShouldCreateNewCategory () { CategoryDto dto = new CategoryDto (); dto . setName ( NEW_CATEGORY_NAME ); restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . PUT , new HttpEntity <> ( dto ), Void . class ); ResponseEntity < List < CategoryDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . GET , null , responseType ); assertNotNull ( response ); assertEquals ( 4 , response . getBody (). size ()); CategoryDto categorySearch = response . getBody (). stream (). filter ( item -> item . getId (). equals ( NEW_CATEGORY_ID )). findFirst (). orElse ( null ); assertNotNull ( categorySearch ); assertEquals ( NEW_CATEGORY_NAME , categorySearch . getName ()); } En el primer caso, estamos construyendo un objeto CategoryDto para darle un nombre a la Categor\u00eda e invocamos a la operaci\u00f3n save pasandole un ID a nulo. Para identificar que el funcionamiento es el esperado, capturamos la categor\u00eda que se proporciona al repository al intentar realizar la acci\u00f3n ficticia de guardado y comprobamos que el valor es el que se proporciona en la invocaci\u00f3n. De forma similar en el segundo caso, estamos construyendo un objeto CategoryDto para darle un nombre a la Categor\u00eda e invocamos al m\u00e9todo PUT sin a\u00f1adir en la ruta referencia al identificador. Seguidamente, recuperamos de nuevo la lista de categor\u00edas y en este caso deber\u00eda tener 4 resultados. Hacemos un filtrado buscando la nueva Categor\u00eda que deber\u00eda tener un ID = 4 y deber\u00eda ser la que acabamos de crear. Si ejecutamos, veremos que ambos test ahora aparecen en verde.","title":"Pruebas de creaci\u00f3n"},{"location":"develop/basic/springboot/#pruebas-de-modificacion","text":"Para este caso de prueba, vamos a realizar varios test, como hemos comentado anteriormente. Tenemos que probar que es lo que pasa cuando intentamos modificar un elemento que existe, pero tambi\u00e9n debemos probar que es lo que pasa cuando intentamos modificar un elemento que no existe. Empezamos con el sencillo, un test que pruebe una modificaci\u00f3n existente. CategoryTest.java CategoryIT.java public static final Long EXISTS_CATEGORY_ID = 1L ; @Test public void saveExistsCategoryIdShouldUpdate () { CategoryDto categoryDto = new CategoryDto (); categoryDto . setName ( CATEGORY_NAME ); Category category = mock ( Category . class ); when ( categoryRepository . findById ( EXISTS_CATEGORY_ID )). thenReturn ( Optional . of ( category )); categoryService . save ( EXISTS_CATEGORY_ID , categoryDto ); verify ( categoryRepository ). save ( category ); } public static final Long MODIFY_CATEGORY_ID = 3L ; @Test public void modifyWithExistIdShouldModifyCategory () { CategoryDto dto = new CategoryDto (); dto . setName ( NEW_CATEGORY_NAME ); restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + MODIFY_CATEGORY_ID , HttpMethod . PUT , new HttpEntity <> ( dto ), Void . class ); ResponseEntity < List < CategoryDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . GET , null , responseType ); assertNotNull ( response ); assertEquals ( 3 , response . getBody (). size ()); CategoryDto categorySearch = response . getBody (). stream (). filter ( item -> item . getId (). equals ( MODIFY_CATEGORY_ID )). findFirst (). orElse ( null ); assertNotNull ( categorySearch ); assertEquals ( NEW_CATEGORY_NAME , categorySearch . getName ()); } En el caso de los test unitarios, comprobamos la l\u00f3gica de la modificaci\u00f3n simulando que el repository nos devuelve una categor\u00eda que modificar y verificado que se invoca el guardado sobre la misma. En el caso de los test de integraci\u00f3n, la misma filosof\u00eda que en el test anterior, pero esta vez modificamos la Categor\u00eda de ID = 3. Luego la filtramos y vemos que realmente se ha modificado. Adem\u00e1s comprobamos que el listado de todas los registros sigue siendo 3 y no se ha creado un nuevo registro. En el siguiente test, probaremos un resultado err\u00f3neo. CategoryIT.java @Test public void modifyWithNotExistIdShouldInternalError () { CategoryDto dto = new CategoryDto (); dto . setName ( NEW_CATEGORY_NAME ); ResponseEntity <?> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + NEW_CATEGORY_ID , HttpMethod . PUT , new HttpEntity <> ( dto ), Void . class ); assertEquals ( HttpStatus . INTERNAL_SERVER_ERROR , response . getStatusCode ()); } Intentamos modificar el ID = 4, que no deber\u00eda existir en BBDD y por tanto lo que se espera en el test es que lance un 500 Internal Server Error al llamar al m\u00e9todo PUT .","title":"Pruebas de modificaci\u00f3n"},{"location":"develop/basic/springboot/#pruebas-de-borrado","text":"Ya por \u00faltimo implementamos las pruebas de borrado. CategoryTest.java CategoryIT.java @Test public void deleteExistsCategoryIdShouldDelete () throws Exception { Category category = mock ( Category . class ); when ( categoryRepository . findById ( EXISTS_CATEGORY_ID )). thenReturn ( Optional . of ( category )); categoryService . delete ( EXISTS_CATEGORY_ID ); verify ( categoryRepository ). deleteById ( EXISTS_CATEGORY_ID ); } public static final Long DELETE_CATEGORY_ID = 2L ; @Test public void deleteWithExistsIdShouldDeleteCategory () { restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + DELETE_CATEGORY_ID , HttpMethod . DELETE , null , Void . class ); ResponseEntity < List < CategoryDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . GET , null , responseType ); assertNotNull ( response ); assertEquals ( 2 , response . getBody (). size ()); } @Test public void deleteWithNotExistsIdShouldInternalError () { ResponseEntity <?> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + NEW_CATEGORY_ID , HttpMethod . DELETE , null , Void . class ); assertEquals ( HttpStatus . INTERNAL_SERVER_ERROR , response . getStatusCode ()); } En cuanto al test unitario, se invoca a la operaci\u00f3n delete y se verifica que la operaci\u00f3n requerida del repository es invocado con el atributo correcto. En lo relativo a las pruebas de integraci\u00f3n, en el primer test, se invoca el m\u00e9todo DELETE y posteriormente se comprueba que el listado tiene un tama\u00f1o de 2 (uno menos que el original). Mientras que en el segundo test, se comprueba que con ID no v\u00e1lido, devuelve un 500 Internal Server Error . Con esto tendr\u00edamos m\u00e1s o menos probados los casos b\u00e1sicos de nuestra aplicaci\u00f3n y tendr\u00edamos una peque\u00f1a red de seguridad que nos ayudar\u00eda por si a futuro necesitamos hacer alg\u00fan cambio o evolutivo.","title":"Pruebas de borrado"},{"location":"develop/basic/springboot/#que-hemos-aprendido","text":"Resumiendo un poco los pasos que hemos seguido: Hay que definir y agrupar por \u00e1mbito funcional, hemos creado el package com.ccsw.tutorial.category para aglutinar todas las clases. Lo primero que debemos empezar a construir siempre son los test, aunque en este cap\u00edtulo del tutorial lo hemos hecho al rev\u00e9s solo con fines did\u00e1cticos. En los siguientes cap\u00edtulos lo haremos de forma correcta, y esto nos ayudar\u00e1 a pensar y dise\u00f1ar que es lo que queremos implementar realmente. La implementaci\u00f3n de la aplicaci\u00f3n se deber\u00eda separar por capas: Controller \u2192 Maneja las peticiones de entrada del cliente y realiza transformaciones. No ejecuta directamente l\u00f3gica de negocio, para eso utiliza llamadas a la siguiente capa. Service \u2192 Ejecuta la l\u00f3gica de negocio en sus m\u00e9todos o llamando a otros objetos de la misma capa. No ejecuta directamente accesos a datos, para eso utiliza la siguiente capa. Repository \u2192 Realiza los accesos a datos de lectura y escritura. NUNCA debe llamar a otros objetos de la misma capa ni de capas anteriores. Hay que tener en cuenta los objetos modelo que se mueven en cada capa. Generalmente son: Json \u2192 Los datos que vienen y van del cliente al Controller . DTO \u2192 Los datos se mueven dentro del Controller y sirven para invocar llamadas. Tambi\u00e9n son los datos que devuelve un Controller . Entity \u2192 Los datos que sirven para persistir y leer datos de una BBDD y que NUNCA deber\u00edan ir m\u00e1s all\u00e1 del Controller .","title":"\u00bfQ\u00fae hemos aprendido?"},{"location":"develop/basic/springboot/#depuracion","text":"Una parte muy importante del desarrollo es tener la capacidad de depurar nuestro c\u00f3digo, en este apartado vamos a explicar como se realiza debug en Backend. Esta parte se realiza con las herramientas incluidas dentro de nuestro IDE favorito, en este caso vamos a utilizar el Eclipse. Lo primero que debemos hacer es arrancar la aplicaci\u00f3n en modo Debug : Arrancada la aplicaci\u00f3n en este modo, vamos a depurar la operaci\u00f3n de crear categor\u00eda. Para ello vamos a abrir nuestro fichero donde tenemos la implementaci\u00f3n del servicio de creaci\u00f3n de la capa de la l\u00f3gica de negocio CategoryServiceImpl . Dentro del fichero ya podemos a\u00f1adir puntos de ruptura (breakpoint), en nuestro caso queremos comprobar que el nombre introducido se recibe correctamente. Colocamos el breakpoint en la primera l\u00ednea del m\u00e9todo (click sobre el n\u00famero de la l\u00ednea) y desde la interfaz/postman creamos una nueva categor\u00eda. Hecho esto, podemos observar que a nivel de interfaz/postman, la petici\u00f3n se queda esperando y el IDE pasa modo Debug (la primera vez nos preguntar\u00e1 si queremos hacerlo, le decimos que si): El IDE nos lleva al punto exacto donde hemos a\u00f1adido el breakpoint y se para en este punto ofreci\u00e9ndonos la posibilidad de explorar el contenido de las variables del c\u00f3digo: Aqu\u00ed podemos comprobar que efectivamente el atributo name de la variable dto tiene el valor que hemos introducido por pantalla/postman. Para continuar con la ejecuci\u00f3n basta con darle al bot\u00f3n de play de la barra de herramientas superior. Nota: para volver al modo Java de Eclipse, presionamos el bot\u00f3n que se sit\u00faa a la izquierda del modo Debug en el que ha entrado el IDE autom\u00e1ticamente.","title":"Depuraci\u00f3n"},{"location":"develop/basic/vuejs/","text":"Listado simple - VUE Ahora que ya tenemos listo el proyecto frontend de VUE, ya podemos empezar a codificar la soluci\u00f3n. Primeros pasos Antes de empezar Quiero hacer hincapi\u00e9 que VUE tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. En la propia web de documentaci\u00f3n de VUE puedes buscar casi cualquier ejemplo que necesites. Si abrimos el proyecto con el IDE que tengamos (Visual Studio Code en el caso del tutorial) podemos ver que en la carpeta src/ existen unos ficheros ya creados por defecto. Estos ficheros son: App.vue \u2192 contiene el c\u00f3digo inicial del proyecto. main.ts \u2192 es el punto de entrada a la aplicaci\u00f3n. Lo primero que vamos a hacer es instalar SASS para poder trabajar con este preprocesador CSS, para ello tendremos que irnos a la terminal, en la misma carpeta donde tenemos el proyecto y ejecutar el siguiente comando: npm install -D sass Con esto ya lo tendremos instalado y para usarlo es tan f\u00e1cil como poner la etiqueta style de esta manera: <style lang=\"scss\"></style> <---> con Sass activado <style></style> <---> sin Sass, css normal En los estilos tambi\u00e9n veremos la propiedad scoped en VUE, el atributo scoped se utiliza para limitar el \u00e1mbito de los estilos de un componente a los elementos del propio componente y no a los elementos hijos o padres, lo que ayuda a evitar conflictos de estilo entre los diferentes componentes de una aplicaci\u00f3n. Esto significa que los estilos definidos en una etiqueta <style scoped> solo se aplicar\u00e1n a los elementos dentro del componente actual, y no se propagar\u00e1n a otros componentes en la jerarqu\u00eda del DOM. De esta manera, se puede evitar que los estilos de un componente afecten a otros componentes en la aplicaci\u00f3n. <style scoped></style> <---> Estos estilos solo afectar\u00e1n al componente donde se aplican <style></style> <---> Estos estilos son generales y afectan a toda la aplicaci\u00f3n. Con estas cositas sobre los estilos en cabeza vamos lo primero a limpiar la aplicaci\u00f3n para poder empezar a trabajar desde cero. Entraremos en la carpeta assets y borraremos todos los archivos excepto base.css . Entraremos en la carpeta components y borraremos todos los archivos dejando solo la carpeta que usaremos m\u00e1s adelante. La carpeta router la dejaremos tal cual esta, sin tocar nada. Entraremos en la carpeta views y borraremos todos los archivos dejando solo la carpeta que usaremos m\u00e1s adelante. Con esto tenemos nuestra estructura preparada y quedar\u00eda tal que asi: Vamos a a\u00f1adir unas l\u00edneas al tsconfig.json para que el typescript deje de marcarnos lo como error, lo dejaremos asi: tsconfig.json { \"extends\" : \"@vue/tsconfig/tsconfig.web.json\" , \"include\" : [ \"env.d.ts\" , \"src/**/*\" , \"src/**/*.vue\" ], \"compilerOptions\" : { \"preserveValueImports\" : false , \"importsNotUsedAsValues\" : \"remove\" , \"verbatimModuleSyntax\" : true , \"baseUrl\" : \".\" , \"paths\" : { \"@/*\" : [ \"./src/*\" ] } }, \"references\" : [ { \"path\" : \"./tsconfig.node.json\" } ] } Para que la aplicaci\u00f3n funcione de nuevo y poder empezar a trabajar faltar\u00eda hacer un par de cositas que os explico: En \u00e9l base.css no hace falta cambiar nada para que funcione, pero tenemos muchas cosas que seguramente no vamos a usar, este archivo lo conservamos solamente para trabajar en variables css todo el tema de los colores de nuestra web o algunas otras cositas como el ancho del menu o del header, etc\u2026 Lo primero vamos a eliminar todas las variables CSS y crearnos las nuestras propias con nuestro color primario y secundario tanto para botones y dem\u00e1s como para texto y tambi\u00e9n para el background principal. Tenemos que dejar nuestro archivo de esta manera: base.css : root { --primary : #2a6fa8 ; --secondary : #12abdb ; --text-ligth : #2c3e50 ; --text-dark : #fff ; --background-color : #fff ; } *, * :: before , * :: after { box-sizing : border-box ; margin : 0 ; position : relative ; font-weight : normal ; } body { min-height : 100 vh ; color : var ( --text-ligth ); background : var ( --background-color ); line-height : 1.6 ; font-family : Inter , - apple-system , BlinkMacSystemFont , 'Segoe UI' , Roboto , Oxygen , Ubuntu , Cantarell , 'Fira Sans' , 'Droid Sans' , 'Helvetica Neue' , sans-serif ; font-size : 16 px ; text-rendering : optimizeLegibility ; -webkit- font-smoothing : antialiased ; -moz- osx-font-smoothing : grayscale ; } Despu\u00e9s vamos a abrir el archivo main.ts y cambiaremos el import que hace del CSS por el base que es el que estamos usando, quedar\u00eda de esta manera: main.ts import { createApp } from 'vue' import App from './App.vue' import router from './router' import './assets/base.css' const app = createApp ( App ) app . use ( router ) app . mount ( '#app' ) Luego abriremos el archivo App.vue y lo dejaremos solo como la entrada a la aplicaci\u00f3n, esto ya son maneras de trabajar de cada uno, pero a m\u00ed me gusta hacerlo asi para tener si hiciera falta diferentes layouts, uno con header y men\u00fa, otro sin header y men\u00fa, otro de la parte de admin, etc\u2026 Lo dejaremos exactamente asi: App.vue < script setup lang = \"ts\" > import { RouterView } from 'vue-router' </ script > < template > < RouterView /> </ template > Por \u00faltimo crearemos nuestro layout principal al que iremos a\u00f1adiendo luego toda nuestra aplicaci\u00f3n. Lo primero nos pondremos en src y crearemos una nueva carpeta llamada layouts , dentro de esta carpeta crearemos otra que se llamara main-layout (esto lo hacemos por si luego tenemos m\u00e1s de un layout que cada uno tenga su carpeta para tener sus propias cosas) y dentro de la carpeta main-layout crearemos el archivo MainLayout.vue , nos deber\u00eda de quedar asi: Una vez tenemos el archivo MainLayout.vue creado lo abriremos y escribiremos el siguiente c\u00f3digo: MainLayout.vue < script setup lang = \"ts\" > const helloWorld = 'Hola Mundo' ; </ script > < template > < h1 > {{ helloWorld }} </ h1 > </ template > Vamos a intentar explicar este c\u00f3digo un poco: Dentro de las etiquetas script metemos todo el c\u00f3digo Javascript, en este caso como vamos a trabajar con Typescript le ponemos la etiqueta Lang=\u201dts\u201d para que el compilador sepa que estamos trabajando con Typescript. Ponemos la palabra setup porque estamos trabajando con la composition api , en VUE podemos trabajar con la options api y con la composition api , nosotros vamos a usar la composition api que aunque al principio cuesta un poco m\u00e1s, luego nos va a hacer la vida much\u00edsimo m\u00e1s f\u00e1cil, sobre todo en aplicaciones \"reales\". Dentro de las etiquetas template va el HTML y como estamos usando el m\u00e9todo setup no necesitamos retornar nada para poder acceder a ello desde la plantilla. Las llaves dobles permiten hacen un binding entre el c\u00f3digo del componente y la plantilla. Es decir, en este caso ir\u00e1 al c\u00f3digo TypeScript y buscar\u00e1 el valor de la variable helloWorld. Consejo El binding tambi\u00e9n nos sirve para ejecutar los m\u00e9todos de TypeScript desde el c\u00f3digo HTML. Adem\u00e1s, si el valor que contiene la variable se modificar\u00e1 durante la ejecuci\u00f3n de alg\u00fan m\u00e9todo, autom\u00e1ticamente el c\u00f3digo HTML refrescar\u00eda el nuevo valor de la variable helloWorld . Ponemos en marcha la aplicaci\u00f3n con npm run dev . Si abrimos el navegador y accedemos a http://localhost:5173/ podremos ver el resultado del c\u00f3digo. Layout general Crear componente Lo primero que vamos a hacer es escoger un tema y una paleta de componentes para trabajar. VUE no tiene una librer\u00eda de componentes oficial al igual que, por ejemplo, Angular tiene Material, por lo que podremos elegir entre las diferentes opciones y ver la que m\u00e1s se ajusta a las necesidades del proyecto o crearnos la nuestra propia, si entramos en proyectos ya comenzados, seguramente este paso ya habr\u00e1 sido abordado y ya sabr\u00e1s con qu\u00e9 librer\u00eda de componentes trabajar, para este proyecto vamos a optar por PrimeVue , no tenemos ning\u00fan motivo especial para decidir esa en especial, pero la hemos usado en un curso anterior y optamos por seguir con la misma librer\u00eda. Para instalarla bastar\u00e1 con seguir los pasos de su documentaci\u00f3n . Vamos a hacerlo y la instalamos en nuestro proyecto: Lo primero ejecutaremos el comando npm o yarn para instalarla, en mi caso lo hare con npm: npm install primevue Despu\u00e9s instalaremos PrimeVue con la funci\u00f3n use en el main.ts que es donde tenemos nuestra configuraci\u00f3n, quedando asi nuestro main.ts : Despu\u00e9s a\u00f1adiremos los estilos necesarios a nuestro main.ts : Por \u00faltimo en nuestro base.css cambiaremos la fuente del proyecto por la que trae el tema de PrimeVue, cambiando en el body la l\u00ednea: base.css ... font-family : Inter , -apple-system , BlinkMacSystemFont , 'Segoe UI' , Roboto , Oxygen , Ubuntu , Cantarell , 'Fira Sans' , 'Droid Sans' , 'Helvetica Neue' , sans-serif ; ... Por: base.css ... font-family : ( --font-family ); ... Recuerda Al a\u00f1adir una nueva librer\u00eda tenemos que parar el servidor y volver a arrancarlo para que compile y pre-cargue las nuevas dependencias. Una vez a\u00f1adida la dependencia, lo que queremos es crear una primera estructura inicial a la p\u00e1gina. Si te acuerdas cual era la estructura (y si no te acuerdas, vuelve a la secci\u00f3n Contexto de la aplicaci\u00f3n y lo revisas), ten\u00edamos una cabecera superior con un logo y t\u00edtulo y unas opciones de men\u00fa. Antes de empezar a crear y programar vamos a instalar unas extensiones en Visual Studio Code que nos har\u00e1n la vida mucho mas f\u00e1cil, en cada una de ellas podeis ver una descripci\u00f3n de que hacen y para que sirven, tu ya dices si la quieres instalar o no, nosotros vamos a trabajar con ellas y por eso te las recomendamos: Vue Volar extension Pack Vue Discovery IntelliCode npm Intellisense Vue VSCode Snippets Para poder seguir trabajando con comodidad vamos a a\u00f1adir una fuente de iconos para todos los iconitos que usemos en la aplicaci\u00f3n, nosotros vamos a usar Material porque es la que estamos acostumbrados, para a\u00f1adirla tenemos una gu\u00eda . Lo haremos paso a paso: Lo primero a\u00f1adimos al index.html la fuente a trav\u00e9s de Google fonts, hay muchas otras maneras de hacerlo, como bajarla y servirla desde local, pero para este tutorial vamos a usar esta por ser la m\u00e1s f\u00e1cil, para a\u00f1adirla pegaremos en el index.html esta l\u00ednea: <link href=\"https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined\" rel=\"stylesheet\" /> Quedando de esta manera: index.html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < link rel = \"icon\" href = \"/favicon.ico\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < link href = \"https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined\" rel = \"stylesheet\" /> < title > Vite App </ title > </ head > < body > < div id = \"app\" ></ div > < script type = \"module\" src = \"/src/main.ts\" ></ script > </ body > </ html > Para que no nos salga el error de comments, a\u00f1adiremos al eslintrc.js estas l\u00edneas: eslintrc.js ... rules : { 'vue/comment-directive' : 'off' } ... Despu\u00e9s nos iremos al fichero base.css y a\u00f1adiremos esto al final del archivo: base.css ... . material-symbols-outlined { font-family : \"Material Symbols Outlined\" , sans-serif ; font-weight : normal ; font-style : normal ; font-size : 24 px ; /* Preferred icon size */ display : inline-block ; line-height : 1 ; text-transform : none ; letter-spacing : normal ; word-wrap : normal ; white-space : nowrap ; direction : ltr ; } Con esto ya tendremos a\u00f1adida la fuente material-symbols y podremos usar todos los iconos disponibles . Despu\u00e9s instalaremos tambi\u00e9n los iconos de PrimeVue para poder usarlos f\u00e1cilmente en los componentes, lo primero pondremos: npm install primeicons Una vez instalados, importaremos los iconos en el main.ts poniendo este import debajo de todos los de css: main.ts ... import 'primeicons/primeicons.css' ; ... Con esto ya lo tendr\u00edamos todo. Pues vamos a ello, con las extensiones ya instaladas y la fuente para los iconos a\u00f1adida crearemos esa estructura com\u00fan para toda la aplicaci\u00f3n. Lo primero crearemos el componente header, dentro de la carpeta components al ser un m\u00f3dulo de la aplicaci\u00f3n y no especifico de una vista o p\u00e1gina. Para eso crearemos una nueva carpeta dentro de components que llamaremos header, nos situaremos encima de la carpeta header y crearemos el archivo HeaderComponent.vue , con el archivo vac\u00edo escribiremos, vbase-3-ts-setup y conforme lo escribimos nos aparecer\u00e1 esto: Consejo Esto nos aparece gracias a las extensiones que hemos instalado, aseg\u00farate de instalarlas para que aparezca o si no las quieres instalar lo puedes crear a mano. Si no te aparece y has instalado las extensiones, cierra vscode y vu\u00e9lvelo a abrir. Podemos seleccionar vbase-3-ts-setup , esto es un snippet que lo que har\u00e1 es generarnos todo el c\u00f3digo de un componente vac\u00edo y lo dejara asi: HeaderComponent.vue < template > < div > </ div > </ template > < script setup lang = \"ts\" > </ script > < style scoped > </ style > Con esto solo nos faltar\u00eda agregar a la etiqueta style que vamos a trabajar con Sass y la dejar\u00edamos asi: HeaderComponent.vue ... < style lang = \"scss\" scoped > </ style > ... Si os dais cuenta hemos a\u00f1adido Lang=\u201dscss\u201d y con esto ya estamos preparados para crear nuestro componente. Para continuar cambiaremos el c\u00f3digo del HeaderComponent.vue por este: HeaderComponent.vue < template > < div class = \"card relative z-2\" > < Menubar :model = \"items\" > < template # start > < span class = \"material-symbols-outlined\" > storefront </ span > < span class = \"title\" > LUDOTECA TAN </ span > </ template > < template # end > < Avatar icon = \"pi pi-user\" class = \"mr-2 avatar-image\" size = \"large\" shape = \"circle\" /> < span class = \"sign-text\" > Sign in </ span > </ template > </ Menubar > </ div > </ template > < script setup lang = \"ts\" > import { ref } from \"vue\" ; import Menubar from \"primevue/menubar\" ; import Avatar from \"primevue/avatar\" ; const items = ref ([ { label : \"Cat\u00e1logo\" , }, { label : \"Categor\u00edas\" , }, { label : \"Autores\" , }, ]); </ script > < style lang = \"scss\" scoped > . p-menubar { padding : 0.5 rem ; background : var ( --primary ); color : var ( --text-dark ); border : none ; border-radius : 0 px ; } . title { margin-left : 1 rem ; font-weight : 600 ; } . avatar-image { background-color : var ( --secondary ); color : var ( --text-dark ); border : 1 px solid var ( --text-dark ); cursor : pointer ; } . sign-text { color : var ( --text-dark ); margin-left : 1 rem ; cursor : pointer ; } : deep ( . p-menubar-start ) { display : flex ; flex-direction : row ; align-items : center ; justify-content : center ; margin-right : 1 rem ; } : deep ( . p-menubar-end ) { display : flex ; flex-direction : row ; align-items : center ; justify-content : center ; } : deep ( . p-menuitem-text ) { color : var ( --text-dark ) !important ; } : deep ( . p-menuitem-content : hover ) { background : var ( --secondary ) !important ; } . material-symbols-outlined { font-size : 36 px ; } </ style > Intentaremos explicarlo un poco: En el template estamos a\u00f1adiendo el Menubar de la librer\u00eda de componentes que estamos utilizando, si queremos saber como se a\u00f1ade podemos verlo en este link . Veremos que lo primero que hacemos es el import dentro de las etiquetas <script> para poder tener el componente disponible y poder usarlo. HeaderComponent.vue ... import Menubar from \"primevue/menubar\"; ... Luego, con el import ya hecho, podemos copiar el HTML que nos dan y ponerlo en nuestro componente: HeaderComponent.vue ... < div class = \"card relative z-2\" > < Menubar :model = \"items\" > < template # start > < span class = \"material-symbols-outlined\" > storefront </ span > < span class = \"title\" > LUDOTECA TAN </ span > </ template > < template # end > < Avatar icon = \"pi pi-user\" class = \"mr-2 avatar-image\" size = \"large\" shape = \"circle\" /> < span class = \"sign-text\" > Sign in </ span > </ template > </ Menubar > </ div > ... Si os dais cuenta es el c\u00f3digo que ellos nos dan retocado para cubrir nuestras necesidades, primero hemos metido un icono de material dentro del template #start que es lo que se situara al principio pegado a la izquierda del Menubar y tras el icono metemos el t\u00edtulo. El template #end se situar\u00e1 al final pegado a la derecha y alli estamos metiendo otro componente de la librer\u00eda de componentes, pod\u00e9is ver la info de como usarlo en este link . Este simplemente lo pegamos como esta y le a\u00f1adimos detr\u00e1s la frase Sign in . En la parte del script metemos todo nuestro Javascript/Typescript: HeaderComponent.vue ... < script setup lang = \"ts\" > import { ref } from \"vue\" ; import Menubar from \"primevue/menubar\" ; import Avatar from \"primevue/avatar\" ; const items = ref ([ { label : \"Cat\u00e1logo\" , }, { label : \"Categor\u00edas\" , }, { label : \"Autores\" , }, ]); </ script > ... Si os dais cuenta, lo \u00fanico que estamos haciendo son los imports necesarios para que todo funcione y creando una variable \u00edtems que es la que luego estamos usando en el men\u00fa para pintar los diferentes menus. Si os dais cuenta envolvemos el valor de la variable dentro de ref() . En Vue 3, la funci\u00f3n ref() se utiliza para crear una referencia reactiva a un valor. Una referencia reactiva es un objeto que puede ser pasado como prop, utilizado en una plantilla, y observado para detectar cambios en su valor. La funci\u00f3n ref() toma un valor como argumento y devuelve un objeto con una propiedad value que contiene el valor proporcionado. Por ejemplo, si queremos crear una referencia a un n\u00famero entero, podemos hacer lo siguiente: import { ref } from 'vue' const myNumber = ref(42) console.log(myNumber.value) // 42 La referencia myNumber es ahora un objeto con una propiedad value que contiene el valor 42 . Si cambiamos el valor de la propiedad value , la referencia notificar\u00e1 a cualquier componente que est\u00e9 observando el valor que ha cambiado. Por ejemplo: myNumber.value = 21 console.log(myNumber.value) // 21 Cualquier componente que est\u00e9 utilizando myNumber se actualizar\u00e1 autom\u00e1ticamente para reflejar el nuevo valor. La funci\u00f3n ref() es muy \u00fatil en Vue 3 para crear referencias reactivas a valores que pueden cambiar con el tiempo. En los styles tenemos poco que explicar, simplemente estamos haciendo que se vea como nosotros queremos, que todos los colores y dem\u00e1s los traemos de las variables que hemos creado antes en el base.css y adem\u00e1s me gustar\u00eda mencionar una cosa: HeaderComponent.vue ... :deep(.p-menubar-start) { display: flex; flex-direction: row; align-items: center; justify-content: center; margin-right: 1rem; } ... Si os dais cuenta algunos estilos llevan el :Deep delante, como seguro ya sabes, puedes utilizar el atributo scoped dentro de la etiqueta <style> para escribir CSS y as\u00ed impedir que tus estilos afecten a posibles sub-componentes. Pero, \u00bfqu\u00e9 ocurre si necesitas que al menos una regla s\u00ed afecte a tu componente hijo?. Para ello puedes usar la pseudo-clase :deep de Vue 3. En este ejemplo lo hemos creado asi para que sepas de su existencia y busques un poco de informaci\u00f3n sobre ella y las otras que existen, este CSS lo podr\u00edamos poner en el styles.scss principal y no tendr\u00edamos que poner el :deep que seria lo mas recomendado. Es importante tener en cuenta que la directiva :deep puede tener un impacto en el rendimiento, ya que Vue necesita buscar en todo el \u00e1rbol de elementos para aplicar los estilos. Por lo tanto, se recomienda utilizar esta directiva con moderaci\u00f3n y solo en casos en los que sea necesario seleccionar elementos anidados de forma din\u00e1mica. Tenerlo en cuenta y solo usarla cuando de verdad sea necesario. Ya por \u00faltimo nos iremos a nuestro MainLayout.vue y a\u00f1adiremos el header que acabamos de crearnos: MainLayout.vue < script setup lang = \"ts\" > import HeaderComponent from '@/components/header/HeaderComponent.vue' ; const helloWorld = 'Hola Mundo' ; </ script > < template > < HeaderComponent ></ HeaderComponent > < h1 > {{ helloWorld }} </ h1 > </ template > Como antes, lo \u00fanico que hacemos es importar el componente en el script y usarlo en el HTML. Lo siguiente iremos a la carpeta router , al archivo index.ts y lo dejaremos asi: index.ts import { createRouter , createWebHistory } from 'vue-router' import MainLayout from '@/layouts/main-layout/MainLayout.vue' const router = createRouter ({ history : createWebHistory ( import . meta . env . BASE_URL ), routes : [ { path : '/' , name : 'home' , component : MainLayout } ] }) export default router Hemos cambiado la ruta principal para que apunte a nuestro layout y nada m\u00e1s entrar en la aplicaci\u00f3n lo carguemos gracias al router de VUE. Si guardamos todo y ponemos en marcha el proyecto ya veremos algo como esto: Creando un listado b\u00e1sico Crear componente Ya tenemos la estructura principal, ahora vamos a crear nuestra primera pantalla. Vamos a empezar por la de Categor\u00edas que es la m\u00e1s sencilla, ya que se trata de un listado, que muestra datos sin filtrar ni paginar. Como categor\u00edas es un dominio funcional de la aplicaci\u00f3n, vamos a crear una nueva carpeta dentro de la carpeta views llamada categories, todas las pantallas, componentes y servicios que creemos, referidos a este dominio funcional, deber\u00e1n ir dentro del m\u00f3dulo categories. Dentro de esa carpeta crearemos un fichero que se llamara CategoriesView.vue y dentro nos crearemos el esqueleto de la misma manera que hicimos anteriormente. Escribiremos vbase-3-ts-setup , le daremos al enter y nos generara toda la estructura a la que solo faltara agregar a la etiqueta <style> Lang=\u201dscss\u201d para decirle que vamos a trabajar con SASS. Con esto tenemos nuestra vista preparada para empezar a trabajar. Lo primero vamos a conectar nuestro componente al router para que cuando hagamos click en el men\u00fa correspondiente podamos llegar hasta \u00e9l y tambi\u00e9n para poder ver lo que vamos trabajando. Para ello lo primero que vamos a hacer en el template de nuestro componente es a\u00f1adir cualquier cosa para saber que estamos donde toca, por ejemplo: CategoriesView.vue < template > < div > SOY CATEGORIAS </ div > </ template > Con esto cuando entremos en la ruta de categor\u00edas deber\u00edamos ver SOY CATEGORIAS . Lo siguiente crearemos en el layout un sitio para cargar todas nuestras rutas que van a ir dentro de ese layout, para ello iremos al archivo MainLayout.vue y a\u00f1adiremos un <RouterView /> que ser\u00e1 el segundo de nuestra aplicaci\u00f3n, el primero lo tenemos en el App.vue que servir\u00e1 para cargar nuestras rutas principales (diferentes layouts, pagina 404, etc) y el segundo es este que acabamos de crear, podemos tener tantos como queramos en una aplicaci\u00f3n y cada uno tendr\u00e1 su cometido. Este que acabamos de crear ser\u00e1 donde se cargaran todas las rutas que quieran estar dentro del layout principal. Para crearlo importaremos \u00e9l RouterView dentro de los <script> desde vue-router : MainLayout.vue import { RouterView } from 'vue-router'; Lo a\u00f1adiremos dentro de los <template> exactamente donde queramos cargar las rutas y si puede ser con un div padre que haga de contenedor asi podremos darle los estilos sin sufrir demasiado. MainLayout.vue < div class = \"outlet-container\" > < RouterView /> </ div > Y luego dentro de <style> le daremos estilo al contenedor padre de acuerdo a lo que necesitemos (grid, flex, etc\u2026) en este ejemplo para hacerlo f\u00e1cil lo haremos con flex, con todo esto quedar\u00eda asi: MainLayout.vue < script setup lang = \"ts\" > import { RouterView } from 'vue-router' ; import HeaderComponent from \"@/components/header/HeaderComponent.vue\" ; </ script > < template > < HeaderComponent ></ HeaderComponent > < div class = \"outlet-container\" > < RouterView /> </ div > </ template > < style lang = \"scss\" scoped > . outlet-container { display : flex ; flex-direction : column ; flex-grow : 1 ; width : 100 % ; min-height : calc ( 100 vh - 65 px ); padding : 1 rem ; } </ style > Ahora vamos a a\u00f1adirlo a nuestras rutas, para ello nos vamos a la carpeta router y dentro tendremos el index.ts con nuestras rutas actuales, vamos a a\u00f1adir la nueva ruta como hija de layout para que siempre se muestre dentro del layout que hemos creado con \u00e9l header : index.ts import { createRouter , createWebHistory } from 'vue-router' import MainLayout from '@/layouts/main-layout/MainLayout.vue' const router = createRouter ({ history : createWebHistory ( import . meta . env . BASE_URL ), routes : [ { path : '/' , name : 'home' , component : MainLayout , children : [ { path : '/categories' , name : 'categories' , component : () => import ( '../views/categories/CategoriesView.vue' ) } ] } ] }) export default router Si os dais cuenta lo hemos a\u00f1adido como hijo de layout y adem\u00e1s lo hemos hecho con lazy loading , es decir, este componente solo se cargara cuando el usuario navegue a esa ruta, asi evitamos cargas much\u00edsimo m\u00e1s grandes al inicio de la aplicaci\u00f3n. Posteriormente nos iremos al HeaderComponent.vue y a\u00f1adiremos la ruta a los \u00edtems del men\u00fa de esta manera: HeaderComponent.vue const items = ref([ { label: \"Cat\u00e1logo\", }, { label: \"Categor\u00edas\", to: { name: 'categories'} }, { label: \"Autores\", }, ]); Si nos fijamos hemos a\u00f1adido la navegaci\u00f3n por el nombre de ruta en el men\u00fa categor\u00edas para que sepa cuando apretemos ese men\u00fa donde nos tiene que llevar. Con todo esto si ponemos en marcha nuestra aplicaci\u00f3n, ya podremos navegar haciendo click en el men\u00fa Categor\u00edas a esta nueva ruta que hemos creado y ya ver\u00edamos el SOY CATEGORIAS pero tenemos un problemilla en los menus, cuando apretamos un men\u00fa se pone el fondo gris, lo cual no nos gusta y adem\u00e1s aunque estemos en categor\u00edas si apretamos en otro men\u00fa se pone el otro gris y se quita el categor\u00edas lo cual tampoco es lo deseado ya que queremos que se quede marcado el men\u00fa donde estamos actualmente para informaci\u00f3n del usuario. Para ello nos iremos al base.css y a\u00f1adiremos al final estas l\u00edneas: base.css ... . router-link-active { background : var ( --secondary ); border-radius : 5 px ; } . p-menuitem . p-focus > . p-menuitem-content : not ( : hover ) { background : transparent !important ; } En Vue 3, la directiva router-link-active se utiliza para establecer una clase CSS en un enlace de router activo, con esto ya tendremos resuelto el problema y todo estar\u00e1 funcionando como toca y poniendo en marcha la aplicaci\u00f3n y haciendo click en el men\u00fa Categor\u00edas ya deber\u00edamos ver esto: C\u00f3digo de la pantalla Ahora vamos a construir la pantalla. Para manejar la informaci\u00f3n del listado, necesitamos tipar los datos para que Typescript no se queje. Para ello crearemos un fichero en categories\\models\\category-interface.ts donde implementaremos la interface necesaria. Esta interface ser\u00e1 la que utilizaremos para tipar el c\u00f3digo de nuestro componente. category-interface.ts export interface Category { id : number name : string } Tambi\u00e9n, escribiremos el c\u00f3digo de CategoriesView.vue : CategoriesView.vue < template > < div class = \"card\" > < DataTable v-model:editingRows = \"editingRows\" :value = \"categories\" tableStyle = \"min-width: 50rem\" editMode = \"row\" dataKey = \"id\" @ row-edit-save = \"onRowEditSave\" > < Column field = \"id\" header = \"IDENTIFICADOR\" > < template # editor = \"{ data, field }\" > < InputText v-model = \"data[field]\" /> </ template > </ Column > < Column field = \"name\" header = \"NOMBRE CATEGOR\u00cdA\" > < template # editor = \"{ data, field }\" > < InputText v-model = \"data[field]\" /> </ template > </ Column > < Column :rowEditor = \"true\" style = \"width: 110px\" bodyStyle = \"text-align:center\" ></ Column > < Column style = \"width: 30px; padding: 0px 2rem 0px 0px; color: red\" bodyStyle = \"text-align:center\" > < template # body = \"{ data }\" > < i class = \"pi pi-times\" @ click = \"onRowDelete(data)\" ></ i > </ template > </ Column > </ DataTable > </ div > < div class = \"actions\" > < Button label = \"Nueva categor\u00eda\" /> </ div > </ template > < script setup lang = \"ts\" > import { ref } from \"vue\" ; import DataTable , { type DataTableRowEditSaveEvent } from \"primevue/datatable\" ; import Column from \"primevue/column\" ; import InputText from \"primevue/inputtext\" ; import Button from 'primevue/button' ; import type { CategoryInterface } from \"./model/category.interface\" ; const categories = ref ([]); const editingRows = ref ([]); const onRowEditSave = ( event : DataTableRowEditSaveEvent ) => { console . log ( event ); }; const onRowDelete = ( data : CategoryInterface ) => { console . log ( data ); } </ script > < style lang = \"scss\" scoped > . actions { display : flex ; flex-direction : row ; margin-top : 1 rem ; justify-content : flex-end ; } . p-button { background : var ( --primary ); border : 1 px solid var ( --primary ); &:enabled { &:hover { background : var ( --secondary ); border-color : var ( --secondary ); } } } </ style > Intentaremos explicar un poco el c\u00f3digo: Lo primero vamos a importar el componente DataTable desde la librer\u00eda de componentes que estamos usando, para ello podemos ver algunos ejemplos de como hacerlo en la documentaci\u00f3n oficial Nosotros hemos puesto las importaciones que necesitamos en el <script> : CategoriesView.vue import DataTable, { type DataTableRowEditSaveEvent } from \"primevue/datatable\"; import Column from \"primevue/column\"; Hemos creado nuestra tabla con las exigencias de la aplicaci\u00f3n, hemos puesto dos columnas, la columna identificador donde en \u00e9l header=\u201d\u201d le ponemos que nombre se muestra en la cabecera y le hemos dicho que debe mostrar en ella el dato id poni\u00e9ndolo en \u00e9l field=\u201d\u201d . CategoriesView.vue < Column field = \"id\" header = \"IDENTIFICADOR\" ></ Column > Como a la tabla le hemos dicho que debe ser editable con: CategoriesView.vue editMode=\"row\" Le decimos a esta columna que debe hacer cuando entremos en modo de edici\u00f3n, con el template le decimos que mostrara un InputText que es otro componente de la librer\u00eda de componentes que viene a ser un input de toda la vida donde podemos escribir texto para editar el valor, quedando al final asi: CategoriesView.vue < Column field = \"id\" header = \"IDENTIFICADOR\" > < template # editor = \"{ data, field }\" > < InputText v-model = \"data[field]\" /> </ template > </ Column > Luego hemos creado dos columnas, una que tiene el l\u00e1piz y activa el modo edici\u00f3n: CategoriesView.vue < Column :rowEditor = \"true\" style = \"width: 110px\" bodyStyle = \"text-align:center\" > </ Column > Y otra que tiene la X y lo que har\u00e1 ser\u00e1 borrar la fila: CategoriesView.vue < Column style = \"width: 30px; padding: 0px 2rem 0px 0px; color: red\" bodyStyle = \"text-align:center\" > < template # body = \"{ data }\" > < i class = \"pi pi-times\" @ click = \"onRowDelete(data)\" ></ i > </ template > </ Column > Al final a\u00f1adimos otro contenedor que vale para alojar los botones como en nuestro caso el de crear nueva categor\u00eda, el bot\u00f3n es tambi\u00e9n un componente de la librer\u00eda por lo que tendremos que hacer su import en la etiqueta <script> : CategoriesView.vue < div class = \"actions\" > < Button label = \"Nueva categor\u00eda\" /> </ div > Si abrimos el navegador y accedemos a http://localhost:5173/ y pulsamos en el men\u00fa de Categor\u00edas obtendremos una pantalla con un listado vac\u00edo (solo con cabeceras) y un bot\u00f3n de crear Nueva Categor\u00eda que a\u00fan no hace nada. A\u00f1adiendo datos En este punto y para ver como responde el listado, vamos a a\u00f1adir datos. Si tuvi\u00e9ramos el backend implementado podr\u00edamos consultar los datos directamente de una operaci\u00f3n de negocio de backend, pero ahora mismo no lo tenemos implementado as\u00ed que para no bloquear el desarrollo vamos a mockear los datos. En Vue para conectar a APIS externas solemos usar una librer\u00eda llamada Axios, lo primero que haremos ser\u00e1 descargarla e instalarla como indica en su documentaci\u00f3n oficial. Para instalarla simplemente nos iremos a la terminal dentro de la carpeta donde tenemos el proyecto y pondremos: npm install axios Con esto ya podremos ver que se ha a\u00f1adido a nuestro package.json , luego crearemos una carpeta api dentro de la carpeta src y dentro de la carpeta api crearemos el archivo app-api.ts . Dentro de este archivo vamos a inicializar nuestra config de la API y guardaremos todos los par\u00e1metros iniciales conforme nos vayan haciendo falta, de momento pondremos solo este c\u00f3digo: app-api.ts import axios from 'axios' ; export const appApi = axios . create ({ baseURL : 'http://localhost:8080' , }); Si os dais cuenta lo \u00fanico que hacemos es importar axios que acabamos de instalarlo y definir nuestra url base del api para no tener que escribirla cada vez y para s\u00ed alg\u00fan d\u00eda cambia, tener que cambiarla solo en un sitio y no en todos los servicios que la usen. Para mockear los datos con axios usaremos una librer\u00eda que se llama axios-mock-adapter y la pod\u00e9is encontrar en este link . Para instalarla lo haremos con npm como siempre, pondremos esta orden en el terminal y enter: npm install axios-mock-adapter --save-dev Si nos vamos al package.json veremos que ya la tenemos en las devDependencies , la diferencia entre estas y las dependencias es que las dependencias las necesitamos en el proyecto y estar\u00e1n en nuestro bundle final que serviremos a la gente, las devDependencies se usan solo mientras programamos y no entraran en el bundle final. Los mocks los usaremos solo en el desarrollo y hasta que podamos conectar con la API real por eso los metemos en las devDependencies. Mockeando datos Como hemos comentado anteriormente, el backend todav\u00eda no est\u00e1 implementado as\u00ed que vamos a mockear datos. Nos crearemos un fichero mock-categories.ts dentro de views/categories/mocks , con datos ficticios y crearemos una llamada a la API que nos devuelva estos datos. De esta forma, cuando tengamos implementada la operaci\u00f3n de negocio en backend, tan solo tenemos que sustituir el c\u00f3digo que devuelve datos est\u00e1ticos por una llamada HTTP. Dentro de la carpeta mocks crearemos el archivo mock-categories.ts con el siguiente c\u00f3digo: mock-categories.ts import type { Category } from \"@/views/categories/models/category-interface\" ; export const CATEGORY_DATA_MOCK : Category [] = [ { id : 1 , name : 'Dados' }, { id : 2 , name : 'Fichas' }, { id : 3 , name : 'Cartas' }, { id : 4 , name : 'Rol' }, { id : 5 , name : 'Tableros' }, { id : 6 , name : 'Tem\u00e1ticos' }, { id : 7 , name : 'Europeos' }, { id : 8 , name : 'Guerra' }, { id : 9 , name : 'Abstractos' }, ] Despu\u00e9s nos crearemos un composable que usaremos para llamar a la API y poder reutilizarlo en otros componentes si hiciera falta. Dentro de la carpeta categories crearemos otra carpeta llamada composables y dentro crearemos un archivo llamado categories-composable.ts , en ese archivo escribiremos este c\u00f3digo: categories-composable.ts import appApi from '@/api/app-api' import MockAdapter from 'axios-mock-adapter' ; import { CATEGORY_DATA_MOCK } from '@/views/categories/mocks/mock-categories' const mock = new MockAdapter ( appApi ); const useCategoriesApiComposable = () => { mock . onGet ( \"/category\" ). reply ( 200 , CATEGORY_DATA_MOCK ); const getCategories = async () => { const categories = await appApi . get ( \"/category\" ); return categories . data ; }; return { getCategories } } export default useCategoriesApiComposable A\u00f1adiremos \u00e9l composable a nuestro CategoriesView.vue dentro de las etiquetas <script> , lo primero en el import que ya tenemos desde Vue a\u00f1adiremos el m\u00e9todo onMounted dej\u00e1ndolo asi: CategoriesView.vue import { onMounted, ref } from 'vue' El m\u00e9todo onMounted es un ciclo de vida que se dispara nada m\u00e1s montarse el componente, despu\u00e9s a\u00f1adiremos al final el import del composable para poder usarlo: CategoriesView.vue import useCategoriesApiComposable from '@/views/categories/composables/categories-composable' Nos traeremos el m\u00e9todo del composable con la desestructuraci\u00f3n del objeto: CategoriesView.vue const { getCategories } = useCategoriesApiComposable() Crearemos una funci\u00f3n as\u00edncrona para llamar al composable y llamaremos al composable en el onMounted : CategoriesView.vue async function getInitCategories() { categories.value = await getCategories() } onMounted(() => { getInitCategories() }) El CategoriesView.vue quedar\u00eda asi: CategoriesView.vue < template > < div class = \"card\" > < DataTable v-model:editingRows = \"editingRows\" :value = \"categories\" tableStyle = \"min-width: 50rem\" editMode = \"row\" dataKey = \"id\" @ row-edit-save = \"onRowEditSave\" > < Column field = \"id\" header = \"IDENTIFICADOR\" > < template # editor = \"{ data, field }\" > < InputText v-model = \"data[field]\" /> </ template > </ Column > < Column field = \"name\" header = \"NOMBRE CATEGOR\u00cdA\" > < template # editor = \"{ data, field }\" > < InputText v-model = \"data[field]\" /> </ template > </ Column > < Column :rowEditor = \"true\" style = \"width: 110px\" bodyStyle = \"text-align:center\" ></ Column > < Column style = \"width: 30px; padding: 0px 2rem 0px 0px; color: red\" bodyStyle = \"text-align:center\" > < template # body = \"{ data }\" > < i class = \"pi pi-times\" @ click = \"onRowDelete(data)\" ></ i > </ template > </ Column > </ DataTable > </ div > < div class = \"actions\" > < Button label = \"Nueva categor\u00eda\" /> </ div > </ template > < script setup lang = \"ts\" > import { onMounted , ref } from 'vue' import DataTable , { type DataTableRowEditSaveEvent } from 'primevue/datatable' import Column from 'primevue/column' import InputText from 'primevue/inputtext' import Button from 'primevue/button' import type { CategoryInterface } from './model/category.interface' import useCategoriesApiComposable from '@/views/categories/composables/categories-composable' const categories = ref ([]) const editingRows = ref ([]) const { getCategories } = useCategoriesApiComposable () const onRowEditSave = ( event : DataTableRowEditSaveEvent ) => { console . log ( event ) } const onRowDelete = ( data : CategoryInterface ) => { console . log ( data ) } async function getInitCategories () { categories . value = await getCategories () } onMounted (() => { getInitCategories () }) </ script > < style lang = \"scss\" scoped > . actions { display : flex ; flex-direction : row ; margin-top : 1 rem ; justify-content : flex-end ; } . p-button { background : var ( --primary ); border : 1 px solid var ( --primary ); &:enabled { &:hover { background : var ( --secondary ); border-color : var ( --secondary ); } } } </ style > Si ahora refrescamos la p\u00e1gina web, veremos que el listado ya tiene datos con los que vamos a interactuar. Simulando las otras peticiones Para terminar, vamos a simular las otras dos peticiones, la de editar y la de borrar para cuando tengamos que utilizarlas. \u00c9l composable debe quedar m\u00e1s o menos as\u00ed: categories-composable.ts import appApi from '@/api/app-api' import MockAdapter from 'axios-mock-adapter' import type { Category } from '@/views/categories/models/category-interface' import { CATEGORY_DATA_MOCK } from '@/views/categories/mocks/mock-categories' const mock = new MockAdapter ( appApi ) const useCategoriesApiComposable = () => { mock . onAny ( '/category' ). reply ( 200 , CATEGORY_DATA_MOCK ) const getCategories = async () => { const categories = await appApi . get ( '/category' ) return categories . data } const saveCategory = async ( category : Category ) => { const categoryEdit = await appApi . post ( '/category' , category ) return categoryEdit . data } const editCategory = async ( category : Category ) => { const categoryEdit = await appApi . put ( '/category' , category ) return categoryEdit . data } const deleteCategory = async ( categoryId : number ) => { const categoryEdit = await appApi . delete ( `/category/ ${ categoryId } ` ) return categoryEdit . data } return { getCategories , saveCategory , editCategory , deleteCategory } } export default useCategoriesApiComposable","title":"Listado simple - VUE"},{"location":"develop/basic/vuejs/#listado-simple-vue","text":"Ahora que ya tenemos listo el proyecto frontend de VUE, ya podemos empezar a codificar la soluci\u00f3n.","title":"Listado simple - VUE"},{"location":"develop/basic/vuejs/#primeros-pasos","text":"Antes de empezar Quiero hacer hincapi\u00e9 que VUE tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. En la propia web de documentaci\u00f3n de VUE puedes buscar casi cualquier ejemplo que necesites. Si abrimos el proyecto con el IDE que tengamos (Visual Studio Code en el caso del tutorial) podemos ver que en la carpeta src/ existen unos ficheros ya creados por defecto. Estos ficheros son: App.vue \u2192 contiene el c\u00f3digo inicial del proyecto. main.ts \u2192 es el punto de entrada a la aplicaci\u00f3n. Lo primero que vamos a hacer es instalar SASS para poder trabajar con este preprocesador CSS, para ello tendremos que irnos a la terminal, en la misma carpeta donde tenemos el proyecto y ejecutar el siguiente comando: npm install -D sass Con esto ya lo tendremos instalado y para usarlo es tan f\u00e1cil como poner la etiqueta style de esta manera: <style lang=\"scss\"></style> <---> con Sass activado <style></style> <---> sin Sass, css normal En los estilos tambi\u00e9n veremos la propiedad scoped en VUE, el atributo scoped se utiliza para limitar el \u00e1mbito de los estilos de un componente a los elementos del propio componente y no a los elementos hijos o padres, lo que ayuda a evitar conflictos de estilo entre los diferentes componentes de una aplicaci\u00f3n. Esto significa que los estilos definidos en una etiqueta <style scoped> solo se aplicar\u00e1n a los elementos dentro del componente actual, y no se propagar\u00e1n a otros componentes en la jerarqu\u00eda del DOM. De esta manera, se puede evitar que los estilos de un componente afecten a otros componentes en la aplicaci\u00f3n. <style scoped></style> <---> Estos estilos solo afectar\u00e1n al componente donde se aplican <style></style> <---> Estos estilos son generales y afectan a toda la aplicaci\u00f3n. Con estas cositas sobre los estilos en cabeza vamos lo primero a limpiar la aplicaci\u00f3n para poder empezar a trabajar desde cero. Entraremos en la carpeta assets y borraremos todos los archivos excepto base.css . Entraremos en la carpeta components y borraremos todos los archivos dejando solo la carpeta que usaremos m\u00e1s adelante. La carpeta router la dejaremos tal cual esta, sin tocar nada. Entraremos en la carpeta views y borraremos todos los archivos dejando solo la carpeta que usaremos m\u00e1s adelante. Con esto tenemos nuestra estructura preparada y quedar\u00eda tal que asi: Vamos a a\u00f1adir unas l\u00edneas al tsconfig.json para que el typescript deje de marcarnos lo como error, lo dejaremos asi: tsconfig.json { \"extends\" : \"@vue/tsconfig/tsconfig.web.json\" , \"include\" : [ \"env.d.ts\" , \"src/**/*\" , \"src/**/*.vue\" ], \"compilerOptions\" : { \"preserveValueImports\" : false , \"importsNotUsedAsValues\" : \"remove\" , \"verbatimModuleSyntax\" : true , \"baseUrl\" : \".\" , \"paths\" : { \"@/*\" : [ \"./src/*\" ] } }, \"references\" : [ { \"path\" : \"./tsconfig.node.json\" } ] } Para que la aplicaci\u00f3n funcione de nuevo y poder empezar a trabajar faltar\u00eda hacer un par de cositas que os explico: En \u00e9l base.css no hace falta cambiar nada para que funcione, pero tenemos muchas cosas que seguramente no vamos a usar, este archivo lo conservamos solamente para trabajar en variables css todo el tema de los colores de nuestra web o algunas otras cositas como el ancho del menu o del header, etc\u2026 Lo primero vamos a eliminar todas las variables CSS y crearnos las nuestras propias con nuestro color primario y secundario tanto para botones y dem\u00e1s como para texto y tambi\u00e9n para el background principal. Tenemos que dejar nuestro archivo de esta manera: base.css : root { --primary : #2a6fa8 ; --secondary : #12abdb ; --text-ligth : #2c3e50 ; --text-dark : #fff ; --background-color : #fff ; } *, * :: before , * :: after { box-sizing : border-box ; margin : 0 ; position : relative ; font-weight : normal ; } body { min-height : 100 vh ; color : var ( --text-ligth ); background : var ( --background-color ); line-height : 1.6 ; font-family : Inter , - apple-system , BlinkMacSystemFont , 'Segoe UI' , Roboto , Oxygen , Ubuntu , Cantarell , 'Fira Sans' , 'Droid Sans' , 'Helvetica Neue' , sans-serif ; font-size : 16 px ; text-rendering : optimizeLegibility ; -webkit- font-smoothing : antialiased ; -moz- osx-font-smoothing : grayscale ; } Despu\u00e9s vamos a abrir el archivo main.ts y cambiaremos el import que hace del CSS por el base que es el que estamos usando, quedar\u00eda de esta manera: main.ts import { createApp } from 'vue' import App from './App.vue' import router from './router' import './assets/base.css' const app = createApp ( App ) app . use ( router ) app . mount ( '#app' ) Luego abriremos el archivo App.vue y lo dejaremos solo como la entrada a la aplicaci\u00f3n, esto ya son maneras de trabajar de cada uno, pero a m\u00ed me gusta hacerlo asi para tener si hiciera falta diferentes layouts, uno con header y men\u00fa, otro sin header y men\u00fa, otro de la parte de admin, etc\u2026 Lo dejaremos exactamente asi: App.vue < script setup lang = \"ts\" > import { RouterView } from 'vue-router' </ script > < template > < RouterView /> </ template > Por \u00faltimo crearemos nuestro layout principal al que iremos a\u00f1adiendo luego toda nuestra aplicaci\u00f3n. Lo primero nos pondremos en src y crearemos una nueva carpeta llamada layouts , dentro de esta carpeta crearemos otra que se llamara main-layout (esto lo hacemos por si luego tenemos m\u00e1s de un layout que cada uno tenga su carpeta para tener sus propias cosas) y dentro de la carpeta main-layout crearemos el archivo MainLayout.vue , nos deber\u00eda de quedar asi: Una vez tenemos el archivo MainLayout.vue creado lo abriremos y escribiremos el siguiente c\u00f3digo: MainLayout.vue < script setup lang = \"ts\" > const helloWorld = 'Hola Mundo' ; </ script > < template > < h1 > {{ helloWorld }} </ h1 > </ template > Vamos a intentar explicar este c\u00f3digo un poco: Dentro de las etiquetas script metemos todo el c\u00f3digo Javascript, en este caso como vamos a trabajar con Typescript le ponemos la etiqueta Lang=\u201dts\u201d para que el compilador sepa que estamos trabajando con Typescript. Ponemos la palabra setup porque estamos trabajando con la composition api , en VUE podemos trabajar con la options api y con la composition api , nosotros vamos a usar la composition api que aunque al principio cuesta un poco m\u00e1s, luego nos va a hacer la vida much\u00edsimo m\u00e1s f\u00e1cil, sobre todo en aplicaciones \"reales\". Dentro de las etiquetas template va el HTML y como estamos usando el m\u00e9todo setup no necesitamos retornar nada para poder acceder a ello desde la plantilla. Las llaves dobles permiten hacen un binding entre el c\u00f3digo del componente y la plantilla. Es decir, en este caso ir\u00e1 al c\u00f3digo TypeScript y buscar\u00e1 el valor de la variable helloWorld. Consejo El binding tambi\u00e9n nos sirve para ejecutar los m\u00e9todos de TypeScript desde el c\u00f3digo HTML. Adem\u00e1s, si el valor que contiene la variable se modificar\u00e1 durante la ejecuci\u00f3n de alg\u00fan m\u00e9todo, autom\u00e1ticamente el c\u00f3digo HTML refrescar\u00eda el nuevo valor de la variable helloWorld . Ponemos en marcha la aplicaci\u00f3n con npm run dev . Si abrimos el navegador y accedemos a http://localhost:5173/ podremos ver el resultado del c\u00f3digo.","title":"Primeros pasos"},{"location":"develop/basic/vuejs/#layout-general","text":"","title":"Layout general"},{"location":"develop/basic/vuejs/#crear-componente","text":"Lo primero que vamos a hacer es escoger un tema y una paleta de componentes para trabajar. VUE no tiene una librer\u00eda de componentes oficial al igual que, por ejemplo, Angular tiene Material, por lo que podremos elegir entre las diferentes opciones y ver la que m\u00e1s se ajusta a las necesidades del proyecto o crearnos la nuestra propia, si entramos en proyectos ya comenzados, seguramente este paso ya habr\u00e1 sido abordado y ya sabr\u00e1s con qu\u00e9 librer\u00eda de componentes trabajar, para este proyecto vamos a optar por PrimeVue , no tenemos ning\u00fan motivo especial para decidir esa en especial, pero la hemos usado en un curso anterior y optamos por seguir con la misma librer\u00eda. Para instalarla bastar\u00e1 con seguir los pasos de su documentaci\u00f3n . Vamos a hacerlo y la instalamos en nuestro proyecto: Lo primero ejecutaremos el comando npm o yarn para instalarla, en mi caso lo hare con npm: npm install primevue Despu\u00e9s instalaremos PrimeVue con la funci\u00f3n use en el main.ts que es donde tenemos nuestra configuraci\u00f3n, quedando asi nuestro main.ts : Despu\u00e9s a\u00f1adiremos los estilos necesarios a nuestro main.ts : Por \u00faltimo en nuestro base.css cambiaremos la fuente del proyecto por la que trae el tema de PrimeVue, cambiando en el body la l\u00ednea: base.css ... font-family : Inter , -apple-system , BlinkMacSystemFont , 'Segoe UI' , Roboto , Oxygen , Ubuntu , Cantarell , 'Fira Sans' , 'Droid Sans' , 'Helvetica Neue' , sans-serif ; ... Por: base.css ... font-family : ( --font-family ); ... Recuerda Al a\u00f1adir una nueva librer\u00eda tenemos que parar el servidor y volver a arrancarlo para que compile y pre-cargue las nuevas dependencias. Una vez a\u00f1adida la dependencia, lo que queremos es crear una primera estructura inicial a la p\u00e1gina. Si te acuerdas cual era la estructura (y si no te acuerdas, vuelve a la secci\u00f3n Contexto de la aplicaci\u00f3n y lo revisas), ten\u00edamos una cabecera superior con un logo y t\u00edtulo y unas opciones de men\u00fa. Antes de empezar a crear y programar vamos a instalar unas extensiones en Visual Studio Code que nos har\u00e1n la vida mucho mas f\u00e1cil, en cada una de ellas podeis ver una descripci\u00f3n de que hacen y para que sirven, tu ya dices si la quieres instalar o no, nosotros vamos a trabajar con ellas y por eso te las recomendamos: Vue Volar extension Pack Vue Discovery IntelliCode npm Intellisense Vue VSCode Snippets Para poder seguir trabajando con comodidad vamos a a\u00f1adir una fuente de iconos para todos los iconitos que usemos en la aplicaci\u00f3n, nosotros vamos a usar Material porque es la que estamos acostumbrados, para a\u00f1adirla tenemos una gu\u00eda . Lo haremos paso a paso: Lo primero a\u00f1adimos al index.html la fuente a trav\u00e9s de Google fonts, hay muchas otras maneras de hacerlo, como bajarla y servirla desde local, pero para este tutorial vamos a usar esta por ser la m\u00e1s f\u00e1cil, para a\u00f1adirla pegaremos en el index.html esta l\u00ednea: <link href=\"https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined\" rel=\"stylesheet\" /> Quedando de esta manera: index.html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < link rel = \"icon\" href = \"/favicon.ico\" /> < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" /> < link href = \"https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined\" rel = \"stylesheet\" /> < title > Vite App </ title > </ head > < body > < div id = \"app\" ></ div > < script type = \"module\" src = \"/src/main.ts\" ></ script > </ body > </ html > Para que no nos salga el error de comments, a\u00f1adiremos al eslintrc.js estas l\u00edneas: eslintrc.js ... rules : { 'vue/comment-directive' : 'off' } ... Despu\u00e9s nos iremos al fichero base.css y a\u00f1adiremos esto al final del archivo: base.css ... . material-symbols-outlined { font-family : \"Material Symbols Outlined\" , sans-serif ; font-weight : normal ; font-style : normal ; font-size : 24 px ; /* Preferred icon size */ display : inline-block ; line-height : 1 ; text-transform : none ; letter-spacing : normal ; word-wrap : normal ; white-space : nowrap ; direction : ltr ; } Con esto ya tendremos a\u00f1adida la fuente material-symbols y podremos usar todos los iconos disponibles . Despu\u00e9s instalaremos tambi\u00e9n los iconos de PrimeVue para poder usarlos f\u00e1cilmente en los componentes, lo primero pondremos: npm install primeicons Una vez instalados, importaremos los iconos en el main.ts poniendo este import debajo de todos los de css: main.ts ... import 'primeicons/primeicons.css' ; ... Con esto ya lo tendr\u00edamos todo. Pues vamos a ello, con las extensiones ya instaladas y la fuente para los iconos a\u00f1adida crearemos esa estructura com\u00fan para toda la aplicaci\u00f3n. Lo primero crearemos el componente header, dentro de la carpeta components al ser un m\u00f3dulo de la aplicaci\u00f3n y no especifico de una vista o p\u00e1gina. Para eso crearemos una nueva carpeta dentro de components que llamaremos header, nos situaremos encima de la carpeta header y crearemos el archivo HeaderComponent.vue , con el archivo vac\u00edo escribiremos, vbase-3-ts-setup y conforme lo escribimos nos aparecer\u00e1 esto: Consejo Esto nos aparece gracias a las extensiones que hemos instalado, aseg\u00farate de instalarlas para que aparezca o si no las quieres instalar lo puedes crear a mano. Si no te aparece y has instalado las extensiones, cierra vscode y vu\u00e9lvelo a abrir. Podemos seleccionar vbase-3-ts-setup , esto es un snippet que lo que har\u00e1 es generarnos todo el c\u00f3digo de un componente vac\u00edo y lo dejara asi: HeaderComponent.vue < template > < div > </ div > </ template > < script setup lang = \"ts\" > </ script > < style scoped > </ style > Con esto solo nos faltar\u00eda agregar a la etiqueta style que vamos a trabajar con Sass y la dejar\u00edamos asi: HeaderComponent.vue ... < style lang = \"scss\" scoped > </ style > ... Si os dais cuenta hemos a\u00f1adido Lang=\u201dscss\u201d y con esto ya estamos preparados para crear nuestro componente. Para continuar cambiaremos el c\u00f3digo del HeaderComponent.vue por este: HeaderComponent.vue < template > < div class = \"card relative z-2\" > < Menubar :model = \"items\" > < template # start > < span class = \"material-symbols-outlined\" > storefront </ span > < span class = \"title\" > LUDOTECA TAN </ span > </ template > < template # end > < Avatar icon = \"pi pi-user\" class = \"mr-2 avatar-image\" size = \"large\" shape = \"circle\" /> < span class = \"sign-text\" > Sign in </ span > </ template > </ Menubar > </ div > </ template > < script setup lang = \"ts\" > import { ref } from \"vue\" ; import Menubar from \"primevue/menubar\" ; import Avatar from \"primevue/avatar\" ; const items = ref ([ { label : \"Cat\u00e1logo\" , }, { label : \"Categor\u00edas\" , }, { label : \"Autores\" , }, ]); </ script > < style lang = \"scss\" scoped > . p-menubar { padding : 0.5 rem ; background : var ( --primary ); color : var ( --text-dark ); border : none ; border-radius : 0 px ; } . title { margin-left : 1 rem ; font-weight : 600 ; } . avatar-image { background-color : var ( --secondary ); color : var ( --text-dark ); border : 1 px solid var ( --text-dark ); cursor : pointer ; } . sign-text { color : var ( --text-dark ); margin-left : 1 rem ; cursor : pointer ; } : deep ( . p-menubar-start ) { display : flex ; flex-direction : row ; align-items : center ; justify-content : center ; margin-right : 1 rem ; } : deep ( . p-menubar-end ) { display : flex ; flex-direction : row ; align-items : center ; justify-content : center ; } : deep ( . p-menuitem-text ) { color : var ( --text-dark ) !important ; } : deep ( . p-menuitem-content : hover ) { background : var ( --secondary ) !important ; } . material-symbols-outlined { font-size : 36 px ; } </ style > Intentaremos explicarlo un poco: En el template estamos a\u00f1adiendo el Menubar de la librer\u00eda de componentes que estamos utilizando, si queremos saber como se a\u00f1ade podemos verlo en este link . Veremos que lo primero que hacemos es el import dentro de las etiquetas <script> para poder tener el componente disponible y poder usarlo. HeaderComponent.vue ... import Menubar from \"primevue/menubar\"; ... Luego, con el import ya hecho, podemos copiar el HTML que nos dan y ponerlo en nuestro componente: HeaderComponent.vue ... < div class = \"card relative z-2\" > < Menubar :model = \"items\" > < template # start > < span class = \"material-symbols-outlined\" > storefront </ span > < span class = \"title\" > LUDOTECA TAN </ span > </ template > < template # end > < Avatar icon = \"pi pi-user\" class = \"mr-2 avatar-image\" size = \"large\" shape = \"circle\" /> < span class = \"sign-text\" > Sign in </ span > </ template > </ Menubar > </ div > ... Si os dais cuenta es el c\u00f3digo que ellos nos dan retocado para cubrir nuestras necesidades, primero hemos metido un icono de material dentro del template #start que es lo que se situara al principio pegado a la izquierda del Menubar y tras el icono metemos el t\u00edtulo. El template #end se situar\u00e1 al final pegado a la derecha y alli estamos metiendo otro componente de la librer\u00eda de componentes, pod\u00e9is ver la info de como usarlo en este link . Este simplemente lo pegamos como esta y le a\u00f1adimos detr\u00e1s la frase Sign in . En la parte del script metemos todo nuestro Javascript/Typescript: HeaderComponent.vue ... < script setup lang = \"ts\" > import { ref } from \"vue\" ; import Menubar from \"primevue/menubar\" ; import Avatar from \"primevue/avatar\" ; const items = ref ([ { label : \"Cat\u00e1logo\" , }, { label : \"Categor\u00edas\" , }, { label : \"Autores\" , }, ]); </ script > ... Si os dais cuenta, lo \u00fanico que estamos haciendo son los imports necesarios para que todo funcione y creando una variable \u00edtems que es la que luego estamos usando en el men\u00fa para pintar los diferentes menus. Si os dais cuenta envolvemos el valor de la variable dentro de ref() . En Vue 3, la funci\u00f3n ref() se utiliza para crear una referencia reactiva a un valor. Una referencia reactiva es un objeto que puede ser pasado como prop, utilizado en una plantilla, y observado para detectar cambios en su valor. La funci\u00f3n ref() toma un valor como argumento y devuelve un objeto con una propiedad value que contiene el valor proporcionado. Por ejemplo, si queremos crear una referencia a un n\u00famero entero, podemos hacer lo siguiente: import { ref } from 'vue' const myNumber = ref(42) console.log(myNumber.value) // 42 La referencia myNumber es ahora un objeto con una propiedad value que contiene el valor 42 . Si cambiamos el valor de la propiedad value , la referencia notificar\u00e1 a cualquier componente que est\u00e9 observando el valor que ha cambiado. Por ejemplo: myNumber.value = 21 console.log(myNumber.value) // 21 Cualquier componente que est\u00e9 utilizando myNumber se actualizar\u00e1 autom\u00e1ticamente para reflejar el nuevo valor. La funci\u00f3n ref() es muy \u00fatil en Vue 3 para crear referencias reactivas a valores que pueden cambiar con el tiempo. En los styles tenemos poco que explicar, simplemente estamos haciendo que se vea como nosotros queremos, que todos los colores y dem\u00e1s los traemos de las variables que hemos creado antes en el base.css y adem\u00e1s me gustar\u00eda mencionar una cosa: HeaderComponent.vue ... :deep(.p-menubar-start) { display: flex; flex-direction: row; align-items: center; justify-content: center; margin-right: 1rem; } ... Si os dais cuenta algunos estilos llevan el :Deep delante, como seguro ya sabes, puedes utilizar el atributo scoped dentro de la etiqueta <style> para escribir CSS y as\u00ed impedir que tus estilos afecten a posibles sub-componentes. Pero, \u00bfqu\u00e9 ocurre si necesitas que al menos una regla s\u00ed afecte a tu componente hijo?. Para ello puedes usar la pseudo-clase :deep de Vue 3. En este ejemplo lo hemos creado asi para que sepas de su existencia y busques un poco de informaci\u00f3n sobre ella y las otras que existen, este CSS lo podr\u00edamos poner en el styles.scss principal y no tendr\u00edamos que poner el :deep que seria lo mas recomendado. Es importante tener en cuenta que la directiva :deep puede tener un impacto en el rendimiento, ya que Vue necesita buscar en todo el \u00e1rbol de elementos para aplicar los estilos. Por lo tanto, se recomienda utilizar esta directiva con moderaci\u00f3n y solo en casos en los que sea necesario seleccionar elementos anidados de forma din\u00e1mica. Tenerlo en cuenta y solo usarla cuando de verdad sea necesario. Ya por \u00faltimo nos iremos a nuestro MainLayout.vue y a\u00f1adiremos el header que acabamos de crearnos: MainLayout.vue < script setup lang = \"ts\" > import HeaderComponent from '@/components/header/HeaderComponent.vue' ; const helloWorld = 'Hola Mundo' ; </ script > < template > < HeaderComponent ></ HeaderComponent > < h1 > {{ helloWorld }} </ h1 > </ template > Como antes, lo \u00fanico que hacemos es importar el componente en el script y usarlo en el HTML. Lo siguiente iremos a la carpeta router , al archivo index.ts y lo dejaremos asi: index.ts import { createRouter , createWebHistory } from 'vue-router' import MainLayout from '@/layouts/main-layout/MainLayout.vue' const router = createRouter ({ history : createWebHistory ( import . meta . env . BASE_URL ), routes : [ { path : '/' , name : 'home' , component : MainLayout } ] }) export default router Hemos cambiado la ruta principal para que apunte a nuestro layout y nada m\u00e1s entrar en la aplicaci\u00f3n lo carguemos gracias al router de VUE. Si guardamos todo y ponemos en marcha el proyecto ya veremos algo como esto:","title":"Crear componente"},{"location":"develop/basic/vuejs/#creando-un-listado-basico","text":"","title":"Creando un listado b\u00e1sico"},{"location":"develop/basic/vuejs/#crear-componente_1","text":"Ya tenemos la estructura principal, ahora vamos a crear nuestra primera pantalla. Vamos a empezar por la de Categor\u00edas que es la m\u00e1s sencilla, ya que se trata de un listado, que muestra datos sin filtrar ni paginar. Como categor\u00edas es un dominio funcional de la aplicaci\u00f3n, vamos a crear una nueva carpeta dentro de la carpeta views llamada categories, todas las pantallas, componentes y servicios que creemos, referidos a este dominio funcional, deber\u00e1n ir dentro del m\u00f3dulo categories. Dentro de esa carpeta crearemos un fichero que se llamara CategoriesView.vue y dentro nos crearemos el esqueleto de la misma manera que hicimos anteriormente. Escribiremos vbase-3-ts-setup , le daremos al enter y nos generara toda la estructura a la que solo faltara agregar a la etiqueta <style> Lang=\u201dscss\u201d para decirle que vamos a trabajar con SASS. Con esto tenemos nuestra vista preparada para empezar a trabajar. Lo primero vamos a conectar nuestro componente al router para que cuando hagamos click en el men\u00fa correspondiente podamos llegar hasta \u00e9l y tambi\u00e9n para poder ver lo que vamos trabajando. Para ello lo primero que vamos a hacer en el template de nuestro componente es a\u00f1adir cualquier cosa para saber que estamos donde toca, por ejemplo: CategoriesView.vue < template > < div > SOY CATEGORIAS </ div > </ template > Con esto cuando entremos en la ruta de categor\u00edas deber\u00edamos ver SOY CATEGORIAS . Lo siguiente crearemos en el layout un sitio para cargar todas nuestras rutas que van a ir dentro de ese layout, para ello iremos al archivo MainLayout.vue y a\u00f1adiremos un <RouterView /> que ser\u00e1 el segundo de nuestra aplicaci\u00f3n, el primero lo tenemos en el App.vue que servir\u00e1 para cargar nuestras rutas principales (diferentes layouts, pagina 404, etc) y el segundo es este que acabamos de crear, podemos tener tantos como queramos en una aplicaci\u00f3n y cada uno tendr\u00e1 su cometido. Este que acabamos de crear ser\u00e1 donde se cargaran todas las rutas que quieran estar dentro del layout principal. Para crearlo importaremos \u00e9l RouterView dentro de los <script> desde vue-router : MainLayout.vue import { RouterView } from 'vue-router'; Lo a\u00f1adiremos dentro de los <template> exactamente donde queramos cargar las rutas y si puede ser con un div padre que haga de contenedor asi podremos darle los estilos sin sufrir demasiado. MainLayout.vue < div class = \"outlet-container\" > < RouterView /> </ div > Y luego dentro de <style> le daremos estilo al contenedor padre de acuerdo a lo que necesitemos (grid, flex, etc\u2026) en este ejemplo para hacerlo f\u00e1cil lo haremos con flex, con todo esto quedar\u00eda asi: MainLayout.vue < script setup lang = \"ts\" > import { RouterView } from 'vue-router' ; import HeaderComponent from \"@/components/header/HeaderComponent.vue\" ; </ script > < template > < HeaderComponent ></ HeaderComponent > < div class = \"outlet-container\" > < RouterView /> </ div > </ template > < style lang = \"scss\" scoped > . outlet-container { display : flex ; flex-direction : column ; flex-grow : 1 ; width : 100 % ; min-height : calc ( 100 vh - 65 px ); padding : 1 rem ; } </ style > Ahora vamos a a\u00f1adirlo a nuestras rutas, para ello nos vamos a la carpeta router y dentro tendremos el index.ts con nuestras rutas actuales, vamos a a\u00f1adir la nueva ruta como hija de layout para que siempre se muestre dentro del layout que hemos creado con \u00e9l header : index.ts import { createRouter , createWebHistory } from 'vue-router' import MainLayout from '@/layouts/main-layout/MainLayout.vue' const router = createRouter ({ history : createWebHistory ( import . meta . env . BASE_URL ), routes : [ { path : '/' , name : 'home' , component : MainLayout , children : [ { path : '/categories' , name : 'categories' , component : () => import ( '../views/categories/CategoriesView.vue' ) } ] } ] }) export default router Si os dais cuenta lo hemos a\u00f1adido como hijo de layout y adem\u00e1s lo hemos hecho con lazy loading , es decir, este componente solo se cargara cuando el usuario navegue a esa ruta, asi evitamos cargas much\u00edsimo m\u00e1s grandes al inicio de la aplicaci\u00f3n. Posteriormente nos iremos al HeaderComponent.vue y a\u00f1adiremos la ruta a los \u00edtems del men\u00fa de esta manera: HeaderComponent.vue const items = ref([ { label: \"Cat\u00e1logo\", }, { label: \"Categor\u00edas\", to: { name: 'categories'} }, { label: \"Autores\", }, ]); Si nos fijamos hemos a\u00f1adido la navegaci\u00f3n por el nombre de ruta en el men\u00fa categor\u00edas para que sepa cuando apretemos ese men\u00fa donde nos tiene que llevar. Con todo esto si ponemos en marcha nuestra aplicaci\u00f3n, ya podremos navegar haciendo click en el men\u00fa Categor\u00edas a esta nueva ruta que hemos creado y ya ver\u00edamos el SOY CATEGORIAS pero tenemos un problemilla en los menus, cuando apretamos un men\u00fa se pone el fondo gris, lo cual no nos gusta y adem\u00e1s aunque estemos en categor\u00edas si apretamos en otro men\u00fa se pone el otro gris y se quita el categor\u00edas lo cual tampoco es lo deseado ya que queremos que se quede marcado el men\u00fa donde estamos actualmente para informaci\u00f3n del usuario. Para ello nos iremos al base.css y a\u00f1adiremos al final estas l\u00edneas: base.css ... . router-link-active { background : var ( --secondary ); border-radius : 5 px ; } . p-menuitem . p-focus > . p-menuitem-content : not ( : hover ) { background : transparent !important ; } En Vue 3, la directiva router-link-active se utiliza para establecer una clase CSS en un enlace de router activo, con esto ya tendremos resuelto el problema y todo estar\u00e1 funcionando como toca y poniendo en marcha la aplicaci\u00f3n y haciendo click en el men\u00fa Categor\u00edas ya deber\u00edamos ver esto:","title":"Crear componente"},{"location":"develop/basic/vuejs/#codigo-de-la-pantalla","text":"Ahora vamos a construir la pantalla. Para manejar la informaci\u00f3n del listado, necesitamos tipar los datos para que Typescript no se queje. Para ello crearemos un fichero en categories\\models\\category-interface.ts donde implementaremos la interface necesaria. Esta interface ser\u00e1 la que utilizaremos para tipar el c\u00f3digo de nuestro componente. category-interface.ts export interface Category { id : number name : string } Tambi\u00e9n, escribiremos el c\u00f3digo de CategoriesView.vue : CategoriesView.vue < template > < div class = \"card\" > < DataTable v-model:editingRows = \"editingRows\" :value = \"categories\" tableStyle = \"min-width: 50rem\" editMode = \"row\" dataKey = \"id\" @ row-edit-save = \"onRowEditSave\" > < Column field = \"id\" header = \"IDENTIFICADOR\" > < template # editor = \"{ data, field }\" > < InputText v-model = \"data[field]\" /> </ template > </ Column > < Column field = \"name\" header = \"NOMBRE CATEGOR\u00cdA\" > < template # editor = \"{ data, field }\" > < InputText v-model = \"data[field]\" /> </ template > </ Column > < Column :rowEditor = \"true\" style = \"width: 110px\" bodyStyle = \"text-align:center\" ></ Column > < Column style = \"width: 30px; padding: 0px 2rem 0px 0px; color: red\" bodyStyle = \"text-align:center\" > < template # body = \"{ data }\" > < i class = \"pi pi-times\" @ click = \"onRowDelete(data)\" ></ i > </ template > </ Column > </ DataTable > </ div > < div class = \"actions\" > < Button label = \"Nueva categor\u00eda\" /> </ div > </ template > < script setup lang = \"ts\" > import { ref } from \"vue\" ; import DataTable , { type DataTableRowEditSaveEvent } from \"primevue/datatable\" ; import Column from \"primevue/column\" ; import InputText from \"primevue/inputtext\" ; import Button from 'primevue/button' ; import type { CategoryInterface } from \"./model/category.interface\" ; const categories = ref ([]); const editingRows = ref ([]); const onRowEditSave = ( event : DataTableRowEditSaveEvent ) => { console . log ( event ); }; const onRowDelete = ( data : CategoryInterface ) => { console . log ( data ); } </ script > < style lang = \"scss\" scoped > . actions { display : flex ; flex-direction : row ; margin-top : 1 rem ; justify-content : flex-end ; } . p-button { background : var ( --primary ); border : 1 px solid var ( --primary ); &:enabled { &:hover { background : var ( --secondary ); border-color : var ( --secondary ); } } } </ style > Intentaremos explicar un poco el c\u00f3digo: Lo primero vamos a importar el componente DataTable desde la librer\u00eda de componentes que estamos usando, para ello podemos ver algunos ejemplos de como hacerlo en la documentaci\u00f3n oficial Nosotros hemos puesto las importaciones que necesitamos en el <script> : CategoriesView.vue import DataTable, { type DataTableRowEditSaveEvent } from \"primevue/datatable\"; import Column from \"primevue/column\"; Hemos creado nuestra tabla con las exigencias de la aplicaci\u00f3n, hemos puesto dos columnas, la columna identificador donde en \u00e9l header=\u201d\u201d le ponemos que nombre se muestra en la cabecera y le hemos dicho que debe mostrar en ella el dato id poni\u00e9ndolo en \u00e9l field=\u201d\u201d . CategoriesView.vue < Column field = \"id\" header = \"IDENTIFICADOR\" ></ Column > Como a la tabla le hemos dicho que debe ser editable con: CategoriesView.vue editMode=\"row\" Le decimos a esta columna que debe hacer cuando entremos en modo de edici\u00f3n, con el template le decimos que mostrara un InputText que es otro componente de la librer\u00eda de componentes que viene a ser un input de toda la vida donde podemos escribir texto para editar el valor, quedando al final asi: CategoriesView.vue < Column field = \"id\" header = \"IDENTIFICADOR\" > < template # editor = \"{ data, field }\" > < InputText v-model = \"data[field]\" /> </ template > </ Column > Luego hemos creado dos columnas, una que tiene el l\u00e1piz y activa el modo edici\u00f3n: CategoriesView.vue < Column :rowEditor = \"true\" style = \"width: 110px\" bodyStyle = \"text-align:center\" > </ Column > Y otra que tiene la X y lo que har\u00e1 ser\u00e1 borrar la fila: CategoriesView.vue < Column style = \"width: 30px; padding: 0px 2rem 0px 0px; color: red\" bodyStyle = \"text-align:center\" > < template # body = \"{ data }\" > < i class = \"pi pi-times\" @ click = \"onRowDelete(data)\" ></ i > </ template > </ Column > Al final a\u00f1adimos otro contenedor que vale para alojar los botones como en nuestro caso el de crear nueva categor\u00eda, el bot\u00f3n es tambi\u00e9n un componente de la librer\u00eda por lo que tendremos que hacer su import en la etiqueta <script> : CategoriesView.vue < div class = \"actions\" > < Button label = \"Nueva categor\u00eda\" /> </ div > Si abrimos el navegador y accedemos a http://localhost:5173/ y pulsamos en el men\u00fa de Categor\u00edas obtendremos una pantalla con un listado vac\u00edo (solo con cabeceras) y un bot\u00f3n de crear Nueva Categor\u00eda que a\u00fan no hace nada.","title":"C\u00f3digo de la pantalla"},{"location":"develop/basic/vuejs/#anadiendo-datos","text":"En este punto y para ver como responde el listado, vamos a a\u00f1adir datos. Si tuvi\u00e9ramos el backend implementado podr\u00edamos consultar los datos directamente de una operaci\u00f3n de negocio de backend, pero ahora mismo no lo tenemos implementado as\u00ed que para no bloquear el desarrollo vamos a mockear los datos. En Vue para conectar a APIS externas solemos usar una librer\u00eda llamada Axios, lo primero que haremos ser\u00e1 descargarla e instalarla como indica en su documentaci\u00f3n oficial. Para instalarla simplemente nos iremos a la terminal dentro de la carpeta donde tenemos el proyecto y pondremos: npm install axios Con esto ya podremos ver que se ha a\u00f1adido a nuestro package.json , luego crearemos una carpeta api dentro de la carpeta src y dentro de la carpeta api crearemos el archivo app-api.ts . Dentro de este archivo vamos a inicializar nuestra config de la API y guardaremos todos los par\u00e1metros iniciales conforme nos vayan haciendo falta, de momento pondremos solo este c\u00f3digo: app-api.ts import axios from 'axios' ; export const appApi = axios . create ({ baseURL : 'http://localhost:8080' , }); Si os dais cuenta lo \u00fanico que hacemos es importar axios que acabamos de instalarlo y definir nuestra url base del api para no tener que escribirla cada vez y para s\u00ed alg\u00fan d\u00eda cambia, tener que cambiarla solo en un sitio y no en todos los servicios que la usen. Para mockear los datos con axios usaremos una librer\u00eda que se llama axios-mock-adapter y la pod\u00e9is encontrar en este link . Para instalarla lo haremos con npm como siempre, pondremos esta orden en el terminal y enter: npm install axios-mock-adapter --save-dev Si nos vamos al package.json veremos que ya la tenemos en las devDependencies , la diferencia entre estas y las dependencias es que las dependencias las necesitamos en el proyecto y estar\u00e1n en nuestro bundle final que serviremos a la gente, las devDependencies se usan solo mientras programamos y no entraran en el bundle final. Los mocks los usaremos solo en el desarrollo y hasta que podamos conectar con la API real por eso los metemos en las devDependencies.","title":"A\u00f1adiendo datos"},{"location":"develop/basic/vuejs/#mockeando-datos","text":"Como hemos comentado anteriormente, el backend todav\u00eda no est\u00e1 implementado as\u00ed que vamos a mockear datos. Nos crearemos un fichero mock-categories.ts dentro de views/categories/mocks , con datos ficticios y crearemos una llamada a la API que nos devuelva estos datos. De esta forma, cuando tengamos implementada la operaci\u00f3n de negocio en backend, tan solo tenemos que sustituir el c\u00f3digo que devuelve datos est\u00e1ticos por una llamada HTTP. Dentro de la carpeta mocks crearemos el archivo mock-categories.ts con el siguiente c\u00f3digo: mock-categories.ts import type { Category } from \"@/views/categories/models/category-interface\" ; export const CATEGORY_DATA_MOCK : Category [] = [ { id : 1 , name : 'Dados' }, { id : 2 , name : 'Fichas' }, { id : 3 , name : 'Cartas' }, { id : 4 , name : 'Rol' }, { id : 5 , name : 'Tableros' }, { id : 6 , name : 'Tem\u00e1ticos' }, { id : 7 , name : 'Europeos' }, { id : 8 , name : 'Guerra' }, { id : 9 , name : 'Abstractos' }, ] Despu\u00e9s nos crearemos un composable que usaremos para llamar a la API y poder reutilizarlo en otros componentes si hiciera falta. Dentro de la carpeta categories crearemos otra carpeta llamada composables y dentro crearemos un archivo llamado categories-composable.ts , en ese archivo escribiremos este c\u00f3digo: categories-composable.ts import appApi from '@/api/app-api' import MockAdapter from 'axios-mock-adapter' ; import { CATEGORY_DATA_MOCK } from '@/views/categories/mocks/mock-categories' const mock = new MockAdapter ( appApi ); const useCategoriesApiComposable = () => { mock . onGet ( \"/category\" ). reply ( 200 , CATEGORY_DATA_MOCK ); const getCategories = async () => { const categories = await appApi . get ( \"/category\" ); return categories . data ; }; return { getCategories } } export default useCategoriesApiComposable A\u00f1adiremos \u00e9l composable a nuestro CategoriesView.vue dentro de las etiquetas <script> , lo primero en el import que ya tenemos desde Vue a\u00f1adiremos el m\u00e9todo onMounted dej\u00e1ndolo asi: CategoriesView.vue import { onMounted, ref } from 'vue' El m\u00e9todo onMounted es un ciclo de vida que se dispara nada m\u00e1s montarse el componente, despu\u00e9s a\u00f1adiremos al final el import del composable para poder usarlo: CategoriesView.vue import useCategoriesApiComposable from '@/views/categories/composables/categories-composable' Nos traeremos el m\u00e9todo del composable con la desestructuraci\u00f3n del objeto: CategoriesView.vue const { getCategories } = useCategoriesApiComposable() Crearemos una funci\u00f3n as\u00edncrona para llamar al composable y llamaremos al composable en el onMounted : CategoriesView.vue async function getInitCategories() { categories.value = await getCategories() } onMounted(() => { getInitCategories() }) El CategoriesView.vue quedar\u00eda asi: CategoriesView.vue < template > < div class = \"card\" > < DataTable v-model:editingRows = \"editingRows\" :value = \"categories\" tableStyle = \"min-width: 50rem\" editMode = \"row\" dataKey = \"id\" @ row-edit-save = \"onRowEditSave\" > < Column field = \"id\" header = \"IDENTIFICADOR\" > < template # editor = \"{ data, field }\" > < InputText v-model = \"data[field]\" /> </ template > </ Column > < Column field = \"name\" header = \"NOMBRE CATEGOR\u00cdA\" > < template # editor = \"{ data, field }\" > < InputText v-model = \"data[field]\" /> </ template > </ Column > < Column :rowEditor = \"true\" style = \"width: 110px\" bodyStyle = \"text-align:center\" ></ Column > < Column style = \"width: 30px; padding: 0px 2rem 0px 0px; color: red\" bodyStyle = \"text-align:center\" > < template # body = \"{ data }\" > < i class = \"pi pi-times\" @ click = \"onRowDelete(data)\" ></ i > </ template > </ Column > </ DataTable > </ div > < div class = \"actions\" > < Button label = \"Nueva categor\u00eda\" /> </ div > </ template > < script setup lang = \"ts\" > import { onMounted , ref } from 'vue' import DataTable , { type DataTableRowEditSaveEvent } from 'primevue/datatable' import Column from 'primevue/column' import InputText from 'primevue/inputtext' import Button from 'primevue/button' import type { CategoryInterface } from './model/category.interface' import useCategoriesApiComposable from '@/views/categories/composables/categories-composable' const categories = ref ([]) const editingRows = ref ([]) const { getCategories } = useCategoriesApiComposable () const onRowEditSave = ( event : DataTableRowEditSaveEvent ) => { console . log ( event ) } const onRowDelete = ( data : CategoryInterface ) => { console . log ( data ) } async function getInitCategories () { categories . value = await getCategories () } onMounted (() => { getInitCategories () }) </ script > < style lang = \"scss\" scoped > . actions { display : flex ; flex-direction : row ; margin-top : 1 rem ; justify-content : flex-end ; } . p-button { background : var ( --primary ); border : 1 px solid var ( --primary ); &:enabled { &:hover { background : var ( --secondary ); border-color : var ( --secondary ); } } } </ style > Si ahora refrescamos la p\u00e1gina web, veremos que el listado ya tiene datos con los que vamos a interactuar.","title":"Mockeando datos"},{"location":"develop/basic/vuejs/#simulando-las-otras-peticiones","text":"Para terminar, vamos a simular las otras dos peticiones, la de editar y la de borrar para cuando tengamos que utilizarlas. \u00c9l composable debe quedar m\u00e1s o menos as\u00ed: categories-composable.ts import appApi from '@/api/app-api' import MockAdapter from 'axios-mock-adapter' import type { Category } from '@/views/categories/models/category-interface' import { CATEGORY_DATA_MOCK } from '@/views/categories/mocks/mock-categories' const mock = new MockAdapter ( appApi ) const useCategoriesApiComposable = () => { mock . onAny ( '/category' ). reply ( 200 , CATEGORY_DATA_MOCK ) const getCategories = async () => { const categories = await appApi . get ( '/category' ) return categories . data } const saveCategory = async ( category : Category ) => { const categoryEdit = await appApi . post ( '/category' , category ) return categoryEdit . data } const editCategory = async ( category : Category ) => { const categoryEdit = await appApi . put ( '/category' , category ) return categoryEdit . data } const deleteCategory = async ( categoryId : number ) => { const categoryEdit = await appApi . delete ( `/category/ ${ categoryId } ` ) return categoryEdit . data } return { getCategories , saveCategory , editCategory , deleteCategory } } export default useCategoriesApiComposable","title":"Simulando las otras peticiones"},{"location":"develop/filtered/angular/","text":"Listado filtrado - Angular En este punto ya tenemos dos listados, uno b\u00e1sico y otro paginado. Ahora vamos a implementar un listado un poco diferente, con filtros y con una presentaci\u00f3n un tanto distinta. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades. Crear componentes Vamos a desarrollar el listado de Juegos . Este listado es un tanto peculiar, porque no tiene una tabla como tal, sino que tiene una tabla con \"tiles\" para cada uno de los juegos. Necesitaremos un componente para el listado y otro componente para el detalle del juego. Tambi\u00e9n necesitaremos otro componente para el dialogo de edici\u00f3n / alta. Manos a la obra: ng generate module game ng generate component game/game-list ng generate component game/game-list/game-item ng generate component game/game-edit ng generate service game/game Y a\u00f1adimos el nuevo m\u00f3dulo al app.module.ts como hemos hecho con el resto de m\u00f3dulos. Game.ts import { NgModule } from '@angular/core' ; import { BrowserModule } from '@angular/platform-browser' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { BrowserAnimationsModule } from '@angular/platform-browser/animations' ; import { CoreModule } from './core/core.module' ; import { CategoryModule } from './category/category.module' ; import { AuthorModule } from './author/author.module' ; import { GameModule } from './game/game.module' ; @NgModule ({ declarations : [ AppComponent ], imports : [ BrowserModule , AppRoutingModule , CoreModule , CategoryModule , AuthorModule , GameModule , BrowserAnimationsModule ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { } Crear el modelo Lo primero que vamos a hacer es crear el modelo en game/model/Game.ts con todas las propiedades necesarias para trabajar con un juego: Game.ts import { Category } from \"src/app/category/model/Category\" ; import { Author } from \"src/app/author/model/Author\" ; export class Game { id : number ; title : string ; age : number ; category : Category ; author : Author ; } Como ves, el juego tiene dos objetos para mapear categor\u00eda y autor. A\u00f1adir el punto de entrada A\u00f1adimos la ruta al men\u00fa para que podamos navegar a esta pantalla: app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { AuthorListComponent } from './author/author-list/author-list.component' ; import { CategoryListComponent } from './category/category-list/category-list.component' ; import { GameListComponent } from './game/game-list/game-list.component' ; const routes : Routes = [ { path : '' , redirectTo : '/games' , pathMatch : 'full' }, { path : 'categories' , component : CategoryListComponent }, { path : 'authors' , component : AuthorListComponent }, { path : 'games' , component : GameListComponent }, ]; @NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } Adem\u00e1s, hemos a\u00f1adido una regla adicional con el path vac\u00edo para indicar que si no pone ruta, por defecto la p\u00e1gina inicial redirija al path /games , que es nuevo path que hemos a\u00f1adido. Implementar servicio A continuaci\u00f3n implementamos el servicio y mockeamos datos de ejemplo: mock-games.ts game.service.ts import { Game } from \"./Game\" ; export const GAME_DATA : Game [] = [ { id : 1 , title : 'Juego 1' , age : 6 , category : { id : 1 , name : 'Categor\u00eda 1' }, author : { id : 1 , name : 'Autor 1' , nationality : 'Nacionalidad 1' } }, { id : 2 , title : 'Juego 2' , age : 8 , category : { id : 1 , name : 'Categor\u00eda 1' }, author : { id : 2 , name : 'Autor 2' , nationality : 'Nacionalidad 2' } }, { id : 3 , title : 'Juego 3' , age : 4 , category : { id : 1 , name : 'Categor\u00eda 1' }, author : { id : 3 , name : 'Autor 3' , nationality : 'Nacionalidad 3' } }, { id : 4 , title : 'Juego 4' , age : 10 , category : { id : 2 , name : 'Categor\u00eda 2' }, author : { id : 1 , name : 'Autor 1' , nationality : 'Nacionalidad 1' } }, { id : 5 , title : 'Juego 5' , age : 16 , category : { id : 2 , name : 'Categor\u00eda 2' }, author : { id : 2 , name : 'Autor 2' , nationality : 'Nacionalidad 2' } }, { id : 6 , title : 'Juego 6' , age : 16 , category : { id : 2 , name : 'Categor\u00eda 2' }, author : { id : 3 , name : 'Autor 3' , nationality : 'Nacionalidad 3' } }, { id : 7 , title : 'Juego 7' , age : 12 , category : { id : 3 , name : 'Categor\u00eda 3' }, author : { id : 1 , name : 'Autor 1' , nationality : 'Nacionalidad 1' } }, { id : 8 , title : 'Juego 8' , age : 14 , category : { id : 3 , name : 'Categor\u00eda 3' }, author : { id : 2 , name : 'Autor 2' , nationality : 'Nacionalidad 2' } }, ] import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Game } from './model/Game' ; import { GAME_DATA } from './model/mock-games' ; @Injectable ({ providedIn : 'root' }) export class GameService { constructor () { } getGames ( title? : String , categoryId? : number ) : Observable < Game [] > { return of ( GAME_DATA ); } saveGame ( game : Game ) : Observable < void > { return of ( null ); } } Implementar listado Ya tenemos las operaciones del servicio con datoos, as\u00ed que ahora vamos a por el listado filtrado. game-list.component.html game-list.component.scss game-list.component.ts < div class = \"container\" > < h1 > Cat\u00e1logo de juegos </ h1 > < div class = \"filters\" > < form > < mat-form-field > < mat-label > T\u00edtulo del juego </ mat-label > < input type = \"text\" matInput placeholder = \"T\u00edtulo del juego\" [( ngModel )]=\" filterTitle \" name = \"title\" > </ mat-form-field > < mat-form-field > < mat-label > Categor\u00eda del juego </ mat-label > < mat-select disableRipple [( ngModel )]=\" filterCategory \" name = \"category\" > < mat-option * ngFor = \"let category of categories\" [ value ]=\" category \" > {{category.name}} </ mat-option > </ mat-select > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onCleanFilter ()\" > Limpiar </ button > < button mat-stroked-button ( click )=\" onSearch ()\" > Filtrar </ button > </ div > </ div > < div class = \"game-list\" > < app-game-item * ngFor = \"let game of games; let i = index;\" ( click )=\" editGame ( game )\" > </ app-game-item > </ div > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createGame ()\" > Nuevo juego </ button > </ div > </ div > . container { margin : 20 px ; .filters { display : flex ; mat-form-field { width : 300 px ; margin-right : 20 px ; } . buttons { flex : auto ; align-self : center ; button { margin-left : 15 px ; } } } . game-list { margin-top : 20 px ; margin-bottom : 20 px ; display : flex ; flex-flow : wrap ; overflow : auto ; } . buttons { text-align : right ; } } button { width : 125 px ; } import { Component , OnInit } from '@angular/core' ; import { MatDialog } from '@angular/material/dialog' ; import { CategoryService } from 'src/app/category/category.service' ; import { Category } from 'src/app/category/model/Category' ; import { GameEditComponent } from '../game-edit/game-edit.component' ; import { GameService } from '../game.service' ; import { Game } from '../model/Game' ; @Component ({ selector : 'app-game-list' , templateUrl : './game-list.component.html' , styleUrls : [ './game-list.component.scss' ] }) export class GameListComponent implements OnInit { categories : Category []; games : Game []; filterCategory : Category ; filterTitle : string ; constructor ( private gameService : GameService , private categoryService : CategoryService , public dialog : MatDialog , ) { } ngOnInit () : void { this . gameService . getGames (). subscribe ( games => this . games = games ); this . categoryService . getCategories (). subscribe ( categories => this . categories = categories ); } onCleanFilter () : void { this . filterTitle = null ; this . filterCategory = null ; this . onSearch (); } onSearch () : void { let title = this . filterTitle ; let categoryId = this . filterCategory != null ? this.filterCategory.id : null ; this . gameService . getGames ( title , categoryId ). subscribe ( games => this . games = games ); } createGame () { const dialogRef = this . dialog . open ( GameEditComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } editGame ( game : Game ) { const dialogRef = this . dialog . open ( GameEditComponent , { data : { game : game } }); dialogRef . afterClosed (). subscribe ( result => { this . onSearch (); }); } } Recuerda, de nuevo, que todos los componentes de Angular que utilicemos hay que importarlos en el m\u00f3dulo padre correspondiente para que se puedan precargar correctamente. game.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { GameListComponent } from './game-list/game-list.component' ; import { GameEditComponent } from './game-edit/game-edit.component' ; import { GameItemComponent } from './game-list/game-item/game-item.component' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; import { MatButtonModule } from '@angular/material/button' ; import { MatOptionModule } from '@angular/material/core' ; import { MatDialogModule } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatIconModule } from '@angular/material/icon' ; import { MatInputModule } from '@angular/material/input' ; import { MatPaginatorModule } from '@angular/material/paginator' ; import { MatSelectModule } from '@angular/material/select' ; import { MatTableModule } from '@angular/material/table' ; import { MatCardModule } from '@angular/material/card' ; @NgModule ({ declarations : [ GameListComponent , GameEditComponent , GameItemComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule , MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , MatPaginatorModule , MatOptionModule , MatSelectModule , MatCardModule , ] }) export class GameModule { } Con todos estos cambios y si refrescamos el navegador, deber\u00eda verse una pantalla similar a esta: Tenemos una pantalla con una secci\u00f3n de filtros en la parte superior, donde podemos introducir un texto o seleccionar una categor\u00eda de un dropdown, un listado que de momento tiene todos los componentes b\u00e1sicos en una fila uno detr\u00e1s del otro, y un bot\u00f3n para crear juegos nuevos. Dropdown El componente Dropdown es uno de los componentes m\u00e1s utilizados en las pantallas y formularios de Angular. Ves familiariz\u00e1ndote con \u00e9l porque lo vas a usar mucho. Es bastante potente y medianamente sencillo de utilizar. Los datos del listado pueden ser din\u00e1micos (desde servidor) o est\u00e1ticos (si los valores ya los tienes prefijados). Implementar detalle del item Ahora vamos a implementar el detalle de cada uno de los items que forman el listado. Para ello lo primero que haremos ser\u00e1 pasarle la informaci\u00f3n del juego a cada componente como un dato de entrada Input hacia el componente. game-list.component.html < div class = \"container\" > < h1 > Cat\u00e1logo de juegos </ h1 > < div class = \"filters\" > < form > < mat-form-field > < mat-label > T\u00edtulo del juego </ mat-label > < input type = \"text\" matInput placeholder = \"T\u00edtulo del juego\" [( ngModel )]=\" filterTitle \" name = \"title\" > </ mat-form-field > < mat-form-field > < mat-label > Categor\u00eda del juego </ mat-label > < mat-select disableRipple [( ngModel )]=\" filterCategory \" name = \"category\" > < mat-option * ngFor = \"let category of categories\" [ value ]=\" category \" > {{category.name}} </ mat-option > </ mat-select > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onCleanFilter ()\" > Limpiar </ button > < button mat-stroked-button ( click )=\" onSearch ()\" > Filtrar </ button > </ div > </ div > < div class = \"game-list\" > < app-game-item * ngFor = \"let game of games; let i = index;\" ( click )=\" editGame ( game )\" [ game ]=\" game \" > </ app-game-item > </ div > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createGame ()\" > Nuevo juego </ button > </ div > </ div > Tambi\u00e9n vamos a necesitar una foto de ejemplo para poner dentro de la tarjeta detalle de los juegos. Vamos a utilizar esta imagen: Desc\u00e1rgala y d\u00e9jala dentro del proyecto en assets/foto.png . Y ya para terminar, implementamos el componente de detalle: game-item.component.html game-item.component.scss game-item.component.ts < div class = \"container\" > < mat-card > < div class = \"photo\" > < img src = \"./assets/foto.png\" > </ div > < div class = \"detail\" > < div class = \"title\" > {{game.title}} </ div > < div class = \"properties\" > < div >< i > Edad recomendada: </ i > +{{game.age}} </ div > < div >< i > Categor\u00eda: </ i > {{game.category.name}} </ div > < div >< i > Autor: </ i > {{game.author.name}} </ div > < div >< i > Nacionalidad: </ i > {{game.author.nationality}} </ div > </ div > </ div > </ mat-card > </ div > . container { display : flex ; width : 325 px ; mat-card { width : 100 % ; margin : 10 px ; display : flex ; .photo { margin-right : 10 px ; img { width : 80 px ; height : 80 px ; } } . detail { .title { font-size : 14 px ; font-weight : bold ; } . properties { font-size : 11 px ; div { height : 15 px ; } } } } } import { Component , OnInit , Input } from '@angular/core' ; import { Game } from '../../model/Game' ; @Component ({ selector : 'app-game-item' , templateUrl : './game-item.component.html' , styleUrls : [ './game-item.component.scss' ] }) export class GameItemComponent implements OnInit { @Input () game : Game ; constructor () { } ngOnInit () : void { } } Ahora si que deber\u00eda quedar algo similar a esta pantalla: Implementar dialogo de edici\u00f3n Ya solo nos falta el \u00faltimo paso, implementar el cuadro de edici\u00f3n / alta de un nuevo juego. Pero tenemos un peque\u00f1o problema, y es que al crear o editar un juego debemos seleccionar una Categor\u00eda y un Autor . Para la Categor\u00eda no tenemos ning\u00fan problema, pero para el Autor no tenemos un servicio que nos devuelva todos los autores, solo tenemos un servicio que nos devuelve una Page de autores. As\u00ed que lo primero que haremos ser\u00e1 implementar una operaci\u00f3n getAllAuthors para poder recuperar una lista. mock-authors-list.ts author.service.ts import { Author } from \"./Author\" ; export const AUTHOR_DATA_LIST : Author [] = [ { id : 1 , name : 'Klaus Teuber' , nationality : 'Alemania' }, { id : 2 , name : 'Matt Leacock' , nationality : 'Estados Unidos' }, { id : 3 , name : 'Keng Leong Yeo' , nationality : 'Singapur' }, { id : 4 , name : 'Gil Hova' , nationality : 'Estados Unidos' }, { id : 5 , name : 'Kelly Adams' , nationality : 'Estados Unidos' }, ] import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Pageable } from '../core/model/page/Pageable' ; import { Author } from './model/Author' ; import { AuthorPage } from './model/AuthorPage' ; import { AUTHOR_DATA_LIST } from './model/mock-authors-list' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor ( private http : HttpClient ) { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return this . http . post < AuthorPage > ( 'http://localhost:8080/author' , { pageable : pageable }); } saveAuthor ( author : Author ) : Observable < void > { let url = 'http://localhost:8080/author' ; if ( author . id != null ) url += '/' + author . id ; return this . http . put < void > ( url , author ); } deleteAuthor ( idAuthor : number ) : Observable < void > { return this . http . delete < void > ( 'http://localhost:8080/author/' + idAuthor ); } getAllAuthors () : Observable < Author [] > { return of ( AUTHOR_DATA_LIST ); } } Ahora s\u00ed que tenemos todo listo para implementar el cuadro de dialogo para dar de alta o editar juegos. game-edit.component.html game-edit.component.scss game-edit.component.ts < div class = \"container\" > < h1 * ngIf = \"game.id == null\" > Crear juego </ h1 > < h1 * ngIf = \"game.id != null\" > Modificar juego </ h1 > < form > < mat-form-field > < mat-label > Identificador </ mat-label > < input type = \"text\" matInput placeholder = \"Identificador\" [( ngModel )]=\" game . id \" name = \"id\" disabled > </ mat-form-field > < mat-form-field > < mat-label > T\u00edtulo </ mat-label > < input type = \"text\" matInput placeholder = \"T\u00edtulo del juego\" [( ngModel )]=\" game . title \" name = \"title\" required > < mat-error > El t\u00edtulo no puede estar vac\u00edo </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Edad recomendada </ mat-label > < input type = \"number\" matInput placeholder = \"Edad recomendada\" [( ngModel )]=\" game . age \" name = \"age\" required > < mat-error > La edad no puede estar vac\u00eda </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Categor\u00eda </ mat-label > < mat-select disableRipple [( ngModel )]=\" game . category \" name = \"category\" required > < mat-option * ngFor = \"let category of categories\" [ value ]=\" category \" > {{category.name}} </ mat-option > </ mat-select > < mat-error > La categor\u00eda no puede estar vac\u00eda </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Autor </ mat-label > < mat-select disableRipple [( ngModel )]=\" game . author \" name = \"author\" required > < mat-option * ngFor = \"let author of authors\" [ value ]=\" author \" > {{author.name}} </ mat-option > </ mat-select > < mat-error > El autor no puede estar vac\u00edo </ mat-error > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onClose ()\" > Cerrar </ button > < button mat-flat-button color = \"primary\" ( click )=\" onSave ()\" > Guardar </ button > </ div > </ div > . container { min-width : 350 px ; max-width : 500 px ; padding : 20 px ; form { display : flex ; flex-direction : column ; margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } import { Component , Inject , OnInit } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { AuthorService } from 'src/app/author/author.service' ; import { Author } from 'src/app/author/model/Author' ; import { CategoryService } from 'src/app/category/category.service' ; import { Category } from 'src/app/category/model/Category' ; import { GameService } from '../game.service' ; import { Game } from '../model/Game' ; @Component ({ selector : 'app-game-edit' , templateUrl : './game-edit.component.html' , styleUrls : [ './game-edit.component.scss' ] }) export class GameEditComponent implements OnInit { game : Game ; authors : Author []; categories : Category []; constructor ( public dialogRef : MatDialogRef < GameEditComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any , private gameService : GameService , private categoryService : CategoryService , private authorService : AuthorService , ) { } ngOnInit () : void { if ( this . data . game != null ) { this . game = Object . assign ({}, this . data . game ); } else { this . game = new Game (); } this . categoryService . getCategories (). subscribe ( categories => { this . categories = categories ; if ( this . game . category != null ) { let categoryFilter : Category [] = categories . filter ( category => category . id == this . data . game . category . id ); if ( categoryFilter != null ) { this . game . category = categoryFilter [ 0 ]; } } } ); this . authorService . getAllAuthors (). subscribe ( authors => { this . authors = authors if ( this . game . author != null ) { let authorFilter : Author [] = authors . filter ( author => author . id == this . data . game . author . id ); if ( authorFilter != null ) { this . game . author = authorFilter [ 0 ]; } } } ); } onSave () { this . gameService . saveGame ( this . game ). subscribe ( result => { this . dialogRef . close (); }); } onClose () { this . dialogRef . close (); } } Como puedes ver, para rellenar los componentes seleccionables de dropdown, hemos realizado una consulta al servicio para recuperar todos los autores y categorias, y en la respuesta de cada uno de ellos, hemos buscado en los resultados cual es el que coincide con el ID enviado desde el listado, y ese es el que hemos fijado en el objeto Game . De esta forma, no estamos cogiendo directamente los datos del listado, sino que no estamos asegurando que los datos de autor y de categor\u00eda son los que vienen del servicio, siempre filtrando por su ID. Conectar con Backend Antes de seguir Antes de seguir con este punto, debes implementar el c\u00f3digo de backend en la tecnolog\u00eda que quieras ( Springboot o Nodejs ). Si has empezado este cap\u00edtulo implementando el frontend, por favor accede a la secci\u00f3n correspondiente de backend para poder continuar con el tutorial. Una vez tengas implementadas todas las operaciones para este listado, puedes volver a este punto y continuar con Angular. Una vez implementado front y back, lo que nos queda es modificar el servicio del front para que conecte directamente con las operaciones ofrecidas por el back. author-service.ts game-service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Pageable } from '../core/model/page/Pageable' ; import { Author } from './model/Author' ; import { AuthorPage } from './model/AuthorPage' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor ( private http : HttpClient ) { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return this . http . post < AuthorPage > ( 'http://localhost:8080/author' , { pageable : pageable }); } saveAuthor ( author : Author ) : Observable < void > { let url = 'http://localhost:8080/author' ; if ( author . id != null ) url += '/' + author . id ; return this . http . put < void > ( url , author ); } deleteAuthor ( idAuthor : number ) : Observable < void > { return this . http . delete < void > ( 'http://localhost:8080/author/' + idAuthor ); } getAllAuthors () : Observable < Author [] > { return this . http . get < Author [] > ( 'http://localhost:8080/author' ); } } import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Game } from './model/Game' ; @Injectable ({ providedIn : 'root' }) export class GameService { constructor ( private http : HttpClient ) { } getGames ( title? : String , categoryId? : number ) : Observable < Game [] > { return this . http . get < Game [] > ( this . composeFindUrl ( title , categoryId )); } saveGame ( game : Game ) : Observable < void > { let url = 'http://localhost:8080/game' ; if ( game . id != null ) { url += '/' + game . id ; } return this . http . put < void > ( url , game ); } private composeFindUrl ( title? : String , categoryId? : number ) : string { let params = '' ; if ( title != null ) { params += 'title=' + title ; } if ( categoryId != null ) { if ( params != '' ) params += \"&\" ; params += \"idCategory=\" + categoryId ; } let url = 'http://localhost:8080/game' if ( params == '' ) return url ; else return url + '?' + params ; } } Y ahora si, podemos navegar por la web y ver el resultado completo.","title":"\ud83d\udd35 Angular"},{"location":"develop/filtered/angular/#listado-filtrado-angular","text":"En este punto ya tenemos dos listados, uno b\u00e1sico y otro paginado. Ahora vamos a implementar un listado un poco diferente, con filtros y con una presentaci\u00f3n un tanto distinta. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.","title":"Listado filtrado - Angular"},{"location":"develop/filtered/angular/#crear-componentes","text":"Vamos a desarrollar el listado de Juegos . Este listado es un tanto peculiar, porque no tiene una tabla como tal, sino que tiene una tabla con \"tiles\" para cada uno de los juegos. Necesitaremos un componente para el listado y otro componente para el detalle del juego. Tambi\u00e9n necesitaremos otro componente para el dialogo de edici\u00f3n / alta. Manos a la obra: ng generate module game ng generate component game/game-list ng generate component game/game-list/game-item ng generate component game/game-edit ng generate service game/game Y a\u00f1adimos el nuevo m\u00f3dulo al app.module.ts como hemos hecho con el resto de m\u00f3dulos. Game.ts import { NgModule } from '@angular/core' ; import { BrowserModule } from '@angular/platform-browser' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { BrowserAnimationsModule } from '@angular/platform-browser/animations' ; import { CoreModule } from './core/core.module' ; import { CategoryModule } from './category/category.module' ; import { AuthorModule } from './author/author.module' ; import { GameModule } from './game/game.module' ; @NgModule ({ declarations : [ AppComponent ], imports : [ BrowserModule , AppRoutingModule , CoreModule , CategoryModule , AuthorModule , GameModule , BrowserAnimationsModule ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { }","title":"Crear componentes"},{"location":"develop/filtered/angular/#crear-el-modelo","text":"Lo primero que vamos a hacer es crear el modelo en game/model/Game.ts con todas las propiedades necesarias para trabajar con un juego: Game.ts import { Category } from \"src/app/category/model/Category\" ; import { Author } from \"src/app/author/model/Author\" ; export class Game { id : number ; title : string ; age : number ; category : Category ; author : Author ; } Como ves, el juego tiene dos objetos para mapear categor\u00eda y autor.","title":"Crear el modelo"},{"location":"develop/filtered/angular/#anadir-el-punto-de-entrada","text":"A\u00f1adimos la ruta al men\u00fa para que podamos navegar a esta pantalla: app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { AuthorListComponent } from './author/author-list/author-list.component' ; import { CategoryListComponent } from './category/category-list/category-list.component' ; import { GameListComponent } from './game/game-list/game-list.component' ; const routes : Routes = [ { path : '' , redirectTo : '/games' , pathMatch : 'full' }, { path : 'categories' , component : CategoryListComponent }, { path : 'authors' , component : AuthorListComponent }, { path : 'games' , component : GameListComponent }, ]; @NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } Adem\u00e1s, hemos a\u00f1adido una regla adicional con el path vac\u00edo para indicar que si no pone ruta, por defecto la p\u00e1gina inicial redirija al path /games , que es nuevo path que hemos a\u00f1adido.","title":"A\u00f1adir el punto de entrada"},{"location":"develop/filtered/angular/#implementar-servicio","text":"A continuaci\u00f3n implementamos el servicio y mockeamos datos de ejemplo: mock-games.ts game.service.ts import { Game } from \"./Game\" ; export const GAME_DATA : Game [] = [ { id : 1 , title : 'Juego 1' , age : 6 , category : { id : 1 , name : 'Categor\u00eda 1' }, author : { id : 1 , name : 'Autor 1' , nationality : 'Nacionalidad 1' } }, { id : 2 , title : 'Juego 2' , age : 8 , category : { id : 1 , name : 'Categor\u00eda 1' }, author : { id : 2 , name : 'Autor 2' , nationality : 'Nacionalidad 2' } }, { id : 3 , title : 'Juego 3' , age : 4 , category : { id : 1 , name : 'Categor\u00eda 1' }, author : { id : 3 , name : 'Autor 3' , nationality : 'Nacionalidad 3' } }, { id : 4 , title : 'Juego 4' , age : 10 , category : { id : 2 , name : 'Categor\u00eda 2' }, author : { id : 1 , name : 'Autor 1' , nationality : 'Nacionalidad 1' } }, { id : 5 , title : 'Juego 5' , age : 16 , category : { id : 2 , name : 'Categor\u00eda 2' }, author : { id : 2 , name : 'Autor 2' , nationality : 'Nacionalidad 2' } }, { id : 6 , title : 'Juego 6' , age : 16 , category : { id : 2 , name : 'Categor\u00eda 2' }, author : { id : 3 , name : 'Autor 3' , nationality : 'Nacionalidad 3' } }, { id : 7 , title : 'Juego 7' , age : 12 , category : { id : 3 , name : 'Categor\u00eda 3' }, author : { id : 1 , name : 'Autor 1' , nationality : 'Nacionalidad 1' } }, { id : 8 , title : 'Juego 8' , age : 14 , category : { id : 3 , name : 'Categor\u00eda 3' }, author : { id : 2 , name : 'Autor 2' , nationality : 'Nacionalidad 2' } }, ] import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Game } from './model/Game' ; import { GAME_DATA } from './model/mock-games' ; @Injectable ({ providedIn : 'root' }) export class GameService { constructor () { } getGames ( title? : String , categoryId? : number ) : Observable < Game [] > { return of ( GAME_DATA ); } saveGame ( game : Game ) : Observable < void > { return of ( null ); } }","title":"Implementar servicio"},{"location":"develop/filtered/angular/#implementar-listado","text":"Ya tenemos las operaciones del servicio con datoos, as\u00ed que ahora vamos a por el listado filtrado. game-list.component.html game-list.component.scss game-list.component.ts < div class = \"container\" > < h1 > Cat\u00e1logo de juegos </ h1 > < div class = \"filters\" > < form > < mat-form-field > < mat-label > T\u00edtulo del juego </ mat-label > < input type = \"text\" matInput placeholder = \"T\u00edtulo del juego\" [( ngModel )]=\" filterTitle \" name = \"title\" > </ mat-form-field > < mat-form-field > < mat-label > Categor\u00eda del juego </ mat-label > < mat-select disableRipple [( ngModel )]=\" filterCategory \" name = \"category\" > < mat-option * ngFor = \"let category of categories\" [ value ]=\" category \" > {{category.name}} </ mat-option > </ mat-select > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onCleanFilter ()\" > Limpiar </ button > < button mat-stroked-button ( click )=\" onSearch ()\" > Filtrar </ button > </ div > </ div > < div class = \"game-list\" > < app-game-item * ngFor = \"let game of games; let i = index;\" ( click )=\" editGame ( game )\" > </ app-game-item > </ div > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createGame ()\" > Nuevo juego </ button > </ div > </ div > . container { margin : 20 px ; .filters { display : flex ; mat-form-field { width : 300 px ; margin-right : 20 px ; } . buttons { flex : auto ; align-self : center ; button { margin-left : 15 px ; } } } . game-list { margin-top : 20 px ; margin-bottom : 20 px ; display : flex ; flex-flow : wrap ; overflow : auto ; } . buttons { text-align : right ; } } button { width : 125 px ; } import { Component , OnInit } from '@angular/core' ; import { MatDialog } from '@angular/material/dialog' ; import { CategoryService } from 'src/app/category/category.service' ; import { Category } from 'src/app/category/model/Category' ; import { GameEditComponent } from '../game-edit/game-edit.component' ; import { GameService } from '../game.service' ; import { Game } from '../model/Game' ; @Component ({ selector : 'app-game-list' , templateUrl : './game-list.component.html' , styleUrls : [ './game-list.component.scss' ] }) export class GameListComponent implements OnInit { categories : Category []; games : Game []; filterCategory : Category ; filterTitle : string ; constructor ( private gameService : GameService , private categoryService : CategoryService , public dialog : MatDialog , ) { } ngOnInit () : void { this . gameService . getGames (). subscribe ( games => this . games = games ); this . categoryService . getCategories (). subscribe ( categories => this . categories = categories ); } onCleanFilter () : void { this . filterTitle = null ; this . filterCategory = null ; this . onSearch (); } onSearch () : void { let title = this . filterTitle ; let categoryId = this . filterCategory != null ? this.filterCategory.id : null ; this . gameService . getGames ( title , categoryId ). subscribe ( games => this . games = games ); } createGame () { const dialogRef = this . dialog . open ( GameEditComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } editGame ( game : Game ) { const dialogRef = this . dialog . open ( GameEditComponent , { data : { game : game } }); dialogRef . afterClosed (). subscribe ( result => { this . onSearch (); }); } } Recuerda, de nuevo, que todos los componentes de Angular que utilicemos hay que importarlos en el m\u00f3dulo padre correspondiente para que se puedan precargar correctamente. game.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { GameListComponent } from './game-list/game-list.component' ; import { GameEditComponent } from './game-edit/game-edit.component' ; import { GameItemComponent } from './game-list/game-item/game-item.component' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; import { MatButtonModule } from '@angular/material/button' ; import { MatOptionModule } from '@angular/material/core' ; import { MatDialogModule } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatIconModule } from '@angular/material/icon' ; import { MatInputModule } from '@angular/material/input' ; import { MatPaginatorModule } from '@angular/material/paginator' ; import { MatSelectModule } from '@angular/material/select' ; import { MatTableModule } from '@angular/material/table' ; import { MatCardModule } from '@angular/material/card' ; @NgModule ({ declarations : [ GameListComponent , GameEditComponent , GameItemComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule , MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , MatPaginatorModule , MatOptionModule , MatSelectModule , MatCardModule , ] }) export class GameModule { } Con todos estos cambios y si refrescamos el navegador, deber\u00eda verse una pantalla similar a esta: Tenemos una pantalla con una secci\u00f3n de filtros en la parte superior, donde podemos introducir un texto o seleccionar una categor\u00eda de un dropdown, un listado que de momento tiene todos los componentes b\u00e1sicos en una fila uno detr\u00e1s del otro, y un bot\u00f3n para crear juegos nuevos. Dropdown El componente Dropdown es uno de los componentes m\u00e1s utilizados en las pantallas y formularios de Angular. Ves familiariz\u00e1ndote con \u00e9l porque lo vas a usar mucho. Es bastante potente y medianamente sencillo de utilizar. Los datos del listado pueden ser din\u00e1micos (desde servidor) o est\u00e1ticos (si los valores ya los tienes prefijados).","title":"Implementar listado"},{"location":"develop/filtered/angular/#implementar-detalle-del-item","text":"Ahora vamos a implementar el detalle de cada uno de los items que forman el listado. Para ello lo primero que haremos ser\u00e1 pasarle la informaci\u00f3n del juego a cada componente como un dato de entrada Input hacia el componente. game-list.component.html < div class = \"container\" > < h1 > Cat\u00e1logo de juegos </ h1 > < div class = \"filters\" > < form > < mat-form-field > < mat-label > T\u00edtulo del juego </ mat-label > < input type = \"text\" matInput placeholder = \"T\u00edtulo del juego\" [( ngModel )]=\" filterTitle \" name = \"title\" > </ mat-form-field > < mat-form-field > < mat-label > Categor\u00eda del juego </ mat-label > < mat-select disableRipple [( ngModel )]=\" filterCategory \" name = \"category\" > < mat-option * ngFor = \"let category of categories\" [ value ]=\" category \" > {{category.name}} </ mat-option > </ mat-select > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onCleanFilter ()\" > Limpiar </ button > < button mat-stroked-button ( click )=\" onSearch ()\" > Filtrar </ button > </ div > </ div > < div class = \"game-list\" > < app-game-item * ngFor = \"let game of games; let i = index;\" ( click )=\" editGame ( game )\" [ game ]=\" game \" > </ app-game-item > </ div > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createGame ()\" > Nuevo juego </ button > </ div > </ div > Tambi\u00e9n vamos a necesitar una foto de ejemplo para poner dentro de la tarjeta detalle de los juegos. Vamos a utilizar esta imagen: Desc\u00e1rgala y d\u00e9jala dentro del proyecto en assets/foto.png . Y ya para terminar, implementamos el componente de detalle: game-item.component.html game-item.component.scss game-item.component.ts < div class = \"container\" > < mat-card > < div class = \"photo\" > < img src = \"./assets/foto.png\" > </ div > < div class = \"detail\" > < div class = \"title\" > {{game.title}} </ div > < div class = \"properties\" > < div >< i > Edad recomendada: </ i > +{{game.age}} </ div > < div >< i > Categor\u00eda: </ i > {{game.category.name}} </ div > < div >< i > Autor: </ i > {{game.author.name}} </ div > < div >< i > Nacionalidad: </ i > {{game.author.nationality}} </ div > </ div > </ div > </ mat-card > </ div > . container { display : flex ; width : 325 px ; mat-card { width : 100 % ; margin : 10 px ; display : flex ; .photo { margin-right : 10 px ; img { width : 80 px ; height : 80 px ; } } . detail { .title { font-size : 14 px ; font-weight : bold ; } . properties { font-size : 11 px ; div { height : 15 px ; } } } } } import { Component , OnInit , Input } from '@angular/core' ; import { Game } from '../../model/Game' ; @Component ({ selector : 'app-game-item' , templateUrl : './game-item.component.html' , styleUrls : [ './game-item.component.scss' ] }) export class GameItemComponent implements OnInit { @Input () game : Game ; constructor () { } ngOnInit () : void { } } Ahora si que deber\u00eda quedar algo similar a esta pantalla:","title":"Implementar detalle del item"},{"location":"develop/filtered/angular/#implementar-dialogo-de-edicion","text":"Ya solo nos falta el \u00faltimo paso, implementar el cuadro de edici\u00f3n / alta de un nuevo juego. Pero tenemos un peque\u00f1o problema, y es que al crear o editar un juego debemos seleccionar una Categor\u00eda y un Autor . Para la Categor\u00eda no tenemos ning\u00fan problema, pero para el Autor no tenemos un servicio que nos devuelva todos los autores, solo tenemos un servicio que nos devuelve una Page de autores. As\u00ed que lo primero que haremos ser\u00e1 implementar una operaci\u00f3n getAllAuthors para poder recuperar una lista. mock-authors-list.ts author.service.ts import { Author } from \"./Author\" ; export const AUTHOR_DATA_LIST : Author [] = [ { id : 1 , name : 'Klaus Teuber' , nationality : 'Alemania' }, { id : 2 , name : 'Matt Leacock' , nationality : 'Estados Unidos' }, { id : 3 , name : 'Keng Leong Yeo' , nationality : 'Singapur' }, { id : 4 , name : 'Gil Hova' , nationality : 'Estados Unidos' }, { id : 5 , name : 'Kelly Adams' , nationality : 'Estados Unidos' }, ] import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Pageable } from '../core/model/page/Pageable' ; import { Author } from './model/Author' ; import { AuthorPage } from './model/AuthorPage' ; import { AUTHOR_DATA_LIST } from './model/mock-authors-list' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor ( private http : HttpClient ) { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return this . http . post < AuthorPage > ( 'http://localhost:8080/author' , { pageable : pageable }); } saveAuthor ( author : Author ) : Observable < void > { let url = 'http://localhost:8080/author' ; if ( author . id != null ) url += '/' + author . id ; return this . http . put < void > ( url , author ); } deleteAuthor ( idAuthor : number ) : Observable < void > { return this . http . delete < void > ( 'http://localhost:8080/author/' + idAuthor ); } getAllAuthors () : Observable < Author [] > { return of ( AUTHOR_DATA_LIST ); } } Ahora s\u00ed que tenemos todo listo para implementar el cuadro de dialogo para dar de alta o editar juegos. game-edit.component.html game-edit.component.scss game-edit.component.ts < div class = \"container\" > < h1 * ngIf = \"game.id == null\" > Crear juego </ h1 > < h1 * ngIf = \"game.id != null\" > Modificar juego </ h1 > < form > < mat-form-field > < mat-label > Identificador </ mat-label > < input type = \"text\" matInput placeholder = \"Identificador\" [( ngModel )]=\" game . id \" name = \"id\" disabled > </ mat-form-field > < mat-form-field > < mat-label > T\u00edtulo </ mat-label > < input type = \"text\" matInput placeholder = \"T\u00edtulo del juego\" [( ngModel )]=\" game . title \" name = \"title\" required > < mat-error > El t\u00edtulo no puede estar vac\u00edo </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Edad recomendada </ mat-label > < input type = \"number\" matInput placeholder = \"Edad recomendada\" [( ngModel )]=\" game . age \" name = \"age\" required > < mat-error > La edad no puede estar vac\u00eda </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Categor\u00eda </ mat-label > < mat-select disableRipple [( ngModel )]=\" game . category \" name = \"category\" required > < mat-option * ngFor = \"let category of categories\" [ value ]=\" category \" > {{category.name}} </ mat-option > </ mat-select > < mat-error > La categor\u00eda no puede estar vac\u00eda </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Autor </ mat-label > < mat-select disableRipple [( ngModel )]=\" game . author \" name = \"author\" required > < mat-option * ngFor = \"let author of authors\" [ value ]=\" author \" > {{author.name}} </ mat-option > </ mat-select > < mat-error > El autor no puede estar vac\u00edo </ mat-error > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onClose ()\" > Cerrar </ button > < button mat-flat-button color = \"primary\" ( click )=\" onSave ()\" > Guardar </ button > </ div > </ div > . container { min-width : 350 px ; max-width : 500 px ; padding : 20 px ; form { display : flex ; flex-direction : column ; margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } import { Component , Inject , OnInit } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { AuthorService } from 'src/app/author/author.service' ; import { Author } from 'src/app/author/model/Author' ; import { CategoryService } from 'src/app/category/category.service' ; import { Category } from 'src/app/category/model/Category' ; import { GameService } from '../game.service' ; import { Game } from '../model/Game' ; @Component ({ selector : 'app-game-edit' , templateUrl : './game-edit.component.html' , styleUrls : [ './game-edit.component.scss' ] }) export class GameEditComponent implements OnInit { game : Game ; authors : Author []; categories : Category []; constructor ( public dialogRef : MatDialogRef < GameEditComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any , private gameService : GameService , private categoryService : CategoryService , private authorService : AuthorService , ) { } ngOnInit () : void { if ( this . data . game != null ) { this . game = Object . assign ({}, this . data . game ); } else { this . game = new Game (); } this . categoryService . getCategories (). subscribe ( categories => { this . categories = categories ; if ( this . game . category != null ) { let categoryFilter : Category [] = categories . filter ( category => category . id == this . data . game . category . id ); if ( categoryFilter != null ) { this . game . category = categoryFilter [ 0 ]; } } } ); this . authorService . getAllAuthors (). subscribe ( authors => { this . authors = authors if ( this . game . author != null ) { let authorFilter : Author [] = authors . filter ( author => author . id == this . data . game . author . id ); if ( authorFilter != null ) { this . game . author = authorFilter [ 0 ]; } } } ); } onSave () { this . gameService . saveGame ( this . game ). subscribe ( result => { this . dialogRef . close (); }); } onClose () { this . dialogRef . close (); } } Como puedes ver, para rellenar los componentes seleccionables de dropdown, hemos realizado una consulta al servicio para recuperar todos los autores y categorias, y en la respuesta de cada uno de ellos, hemos buscado en los resultados cual es el que coincide con el ID enviado desde el listado, y ese es el que hemos fijado en el objeto Game . De esta forma, no estamos cogiendo directamente los datos del listado, sino que no estamos asegurando que los datos de autor y de categor\u00eda son los que vienen del servicio, siempre filtrando por su ID.","title":"Implementar dialogo de edici\u00f3n"},{"location":"develop/filtered/angular/#conectar-con-backend","text":"Antes de seguir Antes de seguir con este punto, debes implementar el c\u00f3digo de backend en la tecnolog\u00eda que quieras ( Springboot o Nodejs ). Si has empezado este cap\u00edtulo implementando el frontend, por favor accede a la secci\u00f3n correspondiente de backend para poder continuar con el tutorial. Una vez tengas implementadas todas las operaciones para este listado, puedes volver a este punto y continuar con Angular. Una vez implementado front y back, lo que nos queda es modificar el servicio del front para que conecte directamente con las operaciones ofrecidas por el back. author-service.ts game-service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Pageable } from '../core/model/page/Pageable' ; import { Author } from './model/Author' ; import { AuthorPage } from './model/AuthorPage' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor ( private http : HttpClient ) { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return this . http . post < AuthorPage > ( 'http://localhost:8080/author' , { pageable : pageable }); } saveAuthor ( author : Author ) : Observable < void > { let url = 'http://localhost:8080/author' ; if ( author . id != null ) url += '/' + author . id ; return this . http . put < void > ( url , author ); } deleteAuthor ( idAuthor : number ) : Observable < void > { return this . http . delete < void > ( 'http://localhost:8080/author/' + idAuthor ); } getAllAuthors () : Observable < Author [] > { return this . http . get < Author [] > ( 'http://localhost:8080/author' ); } } import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Game } from './model/Game' ; @Injectable ({ providedIn : 'root' }) export class GameService { constructor ( private http : HttpClient ) { } getGames ( title? : String , categoryId? : number ) : Observable < Game [] > { return this . http . get < Game [] > ( this . composeFindUrl ( title , categoryId )); } saveGame ( game : Game ) : Observable < void > { let url = 'http://localhost:8080/game' ; if ( game . id != null ) { url += '/' + game . id ; } return this . http . put < void > ( url , game ); } private composeFindUrl ( title? : String , categoryId? : number ) : string { let params = '' ; if ( title != null ) { params += 'title=' + title ; } if ( categoryId != null ) { if ( params != '' ) params += \"&\" ; params += \"idCategory=\" + categoryId ; } let url = 'http://localhost:8080/game' if ( params == '' ) return url ; else return url + '?' + params ; } } Y ahora si, podemos navegar por la web y ver el resultado completo.","title":"Conectar con Backend"},{"location":"develop/filtered/nodejs/","text":"Listado simple - Nodejs En este punto ya tenemos dos listados, uno b\u00e1sico y otro paginado. Ahora vamos a implementar un listado un poco diferente, este listado va a tener filtros de b\u00fasqueda. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades. Crear Modelos Lo primero que vamos a hacer es crear el modelo de author para trabajar con BBDD. En la carpeta schemas creamos el archivo game.schema.js : game.schema.js import mongoose from \"mongoose\" ; const { Schema , model } = mongoose ; import normalize from 'normalize-mongoose' ; const gameSchema = new Schema ({ title : { type : String , require : true }, age : { type : Number , require : true , max : 99 , min : 0 }, category : { type : Schema . Types . ObjectId , ref : 'Category' , required : true }, author : { type : Schema . Types . ObjectId , ref : 'Author' , required : true } }); gameSchema . plugin ( normalize ); const GameModel = model ( 'Game' , gameSchema ); export default GameModel ; Lo m\u00e1s novedoso aqu\u00ed es que ahora cada juego va a tener una categor\u00eda y un autor asociados. Para ello simplemente en el tipo del dato Category y Author tenemos que hacer referencia al id del esquema deseado. Implementar el Service Creamos el service correspondiente game.service.js : game.service.js import GameModel from '../schemas/game.schema.js' ; export const getGames = async ( title , category ) => { try { const regexTitle = new RegExp ( title , 'i' ); const find = category ? { $and : [{ title : regexTitle }, { category : category }] } : { title : regexTitle }; return await GameModel . find ( find ). sort ( 'id' ). populate ( 'category' ). populate ( 'author' ); } catch ( e ) { throw Error ( 'Error fetching games' ); } } export const createGame = async ( data ) => { try { const game = new GameModel ({ ... data , category : data . category . id , author : data . author . id , }); return await game . save (); } catch ( e ) { throw Error ( 'Error creating game' ); } } export const updateGame = async ( id , data ) => { try { const game = await GameModel . findById ( id ); if ( ! game ) { throw Error ( 'There is no game with that Id' ); } const gameToUpdate = { ... data , category : data . category . id , author : data . author . id , }; return await GameModel . findByIdAndUpdate ( id , gameToUpdate , { new : false }); } catch ( e ) { throw Error ( e ); } } En este caso recibimos en el m\u00e9todo para recuperar juegos dos par\u00e1metros, el titulo del juego y la categor\u00eda. Aqu\u00ed vamos a utilizar una expresi\u00f3n regular para que podamos encontrar cualquier juego que contenga el titulo que pasemos en su nombre. Con la categor\u00eda tiene que ser el valor exacto de su id. El m\u00e9todo populate lo que hace es traernos toda la informaci\u00f3n de la categor\u00eda y del autor. Sino lo us\u00e1semos solo nos recuperar\u00eda el id. Implementar el Controller Creamos el controlador game.controller.js : game.controller.js import * as GameService from '../services/game.service.js' ; export const getGames = async ( req , res ) => { try { const titleToFind = req . query ? . title || '' ; const categoryToFind = req . query ? . idCategory || null ; const games = await GameService . getGames ( titleToFind , categoryToFind ); res . status ( 200 ). json ( games ); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } export const createGame = async ( req , res ) => { try { const game = await GameService . createGame ( req . body ); res . status ( 200 ). json ({ game }); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } export const updateGame = async ( req , res ) => { const gameId = req . params . id ; try { await GameService . updateGame ( gameId , req . body ); res . status ( 200 ). json ( 1 ); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } Los m\u00e9todos son muy parecidos al resto de los controllers. En este caso para recuperar los datos del filtro tendremos que hacerlo con req.query para leer los datos que nos lleguen como query params en la url. Por ejemplo: http://localhost:8080/game?title=trivial&category=1 Implementar las Rutas Y por \u00faltimo creamos nuestro archivo de rutas game.routes.js : game.routes.js import { Router } from 'express' ; import { check } from 'express-validator' ; import validateFields from '../middlewares/validateFields.js' ; import { createGame , getGames , updateGame } from '../controllers/game.controller.js' ; const gameRouter = Router (); gameRouter . put ( '/:id' , [ check ( 'title' ). not (). isEmpty (), check ( 'age' ). not (). isEmpty (), check ( 'age' ). isNumeric (), check ( 'category.id' ). not (). isEmpty (), check ( 'author.id' ). not (). isEmpty (), validateFields ], updateGame ); gameRouter . put ( '/' , [ check ( 'title' ). not (). isEmpty (), check ( 'age' ). not (). isEmpty (), check ( 'age' ). isNumeric (), check ( 'category.id' ). not (). isEmpty (), check ( 'author.id' ). not (). isEmpty (), validateFields ], createGame ); gameRouter . get ( '/' , getGames ); gameRouter . get ( '/:query' , getGames ); export default gameRouter ; En este caso hemos tenido que meter dos rutas para get , una para cuando se informen los filtros y otra para cuando no vayan informados. Si lo hici\u00e9ramos con una \u00fanica ruta nos fallar\u00eda en el otro caso. Finalmente en nuestro archivo index.js vamos a a\u00f1adir el nuevo router: index.js ... import gameRouter from './src/routes/game.routes.js' ; ... app . use ( '/game' , gameRouter ); ... Probar las operaciones Y ahora que tenemos todo creado, ya podemos probarlo con Postman: Por un lado creamos juegos con: PUT /game PUT /game/{id} { \"title\" : \"Nuevo juego\" , \"age\" : \"18\" , \"category\" : { \"id\" : \"63e8b795f7dae4b980b63202\" }, \"author\" : { \"id\" : \"63e8bda064c208e065667bfa\" } } Tambi\u00e9n podemos filtrar y recuperar informaci\u00f3n: GET /game GET /game?title=xxx GET /game?idCategory=xxx Implementar validaciones Ahora que ya tenemos todos nuestros CRUDs creados vamos a introducir unas peque\u00f1as validaciones. Validaci\u00f3n en borrado La primera validaci\u00f3n sera para que no podamos borrar categor\u00edas ni autores que tengan un juego asociado. Para ello primero tendremos que crear un m\u00e9todo en el servicio de juegos para buscar los juegos que correspondan con un campo dado. En game.service.js a\u00f1adimos: game.service.js ... export const getGame = async ( field ) => { try { return await GameModel . find ( field ); } catch ( e ) { throw Error ( 'Error fetching games' ); } } ... Y ahora en category.service.js importamos el m\u00e9todo creado y modificamos el m\u00e9todo para borrar categor\u00edas: category.service.js ... import { getGame } from './game.service.js' ; ... ... export const deleteCategory = async ( id ) => { try { const category = await CategoryModel . findById ( id ); if ( ! category ) { throw 'There is no category with that Id' ; } const games = await getGame ({ category }); if ( games . length > 0 ) { throw 'There are games related to this category' ; } return await CategoryModel . findByIdAndDelete ( id ); } catch ( e ) { throw Error ( e ); } } ... De este modo si encontramos alg\u00fan juego con esta categor\u00eda no nos dejar\u00e1 borrarla. Por \u00faltimo, hacemos lo mismo en author.service.js : author.service.js ... import { getGame } from './game.service.js' ; ... ... export const deleteAuthor = async ( id ) => { try { const author = await AuthorModel . findById ( id ); if ( ! author ) { throw 'There is no author with that Id' ; } const games = await getGame ({ author }); if ( games . length > 0 ) { throw 'There are games related to this author' ; } return await AuthorModel . findByIdAndDelete ( id ); } catch ( e ) { throw Error ( e ); } } ... Validaci\u00f3n en creaci\u00f3n En las creaciones es conveniente validad la existencia de las entidades relacionadas para garantizar la integridad de la BBDD. Para esto vamos a introducir una validaci\u00f3n en la creaci\u00f3n y edici\u00f3n de los juegos para garantizar que la categor\u00eda y el autor proporcionados existen. En primer lugar vamos a crear los servicios de consulta de categor\u00eda y autor: category.service.js ... export const getCategory = async ( id ) => { try { return await CategoryModel . findById ( id ); } catch ( e ) { throw Error ( 'There is no category with that Id' ); } } ... author.service.js ... export const getAuthor = async ( id ) => { try { return await AuthorModel . findById ( id ); } catch ( e ) { throw Error ( 'There is no author with that Id' ); } } ... Teniendo los servicios ya disponibles, vamos a a\u00f1adir las validaciones a los servicios de creaci\u00f3n y edici\u00f3n: game.service.js ... import { getCategory } from './category.service.js' ; import { getAuthor } from './author.service.js' ; ... ... export const createGame = async ( data ) => { try { const category = await getCategory ( data . category . id ); if ( ! category ) { throw Error ( 'There is no category with that Id' ); } const author = await getAuthor ( data . author . id ); if ( ! author ) { throw Error ( 'There is no author with that Id' ); } const game = new GameModel ({ ... data , category : data . category . id , author : data . author . id , }); return await game . save (); } catch ( e ) { throw Error ( e ); } } ... ... export const updateGame = async ( id , data ) => { try { const game = await GameModel . findById ( id ); if ( ! game ) { throw Error ( 'There is no game with that Id' ); } const category = await getCategory ( data . category . id ); if ( ! category ) { throw Error ( 'There is no category with that Id' ); } const author = await getAuthor ( data . author . id ); if ( ! author ) { throw Error ( 'There is no author with that Id' ); } const gameToUpdate = { ... data , category : data . category . id , author : data . author . id , }; return await GameModel . findByIdAndUpdate ( id , gameToUpdate , { new : false }); } catch ( e ) { throw Error ( e ); } } ... Con esto ya tendr\u00edamos acabado nuestro CRUD.","title":"\ud83d\udfe2 Nodejs"},{"location":"develop/filtered/nodejs/#listado-simple-nodejs","text":"En este punto ya tenemos dos listados, uno b\u00e1sico y otro paginado. Ahora vamos a implementar un listado un poco diferente, este listado va a tener filtros de b\u00fasqueda. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.","title":"Listado simple - Nodejs"},{"location":"develop/filtered/nodejs/#crear-modelos","text":"Lo primero que vamos a hacer es crear el modelo de author para trabajar con BBDD. En la carpeta schemas creamos el archivo game.schema.js : game.schema.js import mongoose from \"mongoose\" ; const { Schema , model } = mongoose ; import normalize from 'normalize-mongoose' ; const gameSchema = new Schema ({ title : { type : String , require : true }, age : { type : Number , require : true , max : 99 , min : 0 }, category : { type : Schema . Types . ObjectId , ref : 'Category' , required : true }, author : { type : Schema . Types . ObjectId , ref : 'Author' , required : true } }); gameSchema . plugin ( normalize ); const GameModel = model ( 'Game' , gameSchema ); export default GameModel ; Lo m\u00e1s novedoso aqu\u00ed es que ahora cada juego va a tener una categor\u00eda y un autor asociados. Para ello simplemente en el tipo del dato Category y Author tenemos que hacer referencia al id del esquema deseado.","title":"Crear Modelos"},{"location":"develop/filtered/nodejs/#implementar-el-service","text":"Creamos el service correspondiente game.service.js : game.service.js import GameModel from '../schemas/game.schema.js' ; export const getGames = async ( title , category ) => { try { const regexTitle = new RegExp ( title , 'i' ); const find = category ? { $and : [{ title : regexTitle }, { category : category }] } : { title : regexTitle }; return await GameModel . find ( find ). sort ( 'id' ). populate ( 'category' ). populate ( 'author' ); } catch ( e ) { throw Error ( 'Error fetching games' ); } } export const createGame = async ( data ) => { try { const game = new GameModel ({ ... data , category : data . category . id , author : data . author . id , }); return await game . save (); } catch ( e ) { throw Error ( 'Error creating game' ); } } export const updateGame = async ( id , data ) => { try { const game = await GameModel . findById ( id ); if ( ! game ) { throw Error ( 'There is no game with that Id' ); } const gameToUpdate = { ... data , category : data . category . id , author : data . author . id , }; return await GameModel . findByIdAndUpdate ( id , gameToUpdate , { new : false }); } catch ( e ) { throw Error ( e ); } } En este caso recibimos en el m\u00e9todo para recuperar juegos dos par\u00e1metros, el titulo del juego y la categor\u00eda. Aqu\u00ed vamos a utilizar una expresi\u00f3n regular para que podamos encontrar cualquier juego que contenga el titulo que pasemos en su nombre. Con la categor\u00eda tiene que ser el valor exacto de su id. El m\u00e9todo populate lo que hace es traernos toda la informaci\u00f3n de la categor\u00eda y del autor. Sino lo us\u00e1semos solo nos recuperar\u00eda el id.","title":"Implementar el Service"},{"location":"develop/filtered/nodejs/#implementar-el-controller","text":"Creamos el controlador game.controller.js : game.controller.js import * as GameService from '../services/game.service.js' ; export const getGames = async ( req , res ) => { try { const titleToFind = req . query ? . title || '' ; const categoryToFind = req . query ? . idCategory || null ; const games = await GameService . getGames ( titleToFind , categoryToFind ); res . status ( 200 ). json ( games ); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } export const createGame = async ( req , res ) => { try { const game = await GameService . createGame ( req . body ); res . status ( 200 ). json ({ game }); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } export const updateGame = async ( req , res ) => { const gameId = req . params . id ; try { await GameService . updateGame ( gameId , req . body ); res . status ( 200 ). json ( 1 ); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } Los m\u00e9todos son muy parecidos al resto de los controllers. En este caso para recuperar los datos del filtro tendremos que hacerlo con req.query para leer los datos que nos lleguen como query params en la url. Por ejemplo: http://localhost:8080/game?title=trivial&category=1","title":"Implementar el Controller"},{"location":"develop/filtered/nodejs/#implementar-las-rutas","text":"Y por \u00faltimo creamos nuestro archivo de rutas game.routes.js : game.routes.js import { Router } from 'express' ; import { check } from 'express-validator' ; import validateFields from '../middlewares/validateFields.js' ; import { createGame , getGames , updateGame } from '../controllers/game.controller.js' ; const gameRouter = Router (); gameRouter . put ( '/:id' , [ check ( 'title' ). not (). isEmpty (), check ( 'age' ). not (). isEmpty (), check ( 'age' ). isNumeric (), check ( 'category.id' ). not (). isEmpty (), check ( 'author.id' ). not (). isEmpty (), validateFields ], updateGame ); gameRouter . put ( '/' , [ check ( 'title' ). not (). isEmpty (), check ( 'age' ). not (). isEmpty (), check ( 'age' ). isNumeric (), check ( 'category.id' ). not (). isEmpty (), check ( 'author.id' ). not (). isEmpty (), validateFields ], createGame ); gameRouter . get ( '/' , getGames ); gameRouter . get ( '/:query' , getGames ); export default gameRouter ; En este caso hemos tenido que meter dos rutas para get , una para cuando se informen los filtros y otra para cuando no vayan informados. Si lo hici\u00e9ramos con una \u00fanica ruta nos fallar\u00eda en el otro caso. Finalmente en nuestro archivo index.js vamos a a\u00f1adir el nuevo router: index.js ... import gameRouter from './src/routes/game.routes.js' ; ... app . use ( '/game' , gameRouter ); ...","title":"Implementar las Rutas"},{"location":"develop/filtered/nodejs/#probar-las-operaciones","text":"Y ahora que tenemos todo creado, ya podemos probarlo con Postman: Por un lado creamos juegos con: PUT /game PUT /game/{id} { \"title\" : \"Nuevo juego\" , \"age\" : \"18\" , \"category\" : { \"id\" : \"63e8b795f7dae4b980b63202\" }, \"author\" : { \"id\" : \"63e8bda064c208e065667bfa\" } } Tambi\u00e9n podemos filtrar y recuperar informaci\u00f3n: GET /game GET /game?title=xxx GET /game?idCategory=xxx","title":"Probar las operaciones"},{"location":"develop/filtered/nodejs/#implementar-validaciones","text":"Ahora que ya tenemos todos nuestros CRUDs creados vamos a introducir unas peque\u00f1as validaciones.","title":"Implementar validaciones"},{"location":"develop/filtered/nodejs/#validacion-en-borrado","text":"La primera validaci\u00f3n sera para que no podamos borrar categor\u00edas ni autores que tengan un juego asociado. Para ello primero tendremos que crear un m\u00e9todo en el servicio de juegos para buscar los juegos que correspondan con un campo dado. En game.service.js a\u00f1adimos: game.service.js ... export const getGame = async ( field ) => { try { return await GameModel . find ( field ); } catch ( e ) { throw Error ( 'Error fetching games' ); } } ... Y ahora en category.service.js importamos el m\u00e9todo creado y modificamos el m\u00e9todo para borrar categor\u00edas: category.service.js ... import { getGame } from './game.service.js' ; ... ... export const deleteCategory = async ( id ) => { try { const category = await CategoryModel . findById ( id ); if ( ! category ) { throw 'There is no category with that Id' ; } const games = await getGame ({ category }); if ( games . length > 0 ) { throw 'There are games related to this category' ; } return await CategoryModel . findByIdAndDelete ( id ); } catch ( e ) { throw Error ( e ); } } ... De este modo si encontramos alg\u00fan juego con esta categor\u00eda no nos dejar\u00e1 borrarla. Por \u00faltimo, hacemos lo mismo en author.service.js : author.service.js ... import { getGame } from './game.service.js' ; ... ... export const deleteAuthor = async ( id ) => { try { const author = await AuthorModel . findById ( id ); if ( ! author ) { throw 'There is no author with that Id' ; } const games = await getGame ({ author }); if ( games . length > 0 ) { throw 'There are games related to this author' ; } return await AuthorModel . findByIdAndDelete ( id ); } catch ( e ) { throw Error ( e ); } } ...","title":"Validaci\u00f3n en borrado"},{"location":"develop/filtered/nodejs/#validacion-en-creacion","text":"En las creaciones es conveniente validad la existencia de las entidades relacionadas para garantizar la integridad de la BBDD. Para esto vamos a introducir una validaci\u00f3n en la creaci\u00f3n y edici\u00f3n de los juegos para garantizar que la categor\u00eda y el autor proporcionados existen. En primer lugar vamos a crear los servicios de consulta de categor\u00eda y autor: category.service.js ... export const getCategory = async ( id ) => { try { return await CategoryModel . findById ( id ); } catch ( e ) { throw Error ( 'There is no category with that Id' ); } } ... author.service.js ... export const getAuthor = async ( id ) => { try { return await AuthorModel . findById ( id ); } catch ( e ) { throw Error ( 'There is no author with that Id' ); } } ... Teniendo los servicios ya disponibles, vamos a a\u00f1adir las validaciones a los servicios de creaci\u00f3n y edici\u00f3n: game.service.js ... import { getCategory } from './category.service.js' ; import { getAuthor } from './author.service.js' ; ... ... export const createGame = async ( data ) => { try { const category = await getCategory ( data . category . id ); if ( ! category ) { throw Error ( 'There is no category with that Id' ); } const author = await getAuthor ( data . author . id ); if ( ! author ) { throw Error ( 'There is no author with that Id' ); } const game = new GameModel ({ ... data , category : data . category . id , author : data . author . id , }); return await game . save (); } catch ( e ) { throw Error ( e ); } } ... ... export const updateGame = async ( id , data ) => { try { const game = await GameModel . findById ( id ); if ( ! game ) { throw Error ( 'There is no game with that Id' ); } const category = await getCategory ( data . category . id ); if ( ! category ) { throw Error ( 'There is no category with that Id' ); } const author = await getAuthor ( data . author . id ); if ( ! author ) { throw Error ( 'There is no author with that Id' ); } const gameToUpdate = { ... data , category : data . category . id , author : data . author . id , }; return await GameModel . findByIdAndUpdate ( id , gameToUpdate , { new : false }); } catch ( e ) { throw Error ( e ); } } ... Con esto ya tendr\u00edamos acabado nuestro CRUD.","title":"Validaci\u00f3n en creaci\u00f3n"},{"location":"develop/filtered/springboot/","text":"Listado filtrado - Spring Boot En este punto ya tenemos dos listados, uno b\u00e1sico y otro paginado. Ahora vamos a implementar un listado un poco diferente, este listado va a tener filtros de b\u00fasqueda. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades. Crear Modelos Lo primero que vamos a hacer es crear los modelos para trabajar con BBDD y con peticiones hacia el front. Adem\u00e1s, tambi\u00e9n tenemos que a\u00f1adir datos al script de inicializaci\u00f3n de BBDD. Game.java GameDto.java data.sql package com.ccsw.tutorial.game.model ; import com.ccsw.tutorial.author.model.Author ; import com.ccsw.tutorial.category.model.Category ; import jakarta.persistence.* ; /** * @author ccsw * */ @Entity @Table ( name = \"game\" ) public class Game { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"title\" , nullable = false ) private String title ; @Column ( name = \"age\" , nullable = false ) private String age ; @ManyToOne @JoinColumn ( name = \"category_id\" , nullable = false ) private Category category ; @ManyToOne @JoinColumn ( name = \"author_id\" , nullable = false ) private Author author ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return age */ public String getAge () { return this . age ; } /** * @param age new value of {@link #getAge}. */ public void setAge ( String age ) { this . age = age ; } /** * @return category */ public Category getCategory () { return this . category ; } /** * @param category new value of {@link #getCategory}. */ public void setCategory ( Category category ) { this . category = category ; } /** * @return author */ public Author getAuthor () { return this . author ; } /** * @param author new value of {@link #getAuthor}. */ public void setAuthor ( Author author ) { this . author = author ; } } package com.ccsw.tutorial.game.model ; import com.ccsw.tutorial.author.model.AuthorDto ; import com.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw * */ public class GameDto { private Long id ; private String title ; private String age ; private CategoryDto category ; private AuthorDto author ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return age */ public String getAge () { return this . age ; } /** * @param age new value of {@link #getAge}. */ public void setAge ( String age ) { this . age = age ; } /** * @return category */ public CategoryDto getCategory () { return this . category ; } /** * @param category new value of {@link #getCategory}. */ public void setCategory ( CategoryDto category ) { this . category = category ; } /** * @return author */ public AuthorDto getAuthor () { return this . author ; } /** * @param author new value of {@link #getAuthor}. */ public void setAuthor ( AuthorDto author ) { this . author = author ; } } INSERT INTO category ( name ) VALUES ( 'Eurogames' ); INSERT INTO category ( name ) VALUES ( 'Ameritrash' ); INSERT INTO category ( name ) VALUES ( 'Familiar' ); INSERT INTO author ( name , nationality ) VALUES ( 'Alan R. Moon' , 'US' ); INSERT INTO author ( name , nationality ) VALUES ( 'Vital Lacerda' , 'PT' ); INSERT INTO author ( name , nationality ) VALUES ( 'Simone Luciani' , 'IT' ); INSERT INTO author ( name , nationality ) VALUES ( 'Perepau Llistosella' , 'ES' ); INSERT INTO author ( name , nationality ) VALUES ( 'Michael Kiesling' , 'DE' ); INSERT INTO author ( name , nationality ) VALUES ( 'Phil Walker-Harding' , 'US' ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'On Mars' , '14' , 1 , 2 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'Aventureros al tren' , '8' , 3 , 1 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( '1920: Wall Street' , '12' , 1 , 4 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'Barrage' , '14' , 1 , 3 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'Los viajes de Marco Polo' , '12' , 1 , 3 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'Azul' , '8' , 3 , 5 ); Relaciones anidadas F\u00edjate que tanto la Entity como el Dto tienen relaciones con Author y Category . Gracias a Spring JPA se pueden resolver de esta forma y tener toda la informaci\u00f3n de las relaciones hijas dentro del objeto padre. Muy importante recordar que en el mundo entity las relaciones ser\u00e1n con objetos Entity mientras que en el mundo dto las relaciones deben ser siempre con objetos Dto . La utilidad beanMapper ya har\u00e1 las conversiones necesarias, siempre que tengan el mismo nombre de propiedades. TDD - Pruebas Para desarrollar todas las operaciones, empezaremos primero dise\u00f1ando las pruebas y luego implementando el c\u00f3digo necesario que haga funcionar correctamente esas pruebas. Para ir m\u00e1s r\u00e1pido vamos a poner todas las pruebas de golpe, pero realmente se deber\u00edan crear una a una e ir implementando el c\u00f3digo necesario para esa prueba. Para evitar tantas iteraciones en el tutorial las haremos todas de golpe. Vamos a pararnos a pensar un poco que necesitamos en la pantalla. En este caso solo tenemos dos operaciones: Una consulta filtrada, que reciba datos de filtro opcionales (t\u00edtulo e idCategor\u00eda) y devuelva los datos ya filtrados Una operaci\u00f3n de guardado y modificaci\u00f3n De nuevo tendremos que desglosar esto en varios casos de prueba: Buscar un juego sin filtros Buscar un t\u00edtulo que exista Buscar una categor\u00eda que exista Buscar un t\u00edtulo y una categor\u00eda que existan Buscar un t\u00edtulo que no exista Buscar una categor\u00eda que no exista Buscar un t\u00edtulo y una categor\u00eda que no existan Crear un juego nuevo (en realidad deber\u00edamos probar diferentes combinaciones y errores) Modificar un juego que exista Modificar un juego que no exista Tambi\u00e9n crearemos una clase GameController dentro del package de com.ccsw.tutorial.game con la implementaci\u00f3n de los m\u00e9todos vac\u00edos, para que no falle la compilaci\u00f3n. \u00a1Vamos a implementar test! GameController.java GameIT.java package com.ccsw.tutorial.game ; import com.ccsw.tutorial.game.model.Game ; import com.ccsw.tutorial.game.model.GameDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; import org.springframework.web.bind.annotation.* ; import java.util.List ; /** * @author ccsw * */ @Tag ( name = \"Game\" , description = \"API of Game\" ) @RequestMapping ( value = \"/game\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class GameController { /** * M\u00e9todo para recuperar una lista de {@link Game} * * @param title t\u00edtulo del juego * @param idCategory PK de la categor\u00eda * @return {@link List} de {@link GameDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a filtered list of Games\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < GameDto > find ( @RequestParam ( value = \"title\" , required = false ) String title , @RequestParam ( value = \"idCategory\" , required = false ) Long idCategory ) { return null ; } /** * M\u00e9todo para crear o actualizar un {@link Game} * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Game\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody GameDto dto ) { } } package com.ccsw.tutorial.game ; import com.ccsw.tutorial.author.model.AuthorDto ; import com.ccsw.tutorial.category.model.CategoryDto ; import com.ccsw.tutorial.game.model.GameDto ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.boot.test.web.client.TestRestTemplate ; import org.springframework.boot.test.web.server.LocalServerPort ; import org.springframework.core.ParameterizedTypeReference ; import org.springframework.http.HttpEntity ; import org.springframework.http.HttpMethod ; import org.springframework.http.HttpStatus ; import org.springframework.http.ResponseEntity ; import org.springframework.test.annotation.DirtiesContext ; import org.springframework.web.util.UriComponentsBuilder ; import java.util.HashMap ; import java.util.List ; import java.util.Map ; import static org.junit.jupiter.api.Assertions.assertEquals ; import static org.junit.jupiter.api.Assertions.assertNotNull ; @SpringBootTest ( webEnvironment = SpringBootTest . WebEnvironment . RANDOM_PORT ) @DirtiesContext ( classMode = DirtiesContext . ClassMode . BEFORE_EACH_TEST_METHOD ) public class GameIT { public static final String LOCALHOST = \"http://localhost:\" ; public static final String SERVICE_PATH = \"/game\" ; public static final Long EXISTS_GAME_ID = 1L ; public static final Long NOT_EXISTS_GAME_ID = 0 L ; private static final String NOT_EXISTS_TITLE = \"NotExists\" ; private static final String EXISTS_TITLE = \"Aventureros\" ; private static final String NEW_TITLE = \"Nuevo juego\" ; private static final Long NOT_EXISTS_CATEGORY = 0 L ; private static final Long EXISTS_CATEGORY = 3L ; private static final String TITLE_PARAM = \"title\" ; private static final String CATEGORY_ID_PARAM = \"idCategory\" ; @LocalServerPort private int port ; @Autowired private TestRestTemplate restTemplate ; ParameterizedTypeReference < List < GameDto >> responseType = new ParameterizedTypeReference < List < GameDto >> (){}; private String getUrlWithParams (){ return UriComponentsBuilder . fromHttpUrl ( LOCALHOST + port + SERVICE_PATH ) . queryParam ( TITLE_PARAM , \"{\" + TITLE_PARAM + \"}\" ) . queryParam ( CATEGORY_ID_PARAM , \"{\" + CATEGORY_ID_PARAM + \"}\" ) . encode () . toUriString (); } @Test public void findWithoutFiltersShouldReturnAllGamesInDB () { int GAMES_WITH_FILTER = 6 ; Map < String , Object > params = new HashMap <> (); params . put ( TITLE_PARAM , null ); params . put ( CATEGORY_ID_PARAM , null ); ResponseEntity < List < GameDto >> response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( GAMES_WITH_FILTER , response . getBody (). size ()); } @Test public void findExistsTitleShouldReturnGames () { int GAMES_WITH_FILTER = 1 ; Map < String , Object > params = new HashMap <> (); params . put ( TITLE_PARAM , EXISTS_TITLE ); params . put ( CATEGORY_ID_PARAM , null ); ResponseEntity < List < GameDto >> response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( GAMES_WITH_FILTER , response . getBody (). size ()); } @Test public void findExistsCategoryShouldReturnGames () { int GAMES_WITH_FILTER = 2 ; Map < String , Object > params = new HashMap <> (); params . put ( TITLE_PARAM , null ); params . put ( CATEGORY_ID_PARAM , EXISTS_CATEGORY ); ResponseEntity < List < GameDto >> response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( GAMES_WITH_FILTER , response . getBody (). size ()); } @Test public void findExistsTitleAndCategoryShouldReturnGames () { int GAMES_WITH_FILTER = 1 ; Map < String , Object > params = new HashMap <> (); params . put ( TITLE_PARAM , EXISTS_TITLE ); params . put ( CATEGORY_ID_PARAM , EXISTS_CATEGORY ); ResponseEntity < List < GameDto >> response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( GAMES_WITH_FILTER , response . getBody (). size ()); } @Test public void findNotExistsTitleShouldReturnEmpty () { int GAMES_WITH_FILTER = 0 ; Map < String , Object > params = new HashMap <> (); params . put ( TITLE_PARAM , NOT_EXISTS_TITLE ); params . put ( CATEGORY_ID_PARAM , null ); ResponseEntity < List < GameDto >> response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( GAMES_WITH_FILTER , response . getBody (). size ()); } @Test public void findNotExistsCategoryShouldReturnEmpty () { int GAMES_WITH_FILTER = 0 ; Map < String , Object > params = new HashMap <> (); params . put ( TITLE_PARAM , null ); params . put ( CATEGORY_ID_PARAM , NOT_EXISTS_CATEGORY ); ResponseEntity < List < GameDto >> response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( GAMES_WITH_FILTER , response . getBody (). size ()); } @Test public void findNotExistsTitleOrCategoryShouldReturnEmpty () { int GAMES_WITH_FILTER = 0 ; Map < String , Object > params = new HashMap <> (); params . put ( TITLE_PARAM , NOT_EXISTS_TITLE ); params . put ( CATEGORY_ID_PARAM , NOT_EXISTS_CATEGORY ); ResponseEntity < List < GameDto >> response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( GAMES_WITH_FILTER , response . getBody (). size ()); params . put ( TITLE_PARAM , NOT_EXISTS_TITLE ); params . put ( CATEGORY_ID_PARAM , EXISTS_CATEGORY ); response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( GAMES_WITH_FILTER , response . getBody (). size ()); params . put ( TITLE_PARAM , EXISTS_TITLE ); params . put ( CATEGORY_ID_PARAM , NOT_EXISTS_CATEGORY ); response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( GAMES_WITH_FILTER , response . getBody (). size ()); } @Test public void saveWithoutIdShouldCreateNewGame () { GameDto dto = new GameDto (); AuthorDto authorDto = new AuthorDto (); authorDto . setId ( 1L ); CategoryDto categoryDto = new CategoryDto (); categoryDto . setId ( 1L ); dto . setTitle ( NEW_TITLE ); dto . setAge ( \"18\" ); dto . setAuthor ( authorDto ); dto . setCategory ( categoryDto ); Map < String , Object > params = new HashMap <> (); params . put ( TITLE_PARAM , NEW_TITLE ); params . put ( CATEGORY_ID_PARAM , null ); ResponseEntity < List < GameDto >> response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( 0 , response . getBody (). size ()); restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . PUT , new HttpEntity <> ( dto ), Void . class ); response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( 1 , response . getBody (). size ()); } @Test public void modifyWithExistIdShouldModifyGame () { GameDto dto = new GameDto (); AuthorDto authorDto = new AuthorDto (); authorDto . setId ( 1L ); CategoryDto categoryDto = new CategoryDto (); categoryDto . setId ( 1L ); dto . setTitle ( NEW_TITLE ); dto . setAge ( \"18\" ); dto . setAuthor ( authorDto ); dto . setCategory ( categoryDto ); Map < String , Object > params = new HashMap <> (); params . put ( TITLE_PARAM , NEW_TITLE ); params . put ( CATEGORY_ID_PARAM , null ); ResponseEntity < List < GameDto >> response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( 0 , response . getBody (). size ()); restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + EXISTS_GAME_ID , HttpMethod . PUT , new HttpEntity <> ( dto ), Void . class ); response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( 1 , response . getBody (). size ()); assertEquals ( EXISTS_GAME_ID , response . getBody (). get ( 0 ). getId ()); } @Test public void modifyWithNotExistIdShouldThrowException () { GameDto dto = new GameDto (); dto . setTitle ( NEW_TITLE ); ResponseEntity <?> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + NOT_EXISTS_GAME_ID , HttpMethod . PUT , new HttpEntity <> ( dto ), Void . class ); assertEquals ( HttpStatus . INTERNAL_SERVER_ERROR , response . getStatusCode ()); } } B\u00fasquedas en BBDD Siempre deber\u00edamos buscar a los hijos por primary keys, nunca hay que hacerlo por una descripci\u00f3n libre, ya que el usuario podr\u00eda teclear el mismo nombre de diferentes formas y no habr\u00eda manera de buscar correctamente el resultado. As\u00ed que siempre que haya un dropdown, se debe filtrar por su ID. Si ahora ejecutas los jUnits, ver\u00e1s que en este caso hemos construido 10 pruebas, para cubrir los casos b\u00e1sicos del Controller , y todas ellas fallan la ejecuci\u00f3n. Vamos a seguir implementando el resto de capas para hacer que los test funcionen. Controller De nuevo para poder compilar esta capa, nos hace falta delegar sus operaciones de l\u00f3gica de negocio en un Service as\u00ed que lo crearemos al mismo tiempo que lo vamos necesitando. GameService.java GameController.java package com.ccsw.tutorial.game ; import com.ccsw.tutorial.game.model.Game ; import com.ccsw.tutorial.game.model.GameDto ; import java.util.List ; /** * @author ccsw * */ public interface GameService { /** * Recupera los juegos filtrando opcionalmente por t\u00edtulo y/o categor\u00eda * * @param title t\u00edtulo del juego * @param idCategory PK de la categor\u00eda * @return {@link List} de {@link Game} */ List < Game > find ( String title , Long idCategory ); /** * Guarda o modifica un juego, dependiendo de si el identificador est\u00e1 o no informado * * @param id PK de la entidad * @param dto datos de la entidad */ void save ( Long id , GameDto dto ); } package com.ccsw.tutorial.game ; import com.ccsw.tutorial.game.model.Game ; import com.ccsw.tutorial.game.model.GameDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; import org.modelmapper.ModelMapper ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.* ; import java.util.List ; import java.util.stream.Collectors ; /** * @author ccsw * */ @Tag ( name = \"Game\" , description = \"API of Game\" ) @RequestMapping ( value = \"/game\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class GameController { @Autowired GameService gameService ; @Autowired ModelMapper mapper ; /** * M\u00e9todo para recuperar una lista de {@link Game} * * @param title t\u00edtulo del juego * @param idCategory PK de la categor\u00eda * @return {@link List} de {@link GameDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a filtered list of Games\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < GameDto > find ( @RequestParam ( value = \"title\" , required = false ) String title , @RequestParam ( value = \"idCategory\" , required = false ) Long idCategory ) { List < Game > games = gameService . find ( title , idCategory ); return games . stream (). map ( e -> mapper . map ( e , GameDto . class )). collect ( Collectors . toList ()); } /** * M\u00e9todo para crear o actualizar un {@link Game} * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Game\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody GameDto dto ) { gameService . save ( id , dto ); } } En esta ocasi\u00f3n, para el m\u00e9todo de b\u00fasqueda hemos decidido utilizar par\u00e1metros en la URL de tal forma que nos quedar\u00e1 algo as\u00ed http://localhost:8080/game/?title=xxx&idCategoria=yyy . Queremos recuperar el recurso Game que es el raiz de la ruta, pero filtrado por cero o varios par\u00e1metros. Service Siguiente paso, la capa de l\u00f3gica de negocio, es decir el Service , que por tanto har\u00e1 uso de un Repository . GameServiceImpl.java GameRepository.java package com.ccsw.tutorial.game ; import com.ccsw.tutorial.game.model.Game ; import com.ccsw.tutorial.game.model.GameDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class GameServiceImpl implements GameService { @Autowired GameRepository gameRepository ; /** * {@inheritDoc} */ @Override public List < Game > find ( String title , Long idCategory ) { return ( List < Game > ) this . gameRepository . findAll (); } /** * {@inheritDoc} */ @Override public void save ( Long id , GameDto dto ) { Game game ; if ( id == null ) { game = new Game (); } else { game = this . gameRepository . findById ( id ). orElse ( null ); } BeanUtils . copyProperties ( dto , game , \"id\" , \"author\" , \"category\" ); this . gameRepository . save ( game ); } } package com.ccsw.tutorial.game ; import com.ccsw.tutorial.game.model.Game ; import org.springframework.data.repository.CrudRepository ; /** * @author ccsw * */ public interface GameRepository extends CrudRepository < Game , Long > { } Este servicio tiene dos peculiaridades, remarcadas en amarillo en la clase anterior. Por un lado tenemos la consulta, que no es un listado completo ni un listado paginado, sino que es un listado con filtros. Luego veremos como se hace eso, de momento lo dejaremos como un m\u00e9todo que recibe los dos filtros. La segunda peculiaridad es que de cliente nos est\u00e1 llegando un GameDto , que internamente tiene un AuthorDto y un CategoryDto , pero nosotros lo tenemos que traducir a entidades de BBDD. No sirve con copiar las propiedades tal cual, ya que entonces Spring lo que har\u00e1 ser\u00e1 crear un objeto nuevo y persistir ese objeto nuevo de Author y de Category . Adem\u00e1s, de cliente generalmente tan solo nos llega el ID de esos objetos hijo, y no el resto de informaci\u00f3n de la entidad. Por esos motivos lo hemos ignorado del copyProperties. Pero de alguna forma tendremos que asignarle esos valores a la entidad Game . Si conocemos sus ID que es lo que generalmente llega, podemos recuperar esos objetos de BBDD y asignarlos en el objeto Game . Si recuerdas las reglas b\u00e1sicas, un Repository debe pertenecer a un solo Service , por lo que en lugar de llamar a m\u00e9todos de los AuthorRepository y CategoryRepository desde nuestro GameServiceImpl , debemos llamar a m\u00e9todos expuestos en AuthorService y CategoryService , que son los que gestionan sus repositorios. Para ello necesitaremos crear esos m\u00e9todos get en los otros Services . Y ya sabes, para implementar nuevos m\u00e9todos, antes se deben hacer las pruebas jUnit, que en este caso, por variar, cubriremos con pruebas unitarias. Recuerda que los test van en src/test/java AuthorTest.java AuthorService.java AuthorServiceImpl.java package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.Author ; import org.junit.jupiter.api.Test ; import org.junit.jupiter.api.extension.ExtendWith ; import org.mockito.InjectMocks ; import org.mockito.Mock ; import org.mockito.junit.jupiter.MockitoExtension ; import java.util.Optional ; import static org.junit.jupiter.api.Assertions.* ; import static org.mockito.Mockito.mock ; import static org.mockito.Mockito.when ; @ExtendWith ( MockitoExtension . class ) public class AuthorTest { public static final Long EXISTS_AUTHOR_ID = 1L ; public static final Long NOT_EXISTS_AUTHOR_ID = 0 L ; @Mock private AuthorRepository authorRepository ; @InjectMocks private AuthorServiceImpl authorService ; @Test public void getExistsAuthorIdShouldReturnAuthor () { Author author = mock ( Author . class ); when ( author . getId ()). thenReturn ( EXISTS_AUTHOR_ID ); when ( authorRepository . findById ( EXISTS_AUTHOR_ID )). thenReturn ( Optional . of ( author )); Author authorResponse = authorService . get ( EXISTS_AUTHOR_ID ); assertNotNull ( authorResponse ); assertEquals ( EXISTS_AUTHOR_ID , authorResponse . getId ()); } @Test public void getNotExistsAuthorIdShouldReturnNull () { when ( authorRepository . findById ( NOT_EXISTS_AUTHOR_ID )). thenReturn ( Optional . empty ()); Author author = authorService . get ( NOT_EXISTS_AUTHOR_ID ); assertNull ( author ); } } package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.Author ; import com.ccsw.tutorial.author.model.AuthorDto ; import com.ccsw.tutorial.author.model.AuthorSearchDto ; import org.springframework.data.domain.Page ; import java.util.List ; /** * @author ccsw * */ public interface AuthorService { /** * Recupera un {@link Author} a trav\u00e9s de su ID * * @param id PK de la entidad * @return {@link Author} */ Author get ( Long id ); /** * M\u00e9todo para recuperar un listado paginado de {@link Author} * * @param dto dto de b\u00fasqueda * @return {@link Page} de {@link Author} */ Page < Author > findPage ( AuthorSearchDto dto ); /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad * @param dto datos de la entidad */ void save ( Long id , AuthorDto dto ); /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad */ void delete ( Long id ) throws Exception ; } package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.Author ; import com.ccsw.tutorial.author.model.AuthorDto ; import com.ccsw.tutorial.author.model.AuthorSearchDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class AuthorServiceImpl implements AuthorService { @Autowired AuthorRepository authorRepository ; /** * {@inheritDoc} */ @Override public Author get ( Long id ) { return this . authorRepository . findById ( id ). orElse ( null ); } /** * {@inheritDoc} */ @Override public Page < Author > findPage ( AuthorSearchDto dto ) { return this . authorRepository . findAll ( dto . getPageable (). getPageable ()); } /** * {@inheritDoc} */ @Override public void save ( Long id , AuthorDto data ) { Author author ; if ( id == null ) { author = new Author (); } else { author = this . get ( id ); } BeanUtils . copyProperties ( data , author , \"id\" ); this . authorRepository . save ( author ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) throws Exception { if ( this . get ( id ) == null ){ throw new Exception ( \"Not exists\" ); } this . authorRepository . deleteById ( id ); } } Y lo mismo para categor\u00edas. CategoryTest.java CategoryService.java CategoryServiceImpl.java public static final Long NOT_EXISTS_CATEGORY_ID = 0 L ; @Test public void getExistsCategoryIdShouldReturnCategory () { Category category = mock ( Category . class ); when ( category . getId ()). thenReturn ( EXISTS_CATEGORY_ID ); when ( categoryRepository . findById ( EXISTS_CATEGORY_ID )). thenReturn ( Optional . of ( category )); Category categoryResponse = categoryService . get ( EXISTS_CATEGORY_ID ); assertNotNull ( categoryResponse ); assertEquals ( EXISTS_CATEGORY_ID , category . getId ()); } @Test public void getNotExistsCategoryIdShouldReturnNull () { when ( categoryRepository . findById ( NOT_EXISTS_CATEGORY_ID )). thenReturn ( Optional . empty ()); Category category = categoryService . get ( NOT_EXISTS_CATEGORY_ID ); assertNull ( category ); } package com.ccsw.tutorial.category ; import com.ccsw.tutorial.category.model.Category ; import com.ccsw.tutorial.category.model.CategoryDto ; import java.util.List ; /** * @author ccsw * */ public interface CategoryService { /** * Recupera una {@link Category} a partir de su ID * * @param id PK de la entidad * @return {@link Category} */ Category get ( Long id ); /** * M\u00e9todo para recuperar todas las {@link Category} * * @return {@link List} de {@link Category} */ List < Category > findAll (); /** * M\u00e9todo para crear o actualizar una {@link Category} * * @param id PK de la entidad * @param dto datos de la entidad */ void save ( Long id , CategoryDto dto ); /** * M\u00e9todo para borrar una {@link Category} * * @param id PK de la entidad */ void delete ( Long id ) throws Exception ; } package com.ccsw.tutorial.category ; import com.ccsw.tutorial.category.model.Category ; import com.ccsw.tutorial.category.model.CategoryDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class CategoryServiceImpl implements CategoryService { @Autowired CategoryRepository categoryRepository ; /** * {@inheritDoc} */ @Override public Category get ( Long id ) { return this . categoryRepository . findById ( id ). orElse ( null ); } /** * {@inheritDoc} */ @Override public List < Category > findAll () { return ( List < Category > ) this . categoryRepository . findAll (); } /** * {@inheritDoc} */ @Override public void save ( Long id , CategoryDto dto ) { Category category ; if ( id == null ) { category = new Category (); } else { category = this . get ( id ); } category . setName ( dto . getName ()); this . categoryRepository . save ( category ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) throws Exception { if ( this . get ( id ) == null ){ throw new Exception ( \"Not exists\" ); } this . categoryRepository . deleteById ( id ); } } Clean Code A la hora de implementar m\u00e9todos nuevos, ten siempre presente el Clean Code . \u00a1No dupliques c\u00f3digo!, es muy importante de cara al futuro mantenimiento. Si en nuestro m\u00e9todo save hac\u00edamos uso de una operaci\u00f3n findById y ahora hemos creado una nueva operaci\u00f3n get , hagamos uso de esta nueva operaci\u00f3n y no repitamos el c\u00f3digo. Y ahora que ya tenemos los m\u00e9todos necesarios, ya podemos implementar correctamente nuestro GameServiceImpl . GameServiceImpl.java package com.ccsw.tutorial.game ; import com.ccsw.tutorial.author.AuthorService ; import com.ccsw.tutorial.category.CategoryService ; import com.ccsw.tutorial.game.model.Game ; import com.ccsw.tutorial.game.model.GameDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class GameServiceImpl implements GameService { @Autowired GameRepository gameRepository ; @Autowired AuthorService authorService ; @Autowired CategoryService categoryService ; /** * {@inheritDoc} */ @Override public List < Game > find ( String title , Long idCategory ) { return this . gameRepository . findAll (); } /** * {@inheritDoc} */ @Override public void save ( Long id , GameDto dto ) { Game game ; if ( id == null ) { game = new Game (); } else { game = this . gameRepository . findById ( id ). orElse ( null ); } BeanUtils . copyProperties ( dto , game , \"id\" , \"author\" , \"category\" ); game . setAuthor ( authorService . get ( dto . getAuthor (). getId ())); game . setCategory ( categoryService . get ( dto . getCategory (). getId ())); this . gameRepository . save ( game ); } } Ahora si que tenemos la capa de l\u00f3gica de negocio terminada, podemos pasar a la siguiente capa. Repository Y llegamos a la \u00faltima capa donde, si recordamos, ten\u00edamos un m\u00e9todo que recibe dos par\u00e1metros. Necesitamos traducir esto en una consulta a la BBDD. Vamos a necesitar un listado filtrado por t\u00edtulo o por categor\u00eda, as\u00ed que necesitaremos pasarle esos datos y filtrar la query. Para el t\u00edtulo vamos a buscar por una cadena contenida, as\u00ed que el par\u00e1metro ser\u00e1 de tipo String , mientras que para la categor\u00eda vamos a buscar por su primary key, as\u00ed que el par\u00e1metro ser\u00e1 de tipo Long . Existen varias estrategias para abordar esta implementaci\u00f3n. Podr\u00edamos utilizar los QueryMethods para que Spring JPA haga su magia, pero en esta ocasi\u00f3n ser\u00eda bastante complicado encontrar un predicado correcto. Tambi\u00e9n podr\u00edamos hacer una implementaci\u00f3n de la interface y hacer la consulta directamente con Criteria. Por otro lado se podr\u00eda hacer uso de la anotaci\u00f3n @Query . Esta anotaci\u00f3n nos permite definir una consulta en SQL nativo o en JPQL (Java Persistence Query Language) y Spring JPA se encargar\u00e1 de realizar todo el mapeo y conversi\u00f3n de los datos de entrada y salida. Pero esta opci\u00f3n no es la m\u00e1s recomendable. Specifications En este caso vamos a hacer uso de las Specifications que es la opci\u00f3n m\u00e1s robusta y no presenta acoplamientos con el tipo de BBDD. Haciendo un resumen muy r\u00e1pido y con poco detalle, las Specifications sirven para generar de forma robusta las clausulas where de una consulta SQL. Estas clausulas se generar\u00e1n mediante Predicate (predicados) que realizar\u00e1n operaciones de comparaci\u00f3n entre un campo y un valor. En el siguiente ejemplo podemos verlo m\u00e1s claro: en la sentencia select * from Table where name = 'b\u00fasqueda' tenemos un solo predicado que es name = 'b\u00fasqueda' . En ese predicado diferenciamos tres etiquetas: name \u2192 es el campo sobre el que hacemos el predicado = \u2192 es la operaci\u00f3n que realizamos 'b\u00fasqueda' \u2192 es el valor con el que realizamos la operaci\u00f3n Lo que trata de hacer Specifications es agregar varios predicados con AND o con OR de forma tipada en c\u00f3digo. Y \u00bfqu\u00e9 intentamos conseguir con esta forma de programar?, pues f\u00e1cil, intentamos hacer que si cambiamos alg\u00fan tipo o el nombre de alguna propiedad involucrada en la query, nos salte un fallo en tiempo de compilaci\u00f3n y nos demos cuenta de donde est\u00e1 el error. Si utiliz\u00e1ramos queries construidas directamente con String , al cambiar alg\u00fan tipo o el nombre de alguna propiedad involucrada, no nos dar\u00edamos cuenta hasta que saltara un fallo en tiempo de ejecuci\u00f3n. Por este motivo hay que programar con Specifications , porque son robustas ante cambios de c\u00f3digo y tenemos que tratar de evitar las construcciones a trav\u00e9s de cadenas de texto. Dicho esto, \u00a1vamos a implementar! Lo primero que necesitaremos ser\u00e1 una clase que nos permita guardar la informaci\u00f3n de un Predicate para luego generar facilmente la construcci\u00f3n. Para ello vamos a crear una clase que guarde informaci\u00f3n de los criterios de filtrado (campo, operaci\u00f3n y valor), por suerte esta clase ser\u00e1 gen\u00e9rica y la podremos usar en toda la aplicaci\u00f3n, as\u00ed que la vamos a crear en el paquete com.ccsw.tutorial.common.criteria SearchCriteria.java package com.ccsw.tutorial.common.criteria ; public class SearchCriteria { private String key ; private String operation ; private Object value ; public SearchCriteria ( String key , String operation , Object value ) { this . key = key ; this . operation = operation ; this . value = value ; } public String getKey () { return key ; } public void setKey ( String key ) { this . key = key ; } public String getOperation () { return operation ; } public void setOperation ( String operation ) { this . operation = operation ; } public Object getValue () { return value ; } public void setValue ( Object value ) { this . value = value ; } } Hecho esto pasamos a definir el Specification de nuestra clase la cual contendr\u00e1 la construcci\u00f3n de la consulta en funci\u00f3n de los criterios que se le proporcionan. No queremos construir los predicados directamente en nuestro Service ya que duplicariamos mucho c\u00f3digo, mucho mejor si hacemos una clase para centralizar la construcci\u00f3n de predicados. De esta forma vamos a crear una clase Specification por cada una de las Entity que queramos consultar. En nuestro caso solo vamos a generar queries para Game , as\u00ed que solo crearemos un GameSpecification donde construirmos los predicados. GameSpecification.java package com.ccsw.tutorial.game ; import com.ccsw.tutorial.common.criteria.SearchCriteria ; import com.ccsw.tutorial.game.model.Game ; import jakarta.persistence.criteria.* ; import org.springframework.data.jpa.domain.Specification ; public class GameSpecification implements Specification < Game > { private static final long serialVersionUID = 1L ; private final SearchCriteria criteria ; public GameSpecification ( SearchCriteria criteria ) { this . criteria = criteria ; } @Override public Predicate toPredicate ( Root < Game > root , CriteriaQuery <?> query , CriteriaBuilder builder ) { if ( criteria . getOperation (). equalsIgnoreCase ( \":\" ) && criteria . getValue () != null ) { Path < String > path = getPath ( root ); if ( path . getJavaType () == String . class ) { return builder . like ( path , \"%\" + criteria . getValue () + \"%\" ); } else { return builder . equal ( path , criteria . getValue ()); } } return null ; } private Path < String > getPath ( Root < Game > root ) { String key = criteria . getKey (); String [] split = key . split ( \"[.]\" , 0 ); Path < String > expression = root . get ( split [ 0 ] ); for ( int i = 1 ; i < split . length ; i ++ ) { expression = expression . get ( split [ i ] ); } return expression ; } } Voy a tratar de explicar con calma cada una de las l\u00edneas marcadas, ya que son conceptos dificiles de entender hasta que no se utilizan. Las dos primeras l\u00edneas marcadas hacen referencia a que cuando se crea un Specification , esta debe generar un predicado, con lo que necesita unos criterios de filtrado para poder generarlo. En el constructor le estamos pasando esos criterios de filtrado que luego utilizaremos. La tercera l\u00ednea marcada est\u00e1 seleccionando el tipo de operaci\u00f3n. En nuestro caso solo vamos a utilizar operaciones de comparaci\u00f3n. Por convenio las operaciones de comparaci\u00f3n se marcan como \":\" ya que el s\u00edmbolo = est\u00e1 reservado. Aqu\u00ed es donde podr\u00edamos a\u00f1adir otro tipo de operaciones como \">\" o \"<>\" o cualquiera que queramos implementar. Gu\u00e1rdate esa informaci\u00f3n que te servir\u00e1 en el ejercicio final . Las dos siguientes l\u00edneas, las de return est\u00e1n construyendo un Predicate al ser de tipo comparaci\u00f3n, si es un texto har\u00e1 un like y si no es texto (que es un n\u00famero o fecha) har\u00e1 un equals . Por \u00faltimo, tenemos un m\u00e9todo getPath que invocamos dentro la generaci\u00f3n del predicado y que implementamos m\u00e1s abajo. Esta funci\u00f3n nos permite explorar las sub-entidades para realizar consultas sobre los atributos de estas. Por ejemplo, si queremos navegar hasta game.author.name , lo que har\u00e1 la exploraci\u00f3n ser\u00e1 recuperar el atributo name del objeto author de la entidad game . Una vez implementada nuestra clase de Specification , que lo \u00fanico que hace es recoger un criterio de filtrado y construir un predicado, y que en principio solo permite generar comparaciones de igualdad, vamos a utilizarlo dentro de nuestro Service : GameServiceImpl.java GameRepository.java package com.ccsw.tutorial.game ; import com.ccsw.tutorial.author.AuthorService ; import com.ccsw.tutorial.category.CategoryService ; import com.ccsw.tutorial.common.criteria.SearchCriteria ; import com.ccsw.tutorial.game.model.Game ; import com.ccsw.tutorial.game.model.GameDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.jpa.domain.Specification ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class GameServiceImpl implements GameService { @Autowired GameRepository gameRepository ; @Autowired AuthorService authorService ; @Autowired CategoryService categoryService ; /** * {@inheritDoc} */ @Override public List < Game > find ( String title , Long idCategory ) { GameSpecification titleSpec = new GameSpecification ( new SearchCriteria ( \"title\" , \":\" , title )); GameSpecification categorySpec = new GameSpecification ( new SearchCriteria ( \"category.id\" , \":\" , idCategory )); Specification < Game > spec = Specification . where ( titleSpec ). and ( categorySpec ); return this . gameRepository . findAll ( spec ); } /** * {@inheritDoc} */ @Override public void save ( Long id , GameDto dto ) { Game game ; if ( id == null ) { game = new Game (); } else { game = this . gameRepository . findById ( id ). orElse ( null ); } BeanUtils . copyProperties ( dto , game , \"id\" , \"author\" , \"category\" ); game . setAuthor ( authorService . get ( dto . getAuthor (). getId ())); game . setCategory ( categoryService . get ( dto . getCategory (). getId ())); this . gameRepository . save ( game ); } } package com.ccsw.tutorial.game ; import com.ccsw.tutorial.game.model.Game ; import org.springframework.data.jpa.domain.Specification ; import org.springframework.data.jpa.repository.EntityGraph ; import org.springframework.data.jpa.repository.JpaSpecificationExecutor ; import org.springframework.data.repository.CrudRepository ; import java.util.List ; /** * @author ccsw * */ public interface GameRepository extends CrudRepository < Game , Long > , JpaSpecificationExecutor < Game > { } Lo que hemos hecho es crear los dos criterios de filtrado que necesit\u00e1bamos. En nuestro caso eran title , que es un atributo de la entidad Game y por otro lado el identificador de categor\u00eda, que en este caso, ya no es un atributo directo de la entidad, si no, de la categor\u00eda asociada, por lo que debemos navegar hasta el atributo id a trav\u00e9s del atributo category (para esto utilizamos el getPath que hemos visto anteriormente). A partir de estos dos predicados, podemos generar el Specification global para la consulta, uniendo los dos predicados mediante el operador AND . Una vez construido el Specification ya podemos usar el m\u00e9todo por defecto que nos proporciona Spring Data para dicho fin, tan solo tenemos que decirle a nuestro GameRepository que adem\u00e1s extender de CrudRepository debe extender de JpaSpecificationExecutor , para que pueda ejecutarlas. Mejoras rendimiento Finalmente, de cara a mejorar el rendimiento de nuestros servicios vamos a hacer foco en la generaci\u00f3n de transacciones con la base de datos. Si ejecut\u00e1ramos esta petici\u00f3n tal cual lo tenemos implementado ahora mismo, en la consola ver\u00edamos lo siguiente: Hibernate: select g1_0.id,g1_0.age,g1_0.author_id,g1_0.category_id,g1_0.title from game g1_0 Hibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=? Hibernate: select c1_0.id,c1_0.name from category c1_0 where c1_0.id=? Hibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=? Hibernate: select c1_0.id,c1_0.name from category c1_0 where c1_0.id=? Hibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=? Hibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=? Hibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=? Esto es debido a que no le hemos dado indicaciones a Spring Data de como queremos que construya las consultas con relaciones y por defecto est\u00e1 configurado para generar sub-consultas cuando tenemos tablas relacionadas. En nuestro caso la tabla Game est\u00e1 relacionada con Author y Category . Al realizar la consulta a Game realiza las sub-consultas por cada uno de los registros relacionados con los resultados Game . Para evitar tantas consultas contra la BBDD y realizar esto de una forma mucho m\u00e1s \u00f3ptima, podemos decirle a Spring Data el comportamiento que queremos, que en nuestro caso ser\u00e1 que haga una \u00fanica consulta y haga las sub-consultas mediante los join correspondientes. Para ello a\u00f1adimos una sobre-escritura del m\u00e9todo findAll , que ya ten\u00edamos implementado en JpaSpecificationExecutor y que utlizamos de forma heredada, pero en este caso le a\u00f1adimos la anotaci\u00f3n @EntityGraph con los atributos que queremos que se incluyan dentro de la consulta principal mediante join : GameRepository.java package com.ccsw.tutorial.game ; import com.ccsw.tutorial.game.model.Game ; import org.springframework.data.jpa.domain.Specification ; import org.springframework.data.jpa.repository.EntityGraph ; import org.springframework.data.jpa.repository.JpaSpecificationExecutor ; import org.springframework.data.repository.CrudRepository ; import java.util.List ; /** * @author ccsw * */ public interface GameRepository extends CrudRepository < Game , Long > , JpaSpecificationExecutor < Game > { @Override @EntityGraph ( attributePaths = { \"category\" , \"author\" }) List < Game > findAll ( Specification < Game > spec ); } Tras realizar este cambio, podemos observar que la nueva consulta generada es la siguiente: Hibernate: select g1_0.id,g1_0.age,a1_0.id,a1_0.name,a1_0.nationality,c1_0.id,c1_0.name,g1_0.title from game g1_0 join author a1_0 on a1_0.id=g1_0.author_id join category c1_0 on c1_0.id=g1_0.category_id Como podemos observar, ahora se realiza una \u00fanica consulta con la correspondiente transacci\u00f3n con la BBDD, y se trae todos los datos necesarios de Game , Author y Category sin lanzar m\u00faltiples queries. Prueba de las operaciones Si ahora ejecutamos de nuevo los jUnits, vemos que todos los que hemos desarrollado en GameIT ya funcionan correctamente, e incluso el resto de test de la aplicaci\u00f3n tambi\u00e9n funcionan correctamente. Pruebas jUnit Cada vez que desarrollemos un caso de uso nuevo, debemos relanzar todas las pruebas autom\u00e1ticas que tenga la aplicaci\u00f3n. Es muy com\u00fan que al implementar alg\u00fan desarrollo nuevo, interfiramos de alguna forma en el funcionamiento de otra funcionalidad. Si lanzamos toda la bater\u00eda de pruebas, nos daremos cuenta si algo ha dejado de funcionar y podremos solucionarlo antes de llevar ese error a Producci\u00f3n. Las pruebas jUnit son nuestra red de seguridad. Adem\u00e1s de las pruebas autom\u00e1ticas, podemos ver como se comporta la aplicaci\u00f3n y que respuesta nos ofrece, lanzando peticiones Rest con Postman, como hemos hecho en los casos anteriores. As\u00ed que podemos levantar la aplicaci\u00f3n y lanzar las operaciones: GET http://localhost:8080/game GET http://localhost:8080/game?title=xxx GET http://localhost:8080/game?idCategory=xxx Nos devuelve un listado filtrado de Game . F\u00edjate bien en la petici\u00f3n donde enviamos los filtros y la respuesta que tiene los objetos Category y Author inclu\u00eddos. PUT http://localhost:8080/game PUT http://localhost:8080/game/{id} { \"title\": \"Nuevo juego\", \"age\": \"18\", \"category\": { \"id\": 3 }, \"author\": { \"id\": 1 } } Nos sirve para insertar un Game nuevo (si no tienen el id informado) o para actualizar un Game (si tienen el id informado). F\u00edjate que para enlazar Category y Author tan solo hace falta el id de cada no de ellos, ya que en el m\u00e9todo save se hace una consulta get para recuperarlos por su id. Adem\u00e1s que no tendr\u00eda sentido enviar toda la informaci\u00f3n de esas entidades ya que no est\u00e1s dando de alta una Category ni un Author . Rendimiento en las consultas JPA En este punto te recomiendo que visites el Anexo. Funcionamiento JPA para conocer un poco m\u00e1s como funciona por dentro JPA y alg\u00fan peque\u00f1o truco que puede mejorar el rendimiento. Implementar listado Autores Antes de poder conectar front con back, si recuerdas, en la edici\u00f3n de un Game , nos hac\u00eda falta un listado de Author y un listado de Category . El segundo ya lo tenemos ya que lo reutilizaremos del listado de categor\u00edas que implementamos. Pero el primero no lo tenemos, porque en la pantalla que hicimos, se mostraban de forma paginada. As\u00ed que necesitamos implementar esa funcionalidad, y como siempre vamos de la capa de testing hacia las siguientes capas. Deber\u00edamos a\u00f1adir los siguientes m\u00e9todos: AuthorIT.java AuthorController.java AuthorService.java AuthorServiceImpl.java ... ParameterizedTypeReference < List < AuthorDto >> responseTypeList = new ParameterizedTypeReference < List < AuthorDto >> (){}; @Test public void findAllShouldReturnAllAuthor () { ResponseEntity < List < AuthorDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . GET , null , responseTypeList ); assertNotNull ( response ); assertEquals ( TOTAL_AUTHORS , response . getBody (). size ()); } ... ... /** * Recupera un listado de autores {@link Author} * * @return {@link List} de {@link AuthorDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a list of Authors\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < AuthorDto > findAll () { List < Author > authors = this . authorService . findAll (); return authors . stream (). map ( e -> mapper . map ( e , AuthorDto . class )). collect ( Collectors . toList ()); } ... ... /** * Recupera un listado de autores {@link Author} * * @return {@link List} de {@link Author} */ List < Author > findAll (); ... ... /** * {@inheritDoc} */ @Override public List < Author > findAll () { return ( List < Author > ) this . authorRepository . findAll (); } ...","title":"\ud83d\udfe2 Spring Boot"},{"location":"develop/filtered/springboot/#listado-filtrado-spring-boot","text":"En este punto ya tenemos dos listados, uno b\u00e1sico y otro paginado. Ahora vamos a implementar un listado un poco diferente, este listado va a tener filtros de b\u00fasqueda. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.","title":"Listado filtrado - Spring Boot"},{"location":"develop/filtered/springboot/#crear-modelos","text":"Lo primero que vamos a hacer es crear los modelos para trabajar con BBDD y con peticiones hacia el front. Adem\u00e1s, tambi\u00e9n tenemos que a\u00f1adir datos al script de inicializaci\u00f3n de BBDD. Game.java GameDto.java data.sql package com.ccsw.tutorial.game.model ; import com.ccsw.tutorial.author.model.Author ; import com.ccsw.tutorial.category.model.Category ; import jakarta.persistence.* ; /** * @author ccsw * */ @Entity @Table ( name = \"game\" ) public class Game { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"title\" , nullable = false ) private String title ; @Column ( name = \"age\" , nullable = false ) private String age ; @ManyToOne @JoinColumn ( name = \"category_id\" , nullable = false ) private Category category ; @ManyToOne @JoinColumn ( name = \"author_id\" , nullable = false ) private Author author ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return age */ public String getAge () { return this . age ; } /** * @param age new value of {@link #getAge}. */ public void setAge ( String age ) { this . age = age ; } /** * @return category */ public Category getCategory () { return this . category ; } /** * @param category new value of {@link #getCategory}. */ public void setCategory ( Category category ) { this . category = category ; } /** * @return author */ public Author getAuthor () { return this . author ; } /** * @param author new value of {@link #getAuthor}. */ public void setAuthor ( Author author ) { this . author = author ; } } package com.ccsw.tutorial.game.model ; import com.ccsw.tutorial.author.model.AuthorDto ; import com.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw * */ public class GameDto { private Long id ; private String title ; private String age ; private CategoryDto category ; private AuthorDto author ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return age */ public String getAge () { return this . age ; } /** * @param age new value of {@link #getAge}. */ public void setAge ( String age ) { this . age = age ; } /** * @return category */ public CategoryDto getCategory () { return this . category ; } /** * @param category new value of {@link #getCategory}. */ public void setCategory ( CategoryDto category ) { this . category = category ; } /** * @return author */ public AuthorDto getAuthor () { return this . author ; } /** * @param author new value of {@link #getAuthor}. */ public void setAuthor ( AuthorDto author ) { this . author = author ; } } INSERT INTO category ( name ) VALUES ( 'Eurogames' ); INSERT INTO category ( name ) VALUES ( 'Ameritrash' ); INSERT INTO category ( name ) VALUES ( 'Familiar' ); INSERT INTO author ( name , nationality ) VALUES ( 'Alan R. Moon' , 'US' ); INSERT INTO author ( name , nationality ) VALUES ( 'Vital Lacerda' , 'PT' ); INSERT INTO author ( name , nationality ) VALUES ( 'Simone Luciani' , 'IT' ); INSERT INTO author ( name , nationality ) VALUES ( 'Perepau Llistosella' , 'ES' ); INSERT INTO author ( name , nationality ) VALUES ( 'Michael Kiesling' , 'DE' ); INSERT INTO author ( name , nationality ) VALUES ( 'Phil Walker-Harding' , 'US' ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'On Mars' , '14' , 1 , 2 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'Aventureros al tren' , '8' , 3 , 1 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( '1920: Wall Street' , '12' , 1 , 4 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'Barrage' , '14' , 1 , 3 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'Los viajes de Marco Polo' , '12' , 1 , 3 ); INSERT INTO game ( title , age , category_id , author_id ) VALUES ( 'Azul' , '8' , 3 , 5 ); Relaciones anidadas F\u00edjate que tanto la Entity como el Dto tienen relaciones con Author y Category . Gracias a Spring JPA se pueden resolver de esta forma y tener toda la informaci\u00f3n de las relaciones hijas dentro del objeto padre. Muy importante recordar que en el mundo entity las relaciones ser\u00e1n con objetos Entity mientras que en el mundo dto las relaciones deben ser siempre con objetos Dto . La utilidad beanMapper ya har\u00e1 las conversiones necesarias, siempre que tengan el mismo nombre de propiedades.","title":"Crear Modelos"},{"location":"develop/filtered/springboot/#tdd-pruebas","text":"Para desarrollar todas las operaciones, empezaremos primero dise\u00f1ando las pruebas y luego implementando el c\u00f3digo necesario que haga funcionar correctamente esas pruebas. Para ir m\u00e1s r\u00e1pido vamos a poner todas las pruebas de golpe, pero realmente se deber\u00edan crear una a una e ir implementando el c\u00f3digo necesario para esa prueba. Para evitar tantas iteraciones en el tutorial las haremos todas de golpe. Vamos a pararnos a pensar un poco que necesitamos en la pantalla. En este caso solo tenemos dos operaciones: Una consulta filtrada, que reciba datos de filtro opcionales (t\u00edtulo e idCategor\u00eda) y devuelva los datos ya filtrados Una operaci\u00f3n de guardado y modificaci\u00f3n De nuevo tendremos que desglosar esto en varios casos de prueba: Buscar un juego sin filtros Buscar un t\u00edtulo que exista Buscar una categor\u00eda que exista Buscar un t\u00edtulo y una categor\u00eda que existan Buscar un t\u00edtulo que no exista Buscar una categor\u00eda que no exista Buscar un t\u00edtulo y una categor\u00eda que no existan Crear un juego nuevo (en realidad deber\u00edamos probar diferentes combinaciones y errores) Modificar un juego que exista Modificar un juego que no exista Tambi\u00e9n crearemos una clase GameController dentro del package de com.ccsw.tutorial.game con la implementaci\u00f3n de los m\u00e9todos vac\u00edos, para que no falle la compilaci\u00f3n. \u00a1Vamos a implementar test! GameController.java GameIT.java package com.ccsw.tutorial.game ; import com.ccsw.tutorial.game.model.Game ; import com.ccsw.tutorial.game.model.GameDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; import org.springframework.web.bind.annotation.* ; import java.util.List ; /** * @author ccsw * */ @Tag ( name = \"Game\" , description = \"API of Game\" ) @RequestMapping ( value = \"/game\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class GameController { /** * M\u00e9todo para recuperar una lista de {@link Game} * * @param title t\u00edtulo del juego * @param idCategory PK de la categor\u00eda * @return {@link List} de {@link GameDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a filtered list of Games\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < GameDto > find ( @RequestParam ( value = \"title\" , required = false ) String title , @RequestParam ( value = \"idCategory\" , required = false ) Long idCategory ) { return null ; } /** * M\u00e9todo para crear o actualizar un {@link Game} * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Game\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody GameDto dto ) { } } package com.ccsw.tutorial.game ; import com.ccsw.tutorial.author.model.AuthorDto ; import com.ccsw.tutorial.category.model.CategoryDto ; import com.ccsw.tutorial.game.model.GameDto ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.boot.test.web.client.TestRestTemplate ; import org.springframework.boot.test.web.server.LocalServerPort ; import org.springframework.core.ParameterizedTypeReference ; import org.springframework.http.HttpEntity ; import org.springframework.http.HttpMethod ; import org.springframework.http.HttpStatus ; import org.springframework.http.ResponseEntity ; import org.springframework.test.annotation.DirtiesContext ; import org.springframework.web.util.UriComponentsBuilder ; import java.util.HashMap ; import java.util.List ; import java.util.Map ; import static org.junit.jupiter.api.Assertions.assertEquals ; import static org.junit.jupiter.api.Assertions.assertNotNull ; @SpringBootTest ( webEnvironment = SpringBootTest . WebEnvironment . RANDOM_PORT ) @DirtiesContext ( classMode = DirtiesContext . ClassMode . BEFORE_EACH_TEST_METHOD ) public class GameIT { public static final String LOCALHOST = \"http://localhost:\" ; public static final String SERVICE_PATH = \"/game\" ; public static final Long EXISTS_GAME_ID = 1L ; public static final Long NOT_EXISTS_GAME_ID = 0 L ; private static final String NOT_EXISTS_TITLE = \"NotExists\" ; private static final String EXISTS_TITLE = \"Aventureros\" ; private static final String NEW_TITLE = \"Nuevo juego\" ; private static final Long NOT_EXISTS_CATEGORY = 0 L ; private static final Long EXISTS_CATEGORY = 3L ; private static final String TITLE_PARAM = \"title\" ; private static final String CATEGORY_ID_PARAM = \"idCategory\" ; @LocalServerPort private int port ; @Autowired private TestRestTemplate restTemplate ; ParameterizedTypeReference < List < GameDto >> responseType = new ParameterizedTypeReference < List < GameDto >> (){}; private String getUrlWithParams (){ return UriComponentsBuilder . fromHttpUrl ( LOCALHOST + port + SERVICE_PATH ) . queryParam ( TITLE_PARAM , \"{\" + TITLE_PARAM + \"}\" ) . queryParam ( CATEGORY_ID_PARAM , \"{\" + CATEGORY_ID_PARAM + \"}\" ) . encode () . toUriString (); } @Test public void findWithoutFiltersShouldReturnAllGamesInDB () { int GAMES_WITH_FILTER = 6 ; Map < String , Object > params = new HashMap <> (); params . put ( TITLE_PARAM , null ); params . put ( CATEGORY_ID_PARAM , null ); ResponseEntity < List < GameDto >> response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( GAMES_WITH_FILTER , response . getBody (). size ()); } @Test public void findExistsTitleShouldReturnGames () { int GAMES_WITH_FILTER = 1 ; Map < String , Object > params = new HashMap <> (); params . put ( TITLE_PARAM , EXISTS_TITLE ); params . put ( CATEGORY_ID_PARAM , null ); ResponseEntity < List < GameDto >> response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( GAMES_WITH_FILTER , response . getBody (). size ()); } @Test public void findExistsCategoryShouldReturnGames () { int GAMES_WITH_FILTER = 2 ; Map < String , Object > params = new HashMap <> (); params . put ( TITLE_PARAM , null ); params . put ( CATEGORY_ID_PARAM , EXISTS_CATEGORY ); ResponseEntity < List < GameDto >> response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( GAMES_WITH_FILTER , response . getBody (). size ()); } @Test public void findExistsTitleAndCategoryShouldReturnGames () { int GAMES_WITH_FILTER = 1 ; Map < String , Object > params = new HashMap <> (); params . put ( TITLE_PARAM , EXISTS_TITLE ); params . put ( CATEGORY_ID_PARAM , EXISTS_CATEGORY ); ResponseEntity < List < GameDto >> response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( GAMES_WITH_FILTER , response . getBody (). size ()); } @Test public void findNotExistsTitleShouldReturnEmpty () { int GAMES_WITH_FILTER = 0 ; Map < String , Object > params = new HashMap <> (); params . put ( TITLE_PARAM , NOT_EXISTS_TITLE ); params . put ( CATEGORY_ID_PARAM , null ); ResponseEntity < List < GameDto >> response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( GAMES_WITH_FILTER , response . getBody (). size ()); } @Test public void findNotExistsCategoryShouldReturnEmpty () { int GAMES_WITH_FILTER = 0 ; Map < String , Object > params = new HashMap <> (); params . put ( TITLE_PARAM , null ); params . put ( CATEGORY_ID_PARAM , NOT_EXISTS_CATEGORY ); ResponseEntity < List < GameDto >> response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( GAMES_WITH_FILTER , response . getBody (). size ()); } @Test public void findNotExistsTitleOrCategoryShouldReturnEmpty () { int GAMES_WITH_FILTER = 0 ; Map < String , Object > params = new HashMap <> (); params . put ( TITLE_PARAM , NOT_EXISTS_TITLE ); params . put ( CATEGORY_ID_PARAM , NOT_EXISTS_CATEGORY ); ResponseEntity < List < GameDto >> response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( GAMES_WITH_FILTER , response . getBody (). size ()); params . put ( TITLE_PARAM , NOT_EXISTS_TITLE ); params . put ( CATEGORY_ID_PARAM , EXISTS_CATEGORY ); response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( GAMES_WITH_FILTER , response . getBody (). size ()); params . put ( TITLE_PARAM , EXISTS_TITLE ); params . put ( CATEGORY_ID_PARAM , NOT_EXISTS_CATEGORY ); response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( GAMES_WITH_FILTER , response . getBody (). size ()); } @Test public void saveWithoutIdShouldCreateNewGame () { GameDto dto = new GameDto (); AuthorDto authorDto = new AuthorDto (); authorDto . setId ( 1L ); CategoryDto categoryDto = new CategoryDto (); categoryDto . setId ( 1L ); dto . setTitle ( NEW_TITLE ); dto . setAge ( \"18\" ); dto . setAuthor ( authorDto ); dto . setCategory ( categoryDto ); Map < String , Object > params = new HashMap <> (); params . put ( TITLE_PARAM , NEW_TITLE ); params . put ( CATEGORY_ID_PARAM , null ); ResponseEntity < List < GameDto >> response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( 0 , response . getBody (). size ()); restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . PUT , new HttpEntity <> ( dto ), Void . class ); response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( 1 , response . getBody (). size ()); } @Test public void modifyWithExistIdShouldModifyGame () { GameDto dto = new GameDto (); AuthorDto authorDto = new AuthorDto (); authorDto . setId ( 1L ); CategoryDto categoryDto = new CategoryDto (); categoryDto . setId ( 1L ); dto . setTitle ( NEW_TITLE ); dto . setAge ( \"18\" ); dto . setAuthor ( authorDto ); dto . setCategory ( categoryDto ); Map < String , Object > params = new HashMap <> (); params . put ( TITLE_PARAM , NEW_TITLE ); params . put ( CATEGORY_ID_PARAM , null ); ResponseEntity < List < GameDto >> response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( 0 , response . getBody (). size ()); restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + EXISTS_GAME_ID , HttpMethod . PUT , new HttpEntity <> ( dto ), Void . class ); response = restTemplate . exchange ( getUrlWithParams (), HttpMethod . GET , null , responseType , params ); assertNotNull ( response ); assertEquals ( 1 , response . getBody (). size ()); assertEquals ( EXISTS_GAME_ID , response . getBody (). get ( 0 ). getId ()); } @Test public void modifyWithNotExistIdShouldThrowException () { GameDto dto = new GameDto (); dto . setTitle ( NEW_TITLE ); ResponseEntity <?> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + NOT_EXISTS_GAME_ID , HttpMethod . PUT , new HttpEntity <> ( dto ), Void . class ); assertEquals ( HttpStatus . INTERNAL_SERVER_ERROR , response . getStatusCode ()); } } B\u00fasquedas en BBDD Siempre deber\u00edamos buscar a los hijos por primary keys, nunca hay que hacerlo por una descripci\u00f3n libre, ya que el usuario podr\u00eda teclear el mismo nombre de diferentes formas y no habr\u00eda manera de buscar correctamente el resultado. As\u00ed que siempre que haya un dropdown, se debe filtrar por su ID. Si ahora ejecutas los jUnits, ver\u00e1s que en este caso hemos construido 10 pruebas, para cubrir los casos b\u00e1sicos del Controller , y todas ellas fallan la ejecuci\u00f3n. Vamos a seguir implementando el resto de capas para hacer que los test funcionen.","title":"TDD - Pruebas"},{"location":"develop/filtered/springboot/#controller","text":"De nuevo para poder compilar esta capa, nos hace falta delegar sus operaciones de l\u00f3gica de negocio en un Service as\u00ed que lo crearemos al mismo tiempo que lo vamos necesitando. GameService.java GameController.java package com.ccsw.tutorial.game ; import com.ccsw.tutorial.game.model.Game ; import com.ccsw.tutorial.game.model.GameDto ; import java.util.List ; /** * @author ccsw * */ public interface GameService { /** * Recupera los juegos filtrando opcionalmente por t\u00edtulo y/o categor\u00eda * * @param title t\u00edtulo del juego * @param idCategory PK de la categor\u00eda * @return {@link List} de {@link Game} */ List < Game > find ( String title , Long idCategory ); /** * Guarda o modifica un juego, dependiendo de si el identificador est\u00e1 o no informado * * @param id PK de la entidad * @param dto datos de la entidad */ void save ( Long id , GameDto dto ); } package com.ccsw.tutorial.game ; import com.ccsw.tutorial.game.model.Game ; import com.ccsw.tutorial.game.model.GameDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; import org.modelmapper.ModelMapper ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.* ; import java.util.List ; import java.util.stream.Collectors ; /** * @author ccsw * */ @Tag ( name = \"Game\" , description = \"API of Game\" ) @RequestMapping ( value = \"/game\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class GameController { @Autowired GameService gameService ; @Autowired ModelMapper mapper ; /** * M\u00e9todo para recuperar una lista de {@link Game} * * @param title t\u00edtulo del juego * @param idCategory PK de la categor\u00eda * @return {@link List} de {@link GameDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a filtered list of Games\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < GameDto > find ( @RequestParam ( value = \"title\" , required = false ) String title , @RequestParam ( value = \"idCategory\" , required = false ) Long idCategory ) { List < Game > games = gameService . find ( title , idCategory ); return games . stream (). map ( e -> mapper . map ( e , GameDto . class )). collect ( Collectors . toList ()); } /** * M\u00e9todo para crear o actualizar un {@link Game} * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Game\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody GameDto dto ) { gameService . save ( id , dto ); } } En esta ocasi\u00f3n, para el m\u00e9todo de b\u00fasqueda hemos decidido utilizar par\u00e1metros en la URL de tal forma que nos quedar\u00e1 algo as\u00ed http://localhost:8080/game/?title=xxx&idCategoria=yyy . Queremos recuperar el recurso Game que es el raiz de la ruta, pero filtrado por cero o varios par\u00e1metros.","title":"Controller"},{"location":"develop/filtered/springboot/#service","text":"Siguiente paso, la capa de l\u00f3gica de negocio, es decir el Service , que por tanto har\u00e1 uso de un Repository . GameServiceImpl.java GameRepository.java package com.ccsw.tutorial.game ; import com.ccsw.tutorial.game.model.Game ; import com.ccsw.tutorial.game.model.GameDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class GameServiceImpl implements GameService { @Autowired GameRepository gameRepository ; /** * {@inheritDoc} */ @Override public List < Game > find ( String title , Long idCategory ) { return ( List < Game > ) this . gameRepository . findAll (); } /** * {@inheritDoc} */ @Override public void save ( Long id , GameDto dto ) { Game game ; if ( id == null ) { game = new Game (); } else { game = this . gameRepository . findById ( id ). orElse ( null ); } BeanUtils . copyProperties ( dto , game , \"id\" , \"author\" , \"category\" ); this . gameRepository . save ( game ); } } package com.ccsw.tutorial.game ; import com.ccsw.tutorial.game.model.Game ; import org.springframework.data.repository.CrudRepository ; /** * @author ccsw * */ public interface GameRepository extends CrudRepository < Game , Long > { } Este servicio tiene dos peculiaridades, remarcadas en amarillo en la clase anterior. Por un lado tenemos la consulta, que no es un listado completo ni un listado paginado, sino que es un listado con filtros. Luego veremos como se hace eso, de momento lo dejaremos como un m\u00e9todo que recibe los dos filtros. La segunda peculiaridad es que de cliente nos est\u00e1 llegando un GameDto , que internamente tiene un AuthorDto y un CategoryDto , pero nosotros lo tenemos que traducir a entidades de BBDD. No sirve con copiar las propiedades tal cual, ya que entonces Spring lo que har\u00e1 ser\u00e1 crear un objeto nuevo y persistir ese objeto nuevo de Author y de Category . Adem\u00e1s, de cliente generalmente tan solo nos llega el ID de esos objetos hijo, y no el resto de informaci\u00f3n de la entidad. Por esos motivos lo hemos ignorado del copyProperties. Pero de alguna forma tendremos que asignarle esos valores a la entidad Game . Si conocemos sus ID que es lo que generalmente llega, podemos recuperar esos objetos de BBDD y asignarlos en el objeto Game . Si recuerdas las reglas b\u00e1sicas, un Repository debe pertenecer a un solo Service , por lo que en lugar de llamar a m\u00e9todos de los AuthorRepository y CategoryRepository desde nuestro GameServiceImpl , debemos llamar a m\u00e9todos expuestos en AuthorService y CategoryService , que son los que gestionan sus repositorios. Para ello necesitaremos crear esos m\u00e9todos get en los otros Services . Y ya sabes, para implementar nuevos m\u00e9todos, antes se deben hacer las pruebas jUnit, que en este caso, por variar, cubriremos con pruebas unitarias. Recuerda que los test van en src/test/java AuthorTest.java AuthorService.java AuthorServiceImpl.java package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.Author ; import org.junit.jupiter.api.Test ; import org.junit.jupiter.api.extension.ExtendWith ; import org.mockito.InjectMocks ; import org.mockito.Mock ; import org.mockito.junit.jupiter.MockitoExtension ; import java.util.Optional ; import static org.junit.jupiter.api.Assertions.* ; import static org.mockito.Mockito.mock ; import static org.mockito.Mockito.when ; @ExtendWith ( MockitoExtension . class ) public class AuthorTest { public static final Long EXISTS_AUTHOR_ID = 1L ; public static final Long NOT_EXISTS_AUTHOR_ID = 0 L ; @Mock private AuthorRepository authorRepository ; @InjectMocks private AuthorServiceImpl authorService ; @Test public void getExistsAuthorIdShouldReturnAuthor () { Author author = mock ( Author . class ); when ( author . getId ()). thenReturn ( EXISTS_AUTHOR_ID ); when ( authorRepository . findById ( EXISTS_AUTHOR_ID )). thenReturn ( Optional . of ( author )); Author authorResponse = authorService . get ( EXISTS_AUTHOR_ID ); assertNotNull ( authorResponse ); assertEquals ( EXISTS_AUTHOR_ID , authorResponse . getId ()); } @Test public void getNotExistsAuthorIdShouldReturnNull () { when ( authorRepository . findById ( NOT_EXISTS_AUTHOR_ID )). thenReturn ( Optional . empty ()); Author author = authorService . get ( NOT_EXISTS_AUTHOR_ID ); assertNull ( author ); } } package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.Author ; import com.ccsw.tutorial.author.model.AuthorDto ; import com.ccsw.tutorial.author.model.AuthorSearchDto ; import org.springframework.data.domain.Page ; import java.util.List ; /** * @author ccsw * */ public interface AuthorService { /** * Recupera un {@link Author} a trav\u00e9s de su ID * * @param id PK de la entidad * @return {@link Author} */ Author get ( Long id ); /** * M\u00e9todo para recuperar un listado paginado de {@link Author} * * @param dto dto de b\u00fasqueda * @return {@link Page} de {@link Author} */ Page < Author > findPage ( AuthorSearchDto dto ); /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad * @param dto datos de la entidad */ void save ( Long id , AuthorDto dto ); /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad */ void delete ( Long id ) throws Exception ; } package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.Author ; import com.ccsw.tutorial.author.model.AuthorDto ; import com.ccsw.tutorial.author.model.AuthorSearchDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class AuthorServiceImpl implements AuthorService { @Autowired AuthorRepository authorRepository ; /** * {@inheritDoc} */ @Override public Author get ( Long id ) { return this . authorRepository . findById ( id ). orElse ( null ); } /** * {@inheritDoc} */ @Override public Page < Author > findPage ( AuthorSearchDto dto ) { return this . authorRepository . findAll ( dto . getPageable (). getPageable ()); } /** * {@inheritDoc} */ @Override public void save ( Long id , AuthorDto data ) { Author author ; if ( id == null ) { author = new Author (); } else { author = this . get ( id ); } BeanUtils . copyProperties ( data , author , \"id\" ); this . authorRepository . save ( author ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) throws Exception { if ( this . get ( id ) == null ){ throw new Exception ( \"Not exists\" ); } this . authorRepository . deleteById ( id ); } } Y lo mismo para categor\u00edas. CategoryTest.java CategoryService.java CategoryServiceImpl.java public static final Long NOT_EXISTS_CATEGORY_ID = 0 L ; @Test public void getExistsCategoryIdShouldReturnCategory () { Category category = mock ( Category . class ); when ( category . getId ()). thenReturn ( EXISTS_CATEGORY_ID ); when ( categoryRepository . findById ( EXISTS_CATEGORY_ID )). thenReturn ( Optional . of ( category )); Category categoryResponse = categoryService . get ( EXISTS_CATEGORY_ID ); assertNotNull ( categoryResponse ); assertEquals ( EXISTS_CATEGORY_ID , category . getId ()); } @Test public void getNotExistsCategoryIdShouldReturnNull () { when ( categoryRepository . findById ( NOT_EXISTS_CATEGORY_ID )). thenReturn ( Optional . empty ()); Category category = categoryService . get ( NOT_EXISTS_CATEGORY_ID ); assertNull ( category ); } package com.ccsw.tutorial.category ; import com.ccsw.tutorial.category.model.Category ; import com.ccsw.tutorial.category.model.CategoryDto ; import java.util.List ; /** * @author ccsw * */ public interface CategoryService { /** * Recupera una {@link Category} a partir de su ID * * @param id PK de la entidad * @return {@link Category} */ Category get ( Long id ); /** * M\u00e9todo para recuperar todas las {@link Category} * * @return {@link List} de {@link Category} */ List < Category > findAll (); /** * M\u00e9todo para crear o actualizar una {@link Category} * * @param id PK de la entidad * @param dto datos de la entidad */ void save ( Long id , CategoryDto dto ); /** * M\u00e9todo para borrar una {@link Category} * * @param id PK de la entidad */ void delete ( Long id ) throws Exception ; } package com.ccsw.tutorial.category ; import com.ccsw.tutorial.category.model.Category ; import com.ccsw.tutorial.category.model.CategoryDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class CategoryServiceImpl implements CategoryService { @Autowired CategoryRepository categoryRepository ; /** * {@inheritDoc} */ @Override public Category get ( Long id ) { return this . categoryRepository . findById ( id ). orElse ( null ); } /** * {@inheritDoc} */ @Override public List < Category > findAll () { return ( List < Category > ) this . categoryRepository . findAll (); } /** * {@inheritDoc} */ @Override public void save ( Long id , CategoryDto dto ) { Category category ; if ( id == null ) { category = new Category (); } else { category = this . get ( id ); } category . setName ( dto . getName ()); this . categoryRepository . save ( category ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) throws Exception { if ( this . get ( id ) == null ){ throw new Exception ( \"Not exists\" ); } this . categoryRepository . deleteById ( id ); } } Clean Code A la hora de implementar m\u00e9todos nuevos, ten siempre presente el Clean Code . \u00a1No dupliques c\u00f3digo!, es muy importante de cara al futuro mantenimiento. Si en nuestro m\u00e9todo save hac\u00edamos uso de una operaci\u00f3n findById y ahora hemos creado una nueva operaci\u00f3n get , hagamos uso de esta nueva operaci\u00f3n y no repitamos el c\u00f3digo. Y ahora que ya tenemos los m\u00e9todos necesarios, ya podemos implementar correctamente nuestro GameServiceImpl . GameServiceImpl.java package com.ccsw.tutorial.game ; import com.ccsw.tutorial.author.AuthorService ; import com.ccsw.tutorial.category.CategoryService ; import com.ccsw.tutorial.game.model.Game ; import com.ccsw.tutorial.game.model.GameDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class GameServiceImpl implements GameService { @Autowired GameRepository gameRepository ; @Autowired AuthorService authorService ; @Autowired CategoryService categoryService ; /** * {@inheritDoc} */ @Override public List < Game > find ( String title , Long idCategory ) { return this . gameRepository . findAll (); } /** * {@inheritDoc} */ @Override public void save ( Long id , GameDto dto ) { Game game ; if ( id == null ) { game = new Game (); } else { game = this . gameRepository . findById ( id ). orElse ( null ); } BeanUtils . copyProperties ( dto , game , \"id\" , \"author\" , \"category\" ); game . setAuthor ( authorService . get ( dto . getAuthor (). getId ())); game . setCategory ( categoryService . get ( dto . getCategory (). getId ())); this . gameRepository . save ( game ); } } Ahora si que tenemos la capa de l\u00f3gica de negocio terminada, podemos pasar a la siguiente capa.","title":"Service"},{"location":"develop/filtered/springboot/#repository","text":"Y llegamos a la \u00faltima capa donde, si recordamos, ten\u00edamos un m\u00e9todo que recibe dos par\u00e1metros. Necesitamos traducir esto en una consulta a la BBDD. Vamos a necesitar un listado filtrado por t\u00edtulo o por categor\u00eda, as\u00ed que necesitaremos pasarle esos datos y filtrar la query. Para el t\u00edtulo vamos a buscar por una cadena contenida, as\u00ed que el par\u00e1metro ser\u00e1 de tipo String , mientras que para la categor\u00eda vamos a buscar por su primary key, as\u00ed que el par\u00e1metro ser\u00e1 de tipo Long . Existen varias estrategias para abordar esta implementaci\u00f3n. Podr\u00edamos utilizar los QueryMethods para que Spring JPA haga su magia, pero en esta ocasi\u00f3n ser\u00eda bastante complicado encontrar un predicado correcto. Tambi\u00e9n podr\u00edamos hacer una implementaci\u00f3n de la interface y hacer la consulta directamente con Criteria. Por otro lado se podr\u00eda hacer uso de la anotaci\u00f3n @Query . Esta anotaci\u00f3n nos permite definir una consulta en SQL nativo o en JPQL (Java Persistence Query Language) y Spring JPA se encargar\u00e1 de realizar todo el mapeo y conversi\u00f3n de los datos de entrada y salida. Pero esta opci\u00f3n no es la m\u00e1s recomendable.","title":"Repository"},{"location":"develop/filtered/springboot/#specifications","text":"En este caso vamos a hacer uso de las Specifications que es la opci\u00f3n m\u00e1s robusta y no presenta acoplamientos con el tipo de BBDD. Haciendo un resumen muy r\u00e1pido y con poco detalle, las Specifications sirven para generar de forma robusta las clausulas where de una consulta SQL. Estas clausulas se generar\u00e1n mediante Predicate (predicados) que realizar\u00e1n operaciones de comparaci\u00f3n entre un campo y un valor. En el siguiente ejemplo podemos verlo m\u00e1s claro: en la sentencia select * from Table where name = 'b\u00fasqueda' tenemos un solo predicado que es name = 'b\u00fasqueda' . En ese predicado diferenciamos tres etiquetas: name \u2192 es el campo sobre el que hacemos el predicado = \u2192 es la operaci\u00f3n que realizamos 'b\u00fasqueda' \u2192 es el valor con el que realizamos la operaci\u00f3n Lo que trata de hacer Specifications es agregar varios predicados con AND o con OR de forma tipada en c\u00f3digo. Y \u00bfqu\u00e9 intentamos conseguir con esta forma de programar?, pues f\u00e1cil, intentamos hacer que si cambiamos alg\u00fan tipo o el nombre de alguna propiedad involucrada en la query, nos salte un fallo en tiempo de compilaci\u00f3n y nos demos cuenta de donde est\u00e1 el error. Si utiliz\u00e1ramos queries construidas directamente con String , al cambiar alg\u00fan tipo o el nombre de alguna propiedad involucrada, no nos dar\u00edamos cuenta hasta que saltara un fallo en tiempo de ejecuci\u00f3n. Por este motivo hay que programar con Specifications , porque son robustas ante cambios de c\u00f3digo y tenemos que tratar de evitar las construcciones a trav\u00e9s de cadenas de texto. Dicho esto, \u00a1vamos a implementar! Lo primero que necesitaremos ser\u00e1 una clase que nos permita guardar la informaci\u00f3n de un Predicate para luego generar facilmente la construcci\u00f3n. Para ello vamos a crear una clase que guarde informaci\u00f3n de los criterios de filtrado (campo, operaci\u00f3n y valor), por suerte esta clase ser\u00e1 gen\u00e9rica y la podremos usar en toda la aplicaci\u00f3n, as\u00ed que la vamos a crear en el paquete com.ccsw.tutorial.common.criteria SearchCriteria.java package com.ccsw.tutorial.common.criteria ; public class SearchCriteria { private String key ; private String operation ; private Object value ; public SearchCriteria ( String key , String operation , Object value ) { this . key = key ; this . operation = operation ; this . value = value ; } public String getKey () { return key ; } public void setKey ( String key ) { this . key = key ; } public String getOperation () { return operation ; } public void setOperation ( String operation ) { this . operation = operation ; } public Object getValue () { return value ; } public void setValue ( Object value ) { this . value = value ; } } Hecho esto pasamos a definir el Specification de nuestra clase la cual contendr\u00e1 la construcci\u00f3n de la consulta en funci\u00f3n de los criterios que se le proporcionan. No queremos construir los predicados directamente en nuestro Service ya que duplicariamos mucho c\u00f3digo, mucho mejor si hacemos una clase para centralizar la construcci\u00f3n de predicados. De esta forma vamos a crear una clase Specification por cada una de las Entity que queramos consultar. En nuestro caso solo vamos a generar queries para Game , as\u00ed que solo crearemos un GameSpecification donde construirmos los predicados. GameSpecification.java package com.ccsw.tutorial.game ; import com.ccsw.tutorial.common.criteria.SearchCriteria ; import com.ccsw.tutorial.game.model.Game ; import jakarta.persistence.criteria.* ; import org.springframework.data.jpa.domain.Specification ; public class GameSpecification implements Specification < Game > { private static final long serialVersionUID = 1L ; private final SearchCriteria criteria ; public GameSpecification ( SearchCriteria criteria ) { this . criteria = criteria ; } @Override public Predicate toPredicate ( Root < Game > root , CriteriaQuery <?> query , CriteriaBuilder builder ) { if ( criteria . getOperation (). equalsIgnoreCase ( \":\" ) && criteria . getValue () != null ) { Path < String > path = getPath ( root ); if ( path . getJavaType () == String . class ) { return builder . like ( path , \"%\" + criteria . getValue () + \"%\" ); } else { return builder . equal ( path , criteria . getValue ()); } } return null ; } private Path < String > getPath ( Root < Game > root ) { String key = criteria . getKey (); String [] split = key . split ( \"[.]\" , 0 ); Path < String > expression = root . get ( split [ 0 ] ); for ( int i = 1 ; i < split . length ; i ++ ) { expression = expression . get ( split [ i ] ); } return expression ; } } Voy a tratar de explicar con calma cada una de las l\u00edneas marcadas, ya que son conceptos dificiles de entender hasta que no se utilizan. Las dos primeras l\u00edneas marcadas hacen referencia a que cuando se crea un Specification , esta debe generar un predicado, con lo que necesita unos criterios de filtrado para poder generarlo. En el constructor le estamos pasando esos criterios de filtrado que luego utilizaremos. La tercera l\u00ednea marcada est\u00e1 seleccionando el tipo de operaci\u00f3n. En nuestro caso solo vamos a utilizar operaciones de comparaci\u00f3n. Por convenio las operaciones de comparaci\u00f3n se marcan como \":\" ya que el s\u00edmbolo = est\u00e1 reservado. Aqu\u00ed es donde podr\u00edamos a\u00f1adir otro tipo de operaciones como \">\" o \"<>\" o cualquiera que queramos implementar. Gu\u00e1rdate esa informaci\u00f3n que te servir\u00e1 en el ejercicio final . Las dos siguientes l\u00edneas, las de return est\u00e1n construyendo un Predicate al ser de tipo comparaci\u00f3n, si es un texto har\u00e1 un like y si no es texto (que es un n\u00famero o fecha) har\u00e1 un equals . Por \u00faltimo, tenemos un m\u00e9todo getPath que invocamos dentro la generaci\u00f3n del predicado y que implementamos m\u00e1s abajo. Esta funci\u00f3n nos permite explorar las sub-entidades para realizar consultas sobre los atributos de estas. Por ejemplo, si queremos navegar hasta game.author.name , lo que har\u00e1 la exploraci\u00f3n ser\u00e1 recuperar el atributo name del objeto author de la entidad game . Una vez implementada nuestra clase de Specification , que lo \u00fanico que hace es recoger un criterio de filtrado y construir un predicado, y que en principio solo permite generar comparaciones de igualdad, vamos a utilizarlo dentro de nuestro Service : GameServiceImpl.java GameRepository.java package com.ccsw.tutorial.game ; import com.ccsw.tutorial.author.AuthorService ; import com.ccsw.tutorial.category.CategoryService ; import com.ccsw.tutorial.common.criteria.SearchCriteria ; import com.ccsw.tutorial.game.model.Game ; import com.ccsw.tutorial.game.model.GameDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.jpa.domain.Specification ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class GameServiceImpl implements GameService { @Autowired GameRepository gameRepository ; @Autowired AuthorService authorService ; @Autowired CategoryService categoryService ; /** * {@inheritDoc} */ @Override public List < Game > find ( String title , Long idCategory ) { GameSpecification titleSpec = new GameSpecification ( new SearchCriteria ( \"title\" , \":\" , title )); GameSpecification categorySpec = new GameSpecification ( new SearchCriteria ( \"category.id\" , \":\" , idCategory )); Specification < Game > spec = Specification . where ( titleSpec ). and ( categorySpec ); return this . gameRepository . findAll ( spec ); } /** * {@inheritDoc} */ @Override public void save ( Long id , GameDto dto ) { Game game ; if ( id == null ) { game = new Game (); } else { game = this . gameRepository . findById ( id ). orElse ( null ); } BeanUtils . copyProperties ( dto , game , \"id\" , \"author\" , \"category\" ); game . setAuthor ( authorService . get ( dto . getAuthor (). getId ())); game . setCategory ( categoryService . get ( dto . getCategory (). getId ())); this . gameRepository . save ( game ); } } package com.ccsw.tutorial.game ; import com.ccsw.tutorial.game.model.Game ; import org.springframework.data.jpa.domain.Specification ; import org.springframework.data.jpa.repository.EntityGraph ; import org.springframework.data.jpa.repository.JpaSpecificationExecutor ; import org.springframework.data.repository.CrudRepository ; import java.util.List ; /** * @author ccsw * */ public interface GameRepository extends CrudRepository < Game , Long > , JpaSpecificationExecutor < Game > { } Lo que hemos hecho es crear los dos criterios de filtrado que necesit\u00e1bamos. En nuestro caso eran title , que es un atributo de la entidad Game y por otro lado el identificador de categor\u00eda, que en este caso, ya no es un atributo directo de la entidad, si no, de la categor\u00eda asociada, por lo que debemos navegar hasta el atributo id a trav\u00e9s del atributo category (para esto utilizamos el getPath que hemos visto anteriormente). A partir de estos dos predicados, podemos generar el Specification global para la consulta, uniendo los dos predicados mediante el operador AND . Una vez construido el Specification ya podemos usar el m\u00e9todo por defecto que nos proporciona Spring Data para dicho fin, tan solo tenemos que decirle a nuestro GameRepository que adem\u00e1s extender de CrudRepository debe extender de JpaSpecificationExecutor , para que pueda ejecutarlas.","title":"Specifications"},{"location":"develop/filtered/springboot/#mejoras-rendimiento","text":"Finalmente, de cara a mejorar el rendimiento de nuestros servicios vamos a hacer foco en la generaci\u00f3n de transacciones con la base de datos. Si ejecut\u00e1ramos esta petici\u00f3n tal cual lo tenemos implementado ahora mismo, en la consola ver\u00edamos lo siguiente: Hibernate: select g1_0.id,g1_0.age,g1_0.author_id,g1_0.category_id,g1_0.title from game g1_0 Hibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=? Hibernate: select c1_0.id,c1_0.name from category c1_0 where c1_0.id=? Hibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=? Hibernate: select c1_0.id,c1_0.name from category c1_0 where c1_0.id=? Hibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=? Hibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=? Hibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=? Esto es debido a que no le hemos dado indicaciones a Spring Data de como queremos que construya las consultas con relaciones y por defecto est\u00e1 configurado para generar sub-consultas cuando tenemos tablas relacionadas. En nuestro caso la tabla Game est\u00e1 relacionada con Author y Category . Al realizar la consulta a Game realiza las sub-consultas por cada uno de los registros relacionados con los resultados Game . Para evitar tantas consultas contra la BBDD y realizar esto de una forma mucho m\u00e1s \u00f3ptima, podemos decirle a Spring Data el comportamiento que queremos, que en nuestro caso ser\u00e1 que haga una \u00fanica consulta y haga las sub-consultas mediante los join correspondientes. Para ello a\u00f1adimos una sobre-escritura del m\u00e9todo findAll , que ya ten\u00edamos implementado en JpaSpecificationExecutor y que utlizamos de forma heredada, pero en este caso le a\u00f1adimos la anotaci\u00f3n @EntityGraph con los atributos que queremos que se incluyan dentro de la consulta principal mediante join : GameRepository.java package com.ccsw.tutorial.game ; import com.ccsw.tutorial.game.model.Game ; import org.springframework.data.jpa.domain.Specification ; import org.springframework.data.jpa.repository.EntityGraph ; import org.springframework.data.jpa.repository.JpaSpecificationExecutor ; import org.springframework.data.repository.CrudRepository ; import java.util.List ; /** * @author ccsw * */ public interface GameRepository extends CrudRepository < Game , Long > , JpaSpecificationExecutor < Game > { @Override @EntityGraph ( attributePaths = { \"category\" , \"author\" }) List < Game > findAll ( Specification < Game > spec ); } Tras realizar este cambio, podemos observar que la nueva consulta generada es la siguiente: Hibernate: select g1_0.id,g1_0.age,a1_0.id,a1_0.name,a1_0.nationality,c1_0.id,c1_0.name,g1_0.title from game g1_0 join author a1_0 on a1_0.id=g1_0.author_id join category c1_0 on c1_0.id=g1_0.category_id Como podemos observar, ahora se realiza una \u00fanica consulta con la correspondiente transacci\u00f3n con la BBDD, y se trae todos los datos necesarios de Game , Author y Category sin lanzar m\u00faltiples queries.","title":"Mejoras rendimiento"},{"location":"develop/filtered/springboot/#prueba-de-las-operaciones","text":"Si ahora ejecutamos de nuevo los jUnits, vemos que todos los que hemos desarrollado en GameIT ya funcionan correctamente, e incluso el resto de test de la aplicaci\u00f3n tambi\u00e9n funcionan correctamente. Pruebas jUnit Cada vez que desarrollemos un caso de uso nuevo, debemos relanzar todas las pruebas autom\u00e1ticas que tenga la aplicaci\u00f3n. Es muy com\u00fan que al implementar alg\u00fan desarrollo nuevo, interfiramos de alguna forma en el funcionamiento de otra funcionalidad. Si lanzamos toda la bater\u00eda de pruebas, nos daremos cuenta si algo ha dejado de funcionar y podremos solucionarlo antes de llevar ese error a Producci\u00f3n. Las pruebas jUnit son nuestra red de seguridad. Adem\u00e1s de las pruebas autom\u00e1ticas, podemos ver como se comporta la aplicaci\u00f3n y que respuesta nos ofrece, lanzando peticiones Rest con Postman, como hemos hecho en los casos anteriores. As\u00ed que podemos levantar la aplicaci\u00f3n y lanzar las operaciones: GET http://localhost:8080/game GET http://localhost:8080/game?title=xxx GET http://localhost:8080/game?idCategory=xxx Nos devuelve un listado filtrado de Game . F\u00edjate bien en la petici\u00f3n donde enviamos los filtros y la respuesta que tiene los objetos Category y Author inclu\u00eddos. PUT http://localhost:8080/game PUT http://localhost:8080/game/{id} { \"title\": \"Nuevo juego\", \"age\": \"18\", \"category\": { \"id\": 3 }, \"author\": { \"id\": 1 } } Nos sirve para insertar un Game nuevo (si no tienen el id informado) o para actualizar un Game (si tienen el id informado). F\u00edjate que para enlazar Category y Author tan solo hace falta el id de cada no de ellos, ya que en el m\u00e9todo save se hace una consulta get para recuperarlos por su id. Adem\u00e1s que no tendr\u00eda sentido enviar toda la informaci\u00f3n de esas entidades ya que no est\u00e1s dando de alta una Category ni un Author . Rendimiento en las consultas JPA En este punto te recomiendo que visites el Anexo. Funcionamiento JPA para conocer un poco m\u00e1s como funciona por dentro JPA y alg\u00fan peque\u00f1o truco que puede mejorar el rendimiento.","title":"Prueba de las operaciones"},{"location":"develop/filtered/springboot/#implementar-listado-autores","text":"Antes de poder conectar front con back, si recuerdas, en la edici\u00f3n de un Game , nos hac\u00eda falta un listado de Author y un listado de Category . El segundo ya lo tenemos ya que lo reutilizaremos del listado de categor\u00edas que implementamos. Pero el primero no lo tenemos, porque en la pantalla que hicimos, se mostraban de forma paginada. As\u00ed que necesitamos implementar esa funcionalidad, y como siempre vamos de la capa de testing hacia las siguientes capas. Deber\u00edamos a\u00f1adir los siguientes m\u00e9todos: AuthorIT.java AuthorController.java AuthorService.java AuthorServiceImpl.java ... ParameterizedTypeReference < List < AuthorDto >> responseTypeList = new ParameterizedTypeReference < List < AuthorDto >> (){}; @Test public void findAllShouldReturnAllAuthor () { ResponseEntity < List < AuthorDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . GET , null , responseTypeList ); assertNotNull ( response ); assertEquals ( TOTAL_AUTHORS , response . getBody (). size ()); } ... ... /** * Recupera un listado de autores {@link Author} * * @return {@link List} de {@link AuthorDto} */ @Operation ( summary = \"Find\" , description = \"Method that return a list of Authors\" ) @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < AuthorDto > findAll () { List < Author > authors = this . authorService . findAll (); return authors . stream (). map ( e -> mapper . map ( e , AuthorDto . class )). collect ( Collectors . toList ()); } ... ... /** * Recupera un listado de autores {@link Author} * * @return {@link List} de {@link Author} */ List < Author > findAll (); ... ... /** * {@inheritDoc} */ @Override public List < Author > findAll () { return ( List < Author > ) this . authorRepository . findAll (); } ...","title":"Implementar listado Autores"},{"location":"develop/paginated/angular/","text":"Listado paginado - Angular Ya tienes tu primer CRUD desarrollado. \u00bfHa sido sencillo, verdad?. Ahora vamos a implementar un CRUD un poco m\u00e1s complejo, este tiene datos paginados en servidor, esto quiere decir que no nos sirve un array de datos como en el anterior ejemplo. Para que un listado paginado en servidor funcione, el cliente debe enviar en cada petici\u00f3n que p\u00e1gina est\u00e1 solicitando y cual es el tama\u00f1o de la p\u00e1gina, para que el servidor devuelva solamente un subconjunto de datos, en lugar de devolver el listado completo. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades. Crear modulo y componentes Vamos a desarrollar el listado de Autores as\u00ed que, debemos crear los componentes: ng generate module author ng generate component author/author-list ng generate component author/author-edit ng generate service author/author Este m\u00f3dulo lo vamos a a\u00f1adir a la aplicaci\u00f3n para que se cargue en el arranque. Abrimos el fichero app.module.ts y a\u00f1adimos el m\u00f3dulo: app.module.ts import { NgModule } from '@angular/core' ; import { BrowserModule } from '@angular/platform-browser' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { BrowserAnimationsModule } from '@angular/platform-browser/animations' ; import { CoreModule } from './core/core.module' ; import { CategoryModule } from './category/category.module' ; import { AuthorModule } from './author/author.module' ; @NgModule ({ declarations : [ AppComponent ], imports : [ BrowserModule , AppRoutingModule , CoreModule , CategoryModule , AuthorModule , BrowserAnimationsModule ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { } Crear el modelo Creamos el modelo en author/model/Author.ts con las propiedades necesarias para trabajar con la informaci\u00f3n de un autor: Author.ts export class Author { id : number ; name : string ; nationality : string ; } A\u00f1adir el punto de entrada A\u00f1adimos la ruta al men\u00fa para que podamos acceder a la pantalla: app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { CategoryListComponent } from './category/category-list/category-list.component' ; import { AuthorListComponent } from './author/author-list/author-list.component' ; const routes : Routes = [ { path : 'categories' , component : CategoriesComponent }, { path : 'authors' , component : AuthorListComponent }, ]; @NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } Implementar servicio Y realizamos las diferentes implementaciones. Empezaremos por el servicio. En este caso, hay un cambio sustancial con el anterior ejemplo. Al tratarse de un listado paginado, la operaci\u00f3n getAuthors necesita informaci\u00f3n extra acerca de que p\u00e1gina de datos debe mostrar, adem\u00e1s de que el resultado ya no ser\u00e1 un listado sino una p\u00e1gina. Por defecto el esquema de datos de Spring para la paginaci\u00f3n es como el siguiente: Esquema de datos de paginaci\u00f3n { \"content\" : [ ... <lis ta do co n los resul ta dos pagi na dos> ... ], \"pageable\" : { \"pageNumber\" : < n \u00famero de p\u00e1gi na empeza n do por 0 > , \"pageSize\" : < ta ma\u00f1o de p\u00e1gi na > , \"sort\" : [ { \"property\" : < n ombre de la propiedad a orde nar > , \"direction\" : <direcci\u00f3 n de la orde na ci\u00f3 n ASC / DESC> } ] }, \"totalElements\" : < nu mero t o tal de eleme nt os e n la ta bla> } As\u00ed que necesitamos poder enviar y recuperar esa informaci\u00f3n desde Angular, nos hace falta crear esos objetos. Los objetos de paginaci\u00f3n al ser comunes a toda la aplicaci\u00f3n, vamos a crearlos en core/model/page , mientras que la paginaci\u00f3n de AuthorPage.ts la crear\u00e9 en su propio model dentro de author/model . SortPage.ts Pageable.ts AuthorPage.ts export class SortPage { property : String ; direction : String ; } import { SortPage } from './SortPage' ; export class Pageable { pageNumber : number ; pageSize : number ; sort : SortPage []; } import { Pageable } from \"src/app/core/model/page/Pageable\" ; import { Author } from \"./Author\" ; export class AuthorPage { content : Author []; pageable : Pageable ; totalElements : number ; } Con estos objetos creados ya podemos implementar el servicio y sus datos mockeados. mock-authors.ts author.service.ts import { AuthorPage } from \"./AuthorPage\" ; export const AUTHOR_DATA : AuthorPage = { content : [ { id : 1 , name : 'Klaus Teuber' , nationality : 'Alemania' }, { id : 2 , name : 'Matt Leacock' , nationality : 'Estados Unidos' }, { id : 3 , name : 'Keng Leong Yeo' , nationality : 'Singapur' }, { id : 4 , name : 'Gil Hova' , nationality : 'Estados Unidos' }, { id : 5 , name : 'Kelly Adams' , nationality : 'Estados Unidos' }, { id : 6 , name : 'J. Alex Kavern' , nationality : 'Estados Unidos' }, { id : 7 , name : 'Corey Young' , nationality : 'Estados Unidos' }, ], pageable : { pageSize : 5 , pageNumber : 0 , sort : [ { property : \"id\" , direction : \"ASC\" } ] }, totalElements : 7 } import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Pageable } from '../core/model/page/Pageable' ; import { Author } from './model/Author' ; import { AuthorPage } from './model/AuthorPage' ; import { AUTHOR_DATA } from './model/mock-authors' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor () { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return of ( AUTHOR_DATA ); } saveAuthor ( author : Author ) : Observable < void > { return of ( null ); } deleteAuthor ( idAuthor : number ) : Observable < void > { return of ( null ); } } Implementar listado Ya tenemos el servicio con los datos, ahora vamos a por el listado paginado. author-list.component.html author-list.component.scss author-list.component.ts < div class = \"container\" > < h1 > Listado de Autores </ h1 > < mat-table [ dataSource ]=\" dataSource \" > < ng-container matColumnDef = \"id\" > < mat-header-cell * matHeaderCellDef > Identificador </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.id}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"name\" > < mat-header-cell * matHeaderCellDef > Nombre autor </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.name}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"nationality\" > < mat-header-cell * matHeaderCellDef > Nacionalidad </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.nationality}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" ( click )=\" editAuthor ( element )\" > < mat-icon > edit </ mat-icon > </ button > < button mat-icon-button color = \"accent\" ( click )=\" deleteAuthor ( element )\" > < mat-icon > clear </ mat-icon > </ button > </ mat-cell > </ ng-container > < mat-header-row * matHeaderRowDef = \"displayedColumns; sticky: true\" ></ mat-header-row > < mat-row * matRowDef = \"let row; columns: displayedColumns;\" ></ mat-row > </ mat-table > < mat-paginator ( page )=\" loadPage ($ event )\" [ pageSizeOptions ]=\"[ 5 , 10 , 20 ]\" [ pageIndex ]=\" pageNumber \" [ pageSize ]=\" pageSize \" [ length ]=\" totalElements \" showFirstLastButtons ></ mat-paginator > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createAuthor ()\" > Nuevo autor </ button > </ div > </ div > . container { margin : 20 px ; mat-table { margin-top : 10 px ; margin-bottom : 20 px ; .mat-header-row { background-color : #f5f5f5 ; .mat-header-cell { text-transform : uppercase ; font-weight : bold ; color : #838383 ; } } . mat-column-id { flex : 0 0 20 % ; justify-content : center ; } . mat-column-action { flex : 0 0 10 % ; justify-content : center ; } } . buttons { text-align : right ; } } import { Component , OnInit } from '@angular/core' ; import { MatDialog } from '@angular/material/dialog' ; import { PageEvent } from '@angular/material/paginator' ; import { MatTableDataSource } from '@angular/material/table' ; import { DialogConfirmationComponent } from 'src/app/core/dialog-confirmation/dialog-confirmation.component' ; import { Pageable } from 'src/app/core/model/page/Pageable' ; import { AuthorEditComponent } from '../author-edit/author-edit.component' ; import { AuthorService } from '../author.service' ; import { Author } from '../model/Author' ; @Component ({ selector : 'app-author-list' , templateUrl : './author-list.component.html' , styleUrls : [ './author-list.component.scss' ] }) export class AuthorListComponent implements OnInit { pageNumber : number = 0 ; pageSize : number = 5 ; totalElements : number = 0 ; dataSource = new MatTableDataSource < Author > (); displayedColumns : string [] = [ 'id' , 'name' , 'nationality' , 'action' ]; constructor ( private authorService : AuthorService , public dialog : MatDialog , ) { } ngOnInit () : void { this . loadPage (); } loadPage ( event? : PageEvent ) { let pageable : Pageable = { pageNumber : this.pageNumber , pageSize : this.pageSize , sort : [{ property : 'id' , direction : 'ASC' }] } if ( event != null ) { pageable . pageSize = event . pageSize pageable . pageNumber = event . pageIndex ; } this . authorService . getAuthors ( pageable ). subscribe ( data => { this . dataSource . data = data . content ; this . pageNumber = data . pageable . pageNumber ; this . pageSize = data . pageable . pageSize ; this . totalElements = data . totalElements ; }); } createAuthor () { const dialogRef = this . dialog . open ( AuthorEditComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } editAuthor ( author : Author ) { const dialogRef = this . dialog . open ( AuthorEditComponent , { data : { author : author } }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } deleteAuthor ( author : Author ) { const dialogRef = this . dialog . open ( DialogConfirmationComponent , { data : { title : \"Eliminar autor\" , description : \"Atenci\u00f3n si borra el autor se perder\u00e1n sus datos.<br> \u00bfDesea eliminar el autor?\" } }); dialogRef . afterClosed (). subscribe ( result => { if ( result ) { this . authorService . deleteAuthor ( author . id ). subscribe ( result => { this . ngOnInit (); }); } }); } } F\u00edjate como hemos a\u00f1adido la paginaci\u00f3n. Al HTML le hemos a\u00f1adido un componente nuevo mat-paginator , lo que nos va a obligar a a\u00f1adirlo al m\u00f3dulo tambi\u00e9n como dependencia. Ese componente le hemos definido un m\u00e9todo page que se ejecuta cada vez que la p\u00e1gina cambia, y unas propiedades con las que calcular\u00e1 la p\u00e1gina, el tama\u00f1o y el n\u00famero total de p\u00e1ginas. Al Typescript le hemos tenido que a\u00f1adir esas variables y hemos creado un m\u00e9todo para cargar datos que lo que hace es construir un objeto pageable con los valores actuales del componente paginador y lanza la petici\u00f3n con esos datos en el body. Obviamente al ser un mock no funcionar\u00e1 el cambio de p\u00e1gina y dem\u00e1s. Como siempre, a\u00f1adimos las dependencias al m\u00f3dulo, vamos a intentar a\u00f1adir todas las que vamos a necesitar a futuro. author.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { AuthorListComponent } from './author-list/author-list.component' ; import { AuthorEditComponent } from './author-edit/author-edit.component' ; import { MatTableModule } from '@angular/material/table' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; import { MatButtonModule } from '@angular/material/button' ; import { MatDialogModule , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatIconModule } from '@angular/material/icon' ; import { MatInputModule } from '@angular/material/input' ; import { MatPaginatorModule } from '@angular/material/paginator' ; @NgModule ({ declarations : [ AuthorListComponent , AuthorEditComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule , MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , MatPaginatorModule , ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class AuthorModule { } Deber\u00eda verse algo similar a esto: Implementar dialogo edici\u00f3n El \u00faltimo paso, es definir la pantalla de dialogo que realizar\u00e1 el alta y modificado de los datos de un Autor . author-edit.component.html author-edit.component.scss author-edit.component.ts < div class = \"container\" > < h1 * ngIf = \"author.id == null\" > Crear autor </ h1 > < h1 * ngIf = \"author.id != null\" > Modificar autor </ h1 > < form > < mat-form-field > < mat-label > Identificador </ mat-label > < input type = \"text\" matInput placeholder = \"Identificador\" [( ngModel )]=\" author . id \" name = \"id\" disabled > </ mat-form-field > < mat-form-field > < mat-label > Nombre </ mat-label > < input type = \"text\" matInput placeholder = \"Nombre del autor\" [( ngModel )]=\" author . name \" name = \"name\" required > < mat-error > El nombre no puede estar vac\u00edo </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Nacionalidad </ mat-label > < input type = \"text\" matInput placeholder = \"Nacionalidad del autor\" [( ngModel )]=\" author . nationality \" name = \"nationality\" required > < mat-error > La nacionalidad no puede estar vac\u00eda </ mat-error > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onClose ()\" > Cerrar </ button > < button mat-flat-button color = \"primary\" ( click )=\" onSave ()\" > Guardar </ button > </ div > </ div > . container { min-width : 350 px ; max-width : 500 px ; padding : 20 px ; form { display : flex ; flex-direction : column ; margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } import { Component , Inject , OnInit } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { AuthorService } from '../author.service' ; import { Author } from '../model/Author' ; @Component ({ selector : 'app-author-edit' , templateUrl : './author-edit.component.html' , styleUrls : [ './author-edit.component.scss' ] }) export class AuthorEditComponent implements OnInit { author : Author ; constructor ( public dialogRef : MatDialogRef < AuthorEditComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any , private authorService : AuthorService ) { } ngOnInit () : void { if ( this . data . author != null ) { this . author = Object . assign ({}, this . data . author ); } else { this . author = new Author (); } } onSave () { this . authorService . saveAuthor ( this . author ). subscribe ( result => { this . dialogRef . close (); }); } onClose () { this . dialogRef . close (); } } Que deber\u00eda quedar algo as\u00ed: Conectar con Backend Antes de seguir Antes de seguir con este punto, debes implementar el c\u00f3digo de backend en la tecnolog\u00eda que quieras ( Springboot o Nodejs ). Si has empezado este cap\u00edtulo implementando el frontend, por favor accede a la secci\u00f3n correspondiente de backend para poder continuar con el tutorial. Una vez tengas implementadas todas las operaciones para este listado, puedes volver a este punto y continuar con Angular. Una vez implementado front y back, lo que nos queda es modificar el servicio del front para que conecte directamente con las operaciones ofrecidas por el back. author.service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Pageable } from '../core/model/page/Pageable' ; import { Author } from './model/Author' ; import { AuthorPage } from './model/AuthorPage' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor ( private http : HttpClient ) { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return this . http . post < AuthorPage > ( 'http://localhost:8080/author' , { pageable : pageable }); } saveAuthor ( author : Author ) : Observable < void > { let url = 'http://localhost:8080/author' ; if ( author . id != null ) url += '/' + author . id ; return this . http . put < void > ( url , author ); } deleteAuthor ( idAuthor : number ) : Observable < void > { return this . http . delete < void > ( 'http://localhost:8080/author/' + idAuthor ); } }","title":"\ud83d\udd35 Angular"},{"location":"develop/paginated/angular/#listado-paginado-angular","text":"Ya tienes tu primer CRUD desarrollado. \u00bfHa sido sencillo, verdad?. Ahora vamos a implementar un CRUD un poco m\u00e1s complejo, este tiene datos paginados en servidor, esto quiere decir que no nos sirve un array de datos como en el anterior ejemplo. Para que un listado paginado en servidor funcione, el cliente debe enviar en cada petici\u00f3n que p\u00e1gina est\u00e1 solicitando y cual es el tama\u00f1o de la p\u00e1gina, para que el servidor devuelva solamente un subconjunto de datos, en lugar de devolver el listado completo. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.","title":"Listado paginado - Angular"},{"location":"develop/paginated/angular/#crear-modulo-y-componentes","text":"Vamos a desarrollar el listado de Autores as\u00ed que, debemos crear los componentes: ng generate module author ng generate component author/author-list ng generate component author/author-edit ng generate service author/author Este m\u00f3dulo lo vamos a a\u00f1adir a la aplicaci\u00f3n para que se cargue en el arranque. Abrimos el fichero app.module.ts y a\u00f1adimos el m\u00f3dulo: app.module.ts import { NgModule } from '@angular/core' ; import { BrowserModule } from '@angular/platform-browser' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { BrowserAnimationsModule } from '@angular/platform-browser/animations' ; import { CoreModule } from './core/core.module' ; import { CategoryModule } from './category/category.module' ; import { AuthorModule } from './author/author.module' ; @NgModule ({ declarations : [ AppComponent ], imports : [ BrowserModule , AppRoutingModule , CoreModule , CategoryModule , AuthorModule , BrowserAnimationsModule ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { }","title":"Crear modulo y componentes"},{"location":"develop/paginated/angular/#crear-el-modelo","text":"Creamos el modelo en author/model/Author.ts con las propiedades necesarias para trabajar con la informaci\u00f3n de un autor: Author.ts export class Author { id : number ; name : string ; nationality : string ; }","title":"Crear el modelo"},{"location":"develop/paginated/angular/#anadir-el-punto-de-entrada","text":"A\u00f1adimos la ruta al men\u00fa para que podamos acceder a la pantalla: app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { CategoryListComponent } from './category/category-list/category-list.component' ; import { AuthorListComponent } from './author/author-list/author-list.component' ; const routes : Routes = [ { path : 'categories' , component : CategoriesComponent }, { path : 'authors' , component : AuthorListComponent }, ]; @NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { }","title":"A\u00f1adir el punto de entrada"},{"location":"develop/paginated/angular/#implementar-servicio","text":"Y realizamos las diferentes implementaciones. Empezaremos por el servicio. En este caso, hay un cambio sustancial con el anterior ejemplo. Al tratarse de un listado paginado, la operaci\u00f3n getAuthors necesita informaci\u00f3n extra acerca de que p\u00e1gina de datos debe mostrar, adem\u00e1s de que el resultado ya no ser\u00e1 un listado sino una p\u00e1gina. Por defecto el esquema de datos de Spring para la paginaci\u00f3n es como el siguiente: Esquema de datos de paginaci\u00f3n { \"content\" : [ ... <lis ta do co n los resul ta dos pagi na dos> ... ], \"pageable\" : { \"pageNumber\" : < n \u00famero de p\u00e1gi na empeza n do por 0 > , \"pageSize\" : < ta ma\u00f1o de p\u00e1gi na > , \"sort\" : [ { \"property\" : < n ombre de la propiedad a orde nar > , \"direction\" : <direcci\u00f3 n de la orde na ci\u00f3 n ASC / DESC> } ] }, \"totalElements\" : < nu mero t o tal de eleme nt os e n la ta bla> } As\u00ed que necesitamos poder enviar y recuperar esa informaci\u00f3n desde Angular, nos hace falta crear esos objetos. Los objetos de paginaci\u00f3n al ser comunes a toda la aplicaci\u00f3n, vamos a crearlos en core/model/page , mientras que la paginaci\u00f3n de AuthorPage.ts la crear\u00e9 en su propio model dentro de author/model . SortPage.ts Pageable.ts AuthorPage.ts export class SortPage { property : String ; direction : String ; } import { SortPage } from './SortPage' ; export class Pageable { pageNumber : number ; pageSize : number ; sort : SortPage []; } import { Pageable } from \"src/app/core/model/page/Pageable\" ; import { Author } from \"./Author\" ; export class AuthorPage { content : Author []; pageable : Pageable ; totalElements : number ; } Con estos objetos creados ya podemos implementar el servicio y sus datos mockeados. mock-authors.ts author.service.ts import { AuthorPage } from \"./AuthorPage\" ; export const AUTHOR_DATA : AuthorPage = { content : [ { id : 1 , name : 'Klaus Teuber' , nationality : 'Alemania' }, { id : 2 , name : 'Matt Leacock' , nationality : 'Estados Unidos' }, { id : 3 , name : 'Keng Leong Yeo' , nationality : 'Singapur' }, { id : 4 , name : 'Gil Hova' , nationality : 'Estados Unidos' }, { id : 5 , name : 'Kelly Adams' , nationality : 'Estados Unidos' }, { id : 6 , name : 'J. Alex Kavern' , nationality : 'Estados Unidos' }, { id : 7 , name : 'Corey Young' , nationality : 'Estados Unidos' }, ], pageable : { pageSize : 5 , pageNumber : 0 , sort : [ { property : \"id\" , direction : \"ASC\" } ] }, totalElements : 7 } import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Pageable } from '../core/model/page/Pageable' ; import { Author } from './model/Author' ; import { AuthorPage } from './model/AuthorPage' ; import { AUTHOR_DATA } from './model/mock-authors' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor () { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return of ( AUTHOR_DATA ); } saveAuthor ( author : Author ) : Observable < void > { return of ( null ); } deleteAuthor ( idAuthor : number ) : Observable < void > { return of ( null ); } }","title":"Implementar servicio"},{"location":"develop/paginated/angular/#implementar-listado","text":"Ya tenemos el servicio con los datos, ahora vamos a por el listado paginado. author-list.component.html author-list.component.scss author-list.component.ts < div class = \"container\" > < h1 > Listado de Autores </ h1 > < mat-table [ dataSource ]=\" dataSource \" > < ng-container matColumnDef = \"id\" > < mat-header-cell * matHeaderCellDef > Identificador </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.id}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"name\" > < mat-header-cell * matHeaderCellDef > Nombre autor </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.name}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"nationality\" > < mat-header-cell * matHeaderCellDef > Nacionalidad </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.nationality}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" ( click )=\" editAuthor ( element )\" > < mat-icon > edit </ mat-icon > </ button > < button mat-icon-button color = \"accent\" ( click )=\" deleteAuthor ( element )\" > < mat-icon > clear </ mat-icon > </ button > </ mat-cell > </ ng-container > < mat-header-row * matHeaderRowDef = \"displayedColumns; sticky: true\" ></ mat-header-row > < mat-row * matRowDef = \"let row; columns: displayedColumns;\" ></ mat-row > </ mat-table > < mat-paginator ( page )=\" loadPage ($ event )\" [ pageSizeOptions ]=\"[ 5 , 10 , 20 ]\" [ pageIndex ]=\" pageNumber \" [ pageSize ]=\" pageSize \" [ length ]=\" totalElements \" showFirstLastButtons ></ mat-paginator > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createAuthor ()\" > Nuevo autor </ button > </ div > </ div > . container { margin : 20 px ; mat-table { margin-top : 10 px ; margin-bottom : 20 px ; .mat-header-row { background-color : #f5f5f5 ; .mat-header-cell { text-transform : uppercase ; font-weight : bold ; color : #838383 ; } } . mat-column-id { flex : 0 0 20 % ; justify-content : center ; } . mat-column-action { flex : 0 0 10 % ; justify-content : center ; } } . buttons { text-align : right ; } } import { Component , OnInit } from '@angular/core' ; import { MatDialog } from '@angular/material/dialog' ; import { PageEvent } from '@angular/material/paginator' ; import { MatTableDataSource } from '@angular/material/table' ; import { DialogConfirmationComponent } from 'src/app/core/dialog-confirmation/dialog-confirmation.component' ; import { Pageable } from 'src/app/core/model/page/Pageable' ; import { AuthorEditComponent } from '../author-edit/author-edit.component' ; import { AuthorService } from '../author.service' ; import { Author } from '../model/Author' ; @Component ({ selector : 'app-author-list' , templateUrl : './author-list.component.html' , styleUrls : [ './author-list.component.scss' ] }) export class AuthorListComponent implements OnInit { pageNumber : number = 0 ; pageSize : number = 5 ; totalElements : number = 0 ; dataSource = new MatTableDataSource < Author > (); displayedColumns : string [] = [ 'id' , 'name' , 'nationality' , 'action' ]; constructor ( private authorService : AuthorService , public dialog : MatDialog , ) { } ngOnInit () : void { this . loadPage (); } loadPage ( event? : PageEvent ) { let pageable : Pageable = { pageNumber : this.pageNumber , pageSize : this.pageSize , sort : [{ property : 'id' , direction : 'ASC' }] } if ( event != null ) { pageable . pageSize = event . pageSize pageable . pageNumber = event . pageIndex ; } this . authorService . getAuthors ( pageable ). subscribe ( data => { this . dataSource . data = data . content ; this . pageNumber = data . pageable . pageNumber ; this . pageSize = data . pageable . pageSize ; this . totalElements = data . totalElements ; }); } createAuthor () { const dialogRef = this . dialog . open ( AuthorEditComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } editAuthor ( author : Author ) { const dialogRef = this . dialog . open ( AuthorEditComponent , { data : { author : author } }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } deleteAuthor ( author : Author ) { const dialogRef = this . dialog . open ( DialogConfirmationComponent , { data : { title : \"Eliminar autor\" , description : \"Atenci\u00f3n si borra el autor se perder\u00e1n sus datos.<br> \u00bfDesea eliminar el autor?\" } }); dialogRef . afterClosed (). subscribe ( result => { if ( result ) { this . authorService . deleteAuthor ( author . id ). subscribe ( result => { this . ngOnInit (); }); } }); } } F\u00edjate como hemos a\u00f1adido la paginaci\u00f3n. Al HTML le hemos a\u00f1adido un componente nuevo mat-paginator , lo que nos va a obligar a a\u00f1adirlo al m\u00f3dulo tambi\u00e9n como dependencia. Ese componente le hemos definido un m\u00e9todo page que se ejecuta cada vez que la p\u00e1gina cambia, y unas propiedades con las que calcular\u00e1 la p\u00e1gina, el tama\u00f1o y el n\u00famero total de p\u00e1ginas. Al Typescript le hemos tenido que a\u00f1adir esas variables y hemos creado un m\u00e9todo para cargar datos que lo que hace es construir un objeto pageable con los valores actuales del componente paginador y lanza la petici\u00f3n con esos datos en el body. Obviamente al ser un mock no funcionar\u00e1 el cambio de p\u00e1gina y dem\u00e1s. Como siempre, a\u00f1adimos las dependencias al m\u00f3dulo, vamos a intentar a\u00f1adir todas las que vamos a necesitar a futuro. author.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { AuthorListComponent } from './author-list/author-list.component' ; import { AuthorEditComponent } from './author-edit/author-edit.component' ; import { MatTableModule } from '@angular/material/table' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; import { MatButtonModule } from '@angular/material/button' ; import { MatDialogModule , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatIconModule } from '@angular/material/icon' ; import { MatInputModule } from '@angular/material/input' ; import { MatPaginatorModule } from '@angular/material/paginator' ; @NgModule ({ declarations : [ AuthorListComponent , AuthorEditComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule , MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , MatPaginatorModule , ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class AuthorModule { } Deber\u00eda verse algo similar a esto:","title":"Implementar listado"},{"location":"develop/paginated/angular/#implementar-dialogo-edicion","text":"El \u00faltimo paso, es definir la pantalla de dialogo que realizar\u00e1 el alta y modificado de los datos de un Autor . author-edit.component.html author-edit.component.scss author-edit.component.ts < div class = \"container\" > < h1 * ngIf = \"author.id == null\" > Crear autor </ h1 > < h1 * ngIf = \"author.id != null\" > Modificar autor </ h1 > < form > < mat-form-field > < mat-label > Identificador </ mat-label > < input type = \"text\" matInput placeholder = \"Identificador\" [( ngModel )]=\" author . id \" name = \"id\" disabled > </ mat-form-field > < mat-form-field > < mat-label > Nombre </ mat-label > < input type = \"text\" matInput placeholder = \"Nombre del autor\" [( ngModel )]=\" author . name \" name = \"name\" required > < mat-error > El nombre no puede estar vac\u00edo </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Nacionalidad </ mat-label > < input type = \"text\" matInput placeholder = \"Nacionalidad del autor\" [( ngModel )]=\" author . nationality \" name = \"nationality\" required > < mat-error > La nacionalidad no puede estar vac\u00eda </ mat-error > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onClose ()\" > Cerrar </ button > < button mat-flat-button color = \"primary\" ( click )=\" onSave ()\" > Guardar </ button > </ div > </ div > . container { min-width : 350 px ; max-width : 500 px ; padding : 20 px ; form { display : flex ; flex-direction : column ; margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } import { Component , Inject , OnInit } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { AuthorService } from '../author.service' ; import { Author } from '../model/Author' ; @Component ({ selector : 'app-author-edit' , templateUrl : './author-edit.component.html' , styleUrls : [ './author-edit.component.scss' ] }) export class AuthorEditComponent implements OnInit { author : Author ; constructor ( public dialogRef : MatDialogRef < AuthorEditComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any , private authorService : AuthorService ) { } ngOnInit () : void { if ( this . data . author != null ) { this . author = Object . assign ({}, this . data . author ); } else { this . author = new Author (); } } onSave () { this . authorService . saveAuthor ( this . author ). subscribe ( result => { this . dialogRef . close (); }); } onClose () { this . dialogRef . close (); } } Que deber\u00eda quedar algo as\u00ed:","title":"Implementar dialogo edici\u00f3n"},{"location":"develop/paginated/angular/#conectar-con-backend","text":"Antes de seguir Antes de seguir con este punto, debes implementar el c\u00f3digo de backend en la tecnolog\u00eda que quieras ( Springboot o Nodejs ). Si has empezado este cap\u00edtulo implementando el frontend, por favor accede a la secci\u00f3n correspondiente de backend para poder continuar con el tutorial. Una vez tengas implementadas todas las operaciones para este listado, puedes volver a este punto y continuar con Angular. Una vez implementado front y back, lo que nos queda es modificar el servicio del front para que conecte directamente con las operaciones ofrecidas por el back. author.service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Pageable } from '../core/model/page/Pageable' ; import { Author } from './model/Author' ; import { AuthorPage } from './model/AuthorPage' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor ( private http : HttpClient ) { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return this . http . post < AuthorPage > ( 'http://localhost:8080/author' , { pageable : pageable }); } saveAuthor ( author : Author ) : Observable < void > { let url = 'http://localhost:8080/author' ; if ( author . id != null ) url += '/' + author . id ; return this . http . put < void > ( url , author ); } deleteAuthor ( idAuthor : number ) : Observable < void > { return this . http . delete < void > ( 'http://localhost:8080/author/' + idAuthor ); } }","title":"Conectar con Backend"},{"location":"develop/paginated/nodejs/","text":"Listado paginado - Nodejs Ahora vamos a implementar las operaciones necesarias para ayudar al front a cubrir la funcionalidad del CRUD paginado en servidor. Recuerda que para que un listado paginado en servidor funcione, el cliente debe enviar en cada petici\u00f3n que p\u00e1gina est\u00e1 solicitando y cual es el tama\u00f1o de la p\u00e1gina, para que el servidor devuelva solamente un subconjunto de datos, en lugar de devolver el listado completo. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades. Crear modelos Lo primero que vamos a hacer es crear el modelo de author para trabajar con BBDD. En la carpeta schemas creamos el archivo author.schema.js : author.schema.js import mongoose from \"mongoose\" ; import normalize from 'normalize-mongoose' ; import mongoosePaginate from 'mongoose-paginate-v2' ; const { Schema , model } = mongoose ; const authorSchema = new Schema ({ name : { type : String , require : true }, nationality : { type : String , require : true } }); authorSchema . plugin ( normalize ); authorSchema . plugin ( mongoosePaginate ); const AuthorModel = model ( 'Author' , authorSchema ); export default AuthorModel ; Implementar el Service Creamos el service correspondiente author.service.js : author.service.js import AuthorModel from '../schemas/author.schema.js' ; export const getAuthors = async () => { try { return await AuthorModel . find (). sort ( 'id' ); } catch ( e ) { throw Error ( 'Error fetching authors' ); } } export const createAuthor = async ( data ) => { const { name , nationality } = data ; try { const author = new AuthorModel ({ name , nationality }); return await author . save (); } catch ( e ) { throw Error ( 'Error creating author' ); } } export const updateAuthor = async ( id , data ) => { try { const author = await AuthorModel . findById ( id ); if ( ! author ) { throw Error ( 'There is no author with that Id' ); } return await AuthorModel . findByIdAndUpdate ( id , data ); } catch ( e ) { throw Error ( e ); } } export const deleteAuthor = async ( id ) => { try { const author = await AuthorModel . findById ( id ); if ( ! author ) { throw Error ( 'There is no author with that Id' ); } return await AuthorModel . findByIdAndDelete ( id ); } catch ( e ) { throw Error ( e ); } } export const getAuthorsPageable = async ( page , limit , sort ) => { const sortObj = { [ sort ? . property || 'name' ] : sort ? . direction === 'DESC' ? 'DESC' : 'ASC' }; try { const options = { page : parseInt ( page ) + 1 , limit , sort : sortObj }; return await AuthorModel . paginate ({}, options ); } catch ( e ) { throw Error ( 'Error fetching authors page' ); } } Como podemos observar es muy parecido al servicio de categor\u00edas, pero hemos incluido un nuevo m\u00e9todo getAuthorsPageable . Este m\u00e9todo tendr\u00e1 como par\u00e1metros de entrada la p\u00e1gina que queramos mostrar, el tama\u00f1o de esta y las propiedades de ordenaci\u00f3n. Moongose nos proporciona el m\u00e9todo paginate que es muy parecido a find salvo que adem\u00e1s podemos pasar las opciones de paginaci\u00f3n y el solo realizar\u00e1 todo el trabajo. Implementar el Controller Creamos el controlador author.controller.js : author.controller.js import * as AuthorService from '../services/author.service.js' ; export const getAuthors = async ( req , res ) => { try { const authors = await AuthorService . getAuthors (); res . status ( 200 ). json ( authors ); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } export const createAuthor = async ( req , res ) => { try { const author = await AuthorService . createAuthor ( req . body ); res . status ( 200 ). json ({ author }); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } export const updateAuthor = async ( req , res ) => { const authorId = req . params . id ; try { await AuthorService . updateAuthor ( authorId , req . body ); res . status ( 200 ). json ( 1 ); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } export const deleteAuthor = async ( req , res ) => { const authorId = req . params . id ; try { const deletedAuthor = await AuthorService . deleteAuthor ( authorId ); res . status ( 200 ). json ({ author : deletedAuthor }); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } export const getAuthorsPageable = async ( req , res ) => { const page = req . body . pageable . pageNumber || 0 ; const limit = req . body . pageable . pageSize || 5 ; const sort = req . body . pageable . sort || null ; try { const response = await AuthorService . getAuthorsPageable ( page , limit , sort ); res . status ( 200 ). json ({ content : response . docs , pageable : { pageNumber : response . page - 1 , pageSize : response . limit }, totalElements : response . totalDocs }); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } Y vemos que el m\u00e9todo getAuthorsPageable lee los datos de la request, se los pasa al servicio y por \u00faltimo transforma la response con los datos obtenidos. Implementar las Rutas Creamos nuestro archivo de rutas author.routes.js : author.routes.js import { Router } from 'express' ; import { check } from 'express-validator' ; import validateFields from '../middlewares/validateFields.js' ; import { createAuthor , deleteAuthor , getAuthors , updateAuthor , getAuthorsPageable } from '../controllers/author.controller.js' ; const authorRouter = Router (); authorRouter . put ( '/:id' , [ check ( 'name' ). not (). isEmpty (), check ( 'nationality' ). not (). isEmpty (), validateFields ], updateAuthor ); authorRouter . put ( '/' , [ check ( 'name' ). not (). isEmpty (), check ( 'nationality' ). not (). isEmpty (), validateFields ], createAuthor ); authorRouter . get ( '/' , getAuthors ); authorRouter . delete ( '/:id' , deleteAuthor ); authorRouter . post ( '/' , [ check ( 'pageable' ). not (). isEmpty (), check ( 'pageable.pageSize' ). not (). isEmpty (), check ( 'pageable.pageNumber' ). not (). isEmpty (), validateFields ], getAuthorsPageable ) export default authorRouter ; Podemos observar que si hacemos una petici\u00f3n con get a /author nos devolver\u00e1 todos los autores. Pero si hacemos una petici\u00f3n post con el objeto pageable en el body realizaremos el listado paginado. Finalmente en nuestro archivo index.js vamos a a\u00f1adir el nuevo router: index.js ... import authorRouter from './src/routes/author.routes.js' ; ... app . use ( '/author' , authorRouter ); ... Probar las operaciones Y ahora que tenemos todo creado, ya podemos probarlo con Postman: Por un lado creamos autores con: PUT /author PUT /author/{id} { \"name\" : \"Nuevo autor\" , \"nationality\" : \"Nueva nacionalidad\" } Nos sirve para insertar Autores nuevas (si no tienen el id informado) o para actualizar Autores (si tienen el id informado en la URL). F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no te dar\u00e1 un error. DELETE /author/{id} nos sirve eliminar Autores . F\u00edjate que el dato del ID que se env\u00eda est\u00e1 en el path. Luego recuperamos los autores con el m\u00e9todo GET (antes tienes que crear unos cuantos para poder ver un listado): Y por \u00faltimo listamos los autores paginados: POST /author { \"pageable\" : { \"pageSize\" : 4 , \"pageNumber\" : 0 , \"sort\" : [ { \"property\" : \"name\" , \"direction\" : \"ASC\" } ] } }","title":"\ud83d\udfe2 Nodejs"},{"location":"develop/paginated/nodejs/#listado-paginado-nodejs","text":"Ahora vamos a implementar las operaciones necesarias para ayudar al front a cubrir la funcionalidad del CRUD paginado en servidor. Recuerda que para que un listado paginado en servidor funcione, el cliente debe enviar en cada petici\u00f3n que p\u00e1gina est\u00e1 solicitando y cual es el tama\u00f1o de la p\u00e1gina, para que el servidor devuelva solamente un subconjunto de datos, en lugar de devolver el listado completo. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.","title":"Listado paginado - Nodejs"},{"location":"develop/paginated/nodejs/#crear-modelos","text":"Lo primero que vamos a hacer es crear el modelo de author para trabajar con BBDD. En la carpeta schemas creamos el archivo author.schema.js : author.schema.js import mongoose from \"mongoose\" ; import normalize from 'normalize-mongoose' ; import mongoosePaginate from 'mongoose-paginate-v2' ; const { Schema , model } = mongoose ; const authorSchema = new Schema ({ name : { type : String , require : true }, nationality : { type : String , require : true } }); authorSchema . plugin ( normalize ); authorSchema . plugin ( mongoosePaginate ); const AuthorModel = model ( 'Author' , authorSchema ); export default AuthorModel ;","title":"Crear modelos"},{"location":"develop/paginated/nodejs/#implementar-el-service","text":"Creamos el service correspondiente author.service.js : author.service.js import AuthorModel from '../schemas/author.schema.js' ; export const getAuthors = async () => { try { return await AuthorModel . find (). sort ( 'id' ); } catch ( e ) { throw Error ( 'Error fetching authors' ); } } export const createAuthor = async ( data ) => { const { name , nationality } = data ; try { const author = new AuthorModel ({ name , nationality }); return await author . save (); } catch ( e ) { throw Error ( 'Error creating author' ); } } export const updateAuthor = async ( id , data ) => { try { const author = await AuthorModel . findById ( id ); if ( ! author ) { throw Error ( 'There is no author with that Id' ); } return await AuthorModel . findByIdAndUpdate ( id , data ); } catch ( e ) { throw Error ( e ); } } export const deleteAuthor = async ( id ) => { try { const author = await AuthorModel . findById ( id ); if ( ! author ) { throw Error ( 'There is no author with that Id' ); } return await AuthorModel . findByIdAndDelete ( id ); } catch ( e ) { throw Error ( e ); } } export const getAuthorsPageable = async ( page , limit , sort ) => { const sortObj = { [ sort ? . property || 'name' ] : sort ? . direction === 'DESC' ? 'DESC' : 'ASC' }; try { const options = { page : parseInt ( page ) + 1 , limit , sort : sortObj }; return await AuthorModel . paginate ({}, options ); } catch ( e ) { throw Error ( 'Error fetching authors page' ); } } Como podemos observar es muy parecido al servicio de categor\u00edas, pero hemos incluido un nuevo m\u00e9todo getAuthorsPageable . Este m\u00e9todo tendr\u00e1 como par\u00e1metros de entrada la p\u00e1gina que queramos mostrar, el tama\u00f1o de esta y las propiedades de ordenaci\u00f3n. Moongose nos proporciona el m\u00e9todo paginate que es muy parecido a find salvo que adem\u00e1s podemos pasar las opciones de paginaci\u00f3n y el solo realizar\u00e1 todo el trabajo.","title":"Implementar el Service"},{"location":"develop/paginated/nodejs/#implementar-el-controller","text":"Creamos el controlador author.controller.js : author.controller.js import * as AuthorService from '../services/author.service.js' ; export const getAuthors = async ( req , res ) => { try { const authors = await AuthorService . getAuthors (); res . status ( 200 ). json ( authors ); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } export const createAuthor = async ( req , res ) => { try { const author = await AuthorService . createAuthor ( req . body ); res . status ( 200 ). json ({ author }); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } export const updateAuthor = async ( req , res ) => { const authorId = req . params . id ; try { await AuthorService . updateAuthor ( authorId , req . body ); res . status ( 200 ). json ( 1 ); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } export const deleteAuthor = async ( req , res ) => { const authorId = req . params . id ; try { const deletedAuthor = await AuthorService . deleteAuthor ( authorId ); res . status ( 200 ). json ({ author : deletedAuthor }); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } export const getAuthorsPageable = async ( req , res ) => { const page = req . body . pageable . pageNumber || 0 ; const limit = req . body . pageable . pageSize || 5 ; const sort = req . body . pageable . sort || null ; try { const response = await AuthorService . getAuthorsPageable ( page , limit , sort ); res . status ( 200 ). json ({ content : response . docs , pageable : { pageNumber : response . page - 1 , pageSize : response . limit }, totalElements : response . totalDocs }); } catch ( err ) { res . status ( 400 ). json ({ msg : err . toString () }); } } Y vemos que el m\u00e9todo getAuthorsPageable lee los datos de la request, se los pasa al servicio y por \u00faltimo transforma la response con los datos obtenidos.","title":"Implementar el Controller"},{"location":"develop/paginated/nodejs/#implementar-las-rutas","text":"Creamos nuestro archivo de rutas author.routes.js : author.routes.js import { Router } from 'express' ; import { check } from 'express-validator' ; import validateFields from '../middlewares/validateFields.js' ; import { createAuthor , deleteAuthor , getAuthors , updateAuthor , getAuthorsPageable } from '../controllers/author.controller.js' ; const authorRouter = Router (); authorRouter . put ( '/:id' , [ check ( 'name' ). not (). isEmpty (), check ( 'nationality' ). not (). isEmpty (), validateFields ], updateAuthor ); authorRouter . put ( '/' , [ check ( 'name' ). not (). isEmpty (), check ( 'nationality' ). not (). isEmpty (), validateFields ], createAuthor ); authorRouter . get ( '/' , getAuthors ); authorRouter . delete ( '/:id' , deleteAuthor ); authorRouter . post ( '/' , [ check ( 'pageable' ). not (). isEmpty (), check ( 'pageable.pageSize' ). not (). isEmpty (), check ( 'pageable.pageNumber' ). not (). isEmpty (), validateFields ], getAuthorsPageable ) export default authorRouter ; Podemos observar que si hacemos una petici\u00f3n con get a /author nos devolver\u00e1 todos los autores. Pero si hacemos una petici\u00f3n post con el objeto pageable en el body realizaremos el listado paginado. Finalmente en nuestro archivo index.js vamos a a\u00f1adir el nuevo router: index.js ... import authorRouter from './src/routes/author.routes.js' ; ... app . use ( '/author' , authorRouter ); ...","title":"Implementar las Rutas"},{"location":"develop/paginated/nodejs/#probar-las-operaciones","text":"Y ahora que tenemos todo creado, ya podemos probarlo con Postman: Por un lado creamos autores con: PUT /author PUT /author/{id} { \"name\" : \"Nuevo autor\" , \"nationality\" : \"Nueva nacionalidad\" } Nos sirve para insertar Autores nuevas (si no tienen el id informado) o para actualizar Autores (si tienen el id informado en la URL). F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no te dar\u00e1 un error. DELETE /author/{id} nos sirve eliminar Autores . F\u00edjate que el dato del ID que se env\u00eda est\u00e1 en el path. Luego recuperamos los autores con el m\u00e9todo GET (antes tienes que crear unos cuantos para poder ver un listado): Y por \u00faltimo listamos los autores paginados: POST /author { \"pageable\" : { \"pageSize\" : 4 , \"pageNumber\" : 0 , \"sort\" : [ { \"property\" : \"name\" , \"direction\" : \"ASC\" } ] } }","title":"Probar las operaciones"},{"location":"develop/paginated/springboot/","text":"Listado paginado - Spring Boot Ahora vamos a implementar las operaciones necesarias para ayudar al front a cubrir la funcionalidad del CRUD paginado en servidor. Recuerda que para que un listado paginado en servidor funcione, el cliente debe enviar en cada petici\u00f3n que p\u00e1gina est\u00e1 solicitando y cu\u00e1l es el tama\u00f1o de la p\u00e1gina, para que el servidor devuelva solamente un subconjunto de datos, en lugar de devolver el listado completo. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades. Crear modelos Lo primero que vamos a hacer es crear los modelos para trabajar con BBDD y con peticiones hacia el front. Adem\u00e1s, tambi\u00e9n tenemos que a\u00f1adir datos al script de inicializaci\u00f3n de BBDD, siempre respetando la nomenclatura que le hemos dado a la tabla y columnas de BBDD. Author.java AuthorDto.java data.sql package com.ccsw.tutorial.author.model ; import jakarta.persistence.* ; /** * @author ccsw * */ @Entity @Table ( name = \"author\" ) public class Author { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"name\" , nullable = false ) private String name ; @Column ( name = \"nationality\" ) private String nationality ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } /** * @return nationality */ public String getNationality () { return this . nationality ; } /** * @param nationality new value of {@link #getNationality}. */ public void setNationality ( String nationality ) { this . nationality = nationality ; } } package com.ccsw.tutorial.author.model ; /** * @author ccsw * */ public class AuthorDto { private Long id ; private String name ; private String nationality ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } /** * @return nationality */ public String getNationality () { return this . nationality ; } /** * @param nationality new value of {@link #getNationality}. */ public void setNationality ( String nationality ) { this . nationality = nationality ; } } INSERT INTO category ( name ) VALUES ( 'Eurogames' ); INSERT INTO category ( name ) VALUES ( 'Ameritrash' ); INSERT INTO category ( name ) VALUES ( 'Familiar' ); INSERT INTO author ( name , nationality ) VALUES ( 'Alan R. Moon' , 'US' ); INSERT INTO author ( name , nationality ) VALUES ( 'Vital Lacerda' , 'PT' ); INSERT INTO author ( name , nationality ) VALUES ( 'Simone Luciani' , 'IT' ); INSERT INTO author ( name , nationality ) VALUES ( 'Perepau Llistosella' , 'ES' ); INSERT INTO author ( name , nationality ) VALUES ( 'Michael Kiesling' , 'DE' ); INSERT INTO author ( name , nationality ) VALUES ( 'Phil Walker-Harding' , 'US' ); Implementar TDD - Pruebas Para desarrollar todas las operaciones, empezaremos primero dise\u00f1ando las pruebas y luego implementando el c\u00f3digo necesario que haga funcionar correctamente esas pruebas. Para ir m\u00e1s r\u00e1pido vamos a poner todas las pruebas de golpe, pero realmente se deber\u00edan crear una a una e ir implementando el c\u00f3digo necesario para esa prueba. Para evitar tantas iteraciones en el tutorial las haremos todas de golpe. Vamos a pararnos a pensar un poco que necesitamos en la pantalla. Ahora mismo nos sirve con: Una consulta paginada, que reciba datos de la p\u00e1gina a consultar y devuelva los datos paginados Una operaci\u00f3n de guardado y modificaci\u00f3n Una operaci\u00f3n de borrado Para la primera prueba que hemos descrito (consulta paginada) se necesita un objeto que contenga los datos de la p\u00e1gina a consultar. As\u00ed que crearemos una clase AuthorSearchDto para utilizarlo como 'paginador'. Para ello, en primer lugar, deberemos a\u00f1adir una clase que vamos a utilizar como envoltorio para las peticiones de paginaci\u00f3n en el proyecto. Hacemos esto para desacoplar la interface de Spring Boot de nuestro contrato de entrada. Crearemos esta clase en el paquete com.ccsw.tutorial.common.pagination . PageableRequest.java package com.ccsw.tutorial.common.pagination ; import com.fasterxml.jackson.annotation.JsonIgnore ; import org.springframework.data.domain.* ; import java.io.Serializable ; import java.util.ArrayList ; import java.util.List ; import java.util.stream.Collectors ; public class PageableRequest implements Serializable { private static final long serialVersionUID = 1L ; private int pageNumber ; private int pageSize ; private List < SortRequest > sort ; public PageableRequest () { sort = new ArrayList <> (); } public PageableRequest ( int pageNumber , int pageSize ) { this (); this . pageNumber = pageNumber ; this . pageSize = pageSize ; } public PageableRequest ( int pageNumber , int pageSize , List < SortRequest > sort ) { this (); this . pageNumber = pageNumber ; this . pageSize = pageSize ; this . sort = sort ; } public int getPageNumber () { return pageNumber ; } public void setPageNumber ( int pageNumber ) { this . pageNumber = pageNumber ; } public int getPageSize () { return pageSize ; } public void setPageSize ( int pageSize ) { this . pageSize = pageSize ; } public List < SortRequest > getSort () { return sort ; } public void setSort ( List < SortRequest > sort ) { this . sort = sort ; } @JsonIgnore public Pageable getPageable () { return PageRequest . of ( this . pageNumber , this . pageSize , Sort . by ( sort . stream (). map ( e -> new Sort . Order ( e . getDirection (), e . getProperty ())). collect ( Collectors . toList ()))); } public static class SortRequest implements Serializable { private static final long serialVersionUID = 1L ; private String property ; private Sort . Direction direction ; protected String getProperty () { return property ; } protected void setProperty ( String property ) { this . property = property ; } protected Sort . Direction getDirection () { return direction ; } protected void setDirection ( Sort . Direction direction ) { this . direction = direction ; } } } Adicionalmente necesitaremos una clase para deserializar las respuestas de Page recibidas en los test que vamos a implementar. Para ello creamos la clase necesaria dentro de la fuente de la carpeta de los test en el paquete com.ccsw.tutorial.config . Esto solo hace falta porque necesitamos leer la respuesta paginada en el test, si no hicieramos test, no har\u00eda falta. ResponsePage.java package com.ccsw.tutorial.config ; import com.fasterxml.jackson.annotation.JsonCreator ; import com.fasterxml.jackson.annotation.JsonIgnoreProperties ; import com.fasterxml.jackson.annotation.JsonProperty ; import com.fasterxml.jackson.databind.JsonNode ; import org.springframework.data.domain.PageImpl ; import org.springframework.data.domain.PageRequest ; import org.springframework.data.domain.Pageable ; import java.util.ArrayList ; import java.util.List ; @JsonIgnoreProperties ( ignoreUnknown = true ) public class ResponsePage < T > extends PageImpl < T > { private static final long serialVersionUID = 1L ; @JsonCreator ( mode = JsonCreator . Mode . PROPERTIES ) public ResponsePage ( @JsonProperty ( \"content\" ) List < T > content , @JsonProperty ( \"number\" ) int number , @JsonProperty ( \"size\" ) int size , @JsonProperty ( \"totalElements\" ) Long totalElements , @JsonProperty ( \"pageable\" ) JsonNode pageable , @JsonProperty ( \"last\" ) boolean last , @JsonProperty ( \"totalPages\" ) int totalPages , @JsonProperty ( \"sort\" ) JsonNode sort , @JsonProperty ( \"first\" ) boolean first , @JsonProperty ( \"numberOfElements\" ) int numberOfElements ) { super ( content , PageRequest . of ( number , size ), totalElements ); } public ResponsePage ( List < T > content , Pageable pageable , long total ) { super ( content , pageable , total ); } public ResponsePage ( List < T > content ) { super ( content ); } public ResponsePage () { super ( new ArrayList <> ()); } } Paginaci\u00f3n en Springframework Cuando utilicemos paginaci\u00f3n en Springframework, debemos recordar que ya vienen implementados algunos objetos que podemos utilizar y que nos facilitan la vida. Es el caso de Pageable y Page . El objeto Pageable no es m\u00e1s que una interface que le permite a Spring JPA saber que p\u00e1gina se quiere buscar, cual es el tama\u00f1o de p\u00e1gina y cuales son las propiedades de ordenaci\u00f3n que se debe lanzar en la consulta. El objeto PageRequest es una utilidad que permite crear objetos de tipo Pageable de forma sencilla. Se utiliza mucho para codificaci\u00f3n de test. El objeto Page no es m\u00e1s que un contenedor que engloba la informaci\u00f3n b\u00e1sica de la p\u00e1gina que se est\u00e1 consultando (n\u00famero de p\u00e1gina, tama\u00f1o de p\u00e1gina, n\u00famero total de resultados) y el conjunto de datos de la BBDD que contiene esa p\u00e1gina una vez han sido buscados y ordenados. Tambi\u00e9n crearemos una clase AuthorController dentro del package de com.ccsw.tutorial.author con la implementaci\u00f3n de los m\u00e9todos vac\u00edos, para que no falle la compilaci\u00f3n. \u00a1Vamos a implementar test! AuthorSearchDto.java AuthorController.java AuthorIT.java package com.ccsw.tutorial.author.model ; import com.ccsw.tutorial.common.pagination.PageableRequest ; /** * @author ccsw * */ public class AuthorSearchDto { private PageableRequest pageable ; public PageableRequest getPageable () { return pageable ; } public void setPageable ( PageableRequest pageable ) { this . pageable = pageable ; } } package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.Author ; import com.ccsw.tutorial.author.model.AuthorDto ; import com.ccsw.tutorial.author.model.AuthorSearchDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; import org.springframework.data.domain.Page ; import org.springframework.web.bind.annotation.* ; /** * @author ccsw * */ @Tag ( name = \"Author\" , description = \"API of Author\" ) @RequestMapping ( value = \"/author\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class AuthorController { /** * M\u00e9todo para recuperar un listado paginado de {@link Author} * * @param dto dto de b\u00fasqueda * @return {@link Page} de {@link AuthorDto} */ @Operation ( summary = \"Find Page\" , description = \"Method that return a page of Authors\" ) @RequestMapping ( path = \"\" , method = RequestMethod . POST ) public Page < AuthorDto > findPage ( @RequestBody AuthorSearchDto dto ) { return null ; } /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Author\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody AuthorDto dto ) { } /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad */ @Operation ( summary = \"Delete\" , description = \"Method that deletes a Author\" ) @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) throws Exception { } } package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.AuthorDto ; import com.ccsw.tutorial.author.model.AuthorSearchDto ; import com.ccsw.tutorial.common.pagination.PageableRequest ; import com.ccsw.tutorial.config.ResponsePage ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.boot.test.web.client.TestRestTemplate ; import org.springframework.boot.test.web.server.LocalServerPort ; import org.springframework.core.ParameterizedTypeReference ; import org.springframework.http.* ; import org.springframework.test.annotation.DirtiesContext ; import java.util.List ; import static org.junit.jupiter.api.Assertions.assertEquals ; import static org.junit.jupiter.api.Assertions.assertNotNull ; @SpringBootTest ( webEnvironment = SpringBootTest . WebEnvironment . RANDOM_PORT ) @DirtiesContext ( classMode = DirtiesContext . ClassMode . BEFORE_EACH_TEST_METHOD ) public class AuthorIT { public static final String LOCALHOST = \"http://localhost:\" ; public static final String SERVICE_PATH = \"/author\" ; public static final Long DELETE_AUTHOR_ID = 6L ; public static final Long MODIFY_AUTHOR_ID = 3L ; public static final String NEW_AUTHOR_NAME = \"Nuevo Autor\" ; public static final String NEW_NATIONALITY = \"Nueva Nacionalidad\" ; private static final int TOTAL_AUTHORS = 6 ; private static final int PAGE_SIZE = 5 ; @LocalServerPort private int port ; @Autowired private TestRestTemplate restTemplate ; ParameterizedTypeReference < ResponsePage < AuthorDto >> responseTypePage = new ParameterizedTypeReference < ResponsePage < AuthorDto >> (){}; @Test public void findFirstPageWithFiveSizeShouldReturnFirstFiveResults () { AuthorSearchDto searchDto = new AuthorSearchDto (); searchDto . setPageable ( new PageableRequest ( 0 , PAGE_SIZE )); ResponseEntity < ResponsePage < AuthorDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . POST , new HttpEntity <> ( searchDto ), responseTypePage ); assertNotNull ( response ); assertEquals ( TOTAL_AUTHORS , response . getBody (). getTotalElements ()); assertEquals ( PAGE_SIZE , response . getBody (). getContent (). size ()); } @Test public void findSecondPageWithFiveSizeShouldReturnLastResult () { int elementsCount = TOTAL_AUTHORS - PAGE_SIZE ; AuthorSearchDto searchDto = new AuthorSearchDto (); searchDto . setPageable ( new PageableRequest ( 1 , PAGE_SIZE )); ResponseEntity < ResponsePage < AuthorDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . POST , new HttpEntity <> ( searchDto ), responseTypePage ); assertNotNull ( response ); assertEquals ( TOTAL_AUTHORS , response . getBody (). getTotalElements ()); assertEquals ( elementsCount , response . getBody (). getContent (). size ()); } @Test public void saveWithoutIdShouldCreateNewAuthor () { long newAuthorId = TOTAL_AUTHORS + 1 ; long newAuthorSize = TOTAL_AUTHORS + 1 ; AuthorDto dto = new AuthorDto (); dto . setName ( NEW_AUTHOR_NAME ); dto . setNationality ( NEW_NATIONALITY ); restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . PUT , new HttpEntity <> ( dto ), Void . class ); AuthorSearchDto searchDto = new AuthorSearchDto (); searchDto . setPageable ( new PageableRequest ( 0 , ( int ) newAuthorSize )); ResponseEntity < ResponsePage < AuthorDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . POST , new HttpEntity <> ( searchDto ), responseTypePage ); assertNotNull ( response ); assertEquals ( newAuthorSize , response . getBody (). getTotalElements ()); AuthorDto author = response . getBody (). getContent (). stream (). filter ( item -> item . getId (). equals ( newAuthorId )). findFirst (). orElse ( null ); assertNotNull ( author ); assertEquals ( NEW_AUTHOR_NAME , author . getName ()); } @Test public void modifyWithExistIdShouldModifyAuthor () { AuthorDto dto = new AuthorDto (); dto . setName ( NEW_AUTHOR_NAME ); dto . setNationality ( NEW_NATIONALITY ); restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + MODIFY_AUTHOR_ID , HttpMethod . PUT , new HttpEntity <> ( dto ), Void . class ); AuthorSearchDto searchDto = new AuthorSearchDto (); searchDto . setPageable ( new PageableRequest ( 0 , PAGE_SIZE )); ResponseEntity < ResponsePage < AuthorDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . POST , new HttpEntity <> ( searchDto ), responseTypePage ); assertNotNull ( response ); assertEquals ( TOTAL_AUTHORS , response . getBody (). getTotalElements ()); AuthorDto author = response . getBody (). getContent (). stream (). filter ( item -> item . getId (). equals ( MODIFY_AUTHOR_ID )). findFirst (). orElse ( null ); assertNotNull ( author ); assertEquals ( NEW_AUTHOR_NAME , author . getName ()); assertEquals ( NEW_NATIONALITY , author . getNationality ()); } @Test public void modifyWithNotExistIdShouldThrowException () { long authorId = TOTAL_AUTHORS + 1 ; AuthorDto dto = new AuthorDto (); dto . setName ( NEW_AUTHOR_NAME ); ResponseEntity <?> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + authorId , HttpMethod . PUT , new HttpEntity <> ( dto ), Void . class ); assertEquals ( HttpStatus . INTERNAL_SERVER_ERROR , response . getStatusCode ()); } @Test public void deleteWithExistsIdShouldDeleteCategory () { long newAuthorsSize = TOTAL_AUTHORS - 1 ; restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + DELETE_AUTHOR_ID , HttpMethod . DELETE , null , Void . class ); AuthorSearchDto searchDto = new AuthorSearchDto (); searchDto . setPageable ( new PageableRequest ( 0 , TOTAL_AUTHORS )); ResponseEntity < ResponsePage < AuthorDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . POST , new HttpEntity <> ( searchDto ), responseTypePage ); assertNotNull ( response ); assertEquals ( newAuthorsSize , response . getBody (). getTotalElements ()); } @Test public void deleteWithNotExistsIdShouldThrowException () { long deleteAuthorId = TOTAL_AUTHORS + 1 ; ResponseEntity <?> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + deleteAuthorId , HttpMethod . DELETE , null , Void . class ); assertEquals ( HttpStatus . INTERNAL_SERVER_ERROR , response . getStatusCode ()); } } Cuidado con las clases de Test Recuerda que el c\u00f3digo de aplicaci\u00f3n debe ir en src/main/java , mientras que las clases de test deben ir en src/test/java para que no se mezclen unas con otras y se empaquete todo en el artefacto final. En este caso AuthorIT.java va en el directorio de test src/test/java . Si ejecutamos los test, el resultado ser\u00e1 7 maravillosos test que fallan su ejecuci\u00f3n. Es normal, puesto que no hemos implementado nada de c\u00f3digo de aplicaci\u00f3n para corresponder esos test. Implementar Controller Si recuerdas, esta capa de Controller es la que tiene los endpoints de entrada a la aplicaci\u00f3n. Nosotros ya tenemos definidas 3 operaciones, que hemos dise\u00f1ado directamente desde los tests. Ahora vamos a implementar esos m\u00e9todos con el c\u00f3digo necesario para que los test funcionen correctamente, y teniendo en mente que debemos apoyarnos en las capas inferiores Service y Repository para repartir l\u00f3gica de negocio y acceso a datos. AuthorController.java AuthorService.java package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.Author ; import com.ccsw.tutorial.author.model.AuthorDto ; import com.ccsw.tutorial.author.model.AuthorSearchDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; import org.modelmapper.ModelMapper ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.PageImpl ; import org.springframework.web.bind.annotation.* ; import java.util.List ; import java.util.stream.Collectors ; /** * @author ccsw * */ @Tag ( name = \"Author\" , description = \"API of Author\" ) @RequestMapping ( value = \"/author\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class AuthorController { @Autowired AuthorService authorService ; @Autowired ModelMapper mapper ; /** * M\u00e9todo para recuperar un listado paginado de {@link Author} * * @param dto dto de b\u00fasqueda * @return {@link Page} de {@link AuthorDto} */ @Operation ( summary = \"Find Page\" , description = \"Method that return a page of Authors\" ) @RequestMapping ( path = \"\" , method = RequestMethod . POST ) public Page < AuthorDto > findPage ( @RequestBody AuthorSearchDto dto ) { Page < Author > page = this . authorService . findPage ( dto ); return new PageImpl <> ( page . getContent (). stream (). map ( e -> mapper . map ( e , AuthorDto . class )). collect ( Collectors . toList ()), page . getPageable (), page . getTotalElements ()); } /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Author\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody AuthorDto dto ) { this . authorService . save ( id , dto ); } /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad */ @Operation ( summary = \"Delete\" , description = \"Method that deletes a Author\" ) @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) throws Exception { this . authorService . delete ( id ); } } package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.Author ; import com.ccsw.tutorial.author.model.AuthorDto ; import com.ccsw.tutorial.author.model.AuthorSearchDto ; import org.springframework.data.domain.Page ; import java.util.List ; /** * @author ccsw * */ public interface AuthorService { /** * M\u00e9todo para recuperar un listado paginado de {@link Author} * * @param dto dto de b\u00fasqueda * @return {@link Page} de {@link Author} */ Page < Author > findPage ( AuthorSearchDto dto ); /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad * @param dto datos de la entidad */ void save ( Long id , AuthorDto dto ); /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad */ void delete ( Long id ) throws Exception ; } Si te fijas, hemos trasladado toda la l\u00f3gica a llamadas al AuthorService que hemos inyectado, y para que no falle la compilaci\u00f3n hemos creado una interface con los m\u00e9todos necesarios. En la clase AuthorController es donde se hacen las conversiones de cara al cliente, pasaremos de un Page<Author> (modelo entidad) a un Page<AuthorDto> (modelo DTO) con la ayuda del beanMapper. Recuerda que al cliente no le deben llegar modelos entidades sino DTOs. Adem\u00e1s, el m\u00e9todo de carga findPage ya no es un m\u00e9todo de tipo GET , ahora es de tipo POST porque le tenemos que enviar los datos de la paginaci\u00f3n para que Spring JPA pueda hacer su magia. Ahora debemos implementar la siguiente capa. Implementar Service La siguiente capa que vamos a implementar es justamente la capa que contiene toda la l\u00f3gica de negocio, hace uso del Repository para acceder a los datos, y recibe llamadas generalmente de los Controller . AuthorServiceImpl.java AuthorRepository.java package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.Author ; import com.ccsw.tutorial.author.model.AuthorDto ; import com.ccsw.tutorial.author.model.AuthorSearchDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class AuthorServiceImpl implements AuthorService { @Autowired AuthorRepository authorRepository ; /** * {@inheritDoc} */ @Override public Page < Author > findPage ( AuthorSearchDto dto ) { return this . authorRepository . findAll ( dto . getPageable (). getPageable ()); } /** * {@inheritDoc} */ @Override public void save ( Long id , AuthorDto data ) { Author author ; if ( id == null ) { author = new Author (); } else { author = this . authorRepository . findById ( id ). orElse ( null ); } BeanUtils . copyProperties ( data , author , \"id\" ); this . authorRepository . save ( author ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) throws Exception { if ( this . authorRepository . findById ( id ). orElse ( null ) == null ){ throw new Exception ( \"Not exists\" ); } this . authorRepository . deleteById ( id ); } } package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.Author ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.Pageable ; import org.springframework.data.repository.CrudRepository ; /** * @author ccsw * */ public interface AuthorRepository extends CrudRepository < Author , Long > { } De nuevo pasa lo mismo que con la capa anterior, aqu\u00ed delegamos muchas operaciones de consulta y guardado de datos en AuthorRepository . Hemos tenido que crearlo como interface para que no falle la compilaci\u00f3n. Recuerda que cuando creamos un Repository es de gran ayuda hacerlo extender de CrudRepository<T, ID> ya que tiene muchos m\u00e9todos implementados de base que nos pueden servir, como el delete o el save . F\u00edjate tambi\u00e9n que cuando queremos copiar m\u00e1s de un dato de una clase a otra, tenemos una utilidad llamada BeanUtils que nos permite realizar esa copia (siempre que las propiedades de ambas clases se llamen igual). Adem\u00e1s, en nuestro ejemplo hemos ignorado el 'id' para que no nos copie un null a la clase destino. Implementar Repository Y llegamos a la \u00faltima capa, la que est\u00e1 m\u00e1s cerca de los datos finales. Tenemos la siguiente interface: AuthorRepository.java package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.Author ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.Pageable ; import org.springframework.data.repository.CrudRepository ; /** * @author ccsw * */ public interface AuthorRepository extends CrudRepository < Author , Long > { /** * M\u00e9todo para recuperar un listado paginado de {@link Author} * * @param pageable pageable * @return {@link Page} de {@link Author} */ Page < Author > findAll ( Pageable pageable ); } Si te fijas, este Repository ya no est\u00e1 vac\u00edo como el anterior, no nos sirve con las operaciones b\u00e1sicas del CrudRepository en este caso hemos tenido que a\u00f1adir un m\u00e9todo nuevo al que pasandole un objeto de tipo Pageable nos devuelva una Page . Pues bien, resulta que la m\u00e1gina de Spring JPA en este caso har\u00e1 su trabajo y nosotros no necesitamos implementar ninguna query, Spring ya entiende que un findAll significa que debe recuperar todos los datos de la tabla Author (que es la tabla que tiene como generico en CrudRepository ) y adem\u00e1s deben estar paginados ya que el m\u00e9todo devuelve un objeto tipo Page . Nos ahorra tener que generar una sql para buscar una p\u00e1gina concreta de datos y hacer un count de la tabla para obtener el total de resultados. Para ver otros ejemplos y m\u00e1s informaci\u00f3n, visita la p\u00e1gina de QueryMethods . Realmente se puede hacer much\u00edsimas cosas con solo escribir el nombre del m\u00e9todo, sin tener que pensar ni teclear ninguna sql. Con esto ya lo tendr\u00edamos todo. Probar las operaciones Si ahora ejecutamos los test jUnit, veremos que todos funcionan y est\u00e1n en verde. Hemos implementado todas nuestras pruebas y la aplicaci\u00f3n es correcta. Aun as\u00ed, debemos realizar pruebas con el postman para ver los resultados que nos ofrece el back. Para ello, tienes que levantar la aplici\u00f3n y ejecutar las siguientes operaciones: POST /author { \"pageable\": { \"pageSize\" : 4, \"pageNumber\" : 0, \"sort\" : [ { \"property\": \"name\", \"direction\": \"ASC\" } ] } } Nos devuelve un listado paginado de Autores . F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no env\u00edas datos con formato Pageable , te dar\u00e1 un error. Tambi\u00e9n f\u00edjate que la respuesta es de tipo Page . Prueba a jugar con los datos de paginaci\u00f3n e incluso de ordenaci\u00f3n. No hemos programado ninguna SQL pero Spring hace su magia. PUT /author PUT /author/{id} { \"name\" : \"Nuevo autor\", \"nationality\" : \"Nueva nacionalidad\" } Nos sirve para insertar Autores nuevas (si no tienen el id informado) o para actualizar Autores (si tienen el id informado en la URL). F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no te dar\u00e1 un error. DELETE /author/{id} nos sirve eliminar Autores . F\u00edjate que el dato del ID que se env\u00eda est\u00e1 en el path.","title":"\ud83d\udfe2 Spring Boot"},{"location":"develop/paginated/springboot/#listado-paginado-spring-boot","text":"Ahora vamos a implementar las operaciones necesarias para ayudar al front a cubrir la funcionalidad del CRUD paginado en servidor. Recuerda que para que un listado paginado en servidor funcione, el cliente debe enviar en cada petici\u00f3n que p\u00e1gina est\u00e1 solicitando y cu\u00e1l es el tama\u00f1o de la p\u00e1gina, para que el servidor devuelva solamente un subconjunto de datos, en lugar de devolver el listado completo. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.","title":"Listado paginado - Spring Boot"},{"location":"develop/paginated/springboot/#crear-modelos","text":"Lo primero que vamos a hacer es crear los modelos para trabajar con BBDD y con peticiones hacia el front. Adem\u00e1s, tambi\u00e9n tenemos que a\u00f1adir datos al script de inicializaci\u00f3n de BBDD, siempre respetando la nomenclatura que le hemos dado a la tabla y columnas de BBDD. Author.java AuthorDto.java data.sql package com.ccsw.tutorial.author.model ; import jakarta.persistence.* ; /** * @author ccsw * */ @Entity @Table ( name = \"author\" ) public class Author { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"name\" , nullable = false ) private String name ; @Column ( name = \"nationality\" ) private String nationality ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } /** * @return nationality */ public String getNationality () { return this . nationality ; } /** * @param nationality new value of {@link #getNationality}. */ public void setNationality ( String nationality ) { this . nationality = nationality ; } } package com.ccsw.tutorial.author.model ; /** * @author ccsw * */ public class AuthorDto { private Long id ; private String name ; private String nationality ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } /** * @return nationality */ public String getNationality () { return this . nationality ; } /** * @param nationality new value of {@link #getNationality}. */ public void setNationality ( String nationality ) { this . nationality = nationality ; } } INSERT INTO category ( name ) VALUES ( 'Eurogames' ); INSERT INTO category ( name ) VALUES ( 'Ameritrash' ); INSERT INTO category ( name ) VALUES ( 'Familiar' ); INSERT INTO author ( name , nationality ) VALUES ( 'Alan R. Moon' , 'US' ); INSERT INTO author ( name , nationality ) VALUES ( 'Vital Lacerda' , 'PT' ); INSERT INTO author ( name , nationality ) VALUES ( 'Simone Luciani' , 'IT' ); INSERT INTO author ( name , nationality ) VALUES ( 'Perepau Llistosella' , 'ES' ); INSERT INTO author ( name , nationality ) VALUES ( 'Michael Kiesling' , 'DE' ); INSERT INTO author ( name , nationality ) VALUES ( 'Phil Walker-Harding' , 'US' );","title":"Crear modelos"},{"location":"develop/paginated/springboot/#implementar-tdd-pruebas","text":"Para desarrollar todas las operaciones, empezaremos primero dise\u00f1ando las pruebas y luego implementando el c\u00f3digo necesario que haga funcionar correctamente esas pruebas. Para ir m\u00e1s r\u00e1pido vamos a poner todas las pruebas de golpe, pero realmente se deber\u00edan crear una a una e ir implementando el c\u00f3digo necesario para esa prueba. Para evitar tantas iteraciones en el tutorial las haremos todas de golpe. Vamos a pararnos a pensar un poco que necesitamos en la pantalla. Ahora mismo nos sirve con: Una consulta paginada, que reciba datos de la p\u00e1gina a consultar y devuelva los datos paginados Una operaci\u00f3n de guardado y modificaci\u00f3n Una operaci\u00f3n de borrado Para la primera prueba que hemos descrito (consulta paginada) se necesita un objeto que contenga los datos de la p\u00e1gina a consultar. As\u00ed que crearemos una clase AuthorSearchDto para utilizarlo como 'paginador'. Para ello, en primer lugar, deberemos a\u00f1adir una clase que vamos a utilizar como envoltorio para las peticiones de paginaci\u00f3n en el proyecto. Hacemos esto para desacoplar la interface de Spring Boot de nuestro contrato de entrada. Crearemos esta clase en el paquete com.ccsw.tutorial.common.pagination . PageableRequest.java package com.ccsw.tutorial.common.pagination ; import com.fasterxml.jackson.annotation.JsonIgnore ; import org.springframework.data.domain.* ; import java.io.Serializable ; import java.util.ArrayList ; import java.util.List ; import java.util.stream.Collectors ; public class PageableRequest implements Serializable { private static final long serialVersionUID = 1L ; private int pageNumber ; private int pageSize ; private List < SortRequest > sort ; public PageableRequest () { sort = new ArrayList <> (); } public PageableRequest ( int pageNumber , int pageSize ) { this (); this . pageNumber = pageNumber ; this . pageSize = pageSize ; } public PageableRequest ( int pageNumber , int pageSize , List < SortRequest > sort ) { this (); this . pageNumber = pageNumber ; this . pageSize = pageSize ; this . sort = sort ; } public int getPageNumber () { return pageNumber ; } public void setPageNumber ( int pageNumber ) { this . pageNumber = pageNumber ; } public int getPageSize () { return pageSize ; } public void setPageSize ( int pageSize ) { this . pageSize = pageSize ; } public List < SortRequest > getSort () { return sort ; } public void setSort ( List < SortRequest > sort ) { this . sort = sort ; } @JsonIgnore public Pageable getPageable () { return PageRequest . of ( this . pageNumber , this . pageSize , Sort . by ( sort . stream (). map ( e -> new Sort . Order ( e . getDirection (), e . getProperty ())). collect ( Collectors . toList ()))); } public static class SortRequest implements Serializable { private static final long serialVersionUID = 1L ; private String property ; private Sort . Direction direction ; protected String getProperty () { return property ; } protected void setProperty ( String property ) { this . property = property ; } protected Sort . Direction getDirection () { return direction ; } protected void setDirection ( Sort . Direction direction ) { this . direction = direction ; } } } Adicionalmente necesitaremos una clase para deserializar las respuestas de Page recibidas en los test que vamos a implementar. Para ello creamos la clase necesaria dentro de la fuente de la carpeta de los test en el paquete com.ccsw.tutorial.config . Esto solo hace falta porque necesitamos leer la respuesta paginada en el test, si no hicieramos test, no har\u00eda falta. ResponsePage.java package com.ccsw.tutorial.config ; import com.fasterxml.jackson.annotation.JsonCreator ; import com.fasterxml.jackson.annotation.JsonIgnoreProperties ; import com.fasterxml.jackson.annotation.JsonProperty ; import com.fasterxml.jackson.databind.JsonNode ; import org.springframework.data.domain.PageImpl ; import org.springframework.data.domain.PageRequest ; import org.springframework.data.domain.Pageable ; import java.util.ArrayList ; import java.util.List ; @JsonIgnoreProperties ( ignoreUnknown = true ) public class ResponsePage < T > extends PageImpl < T > { private static final long serialVersionUID = 1L ; @JsonCreator ( mode = JsonCreator . Mode . PROPERTIES ) public ResponsePage ( @JsonProperty ( \"content\" ) List < T > content , @JsonProperty ( \"number\" ) int number , @JsonProperty ( \"size\" ) int size , @JsonProperty ( \"totalElements\" ) Long totalElements , @JsonProperty ( \"pageable\" ) JsonNode pageable , @JsonProperty ( \"last\" ) boolean last , @JsonProperty ( \"totalPages\" ) int totalPages , @JsonProperty ( \"sort\" ) JsonNode sort , @JsonProperty ( \"first\" ) boolean first , @JsonProperty ( \"numberOfElements\" ) int numberOfElements ) { super ( content , PageRequest . of ( number , size ), totalElements ); } public ResponsePage ( List < T > content , Pageable pageable , long total ) { super ( content , pageable , total ); } public ResponsePage ( List < T > content ) { super ( content ); } public ResponsePage () { super ( new ArrayList <> ()); } } Paginaci\u00f3n en Springframework Cuando utilicemos paginaci\u00f3n en Springframework, debemos recordar que ya vienen implementados algunos objetos que podemos utilizar y que nos facilitan la vida. Es el caso de Pageable y Page . El objeto Pageable no es m\u00e1s que una interface que le permite a Spring JPA saber que p\u00e1gina se quiere buscar, cual es el tama\u00f1o de p\u00e1gina y cuales son las propiedades de ordenaci\u00f3n que se debe lanzar en la consulta. El objeto PageRequest es una utilidad que permite crear objetos de tipo Pageable de forma sencilla. Se utiliza mucho para codificaci\u00f3n de test. El objeto Page no es m\u00e1s que un contenedor que engloba la informaci\u00f3n b\u00e1sica de la p\u00e1gina que se est\u00e1 consultando (n\u00famero de p\u00e1gina, tama\u00f1o de p\u00e1gina, n\u00famero total de resultados) y el conjunto de datos de la BBDD que contiene esa p\u00e1gina una vez han sido buscados y ordenados. Tambi\u00e9n crearemos una clase AuthorController dentro del package de com.ccsw.tutorial.author con la implementaci\u00f3n de los m\u00e9todos vac\u00edos, para que no falle la compilaci\u00f3n. \u00a1Vamos a implementar test! AuthorSearchDto.java AuthorController.java AuthorIT.java package com.ccsw.tutorial.author.model ; import com.ccsw.tutorial.common.pagination.PageableRequest ; /** * @author ccsw * */ public class AuthorSearchDto { private PageableRequest pageable ; public PageableRequest getPageable () { return pageable ; } public void setPageable ( PageableRequest pageable ) { this . pageable = pageable ; } } package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.Author ; import com.ccsw.tutorial.author.model.AuthorDto ; import com.ccsw.tutorial.author.model.AuthorSearchDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; import org.springframework.data.domain.Page ; import org.springframework.web.bind.annotation.* ; /** * @author ccsw * */ @Tag ( name = \"Author\" , description = \"API of Author\" ) @RequestMapping ( value = \"/author\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class AuthorController { /** * M\u00e9todo para recuperar un listado paginado de {@link Author} * * @param dto dto de b\u00fasqueda * @return {@link Page} de {@link AuthorDto} */ @Operation ( summary = \"Find Page\" , description = \"Method that return a page of Authors\" ) @RequestMapping ( path = \"\" , method = RequestMethod . POST ) public Page < AuthorDto > findPage ( @RequestBody AuthorSearchDto dto ) { return null ; } /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Author\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody AuthorDto dto ) { } /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad */ @Operation ( summary = \"Delete\" , description = \"Method that deletes a Author\" ) @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) throws Exception { } } package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.AuthorDto ; import com.ccsw.tutorial.author.model.AuthorSearchDto ; import com.ccsw.tutorial.common.pagination.PageableRequest ; import com.ccsw.tutorial.config.ResponsePage ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.boot.test.web.client.TestRestTemplate ; import org.springframework.boot.test.web.server.LocalServerPort ; import org.springframework.core.ParameterizedTypeReference ; import org.springframework.http.* ; import org.springframework.test.annotation.DirtiesContext ; import java.util.List ; import static org.junit.jupiter.api.Assertions.assertEquals ; import static org.junit.jupiter.api.Assertions.assertNotNull ; @SpringBootTest ( webEnvironment = SpringBootTest . WebEnvironment . RANDOM_PORT ) @DirtiesContext ( classMode = DirtiesContext . ClassMode . BEFORE_EACH_TEST_METHOD ) public class AuthorIT { public static final String LOCALHOST = \"http://localhost:\" ; public static final String SERVICE_PATH = \"/author\" ; public static final Long DELETE_AUTHOR_ID = 6L ; public static final Long MODIFY_AUTHOR_ID = 3L ; public static final String NEW_AUTHOR_NAME = \"Nuevo Autor\" ; public static final String NEW_NATIONALITY = \"Nueva Nacionalidad\" ; private static final int TOTAL_AUTHORS = 6 ; private static final int PAGE_SIZE = 5 ; @LocalServerPort private int port ; @Autowired private TestRestTemplate restTemplate ; ParameterizedTypeReference < ResponsePage < AuthorDto >> responseTypePage = new ParameterizedTypeReference < ResponsePage < AuthorDto >> (){}; @Test public void findFirstPageWithFiveSizeShouldReturnFirstFiveResults () { AuthorSearchDto searchDto = new AuthorSearchDto (); searchDto . setPageable ( new PageableRequest ( 0 , PAGE_SIZE )); ResponseEntity < ResponsePage < AuthorDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . POST , new HttpEntity <> ( searchDto ), responseTypePage ); assertNotNull ( response ); assertEquals ( TOTAL_AUTHORS , response . getBody (). getTotalElements ()); assertEquals ( PAGE_SIZE , response . getBody (). getContent (). size ()); } @Test public void findSecondPageWithFiveSizeShouldReturnLastResult () { int elementsCount = TOTAL_AUTHORS - PAGE_SIZE ; AuthorSearchDto searchDto = new AuthorSearchDto (); searchDto . setPageable ( new PageableRequest ( 1 , PAGE_SIZE )); ResponseEntity < ResponsePage < AuthorDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . POST , new HttpEntity <> ( searchDto ), responseTypePage ); assertNotNull ( response ); assertEquals ( TOTAL_AUTHORS , response . getBody (). getTotalElements ()); assertEquals ( elementsCount , response . getBody (). getContent (). size ()); } @Test public void saveWithoutIdShouldCreateNewAuthor () { long newAuthorId = TOTAL_AUTHORS + 1 ; long newAuthorSize = TOTAL_AUTHORS + 1 ; AuthorDto dto = new AuthorDto (); dto . setName ( NEW_AUTHOR_NAME ); dto . setNationality ( NEW_NATIONALITY ); restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . PUT , new HttpEntity <> ( dto ), Void . class ); AuthorSearchDto searchDto = new AuthorSearchDto (); searchDto . setPageable ( new PageableRequest ( 0 , ( int ) newAuthorSize )); ResponseEntity < ResponsePage < AuthorDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . POST , new HttpEntity <> ( searchDto ), responseTypePage ); assertNotNull ( response ); assertEquals ( newAuthorSize , response . getBody (). getTotalElements ()); AuthorDto author = response . getBody (). getContent (). stream (). filter ( item -> item . getId (). equals ( newAuthorId )). findFirst (). orElse ( null ); assertNotNull ( author ); assertEquals ( NEW_AUTHOR_NAME , author . getName ()); } @Test public void modifyWithExistIdShouldModifyAuthor () { AuthorDto dto = new AuthorDto (); dto . setName ( NEW_AUTHOR_NAME ); dto . setNationality ( NEW_NATIONALITY ); restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + MODIFY_AUTHOR_ID , HttpMethod . PUT , new HttpEntity <> ( dto ), Void . class ); AuthorSearchDto searchDto = new AuthorSearchDto (); searchDto . setPageable ( new PageableRequest ( 0 , PAGE_SIZE )); ResponseEntity < ResponsePage < AuthorDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . POST , new HttpEntity <> ( searchDto ), responseTypePage ); assertNotNull ( response ); assertEquals ( TOTAL_AUTHORS , response . getBody (). getTotalElements ()); AuthorDto author = response . getBody (). getContent (). stream (). filter ( item -> item . getId (). equals ( MODIFY_AUTHOR_ID )). findFirst (). orElse ( null ); assertNotNull ( author ); assertEquals ( NEW_AUTHOR_NAME , author . getName ()); assertEquals ( NEW_NATIONALITY , author . getNationality ()); } @Test public void modifyWithNotExistIdShouldThrowException () { long authorId = TOTAL_AUTHORS + 1 ; AuthorDto dto = new AuthorDto (); dto . setName ( NEW_AUTHOR_NAME ); ResponseEntity <?> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + authorId , HttpMethod . PUT , new HttpEntity <> ( dto ), Void . class ); assertEquals ( HttpStatus . INTERNAL_SERVER_ERROR , response . getStatusCode ()); } @Test public void deleteWithExistsIdShouldDeleteCategory () { long newAuthorsSize = TOTAL_AUTHORS - 1 ; restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + DELETE_AUTHOR_ID , HttpMethod . DELETE , null , Void . class ); AuthorSearchDto searchDto = new AuthorSearchDto (); searchDto . setPageable ( new PageableRequest ( 0 , TOTAL_AUTHORS )); ResponseEntity < ResponsePage < AuthorDto >> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH , HttpMethod . POST , new HttpEntity <> ( searchDto ), responseTypePage ); assertNotNull ( response ); assertEquals ( newAuthorsSize , response . getBody (). getTotalElements ()); } @Test public void deleteWithNotExistsIdShouldThrowException () { long deleteAuthorId = TOTAL_AUTHORS + 1 ; ResponseEntity <?> response = restTemplate . exchange ( LOCALHOST + port + SERVICE_PATH + \"/\" + deleteAuthorId , HttpMethod . DELETE , null , Void . class ); assertEquals ( HttpStatus . INTERNAL_SERVER_ERROR , response . getStatusCode ()); } } Cuidado con las clases de Test Recuerda que el c\u00f3digo de aplicaci\u00f3n debe ir en src/main/java , mientras que las clases de test deben ir en src/test/java para que no se mezclen unas con otras y se empaquete todo en el artefacto final. En este caso AuthorIT.java va en el directorio de test src/test/java . Si ejecutamos los test, el resultado ser\u00e1 7 maravillosos test que fallan su ejecuci\u00f3n. Es normal, puesto que no hemos implementado nada de c\u00f3digo de aplicaci\u00f3n para corresponder esos test.","title":"Implementar TDD - Pruebas"},{"location":"develop/paginated/springboot/#implementar-controller","text":"Si recuerdas, esta capa de Controller es la que tiene los endpoints de entrada a la aplicaci\u00f3n. Nosotros ya tenemos definidas 3 operaciones, que hemos dise\u00f1ado directamente desde los tests. Ahora vamos a implementar esos m\u00e9todos con el c\u00f3digo necesario para que los test funcionen correctamente, y teniendo en mente que debemos apoyarnos en las capas inferiores Service y Repository para repartir l\u00f3gica de negocio y acceso a datos. AuthorController.java AuthorService.java package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.Author ; import com.ccsw.tutorial.author.model.AuthorDto ; import com.ccsw.tutorial.author.model.AuthorSearchDto ; import io.swagger.v3.oas.annotations.Operation ; import io.swagger.v3.oas.annotations.tags.Tag ; import org.modelmapper.ModelMapper ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.PageImpl ; import org.springframework.web.bind.annotation.* ; import java.util.List ; import java.util.stream.Collectors ; /** * @author ccsw * */ @Tag ( name = \"Author\" , description = \"API of Author\" ) @RequestMapping ( value = \"/author\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class AuthorController { @Autowired AuthorService authorService ; @Autowired ModelMapper mapper ; /** * M\u00e9todo para recuperar un listado paginado de {@link Author} * * @param dto dto de b\u00fasqueda * @return {@link Page} de {@link AuthorDto} */ @Operation ( summary = \"Find Page\" , description = \"Method that return a page of Authors\" ) @RequestMapping ( path = \"\" , method = RequestMethod . POST ) public Page < AuthorDto > findPage ( @RequestBody AuthorSearchDto dto ) { Page < Author > page = this . authorService . findPage ( dto ); return new PageImpl <> ( page . getContent (). stream (). map ( e -> mapper . map ( e , AuthorDto . class )). collect ( Collectors . toList ()), page . getPageable (), page . getTotalElements ()); } /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad * @param dto datos de la entidad */ @Operation ( summary = \"Save or Update\" , description = \"Method that saves or updates a Author\" ) @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody AuthorDto dto ) { this . authorService . save ( id , dto ); } /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad */ @Operation ( summary = \"Delete\" , description = \"Method that deletes a Author\" ) @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) throws Exception { this . authorService . delete ( id ); } } package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.Author ; import com.ccsw.tutorial.author.model.AuthorDto ; import com.ccsw.tutorial.author.model.AuthorSearchDto ; import org.springframework.data.domain.Page ; import java.util.List ; /** * @author ccsw * */ public interface AuthorService { /** * M\u00e9todo para recuperar un listado paginado de {@link Author} * * @param dto dto de b\u00fasqueda * @return {@link Page} de {@link Author} */ Page < Author > findPage ( AuthorSearchDto dto ); /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad * @param dto datos de la entidad */ void save ( Long id , AuthorDto dto ); /** * M\u00e9todo para crear o actualizar un {@link Author} * * @param id PK de la entidad */ void delete ( Long id ) throws Exception ; } Si te fijas, hemos trasladado toda la l\u00f3gica a llamadas al AuthorService que hemos inyectado, y para que no falle la compilaci\u00f3n hemos creado una interface con los m\u00e9todos necesarios. En la clase AuthorController es donde se hacen las conversiones de cara al cliente, pasaremos de un Page<Author> (modelo entidad) a un Page<AuthorDto> (modelo DTO) con la ayuda del beanMapper. Recuerda que al cliente no le deben llegar modelos entidades sino DTOs. Adem\u00e1s, el m\u00e9todo de carga findPage ya no es un m\u00e9todo de tipo GET , ahora es de tipo POST porque le tenemos que enviar los datos de la paginaci\u00f3n para que Spring JPA pueda hacer su magia. Ahora debemos implementar la siguiente capa.","title":"Implementar Controller"},{"location":"develop/paginated/springboot/#implementar-service","text":"La siguiente capa que vamos a implementar es justamente la capa que contiene toda la l\u00f3gica de negocio, hace uso del Repository para acceder a los datos, y recibe llamadas generalmente de los Controller . AuthorServiceImpl.java AuthorRepository.java package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.Author ; import com.ccsw.tutorial.author.model.AuthorDto ; import com.ccsw.tutorial.author.model.AuthorSearchDto ; import jakarta.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.stereotype.Service ; import java.util.List ; /** * @author ccsw * */ @Service @Transactional public class AuthorServiceImpl implements AuthorService { @Autowired AuthorRepository authorRepository ; /** * {@inheritDoc} */ @Override public Page < Author > findPage ( AuthorSearchDto dto ) { return this . authorRepository . findAll ( dto . getPageable (). getPageable ()); } /** * {@inheritDoc} */ @Override public void save ( Long id , AuthorDto data ) { Author author ; if ( id == null ) { author = new Author (); } else { author = this . authorRepository . findById ( id ). orElse ( null ); } BeanUtils . copyProperties ( data , author , \"id\" ); this . authorRepository . save ( author ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) throws Exception { if ( this . authorRepository . findById ( id ). orElse ( null ) == null ){ throw new Exception ( \"Not exists\" ); } this . authorRepository . deleteById ( id ); } } package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.Author ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.Pageable ; import org.springframework.data.repository.CrudRepository ; /** * @author ccsw * */ public interface AuthorRepository extends CrudRepository < Author , Long > { } De nuevo pasa lo mismo que con la capa anterior, aqu\u00ed delegamos muchas operaciones de consulta y guardado de datos en AuthorRepository . Hemos tenido que crearlo como interface para que no falle la compilaci\u00f3n. Recuerda que cuando creamos un Repository es de gran ayuda hacerlo extender de CrudRepository<T, ID> ya que tiene muchos m\u00e9todos implementados de base que nos pueden servir, como el delete o el save . F\u00edjate tambi\u00e9n que cuando queremos copiar m\u00e1s de un dato de una clase a otra, tenemos una utilidad llamada BeanUtils que nos permite realizar esa copia (siempre que las propiedades de ambas clases se llamen igual). Adem\u00e1s, en nuestro ejemplo hemos ignorado el 'id' para que no nos copie un null a la clase destino.","title":"Implementar Service"},{"location":"develop/paginated/springboot/#implementar-repository","text":"Y llegamos a la \u00faltima capa, la que est\u00e1 m\u00e1s cerca de los datos finales. Tenemos la siguiente interface: AuthorRepository.java package com.ccsw.tutorial.author ; import com.ccsw.tutorial.author.model.Author ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.Pageable ; import org.springframework.data.repository.CrudRepository ; /** * @author ccsw * */ public interface AuthorRepository extends CrudRepository < Author , Long > { /** * M\u00e9todo para recuperar un listado paginado de {@link Author} * * @param pageable pageable * @return {@link Page} de {@link Author} */ Page < Author > findAll ( Pageable pageable ); } Si te fijas, este Repository ya no est\u00e1 vac\u00edo como el anterior, no nos sirve con las operaciones b\u00e1sicas del CrudRepository en este caso hemos tenido que a\u00f1adir un m\u00e9todo nuevo al que pasandole un objeto de tipo Pageable nos devuelva una Page . Pues bien, resulta que la m\u00e1gina de Spring JPA en este caso har\u00e1 su trabajo y nosotros no necesitamos implementar ninguna query, Spring ya entiende que un findAll significa que debe recuperar todos los datos de la tabla Author (que es la tabla que tiene como generico en CrudRepository ) y adem\u00e1s deben estar paginados ya que el m\u00e9todo devuelve un objeto tipo Page . Nos ahorra tener que generar una sql para buscar una p\u00e1gina concreta de datos y hacer un count de la tabla para obtener el total de resultados. Para ver otros ejemplos y m\u00e1s informaci\u00f3n, visita la p\u00e1gina de QueryMethods . Realmente se puede hacer much\u00edsimas cosas con solo escribir el nombre del m\u00e9todo, sin tener que pensar ni teclear ninguna sql. Con esto ya lo tendr\u00edamos todo.","title":"Implementar Repository"},{"location":"develop/paginated/springboot/#probar-las-operaciones","text":"Si ahora ejecutamos los test jUnit, veremos que todos funcionan y est\u00e1n en verde. Hemos implementado todas nuestras pruebas y la aplicaci\u00f3n es correcta. Aun as\u00ed, debemos realizar pruebas con el postman para ver los resultados que nos ofrece el back. Para ello, tienes que levantar la aplici\u00f3n y ejecutar las siguientes operaciones: POST /author { \"pageable\": { \"pageSize\" : 4, \"pageNumber\" : 0, \"sort\" : [ { \"property\": \"name\", \"direction\": \"ASC\" } ] } } Nos devuelve un listado paginado de Autores . F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no env\u00edas datos con formato Pageable , te dar\u00e1 un error. Tambi\u00e9n f\u00edjate que la respuesta es de tipo Page . Prueba a jugar con los datos de paginaci\u00f3n e incluso de ordenaci\u00f3n. No hemos programado ninguna SQL pero Spring hace su magia. PUT /author PUT /author/{id} { \"name\" : \"Nuevo autor\", \"nationality\" : \"Nueva nacionalidad\" } Nos sirve para insertar Autores nuevas (si no tienen el id informado) o para actualizar Autores (si tienen el id informado en la URL). F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no te dar\u00e1 un error. DELETE /author/{id} nos sirve eliminar Autores . F\u00edjate que el dato del ID que se env\u00eda est\u00e1 en el path.","title":"Probar las operaciones"},{"location":"install/angular/","text":"Entorno de desarrollo - Angular Instalaci\u00f3n de herramientas Las herramientas b\u00e1sicas que vamos a utilizar para esta tecnolog\u00eda son: Visual Studio Code Nodejs Angular CLI Visual Studio Code Lo primero de todo es instalar el IDE para el desarrollo front. Te recomiendo utilizar Visual Studio Code , en un IDE que a nosotros nos gusta mucho y tiene muchos plugins configurables. Puedes entrar en su p\u00e1gina y descargarte la versi\u00f3n estable. Nodejs El siguiente paso ser\u00e1 instalar el motor de Nodejs . Entrando en la p\u00e1gina de descargas e instalando la \u00faltima versi\u00f3n estable. Con esta herramienta podremos compilar y ejecutar aplicaciones basadas en Javascript y Typescript, e instalar y gestionar las dependencias de las aplicaciones. Angular CLI Por \u00faltimo vamos a instalar una capa de gesti\u00f3n por encima de Nodejs que nos ayudar\u00e1 en concreto con la funcionalida de Angular. En concreto instalaremos el CLI de Angular. Para poder instalarlo, tan solo hay que abrir una consola de msdos y ejecutar el comando y Nodejs ya har\u00e1 el resto: npm install -g @angular/cli Y con esto ya tendremos todo instalado, listo para empezar a crear los proyectos. Creaci\u00f3n de proyecto La mayor\u00eda de los proyectos con Angular en los que trabajamos normalmente, suelen ser proyectos web usando las librer\u00edas mas comunes de angular, como Angular Material. Crear un proyecto de Angular es muy sencillo si tienes instalado el CLI de Angular. Lo primero abrir una consola de msdos y posicionarte en el directorio raiz donde quieres crear tu proyecto Angular, y ejecutamos lo siguiente: ng new tutorial --strict=false El propio CLI nos ir\u00e1 realizando una serie de preguntas. Would you like to add Angular routing? (y/N) Preferiblemente: y Which stylesheet format would you like to use? Preferiblemente: SCSS En el caso del tutorial como vamos a tener dos proyectos para nuestra aplicaci\u00f3n (front y back), para poder seguir correctamente las explicaciones, voy a renombrar la carpeta para poder diferenciarla del otro proyecto. A partir de ahora se llamar\u00e1 client . Info Si durante el desarrollo del proyecto necesitas a\u00f1adir nuevos m\u00f3dulos al proyecto Angular, ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor de dependencias de Nodejs, directamente en consola ejecuta el comando npm update y descargar\u00e1 e instalar\u00e1 las nuevas dependencias. Arrancar el proyecto Para arrancar el proyecto, tan solo necesitamos ejecutar en consola el siguiente comando siempre dentro del directorio creado por Angular CLI: ng serve Angular compilar\u00e1 el c\u00f3digo fuente, levantar\u00e1 un servidor local al que podremos acceder por defecto mediante la URL: http://localhost:4200/ Y ya podemos empezar a trabajar con Angular. Info Cuando se trata de un proyecto nuevo recien descargado de un repositorio, recuerda que ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor de dependencias de Nodejs, directamente en consola ejecuta el comando npm update y descargar\u00e1 e instalar\u00e1 las nuevas dependencias. Comandos de Angular CLI Si necesitas m\u00e1s informaci\u00f3n sobre los comandos que ofrece Angular CLI para poder crear aplicaciones, componentes, servicios, etc. los tienes disponibles en: https://angular.io/cli#command-overview","title":"\ud83d\udd35 Angular"},{"location":"install/angular/#entorno-de-desarrollo-angular","text":"","title":"Entorno de desarrollo - Angular"},{"location":"install/angular/#instalacion-de-herramientas","text":"Las herramientas b\u00e1sicas que vamos a utilizar para esta tecnolog\u00eda son: Visual Studio Code Nodejs Angular CLI","title":"Instalaci\u00f3n de herramientas"},{"location":"install/angular/#visual-studio-code","text":"Lo primero de todo es instalar el IDE para el desarrollo front. Te recomiendo utilizar Visual Studio Code , en un IDE que a nosotros nos gusta mucho y tiene muchos plugins configurables. Puedes entrar en su p\u00e1gina y descargarte la versi\u00f3n estable.","title":"Visual Studio Code"},{"location":"install/angular/#nodejs","text":"El siguiente paso ser\u00e1 instalar el motor de Nodejs . Entrando en la p\u00e1gina de descargas e instalando la \u00faltima versi\u00f3n estable. Con esta herramienta podremos compilar y ejecutar aplicaciones basadas en Javascript y Typescript, e instalar y gestionar las dependencias de las aplicaciones.","title":"Nodejs"},{"location":"install/angular/#angular-cli","text":"Por \u00faltimo vamos a instalar una capa de gesti\u00f3n por encima de Nodejs que nos ayudar\u00e1 en concreto con la funcionalida de Angular. En concreto instalaremos el CLI de Angular. Para poder instalarlo, tan solo hay que abrir una consola de msdos y ejecutar el comando y Nodejs ya har\u00e1 el resto: npm install -g @angular/cli Y con esto ya tendremos todo instalado, listo para empezar a crear los proyectos.","title":"Angular CLI"},{"location":"install/angular/#creacion-de-proyecto","text":"La mayor\u00eda de los proyectos con Angular en los que trabajamos normalmente, suelen ser proyectos web usando las librer\u00edas mas comunes de angular, como Angular Material. Crear un proyecto de Angular es muy sencillo si tienes instalado el CLI de Angular. Lo primero abrir una consola de msdos y posicionarte en el directorio raiz donde quieres crear tu proyecto Angular, y ejecutamos lo siguiente: ng new tutorial --strict=false El propio CLI nos ir\u00e1 realizando una serie de preguntas. Would you like to add Angular routing? (y/N) Preferiblemente: y Which stylesheet format would you like to use? Preferiblemente: SCSS En el caso del tutorial como vamos a tener dos proyectos para nuestra aplicaci\u00f3n (front y back), para poder seguir correctamente las explicaciones, voy a renombrar la carpeta para poder diferenciarla del otro proyecto. A partir de ahora se llamar\u00e1 client . Info Si durante el desarrollo del proyecto necesitas a\u00f1adir nuevos m\u00f3dulos al proyecto Angular, ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor de dependencias de Nodejs, directamente en consola ejecuta el comando npm update y descargar\u00e1 e instalar\u00e1 las nuevas dependencias.","title":"Creaci\u00f3n de proyecto"},{"location":"install/angular/#arrancar-el-proyecto","text":"Para arrancar el proyecto, tan solo necesitamos ejecutar en consola el siguiente comando siempre dentro del directorio creado por Angular CLI: ng serve Angular compilar\u00e1 el c\u00f3digo fuente, levantar\u00e1 un servidor local al que podremos acceder por defecto mediante la URL: http://localhost:4200/ Y ya podemos empezar a trabajar con Angular. Info Cuando se trata de un proyecto nuevo recien descargado de un repositorio, recuerda que ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor de dependencias de Nodejs, directamente en consola ejecuta el comando npm update y descargar\u00e1 e instalar\u00e1 las nuevas dependencias. Comandos de Angular CLI Si necesitas m\u00e1s informaci\u00f3n sobre los comandos que ofrece Angular CLI para poder crear aplicaciones, componentes, servicios, etc. los tienes disponibles en: https://angular.io/cli#command-overview","title":"Arrancar el proyecto"},{"location":"install/nodejs/","text":"Entorno de desarrollo - Nodejs Instalaci\u00f3n de herramientas Las herramientas b\u00e1sicas que vamos a utilizar para esta tecnolog\u00eda son: Visual Studio Code Nodejs MongoDB Atlas Postman Visual Studio Code Lo primero de todo es instalar el IDE para el desarrollo en node si no lo has hecho previamente. Te recomiendo utilizar Visual Studio Code , en un IDE que a nosotros nos gusta mucho y tiene muchos plugins configurables. Puedes entrar en su p\u00e1gina y descargarte la versi\u00f3n estable. Nodejs El siguiente paso ser\u00e1 instalar el motor de Nodejs . Entrando en la p\u00e1gina de descargas e instalando la \u00faltima versi\u00f3n estable. Con esta herramienta podremos compilar y ejecutar aplicaciones basadas en Javascript y Typescript, e instalar y gestionar las dependencias de las aplicaciones. MongoDB Atlas Tambi\u00e9n necesitaremos crear una cuenta de MongoDB Atlas para crear nuestra base de datos MongoDB en la nube. Accede a la URL , registrate gr\u00e1tis con cualquier cuenta de correo y elige el tipo de cuenta gratuita \ud83d\ude0a: Configura el cluster a tu gusto (selecciona la opci\u00f3n gratuita en el cloud que m\u00e1s te guste) y ya tendr\u00edas una BBDD en cloud para hacer pruebas. Lo primero que se muestra es el dashboard que se ver\u00e1 algo similar a lo siguiente: A continuaci\u00f3n, pulsamos en la opci\u00f3n Database del men\u00fa y, sobre el Cluster0 , pulsamos tambi\u00e9n el bot\u00f3n Connect . Se nos abrir\u00e1 el siguiente pop-up donde tendremos que elegir la opci\u00f3n Connect your application : En el siguiente paso es donde se nos muestra la url que tendremos que utilizar en nuestra aplicaci\u00f3n. La copiamos y guardamos para m\u00e1s tarde: Pulsamos Close y la BBDD ya estar\u00eda creada. Nota: Al crear la base de datos te aprecer\u00e1 un aviso para introducir tu IP en la whitelist, aseg\u00farate no estar en la VPN cuando lo hagas, de lo contrario no tendr\u00e1s conexi\u00f3n posteriormente. Herramientas para pruebas Para poder probar las operaciones de negocio que vamos a crear, lo mejor es utilizar una herramienta que permita realizar llamadas a API Rest. Para ello te propongo utilizar Postman , en su versi\u00f3n web o en su versi\u00f3n desktop, cualquiera de las dos sirve. Con esta herramienta se puede generar peticiones GET, POST, PUT, DELETE contra el servidor y pasarle par\u00e1metros de forma muy sencilla y visual. Lo usaremos durante el tutorial. Creaci\u00f3n de proyecto Para la creaci\u00f3n de nuestro proyecto Node nos crearemos una carpeta con el nombre que deseemos y accederemos a ella con la consola de comandos de windows. Una vez dentro ejecutaremos el siguiente comando para inicializar nuestro proyecto con npm: npm init Cuando ejecutemos este comando nos pedir\u00e1 los valores para distintos par\u00e1metros de nuestro proyecto. Aconsejo solo cambiar el nombre y el resto dejarlo por defecto pulsando enter para cada valor. Una vez que hayamos terminado se nos habr\u00e1 generado un fichero package.json que contendr\u00e1 informaci\u00f3n b\u00e1sica de nuestro proyecto. Dentro de este fichero tendremos que a\u00f1adir un nuevo par\u00e1metro type con el valor module , esto nos permitir\u00e1 importar nuestros m\u00f3dulos con el est\u00e1ndar ES: { \"name\" : \"tutorialNode\" , \"version\" : \"1.0.0\" , \"description\" : \"\" , \"main\" : \"index.js\" , \"scripts\" : { \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"keywords\" : [], \"author\" : \"\" , \"license\" : \"ISC\" , \"type\" : \"module\" } Instalar dependencias En ese fichero aparte de la informaci\u00f3n de nuestro proyecto tambi\u00e9n tendremos que a\u00f1adir las dependencias que usara nuestra aplicaci\u00f3n. Para a\u00f1adir las dependencias, desde la consola de comandos y situados en la misma carpeta donde se haya creado el fichero package.json vamos a teclear los siguientes comandos: npm i express npm i express-validator npm i dotenv npm i mongoose npm i mongoose-paginate-v2 npm i normalize-mongoose npm i cors npm i nodemon --save-dev Tambi\u00e9n podr\u00edamos haber instalado todas a la vez en dos l\u00edneas: npm i express express-validator dotenv mongoose mongoose-paginate-v2 normalize-mongoose cors npm i nodemon --save-dev Las dependencias que acabamos de instalar son las siguientes: Express es un framework de Node que nos facilitara mucho la tarea a la hora de crear nuestra aplicaci\u00f3n. Dotenv es una librer\u00eda para usar variables de entorno. Mongoose es una librer\u00eda ODM que nos ayudara a los accesos a BBDD. Nodemon es una herramienta que nos ayuda reiniciando nuestro servidor cuando detecta un cambio en alguno de nuestros ficheros y as\u00ed no tener que hacerlo manualmente. Cors es una herramienta que nos ayuda a configurar el CORS de nuestra app para que posteriormente podemos conectarlo al front. Ahora podemos fijarnos en nuestro fichero package.json donde se habr\u00e1n a\u00f1adido dos nuevos par\u00e1metros: dependencies y devDependencies . La diferencia est\u00e1 en que las devDependencies solo se utilizar en la fase de desarrollo de nuestro proyecto y las dependencies se utilizar\u00e1n en todo momento. Configurar la BBDD A partir de aqu\u00ed ya podemos abrir Visual Studio Code , el IDE recomendado, y abrir la carpeta del proyecto para poder configurarlo y programarlo. Lo primero ser\u00e1 configurar el acceso con la BBDD. Para ello vamos a crear en la ra\u00edz de nuestro proyecto una carpeta config dentro de la cual crearemos un archivo llamado db.js . Este archivo exportar\u00e1 una funci\u00f3n que recibe una url de nuestra BBDD y la conectar\u00e1 con mongoose. El contenido de este archivo debe ser el siguiente: db.js import mongoose from 'mongoose' ; const connectDB = async ( url ) => { try { await mongoose . connect ( url ); console . log ( 'BBDD connected' ); } catch ( error ) { throw new Error ( 'Error initiating BBDD:' + error ); } } export default connectDB ; Ahora vamos a crear en la ra\u00edz de nuestro proyecto un archivo con el nombre .env . Este archivo tendr\u00e1 las variables de entorno de nuestro proyecto. Es aqu\u00ed donde pondremos la url que obtuvimos al crear nuestra BBDD. As\u00ed pues, crearemos una nueva variable y pegaremos la URL. Tambi\u00e9n vamos a configurar el puerto del servidor. .env MONGODB_URL = 'mongodb+srv://<user>:<pass>@<url>.mongodb.net/?retryWrites=true&w=majority' PORT = '8080' Arrancar el proyecto Con toda esa configuraci\u00f3n, ahora ya podemos crear nuestra p\u00e1gina inicial. Dentro del fichero package.json , en concreto en el contenido de main vemos que nos indica el valor de index.js . Este ser\u00e1 el punto de entrada a nuestra aplicaci\u00f3n, pero este fichero todav\u00eda no existe, as\u00ed que lo crearemos con el siguiente contenido: index.js import express from 'express' ; import cors from 'cors' ; import connectDB from './config/db.js' ; import { config } from 'dotenv' ; config (); connectDB ( process . env . MONGODB_URL ); const app = express (); app . use ( cors ({ origin : '*' })); app . listen ( process . env . PORT , () => { console . log ( `Server running on port ${ process . env . PORT } ` ); }); El funcionamiento de este c\u00f3digo, resumiendo mucho, es el siguiente. Configurar la base de datos, configurar el CORS para que posteriormente podamos realizar peticiones desde el front y crea un servidor con express en el puerto 8080 . Pero antes, para poder ejecutar nuestro servidor debemos modificar el fichero package.json , y a\u00f1adir un script de arranque. A\u00f1adiremos la siguiente l\u00ednea: \"dev\" : \"nodemon ./index.js\" Y ahora s\u00ed, desde la consola de comando ya podemos ejecutar el siguiente comando: npm run dev y ya podremos ver en la consola como la aplicaci\u00f3n ha arrancado correctamente con el mensaje que le hemos a\u00f1adido.","title":"\ud83d\udfe2 Nodejs"},{"location":"install/nodejs/#entorno-de-desarrollo-nodejs","text":"","title":"Entorno de desarrollo - Nodejs"},{"location":"install/nodejs/#instalacion-de-herramientas","text":"Las herramientas b\u00e1sicas que vamos a utilizar para esta tecnolog\u00eda son: Visual Studio Code Nodejs MongoDB Atlas Postman","title":"Instalaci\u00f3n de herramientas"},{"location":"install/nodejs/#visual-studio-code","text":"Lo primero de todo es instalar el IDE para el desarrollo en node si no lo has hecho previamente. Te recomiendo utilizar Visual Studio Code , en un IDE que a nosotros nos gusta mucho y tiene muchos plugins configurables. Puedes entrar en su p\u00e1gina y descargarte la versi\u00f3n estable.","title":"Visual Studio Code"},{"location":"install/nodejs/#nodejs","text":"El siguiente paso ser\u00e1 instalar el motor de Nodejs . Entrando en la p\u00e1gina de descargas e instalando la \u00faltima versi\u00f3n estable. Con esta herramienta podremos compilar y ejecutar aplicaciones basadas en Javascript y Typescript, e instalar y gestionar las dependencias de las aplicaciones.","title":"Nodejs"},{"location":"install/nodejs/#mongodb-atlas","text":"Tambi\u00e9n necesitaremos crear una cuenta de MongoDB Atlas para crear nuestra base de datos MongoDB en la nube. Accede a la URL , registrate gr\u00e1tis con cualquier cuenta de correo y elige el tipo de cuenta gratuita \ud83d\ude0a: Configura el cluster a tu gusto (selecciona la opci\u00f3n gratuita en el cloud que m\u00e1s te guste) y ya tendr\u00edas una BBDD en cloud para hacer pruebas. Lo primero que se muestra es el dashboard que se ver\u00e1 algo similar a lo siguiente: A continuaci\u00f3n, pulsamos en la opci\u00f3n Database del men\u00fa y, sobre el Cluster0 , pulsamos tambi\u00e9n el bot\u00f3n Connect . Se nos abrir\u00e1 el siguiente pop-up donde tendremos que elegir la opci\u00f3n Connect your application : En el siguiente paso es donde se nos muestra la url que tendremos que utilizar en nuestra aplicaci\u00f3n. La copiamos y guardamos para m\u00e1s tarde: Pulsamos Close y la BBDD ya estar\u00eda creada. Nota: Al crear la base de datos te aprecer\u00e1 un aviso para introducir tu IP en la whitelist, aseg\u00farate no estar en la VPN cuando lo hagas, de lo contrario no tendr\u00e1s conexi\u00f3n posteriormente.","title":"MongoDB Atlas"},{"location":"install/nodejs/#herramientas-para-pruebas","text":"Para poder probar las operaciones de negocio que vamos a crear, lo mejor es utilizar una herramienta que permita realizar llamadas a API Rest. Para ello te propongo utilizar Postman , en su versi\u00f3n web o en su versi\u00f3n desktop, cualquiera de las dos sirve. Con esta herramienta se puede generar peticiones GET, POST, PUT, DELETE contra el servidor y pasarle par\u00e1metros de forma muy sencilla y visual. Lo usaremos durante el tutorial.","title":"Herramientas para pruebas"},{"location":"install/nodejs/#creacion-de-proyecto","text":"Para la creaci\u00f3n de nuestro proyecto Node nos crearemos una carpeta con el nombre que deseemos y accederemos a ella con la consola de comandos de windows. Una vez dentro ejecutaremos el siguiente comando para inicializar nuestro proyecto con npm: npm init Cuando ejecutemos este comando nos pedir\u00e1 los valores para distintos par\u00e1metros de nuestro proyecto. Aconsejo solo cambiar el nombre y el resto dejarlo por defecto pulsando enter para cada valor. Una vez que hayamos terminado se nos habr\u00e1 generado un fichero package.json que contendr\u00e1 informaci\u00f3n b\u00e1sica de nuestro proyecto. Dentro de este fichero tendremos que a\u00f1adir un nuevo par\u00e1metro type con el valor module , esto nos permitir\u00e1 importar nuestros m\u00f3dulos con el est\u00e1ndar ES: { \"name\" : \"tutorialNode\" , \"version\" : \"1.0.0\" , \"description\" : \"\" , \"main\" : \"index.js\" , \"scripts\" : { \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"keywords\" : [], \"author\" : \"\" , \"license\" : \"ISC\" , \"type\" : \"module\" }","title":"Creaci\u00f3n de proyecto"},{"location":"install/nodejs/#instalar-dependencias","text":"En ese fichero aparte de la informaci\u00f3n de nuestro proyecto tambi\u00e9n tendremos que a\u00f1adir las dependencias que usara nuestra aplicaci\u00f3n. Para a\u00f1adir las dependencias, desde la consola de comandos y situados en la misma carpeta donde se haya creado el fichero package.json vamos a teclear los siguientes comandos: npm i express npm i express-validator npm i dotenv npm i mongoose npm i mongoose-paginate-v2 npm i normalize-mongoose npm i cors npm i nodemon --save-dev Tambi\u00e9n podr\u00edamos haber instalado todas a la vez en dos l\u00edneas: npm i express express-validator dotenv mongoose mongoose-paginate-v2 normalize-mongoose cors npm i nodemon --save-dev Las dependencias que acabamos de instalar son las siguientes: Express es un framework de Node que nos facilitara mucho la tarea a la hora de crear nuestra aplicaci\u00f3n. Dotenv es una librer\u00eda para usar variables de entorno. Mongoose es una librer\u00eda ODM que nos ayudara a los accesos a BBDD. Nodemon es una herramienta que nos ayuda reiniciando nuestro servidor cuando detecta un cambio en alguno de nuestros ficheros y as\u00ed no tener que hacerlo manualmente. Cors es una herramienta que nos ayuda a configurar el CORS de nuestra app para que posteriormente podemos conectarlo al front. Ahora podemos fijarnos en nuestro fichero package.json donde se habr\u00e1n a\u00f1adido dos nuevos par\u00e1metros: dependencies y devDependencies . La diferencia est\u00e1 en que las devDependencies solo se utilizar en la fase de desarrollo de nuestro proyecto y las dependencies se utilizar\u00e1n en todo momento.","title":"Instalar dependencias"},{"location":"install/nodejs/#configurar-la-bbdd","text":"A partir de aqu\u00ed ya podemos abrir Visual Studio Code , el IDE recomendado, y abrir la carpeta del proyecto para poder configurarlo y programarlo. Lo primero ser\u00e1 configurar el acceso con la BBDD. Para ello vamos a crear en la ra\u00edz de nuestro proyecto una carpeta config dentro de la cual crearemos un archivo llamado db.js . Este archivo exportar\u00e1 una funci\u00f3n que recibe una url de nuestra BBDD y la conectar\u00e1 con mongoose. El contenido de este archivo debe ser el siguiente: db.js import mongoose from 'mongoose' ; const connectDB = async ( url ) => { try { await mongoose . connect ( url ); console . log ( 'BBDD connected' ); } catch ( error ) { throw new Error ( 'Error initiating BBDD:' + error ); } } export default connectDB ; Ahora vamos a crear en la ra\u00edz de nuestro proyecto un archivo con el nombre .env . Este archivo tendr\u00e1 las variables de entorno de nuestro proyecto. Es aqu\u00ed donde pondremos la url que obtuvimos al crear nuestra BBDD. As\u00ed pues, crearemos una nueva variable y pegaremos la URL. Tambi\u00e9n vamos a configurar el puerto del servidor. .env MONGODB_URL = 'mongodb+srv://<user>:<pass>@<url>.mongodb.net/?retryWrites=true&w=majority' PORT = '8080'","title":"Configurar la BBDD"},{"location":"install/nodejs/#arrancar-el-proyecto","text":"Con toda esa configuraci\u00f3n, ahora ya podemos crear nuestra p\u00e1gina inicial. Dentro del fichero package.json , en concreto en el contenido de main vemos que nos indica el valor de index.js . Este ser\u00e1 el punto de entrada a nuestra aplicaci\u00f3n, pero este fichero todav\u00eda no existe, as\u00ed que lo crearemos con el siguiente contenido: index.js import express from 'express' ; import cors from 'cors' ; import connectDB from './config/db.js' ; import { config } from 'dotenv' ; config (); connectDB ( process . env . MONGODB_URL ); const app = express (); app . use ( cors ({ origin : '*' })); app . listen ( process . env . PORT , () => { console . log ( `Server running on port ${ process . env . PORT } ` ); }); El funcionamiento de este c\u00f3digo, resumiendo mucho, es el siguiente. Configurar la base de datos, configurar el CORS para que posteriormente podamos realizar peticiones desde el front y crea un servidor con express en el puerto 8080 . Pero antes, para poder ejecutar nuestro servidor debemos modificar el fichero package.json , y a\u00f1adir un script de arranque. A\u00f1adiremos la siguiente l\u00ednea: \"dev\" : \"nodemon ./index.js\" Y ahora s\u00ed, desde la consola de comando ya podemos ejecutar el siguiente comando: npm run dev y ya podremos ver en la consola como la aplicaci\u00f3n ha arrancado correctamente con el mensaje que le hemos a\u00f1adido.","title":"Arrancar el proyecto"},{"location":"install/springboot/","text":"Entorno de desarrollo - Spring Boot Instalaci\u00f3n de herramientas Las herramientas b\u00e1sicas que vamos a utilizar para esta tecnolog\u00eda son: Eclipse IDE Maven (viene por defecto con Eclipse IDE) Java 19 Postman Instalaci\u00f3n de IDE - Eclipse Necesitamos instalar un IDE de desarrollo, en nuestro caso ser\u00e1 Eclipse IDE y la m\u00e1quina virtual de java necesaria para ejecutar el c\u00f3digo. Recomendamos Java 19, que es la versi\u00f3n con la que est\u00e1 desarrollado y probado el tutorial. Para instalar el IDE deber\u00e1s acceder a la web de Eclipse IDE y descargarte la \u00faltima versi\u00f3n del instalador. Una vez lo ejecutes te pedir\u00e1 el tipo de instalaci\u00f3n que deseas instalar. Por lo general con la de \"Eclipse IDE for Java Developers\" es suficiente. Con esta versi\u00f3n ya tiene integrado los plugins de Maven y Git. Instalaci\u00f3n de Java Una vez instalado eclipse, debes asegurarte que est\u00e1 usando por defecto la versi\u00f3n de Java 19 y para ello deber\u00e1s instalarla. Desc\u00e1rgala del siguiente enlace . Es posible que te pida un registro de correo, utiliza el email que quieras (corporativo o personal). Revisa bien el enlace para buscar y descargar la versi\u00f3n 19 para Windows: Ya solo queda a\u00f1adir Java al Eclipse. Para ello, abre el men\u00fa Window -> Preferences : y dentro de la secci\u00f3n Java - Installed JREs a\u00f1ade la versi\u00f3n que acabas de descargar, siempre pulsando el bot\u00f3n Add... y buscando el directorio home de la instalaci\u00f3n de Java. Adem\u00e1s, la debes marcar como default . Configuraci\u00f3n de IDE - Eclipse Como complemento al Eclipse, con el fin de crear c\u00f3digo homog\u00e9neo y mantenible, vamos a configurar el formateador de c\u00f3digo autom\u00e1tico. Para ello de nuevo abrimos el men\u00fa Window -> Preferences , nos vamos a la secci\u00f3n Formatter de Java: Aqu\u00ed crearemos un nuevo perfil heredando la configuraci\u00f3n por defecto. En el nuevo perfil configuramos que se use espacios en vez de tabuladores con sangrado de 4 caracteres. Una vez cofigurado el nuevo formateador debemos activar que se aplique en el guardado. Para ello volvemos acceder a las preferencias de Eclipse y nos dirigimos a la sub secci\u00f3n Save Actions del la secci\u00f3n Editor nuevamente de Java. Aqu\u00ed aplicamos la configuraci\u00f3n deseada. Herramientas para pruebas Para poder probar las operaciones de negocio que vamos a crear, lo mejor es utilizar una herramienta que permita realizar llamadas a API Rest. Para ello te propongo utilizar Postman , en su versi\u00f3n web o en su versi\u00f3n desktop, cualquiera de las dos sirve. Con esta herramienta se puede generar peticiones GET, POST, PUT, DELETE contra el servidor y pasarle par\u00e1metros de forma muy sencilla y visual. Lo usaremos durante el tutorial. Creaci\u00f3n de proyecto La mayor\u00eda de los proyectos Spring Boot en los que trabajamos normalmente, suelen ser proyectos web sencillos con pocas dependencias de terceros o incluso proyectos basados en micro-servicios que ejecutan pocas acciones. Ahora tienes que preparar el proyecto SpringBoot, Crear con Initilizr Vamos a ver como configurar paso a paso un proyecto de cero, con las librer\u00edas que vamos a utilizar en el tutorial. \u00bfComo usarlo? Spring ha creado una p\u00e1gina interactiva que permite crear y configurar proyectos en diferentes lenguajes, con diferentes versiones de Spring Boot y a\u00f1adi\u00e9ndole los m\u00f3dulos que nosotros queramos. Esta p\u00e1gina est\u00e1 disponible desde Spring Initializr . Para seguir el ejemplo del tutorial, entraremos en la web y seleccionaremos los siguientes datos: Tipo de proyecto: Maven Lenguage: Java Versi\u00f3n Spring boot: 3.0.4 (o alguna similar) Group: com.ccsw ArtifactId: tutorial Versi\u00f3n Java: 19 Dependencias: Spring Web, Spring Data JPA, H2 Database Esto nos generar\u00e1 un proyecto que ya vendr\u00e1 configurado con Spring Web, JPA y H2 para crear una BBDD en memoria de ejemplo con la que trabajaremos durante el tutorial. Importar en eclipse El siguiente paso, es descomprimir el proyecto generado e importarlo como proyecto Maven. Abrimos el eclipse, pulsamos en File \u2192 Import y seleccionamos Existing Maven Projects . Buscamos el proyecto y le damos a importar. Configurar las dependencias Lo primero que vamos a hacer es a\u00f1adir las dependencias a algunas librer\u00edas que vamos a utilizar. Abriremos el fichero pom.xml que nos ha generado el Spring Initilizr y a\u00f1adiremos las siguientes l\u00edneas: pom.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <parent> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-parent </artifactId> <version> 3.0.4 </version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId> com.ccsw </groupId> <artifactId> tutorial </artifactId> <version> 0.0.1-SNAPSHOT </version> <name> tutorial </name> <description> Tutorial project for Spring Boot </description> <properties> <java.version> 19 </java.version> </properties> <dependencies> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-data-jpa </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-web </artifactId> </dependency> <dependency> <groupId> org.springdoc </groupId> <artifactId> springdoc-openapi-starter-webmvc-ui </artifactId> <version> 2.0.3 </version> </dependency> <dependency> <groupId> org.hibernate </groupId> <artifactId> hibernate-validator </artifactId> <version> 8.0.0.Final </version> </dependency> <dependency> <groupId> org.modelmapper </groupId> <artifactId> modelmapper </artifactId> <version> 3.1.1 </version> </dependency> <dependency> <groupId> com.h2database </groupId> <artifactId> h2 </artifactId> <scope> runtime </scope> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-test </artifactId> <scope> test </scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> </plugin> </plugins> </build> </project> Hemos a\u00f1adido las dependencias de que nos permite utilizar Open API para documentar nuestras APIs. Adem\u00e1s de esa dependencia, hemos a\u00f1adido una utilidad para hacer mapeos entre objetos y para configurar los servicios Rest. M\u00e1s adelante veremos como se utilizan. Configurar librer\u00edas El siguiente punto es crear las clases de configuraci\u00f3n para las librer\u00edas que hemos a\u00f1adido. Para ello vamos a crear un package de configuraci\u00f3n general de la aplicaci\u00f3n com.ccsw.tutorial.config donde crearemos una clase que llamaremos ModelMapperConfig y usaremos para configurar el bean de ModelMapper. ModelMapperConfig.java package com.ccsw.tutorial.config ; import org.modelmapper.ModelMapper ; import org.springframework.context.annotation.Bean ; import org.springframework.context.annotation.Configuration ; /** * @author ccsw * */ @Configuration public class ModelMapperConfig { @Bean public ModelMapper getModelMapper () { return new ModelMapper (); } } Esta configuraci\u00f3n nos permitir\u00e1 luego hacer transformaciones entre objetos de forma muy sencilla. Ya lo iremos viendo m\u00e1s adelante. Listo, ya podemos empezar a desarrollar nuestros servicios. Configurar la BBDD Por \u00faltimo, vamos a dejar configurada la BBDD en memoria. Para ello crearemos un fichero, de momento en blanco, dentro de src/main/resources/ : data.sql \u2192 Ser\u00e1 el fichero que utilizaremos para rellenar con datos iniciales el esquema de BBDD Este fichero no puede estar vac\u00edo, ya que si no dar\u00e1 un error al arrancar. Puedes a\u00f1adirle la siguiente query (que no hace nada) para que pueda arrancar el proyecto. select 1 from dual; Y ahora le vamos a decir a Spring Boot que la BBDD ser\u00e1 en memoria, que use un motor de H2 y que la cree autom\u00e1ticamente desde el modelo y que utilice el fichero data.sql (por defecto) para cargar datos en esta. Para ello hay que configurar el fichero application.properties que est\u00e1 dentro de src/main/resources/ : application.properties #Database spring.datasource.url = jdbc:h2:mem:testdb spring.datasource.username = sa spring.datasource.password = sa spring.datasource.driver-class-name = org.h2.Driver spring.jpa.database-platform = org.hibernate.dialect.H2Dialect spring.jpa.defer-datasource-initialization = true spring.jpa.show-sql = true spring.h2.console.enabled = true Arrancar el proyecto Por \u00faltimo ya solo nos queda arrancar el proyecto creado. Para ello buscaremos la clase TutorialApplication.java (o la clase principal del proyecto) y con el bot\u00f3n derecho seleccionaremos Run As \u2192 Java Application. La aplicaci\u00f3n al estar basada en Spring Boot arrancar\u00e1 internamente un Tomcat embebido donde se despliega el proyecto. Si hab\u00e9is seguido el tutorial la aplicaci\u00f3n estar\u00e1 disponible en http://localhost:8080 , aunque de momento a\u00fan no tenemos nada accesible y nos dar\u00e1 una p\u00e1gina de error Whitelabel Error Page , error 404. Eso significa que el Tomcat embedido nos ha contestado pero no sabe que devolvernos porque no hemos implementado todav\u00eda nada.","title":"\ud83d\udfe2 Spring Boot"},{"location":"install/springboot/#entorno-de-desarrollo-spring-boot","text":"","title":"Entorno de desarrollo - Spring Boot"},{"location":"install/springboot/#instalacion-de-herramientas","text":"Las herramientas b\u00e1sicas que vamos a utilizar para esta tecnolog\u00eda son: Eclipse IDE Maven (viene por defecto con Eclipse IDE) Java 19 Postman","title":"Instalaci\u00f3n de herramientas"},{"location":"install/springboot/#instalacion-de-ide-eclipse","text":"Necesitamos instalar un IDE de desarrollo, en nuestro caso ser\u00e1 Eclipse IDE y la m\u00e1quina virtual de java necesaria para ejecutar el c\u00f3digo. Recomendamos Java 19, que es la versi\u00f3n con la que est\u00e1 desarrollado y probado el tutorial. Para instalar el IDE deber\u00e1s acceder a la web de Eclipse IDE y descargarte la \u00faltima versi\u00f3n del instalador. Una vez lo ejecutes te pedir\u00e1 el tipo de instalaci\u00f3n que deseas instalar. Por lo general con la de \"Eclipse IDE for Java Developers\" es suficiente. Con esta versi\u00f3n ya tiene integrado los plugins de Maven y Git.","title":"Instalaci\u00f3n de IDE - Eclipse"},{"location":"install/springboot/#instalacion-de-java","text":"Una vez instalado eclipse, debes asegurarte que est\u00e1 usando por defecto la versi\u00f3n de Java 19 y para ello deber\u00e1s instalarla. Desc\u00e1rgala del siguiente enlace . Es posible que te pida un registro de correo, utiliza el email que quieras (corporativo o personal). Revisa bien el enlace para buscar y descargar la versi\u00f3n 19 para Windows: Ya solo queda a\u00f1adir Java al Eclipse. Para ello, abre el men\u00fa Window -> Preferences : y dentro de la secci\u00f3n Java - Installed JREs a\u00f1ade la versi\u00f3n que acabas de descargar, siempre pulsando el bot\u00f3n Add... y buscando el directorio home de la instalaci\u00f3n de Java. Adem\u00e1s, la debes marcar como default .","title":"Instalaci\u00f3n de Java"},{"location":"install/springboot/#configuracion-de-ide-eclipse","text":"Como complemento al Eclipse, con el fin de crear c\u00f3digo homog\u00e9neo y mantenible, vamos a configurar el formateador de c\u00f3digo autom\u00e1tico. Para ello de nuevo abrimos el men\u00fa Window -> Preferences , nos vamos a la secci\u00f3n Formatter de Java: Aqu\u00ed crearemos un nuevo perfil heredando la configuraci\u00f3n por defecto. En el nuevo perfil configuramos que se use espacios en vez de tabuladores con sangrado de 4 caracteres. Una vez cofigurado el nuevo formateador debemos activar que se aplique en el guardado. Para ello volvemos acceder a las preferencias de Eclipse y nos dirigimos a la sub secci\u00f3n Save Actions del la secci\u00f3n Editor nuevamente de Java. Aqu\u00ed aplicamos la configuraci\u00f3n deseada.","title":"Configuraci\u00f3n de IDE - Eclipse"},{"location":"install/springboot/#herramientas-para-pruebas","text":"Para poder probar las operaciones de negocio que vamos a crear, lo mejor es utilizar una herramienta que permita realizar llamadas a API Rest. Para ello te propongo utilizar Postman , en su versi\u00f3n web o en su versi\u00f3n desktop, cualquiera de las dos sirve. Con esta herramienta se puede generar peticiones GET, POST, PUT, DELETE contra el servidor y pasarle par\u00e1metros de forma muy sencilla y visual. Lo usaremos durante el tutorial.","title":"Herramientas para pruebas"},{"location":"install/springboot/#creacion-de-proyecto","text":"La mayor\u00eda de los proyectos Spring Boot en los que trabajamos normalmente, suelen ser proyectos web sencillos con pocas dependencias de terceros o incluso proyectos basados en micro-servicios que ejecutan pocas acciones. Ahora tienes que preparar el proyecto SpringBoot,","title":"Creaci\u00f3n de proyecto"},{"location":"install/springboot/#crear-con-initilizr","text":"Vamos a ver como configurar paso a paso un proyecto de cero, con las librer\u00edas que vamos a utilizar en el tutorial.","title":"Crear con Initilizr"},{"location":"install/springboot/#como-usarlo","text":"Spring ha creado una p\u00e1gina interactiva que permite crear y configurar proyectos en diferentes lenguajes, con diferentes versiones de Spring Boot y a\u00f1adi\u00e9ndole los m\u00f3dulos que nosotros queramos. Esta p\u00e1gina est\u00e1 disponible desde Spring Initializr . Para seguir el ejemplo del tutorial, entraremos en la web y seleccionaremos los siguientes datos: Tipo de proyecto: Maven Lenguage: Java Versi\u00f3n Spring boot: 3.0.4 (o alguna similar) Group: com.ccsw ArtifactId: tutorial Versi\u00f3n Java: 19 Dependencias: Spring Web, Spring Data JPA, H2 Database Esto nos generar\u00e1 un proyecto que ya vendr\u00e1 configurado con Spring Web, JPA y H2 para crear una BBDD en memoria de ejemplo con la que trabajaremos durante el tutorial.","title":"\u00bfComo usarlo?"},{"location":"install/springboot/#importar-en-eclipse","text":"El siguiente paso, es descomprimir el proyecto generado e importarlo como proyecto Maven. Abrimos el eclipse, pulsamos en File \u2192 Import y seleccionamos Existing Maven Projects . Buscamos el proyecto y le damos a importar.","title":"Importar en eclipse"},{"location":"install/springboot/#configurar-las-dependencias","text":"Lo primero que vamos a hacer es a\u00f1adir las dependencias a algunas librer\u00edas que vamos a utilizar. Abriremos el fichero pom.xml que nos ha generado el Spring Initilizr y a\u00f1adiremos las siguientes l\u00edneas: pom.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <parent> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-parent </artifactId> <version> 3.0.4 </version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId> com.ccsw </groupId> <artifactId> tutorial </artifactId> <version> 0.0.1-SNAPSHOT </version> <name> tutorial </name> <description> Tutorial project for Spring Boot </description> <properties> <java.version> 19 </java.version> </properties> <dependencies> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-data-jpa </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-web </artifactId> </dependency> <dependency> <groupId> org.springdoc </groupId> <artifactId> springdoc-openapi-starter-webmvc-ui </artifactId> <version> 2.0.3 </version> </dependency> <dependency> <groupId> org.hibernate </groupId> <artifactId> hibernate-validator </artifactId> <version> 8.0.0.Final </version> </dependency> <dependency> <groupId> org.modelmapper </groupId> <artifactId> modelmapper </artifactId> <version> 3.1.1 </version> </dependency> <dependency> <groupId> com.h2database </groupId> <artifactId> h2 </artifactId> <scope> runtime </scope> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-test </artifactId> <scope> test </scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> </plugin> </plugins> </build> </project> Hemos a\u00f1adido las dependencias de que nos permite utilizar Open API para documentar nuestras APIs. Adem\u00e1s de esa dependencia, hemos a\u00f1adido una utilidad para hacer mapeos entre objetos y para configurar los servicios Rest. M\u00e1s adelante veremos como se utilizan.","title":"Configurar las dependencias"},{"location":"install/springboot/#configurar-librerias","text":"El siguiente punto es crear las clases de configuraci\u00f3n para las librer\u00edas que hemos a\u00f1adido. Para ello vamos a crear un package de configuraci\u00f3n general de la aplicaci\u00f3n com.ccsw.tutorial.config donde crearemos una clase que llamaremos ModelMapperConfig y usaremos para configurar el bean de ModelMapper. ModelMapperConfig.java package com.ccsw.tutorial.config ; import org.modelmapper.ModelMapper ; import org.springframework.context.annotation.Bean ; import org.springframework.context.annotation.Configuration ; /** * @author ccsw * */ @Configuration public class ModelMapperConfig { @Bean public ModelMapper getModelMapper () { return new ModelMapper (); } } Esta configuraci\u00f3n nos permitir\u00e1 luego hacer transformaciones entre objetos de forma muy sencilla. Ya lo iremos viendo m\u00e1s adelante. Listo, ya podemos empezar a desarrollar nuestros servicios.","title":"Configurar librer\u00edas"},{"location":"install/springboot/#configurar-la-bbdd","text":"Por \u00faltimo, vamos a dejar configurada la BBDD en memoria. Para ello crearemos un fichero, de momento en blanco, dentro de src/main/resources/ : data.sql \u2192 Ser\u00e1 el fichero que utilizaremos para rellenar con datos iniciales el esquema de BBDD Este fichero no puede estar vac\u00edo, ya que si no dar\u00e1 un error al arrancar. Puedes a\u00f1adirle la siguiente query (que no hace nada) para que pueda arrancar el proyecto. select 1 from dual; Y ahora le vamos a decir a Spring Boot que la BBDD ser\u00e1 en memoria, que use un motor de H2 y que la cree autom\u00e1ticamente desde el modelo y que utilice el fichero data.sql (por defecto) para cargar datos en esta. Para ello hay que configurar el fichero application.properties que est\u00e1 dentro de src/main/resources/ : application.properties #Database spring.datasource.url = jdbc:h2:mem:testdb spring.datasource.username = sa spring.datasource.password = sa spring.datasource.driver-class-name = org.h2.Driver spring.jpa.database-platform = org.hibernate.dialect.H2Dialect spring.jpa.defer-datasource-initialization = true spring.jpa.show-sql = true spring.h2.console.enabled = true","title":"Configurar la BBDD"},{"location":"install/springboot/#arrancar-el-proyecto","text":"Por \u00faltimo ya solo nos queda arrancar el proyecto creado. Para ello buscaremos la clase TutorialApplication.java (o la clase principal del proyecto) y con el bot\u00f3n derecho seleccionaremos Run As \u2192 Java Application. La aplicaci\u00f3n al estar basada en Spring Boot arrancar\u00e1 internamente un Tomcat embebido donde se despliega el proyecto. Si hab\u00e9is seguido el tutorial la aplicaci\u00f3n estar\u00e1 disponible en http://localhost:8080 , aunque de momento a\u00fan no tenemos nada accesible y nos dar\u00e1 una p\u00e1gina de error Whitelabel Error Page , error 404. Eso significa que el Tomcat embedido nos ha contestado pero no sabe que devolvernos porque no hemos implementado todav\u00eda nada.","title":"Arrancar el proyecto"},{"location":"install/vuejs/","text":"Entorno de desarrollo - Vue.js Instalaci\u00f3n de herramientas Las herramientas b\u00e1sicas que vamos a utilizar para esta tecnolog\u00eda son: Visual Studio Code Nodejs Visual Studio Code Lo primero de todo es instalar el IDE para el desarrollo front. Te recomiendo utilizar Visual Studio Code , en un IDE que a nosotros nos gusta mucho y tiene muchos plugins configurables. Puedes entrar en su p\u00e1gina y descargarte la versi\u00f3n estable. Nodejs El siguiente paso ser\u00e1 instalar el motor de Nodejs . Entrando en la p\u00e1gina de descargas e instalando la \u00faltima versi\u00f3n estable. Con esta herramienta podremos compilar y ejecutar aplicaciones basadas en Javascript y Typescript, e instalar y gestionar las dependencias de las aplicaciones. Creaci\u00f3n de proyecto Preparar versiones Lo primero tienes que estar seguro de tener tu versi\u00f3n de node actualizada para poder instalar Vue, para saber la versi\u00f3n de Node que tenemos actualmente nos iremos a la consola y escribiremos: node -v Nos deber\u00eda salir algo como esto: Donde el v16.17.0 es nuestra versi\u00f3n de node, una vez sabemos esto podemos ir a Nodejs y ver la versi\u00f3n de node recomendada: En el momento de escribir este tutorial, seria la 18.16.0 por lo que no estar\u00eda de mas actualizarla. Crear scaffold Una vez esta parte la tenemos y comprobamos que hemos subido bien la versi\u00f3n de node con node -v , ya podemos hacer el scaffold de la aplicacion. Hacer el scaffold de una aplicaci\u00f3n es un t\u00e9rmino que se utiliza en el desarrollo de software para describir el proceso de generar autom\u00e1ticamente la estructura b\u00e1sica de una aplicaci\u00f3n, incluyendo archivos y directorios, modelos de datos, controladores y vistas. El objetivo del proceso de scaffolding es ayudar a los desarrolladores a poner en marcha r\u00e1pidamente una nueva aplicaci\u00f3n, proporcion\u00e1ndoles una base s\u00f3lida sobre la que puedan construir el resto de la aplicaci\u00f3n. En muchos casos, los desarrolladores pueden personalizar f\u00e1cilmente la estructura generada por el scaffold para adaptarla a sus necesidades espec\u00edficas. Crear un proyecto de Vue.js o hacer el scaffold es muy sencillo. Lo primero abrir una consola de msdos y posicionarte en el directorio raiz donde quieres crear tu proyecto Vue, y ejecutamos lo siguiente: npm init vue@latest Este comando instalar\u00e1 y ejecutar\u00e1 create-vue , la herramienta oficial de scaffolding de Vue. Se presentar\u00e1n indicaciones para varias funciones opcionales, como TypeScript o Testing, algo similar a esto: Y tendremos que elegir lo siguiente: Project name: El nombre que te gustar\u00eda darle al proyecto Add TypeScript? (y/N) Yes Add JSX Support (y/N) No Add Vue.js Router for Single Page Application development? (y/N) Yes Add Pinia for state management? (y/N) No Add Vitest for Unit testing? (y/N) No Add an End-to-End Testing Solution? No Add ESLint for code quality? (y/N) Yes Add Prettier for code formatting? Yes Y ahora la explicaci\u00f3n de cada uno de los puntos anteriormente vistos. Add JSX Support (y/N) JSX es una extensi\u00f3n de sintaxis para JavaScript que permite escribir una marca similar a HTML dentro de un archivo de JavaScript. B\u00e1sicamente, JSX es una funci\u00f3n de renderizado de JavaScript que te ayuda a insertar tu HTML directamente en tu c\u00f3digo de JavaScript. Sintaxis de plantillas: Una sintaxis de plantilla basada en HTML que te permite enlazar declarativamente el DOM renderizado con los datos de la instancia del componente subyacente. El uso de las plantillas Vue.js es similar al uso de JSX, ya que ambas se crean utilizando JavaScript. La principal diferencia es que las plantillas Vue.js son sint\u00e1cticamente HTML v\u00e1lido que puede ser analizado por navegadores y analizadores de HTML compatibles con las especificaciones. \u00bfQu\u00e9 significa esto? Las funciones JSX nunca se usan en el archivo HTML real, mientras que las plantillas Vue.js s\u00ed. \u00bfCu\u00e1l es la diferencia? \u00bfCu\u00e1l es mejor usar? Seg\u00fan la documentaci\u00f3n de Vue.js, compila las plantillas en c\u00f3digo JavaScript altamente optimizado. Pero si est\u00e1s familiarizado con los conceptos de Virtual DOM y prefieres la potencia de JavaScript, tambi\u00e9n puedes escribir directamente funciones de renderizado en lugar de plantillas, con soporte opcional para JSX. Sin embargo, debes tener en cuenta que no disfrutan del mismo nivel de optimizaciones en tiempo de compilaci\u00f3n que las plantillas. Por lo tanto, podemos concluir que escribir la sintaxis de plantillas con Vue.js es m\u00e1s optimizado y por lo tanto la respuesta seria no a\u00f1adir jsx Add Vue.js Router for Single Page Application development? (y/N) Cuando estamos trabajando en una aplicaci\u00f3n y vamos a hacer uso de las rutas deberemos indicar que s\u00ed queremos a\u00f1adir el router. Si la idea es solo meter en un div algo de Vue.js y no vamos a tener enrutado no. Add Pinia for state management? (y/N) Uffff, la maquina de estados, de momento le decimos que no y mas adelante seguro que alg\u00fan d\u00eda nos tocara pelearnos con ella. Add Vitest for Unit testing? (y/N) Vitest es una librer\u00eda de testing desarrollada sobre vite, la alternativa a webpack que usa VUE. Si vamos ha hacer test unitarios en la aplicaci\u00f3n es una muy buena alternativa por lo que seria un yes, si no estamos seguros podemos a\u00f1adirla luego sin ning\u00fan problema. Add an End-to-End Testing Solution? Lo mismo que antes, la podemos instalar luego, en principio diremos que no aunque los test en todos los proyectos son muy necesarios. Add ESLint for code quality? (y/N) Add Prettier for code formatting? Ambas dos nos sirve para mejorar la calidad de nuestro c\u00f3digo. En conjunto dejan un c\u00f3digo muy bonito si se saben configurar bien, Vue.js ya lo trae con las opciones b\u00e1sicas configuradas, luego tu puedes variarlas tanto en prettier como en ESLint para adaptarlas a tus necesidades. Arrancar el proyecto Cuando todo ha terminado el propio scaffolding te dice lo que tienes que hacer para poner el proyecto en marcha y ver lo que te ha generado, solo tienes que seguir esos pasos: Con npm install instalamos todos los paquetes node que necesitamos para el proyecto. Con npm run format ejecutaremos Prettier en el directorio src/ y sobrescribir\u00e1 los archivos de c\u00f3digo fuente existentes con el nuevo formato. Con npm run dev podremos en marcha la aplicaci\u00f3n y al ponerse en marcha nos aparecer\u00e1 esto: Lo que quiere decir que si en el navegador nos vamos a http://localhost:5173/ podremos ver nuestra aplicaci\u00f3n Vue.js funcionando. Info Si durante el desarrollo del proyecto necesitas a\u00f1adir nuevos m\u00f3dulos al proyecto Vue.js, ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor de dependencias de Nodejs, directamente en consola ejecuta el comando npm install y descargar\u00e1 e instalar\u00e1 las nuevas dependencias.. Proyecto descargado Cuando se trata de un proyecto nuevo recien descargado de un repositorio, recuerda que ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor de dependencias de Nodejs, directamente en consola ejecuta el comando npm install y descargar\u00e1 e instalar\u00e1 las nuevas dependencias. Comandos de consola Si necesitas m\u00e1s informaci\u00f3n sobre, por ejemplo, usar Vue.js desde el CDN puedes acceder a la informaci\u00f3n oficial en: https://vuejs.org/guide/quick-start.html","title":"Entorno de desarrollo - Vue.js"},{"location":"install/vuejs/#entorno-de-desarrollo-vuejs","text":"","title":"Entorno de desarrollo - Vue.js"},{"location":"install/vuejs/#instalacion-de-herramientas","text":"Las herramientas b\u00e1sicas que vamos a utilizar para esta tecnolog\u00eda son: Visual Studio Code Nodejs","title":"Instalaci\u00f3n de herramientas"},{"location":"install/vuejs/#visual-studio-code","text":"Lo primero de todo es instalar el IDE para el desarrollo front. Te recomiendo utilizar Visual Studio Code , en un IDE que a nosotros nos gusta mucho y tiene muchos plugins configurables. Puedes entrar en su p\u00e1gina y descargarte la versi\u00f3n estable.","title":"Visual Studio Code"},{"location":"install/vuejs/#nodejs","text":"El siguiente paso ser\u00e1 instalar el motor de Nodejs . Entrando en la p\u00e1gina de descargas e instalando la \u00faltima versi\u00f3n estable. Con esta herramienta podremos compilar y ejecutar aplicaciones basadas en Javascript y Typescript, e instalar y gestionar las dependencias de las aplicaciones.","title":"Nodejs"},{"location":"install/vuejs/#creacion-de-proyecto","text":"","title":"Creaci\u00f3n de proyecto"},{"location":"install/vuejs/#preparar-versiones","text":"Lo primero tienes que estar seguro de tener tu versi\u00f3n de node actualizada para poder instalar Vue, para saber la versi\u00f3n de Node que tenemos actualmente nos iremos a la consola y escribiremos: node -v Nos deber\u00eda salir algo como esto: Donde el v16.17.0 es nuestra versi\u00f3n de node, una vez sabemos esto podemos ir a Nodejs y ver la versi\u00f3n de node recomendada: En el momento de escribir este tutorial, seria la 18.16.0 por lo que no estar\u00eda de mas actualizarla.","title":"Preparar versiones"},{"location":"install/vuejs/#crear-scaffold","text":"Una vez esta parte la tenemos y comprobamos que hemos subido bien la versi\u00f3n de node con node -v , ya podemos hacer el scaffold de la aplicacion. Hacer el scaffold de una aplicaci\u00f3n es un t\u00e9rmino que se utiliza en el desarrollo de software para describir el proceso de generar autom\u00e1ticamente la estructura b\u00e1sica de una aplicaci\u00f3n, incluyendo archivos y directorios, modelos de datos, controladores y vistas. El objetivo del proceso de scaffolding es ayudar a los desarrolladores a poner en marcha r\u00e1pidamente una nueva aplicaci\u00f3n, proporcion\u00e1ndoles una base s\u00f3lida sobre la que puedan construir el resto de la aplicaci\u00f3n. En muchos casos, los desarrolladores pueden personalizar f\u00e1cilmente la estructura generada por el scaffold para adaptarla a sus necesidades espec\u00edficas. Crear un proyecto de Vue.js o hacer el scaffold es muy sencillo. Lo primero abrir una consola de msdos y posicionarte en el directorio raiz donde quieres crear tu proyecto Vue, y ejecutamos lo siguiente: npm init vue@latest Este comando instalar\u00e1 y ejecutar\u00e1 create-vue , la herramienta oficial de scaffolding de Vue. Se presentar\u00e1n indicaciones para varias funciones opcionales, como TypeScript o Testing, algo similar a esto: Y tendremos que elegir lo siguiente: Project name: El nombre que te gustar\u00eda darle al proyecto Add TypeScript? (y/N) Yes Add JSX Support (y/N) No Add Vue.js Router for Single Page Application development? (y/N) Yes Add Pinia for state management? (y/N) No Add Vitest for Unit testing? (y/N) No Add an End-to-End Testing Solution? No Add ESLint for code quality? (y/N) Yes Add Prettier for code formatting? Yes Y ahora la explicaci\u00f3n de cada uno de los puntos anteriormente vistos. Add JSX Support (y/N) JSX es una extensi\u00f3n de sintaxis para JavaScript que permite escribir una marca similar a HTML dentro de un archivo de JavaScript. B\u00e1sicamente, JSX es una funci\u00f3n de renderizado de JavaScript que te ayuda a insertar tu HTML directamente en tu c\u00f3digo de JavaScript. Sintaxis de plantillas: Una sintaxis de plantilla basada en HTML que te permite enlazar declarativamente el DOM renderizado con los datos de la instancia del componente subyacente. El uso de las plantillas Vue.js es similar al uso de JSX, ya que ambas se crean utilizando JavaScript. La principal diferencia es que las plantillas Vue.js son sint\u00e1cticamente HTML v\u00e1lido que puede ser analizado por navegadores y analizadores de HTML compatibles con las especificaciones. \u00bfQu\u00e9 significa esto? Las funciones JSX nunca se usan en el archivo HTML real, mientras que las plantillas Vue.js s\u00ed. \u00bfCu\u00e1l es la diferencia? \u00bfCu\u00e1l es mejor usar? Seg\u00fan la documentaci\u00f3n de Vue.js, compila las plantillas en c\u00f3digo JavaScript altamente optimizado. Pero si est\u00e1s familiarizado con los conceptos de Virtual DOM y prefieres la potencia de JavaScript, tambi\u00e9n puedes escribir directamente funciones de renderizado en lugar de plantillas, con soporte opcional para JSX. Sin embargo, debes tener en cuenta que no disfrutan del mismo nivel de optimizaciones en tiempo de compilaci\u00f3n que las plantillas. Por lo tanto, podemos concluir que escribir la sintaxis de plantillas con Vue.js es m\u00e1s optimizado y por lo tanto la respuesta seria no a\u00f1adir jsx Add Vue.js Router for Single Page Application development? (y/N) Cuando estamos trabajando en una aplicaci\u00f3n y vamos a hacer uso de las rutas deberemos indicar que s\u00ed queremos a\u00f1adir el router. Si la idea es solo meter en un div algo de Vue.js y no vamos a tener enrutado no. Add Pinia for state management? (y/N) Uffff, la maquina de estados, de momento le decimos que no y mas adelante seguro que alg\u00fan d\u00eda nos tocara pelearnos con ella. Add Vitest for Unit testing? (y/N) Vitest es una librer\u00eda de testing desarrollada sobre vite, la alternativa a webpack que usa VUE. Si vamos ha hacer test unitarios en la aplicaci\u00f3n es una muy buena alternativa por lo que seria un yes, si no estamos seguros podemos a\u00f1adirla luego sin ning\u00fan problema. Add an End-to-End Testing Solution? Lo mismo que antes, la podemos instalar luego, en principio diremos que no aunque los test en todos los proyectos son muy necesarios. Add ESLint for code quality? (y/N) Add Prettier for code formatting? Ambas dos nos sirve para mejorar la calidad de nuestro c\u00f3digo. En conjunto dejan un c\u00f3digo muy bonito si se saben configurar bien, Vue.js ya lo trae con las opciones b\u00e1sicas configuradas, luego tu puedes variarlas tanto en prettier como en ESLint para adaptarlas a tus necesidades.","title":"Crear scaffold"},{"location":"install/vuejs/#arrancar-el-proyecto","text":"Cuando todo ha terminado el propio scaffolding te dice lo que tienes que hacer para poner el proyecto en marcha y ver lo que te ha generado, solo tienes que seguir esos pasos: Con npm install instalamos todos los paquetes node que necesitamos para el proyecto. Con npm run format ejecutaremos Prettier en el directorio src/ y sobrescribir\u00e1 los archivos de c\u00f3digo fuente existentes con el nuevo formato. Con npm run dev podremos en marcha la aplicaci\u00f3n y al ponerse en marcha nos aparecer\u00e1 esto: Lo que quiere decir que si en el navegador nos vamos a http://localhost:5173/ podremos ver nuestra aplicaci\u00f3n Vue.js funcionando. Info Si durante el desarrollo del proyecto necesitas a\u00f1adir nuevos m\u00f3dulos al proyecto Vue.js, ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor de dependencias de Nodejs, directamente en consola ejecuta el comando npm install y descargar\u00e1 e instalar\u00e1 las nuevas dependencias.. Proyecto descargado Cuando se trata de un proyecto nuevo recien descargado de un repositorio, recuerda que ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor de dependencias de Nodejs, directamente en consola ejecuta el comando npm install y descargar\u00e1 e instalar\u00e1 las nuevas dependencias. Comandos de consola Si necesitas m\u00e1s informaci\u00f3n sobre, por ejemplo, usar Vue.js desde el CDN puedes acceder a la informaci\u00f3n oficial en: https://vuejs.org/guide/quick-start.html","title":"Arrancar el proyecto"}]}