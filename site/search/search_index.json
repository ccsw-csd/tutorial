{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenido! Si est\u00e1s leyendo esto es porque tienes mucha fuerza de voluntad y unas enormes ganas de aprender a desarrollar con el stack tecnol\u00f3gico de devonfw (Java Spring Boot + Angular) o porque te han mandando hacer este tutorial en tu etapa de formaci\u00f3n. En cualquier caso, te agradecemos el esfuerzo que est\u00e1s haciendo y te deseamos suerte . Por favor, si detectas que hay algo incorrecto en el tutorial, que no funciona o que est\u00e1 mal escrito, contacta con nosotros para que podamos solventarlo para futuras lecturas. Escr\u00edbenos un issue aqu\u00ed . \u00bfQue vamos a hacer? Durante este tutorial, vamos a crear una aplicaci\u00f3n web paso a paso con Spring Boot para la parte servidora y con Angular para la parte frontal. Intentar\u00e9 comentar todo lo m\u00e1s detallado posible, pero si echas en falta alguna explicaci\u00f3n por favor, escr\u00edbenos un issue aqu\u00ed para que podamos a\u00f1adirla. \u00bfComo lo vamos a hacer? En primer lugar te comentar\u00e9 brevemente las herramientas que usaremos en el tutorial y la forma de instalarlas (altamente recomendado). Luego veremos un vistazo general de lo que vamos a construir para que tengas un contexto general de la aplicaci\u00f3n. Y por \u00faltimo desarrollaremos paso a paso el back y el front de la aplicaci\u00f3n. Durante todo el tutorial intentar\u00e9 dar unas pautas y consejos de buenas pr\u00e1cticas que todos deber\u00edamos adoptar, en la medida de lo posible, para homogeneizar el desarrollo de todos los proyectos. \u00bfY luego qu\u00e9? Pues al final del tutorial, expondremos unos ejercicios pr\u00e1cticos para que los resuelvas tu mismo, aplicando los conocimientos adquiridos en el tutorial. Para ver si has comprendido correctamente todo lo aqu\u00ed descrito. No te preocupes, no es un examen Recomendaciones Te recomiendo que leas todo el tutorial, que no te saltes ning\u00fan punto y si se hace referencia a los anexos, que los visites y los leas tambi\u00e9n. Si tan solo copias y pegas, no ser\u00e1s capaz de hacer el \u00faltimo ejercicio por ti mismo. Debes leer y comprender lo que se est\u00e1 haciendo. Adem\u00e1s, los anexos est\u00e1n ah\u00ed por algo, sirven para completar informaci\u00f3n y para que conozcas los motivos por los que estamos programando as\u00ed el tutorial. Por favor, \u00e9chales un ojo tambi\u00e9n cuando te lo indique. Por \u00faltimo, \u00a1no te olvides! Cuando lo tengas todo listo, por favor no te olvides de subir los proyectos a alg\u00fan repositorio Github propio y av\u00edsanos para que podamos echarle un ojo y darte sugerencias y feedback .","title":"Bienvenido!"},{"location":"#bienvenido","text":"Si est\u00e1s leyendo esto es porque tienes mucha fuerza de voluntad y unas enormes ganas de aprender a desarrollar con el stack tecnol\u00f3gico de devonfw (Java Spring Boot + Angular) o porque te han mandando hacer este tutorial en tu etapa de formaci\u00f3n. En cualquier caso, te agradecemos el esfuerzo que est\u00e1s haciendo y te deseamos suerte . Por favor, si detectas que hay algo incorrecto en el tutorial, que no funciona o que est\u00e1 mal escrito, contacta con nosotros para que podamos solventarlo para futuras lecturas. Escr\u00edbenos un issue aqu\u00ed .","title":"Bienvenido!"},{"location":"#que-vamos-a-hacer","text":"Durante este tutorial, vamos a crear una aplicaci\u00f3n web paso a paso con Spring Boot para la parte servidora y con Angular para la parte frontal. Intentar\u00e9 comentar todo lo m\u00e1s detallado posible, pero si echas en falta alguna explicaci\u00f3n por favor, escr\u00edbenos un issue aqu\u00ed para que podamos a\u00f1adirla.","title":"\u00bfQue vamos a hacer?"},{"location":"#como-lo-vamos-a-hacer","text":"En primer lugar te comentar\u00e9 brevemente las herramientas que usaremos en el tutorial y la forma de instalarlas (altamente recomendado). Luego veremos un vistazo general de lo que vamos a construir para que tengas un contexto general de la aplicaci\u00f3n. Y por \u00faltimo desarrollaremos paso a paso el back y el front de la aplicaci\u00f3n. Durante todo el tutorial intentar\u00e9 dar unas pautas y consejos de buenas pr\u00e1cticas que todos deber\u00edamos adoptar, en la medida de lo posible, para homogeneizar el desarrollo de todos los proyectos.","title":"\u00bfComo lo vamos a hacer?"},{"location":"#y-luego-que","text":"Pues al final del tutorial, expondremos unos ejercicios pr\u00e1cticos para que los resuelvas tu mismo, aplicando los conocimientos adquiridos en el tutorial. Para ver si has comprendido correctamente todo lo aqu\u00ed descrito. No te preocupes, no es un examen","title":"\u00bfY luego qu\u00e9?"},{"location":"#recomendaciones","text":"Te recomiendo que leas todo el tutorial, que no te saltes ning\u00fan punto y si se hace referencia a los anexos, que los visites y los leas tambi\u00e9n. Si tan solo copias y pegas, no ser\u00e1s capaz de hacer el \u00faltimo ejercicio por ti mismo. Debes leer y comprender lo que se est\u00e1 haciendo. Adem\u00e1s, los anexos est\u00e1n ah\u00ed por algo, sirven para completar informaci\u00f3n y para que conozcas los motivos por los que estamos programando as\u00ed el tutorial. Por favor, \u00e9chales un ojo tambi\u00e9n cuando te lo indique.","title":"Recomendaciones"},{"location":"#por-ultimo-no-te-olvides","text":"Cuando lo tengas todo listo, por favor no te olvides de subir los proyectos a alg\u00fan repositorio Github propio y av\u00edsanos para que podamos echarle un ojo y darte sugerencias y feedback .","title":"Por \u00faltimo, \u00a1no te olvides!"},{"location":"cleancode/","text":"Estructura de proyecto y Clean Code Angular Nota Antes de empezar y para puntualizar, Angular se considera un framework SPA Single-page application. En esta parte vamos a explicar los fundamentos de un proyecto en Angular y las recomendaciones existentes. Estructura y funcionamiento Ciclo de vida de Angular El comportamiento de ciclo de vida de un componente Angular pasa por diferentes etapas que podemos ver en el esquema que mostramos a continuaci\u00f3n: Es importante tenerlo claro para saber que m\u00e9todos podemos utilizar para realizar operaciones con el componente. Carpetas creadas por Angular Al crear una aplicaci\u00f3n Angular, tendremos los siguientes directorios: node_modules: Todos los m\u00f3dulos de librar\u00edas usado por el proyecto. \\src\\app: Contiene todo el c\u00f3digo asociado al proyecto. \\src\\assets: Normalmente la carpeta usada para los recursos. \\src\\environments: Aqu\u00ed ir\u00e1n los ficheros relacionados con los entornos de desarrollos. Otros ficheros importantes de un proyecto de Angular Otros archivos que debemos tener en cuenta dentro del proyecto son: angular.json: Configuraci\u00f3n del propio CLI. La madre de todos los configuradores package.json: Dependencias de librer\u00edas y scripts Estructura de m\u00f3dulos Existe m\u00faltiples consensos al respecto de como estructurar un proyecto en Angular, pero al final, depende de los requisitos del proyecto. Una sugerencia de como hacerlo es la siguiente: - src\\app - core /* Componentes y utilidades comunes */ - header /* Estructura del header */ - footer /* Estructura del footer */ - domain1 /* M\u00f3dulo con los componentes del dominio1 */ - services /* Servicios con operaciones del dominio1 */ - models /* Modelos de datos del dominio1 */ - component1 /* Componente1 del dominio1 */ - componentX /* ComponenteX del dominio1 */ - domainX /* As\u00ed para el resto de dominios de la aplicaci\u00f3n */ Recordar, que esto es una sugerencia para una estructura de carpetas y componentes. No existe un estandar. ATENCI\u00d3N: Componentes gen\u00e9ricos Debemos tener en cuenta que a la hora de programar un componente core , lo ideal es pensar que sea un componente plug & play, es decir que si lo copias y lo llevas a otro proyecto funcione sin la necesidad de adaptarlo. Buenas pr\u00e1cticas y Clean Code A continuaci\u00f3n veremos un listado de buenas pr\u00e1cticas de Angular y de c\u00f3digo limpio que deber\u00edamos intentar seguir en nuestro desarrollo. Estructura de archivos Antes de empezar con un proyecto lo ideal, es pararse y pensar en los requerimientos de una buena estructura, en un futuro lo agradecer\u00e1s. Nombres claros Utilizar la S de los principios S.O.L.I.D para los nombres de variables, m\u00e9todos y dem\u00e1s c\u00f3digo. El efecto que produce este principio son clases con nombres muy descriptivos y por tanto largos. Tambi\u00e9n se recomienta utilizar kebab-case para los nombres de ficheros. Ej. hero-button.component.ts Organiza tu c\u00f3digo Intenta organizar tu c\u00f3digo fuente: Lo m\u00e1s importante debe ir arriba. Primero propiedades, despu\u00e9s m\u00e9todos. Un Item para un archivo : cada archivo deber\u00eda contener solamente un componente, al igual que los servicios. Solo una responsabilidad : Cada clase o modulo deber\u00eda tener solamente una responsabilidad. El nombre correcto : las propiedades y m\u00e9todos deber\u00edan usar el sistema de camel case (ej: getUserByName) , al contrario, las clases (componentes, servicios, etc) deben usar upper camel case (ej: UserComponent) . Los componentes y servicios deben tener su respectivo sufijo: UserComponent, UserService. Imports : los archivos externos van primero. Usar linters Prettier & ESLint Un linter es una herramienta que nos ayuda a seguir las buenas pr\u00e1cticas o gu\u00edas de estilo de nuestro c\u00f3digo fuente. En este caso, para JavaScript, proveeremos de unos muy famosos. Una de las m\u00e1s famosas es la combinaci\u00f3n de Angular app to ESLint with Prettier, AirBnB Styleguide Recordar que a\u00f1adir este tipo de configuraci\u00f3n es opcional, pero necesaria para tener un buen c\u00f3digo de calidad. Git Hooks Los Git Hooks son scripts de shell que se ejecutan autom\u00e1ticamente antes o despu\u00e9s de que Git ejecute un comando importante como Commit o Push. Para hacer uso de el es tan sencillo como: npm install husky --save-dev Y a\u00f1adir en el fichero lo siguiente: // package.json { \"husky\" : { \"hooks\" : { \"pre-commit\" : \"npm test\" , \"pre-push\" : \"npm test\" , \"...\" : \"...\" } } } Usar husky para el preformateo de c\u00f3digo antes de subirlo Es una buena pr\u00e1ctica que todo el equipo use el mismo est\u00e1ndar de formateo de codigo, con husky se puede solucionar. Utilizar Banana in the Box Como el nombre sugiere banana in the box se debe a la forma que tiene lo siguiente: [{}] Esto es una forma muy sencilla de trabajar los cambios en la forma de Two ways binding. Es decir, el padre informa de un valor u objeto y el hijo lo manipula y actualiza el estado/valor al padre inmediatamente. La forma de implementarlo es sencillo Padre: HTML: <my-input [(text)]=\"text\"></my-input> Hijo @ Input () value : string ; @ Output () valueChange = new EventEmitter < string > (); updateValue ( value ){ this . value = value ; this . valueChange . emit ( value ); } Prefijo Change Destacar que el prefijo 'Change' es necesario incluirlo en el Hijo para que funcione Correcto uso de los servicios Una buena practica es aconsejable no declarar los servicios en el provides, sino usar un decorador que forma parte de las ultimas versiones de Angular @ Injectable ({ providedIn : 'root' , }) export class HeroService { constructor () { } } Lazy Load Lazy Load es un patr\u00f3n de dise\u00f1o que consiste en retrasar la carga o inicializaci\u00f3n desde el app-routing.module.ts A\u00f1adiremos un codigo parecido a este { path : 'customers' , loadChildren : () => import ( './customers/customers.module' ). then ( m => m . CustomersModule ) }, Con esto veremos que el m\u00f3dulo se cargar\u00e1 seg\u00fan se necesite. Springboot Estructura Aqu\u00ed tampoco existe nada estandarizado y oficial que hable sobre estructura de proyectos y nomenclatura de Springboot. Tan solo existen algunas sugerencias y buenas pr\u00e1cticas a la hora de desarrollar que te recomiendo que utilices en la medida de lo posible. Tip Piensa que el c\u00f3digo fuente que escribes hoy, es como un libro que se leer\u00e1 durante a\u00f1os. Alguien tendr\u00e1 que coger tu c\u00f3digo y leerlo en unos meses o a\u00f1os para hacer alguna modificaci\u00f3n y, como buenos desarrolladores que somos, tenemos la obligaci\u00f3n de facilitarle en todo lo posible la comprensi\u00f3n de ese c\u00f3digo fuente. Quiz\u00e1 esa persona futura podr\u00edas ser tu en unos meses y quedar\u00eda muy mal que no entendieras ni tu propio c\u00f3digo Estructura en capas Todos los proyectos web que construimos basados en Springboot se caracterizan por estar divididos en tres capas (a menos que utilicemos DDD para desarrollar que entonces existen infinitas capas ). Controlador . Es la capa m\u00e1s alta, la que tiene acceso directo con el cliente. En esta capa es donde se exponen las operaciones que queremos publicar y que el cliente puede consumir. Para realizar sus operaciones lo m\u00e1s normal es que realice llamadas a las clases de la capa inmediatamente inferior. L\u00f3gica . Tambi\u00e9n llamada capa de Servicios . Es la capa intermedia que da soporte a las operaciones que est\u00e1n expuestas y ejecutan toda la l\u00f3gica de negocio de la aplicaci\u00f3n. Para realizar sus operaciones puede realizar llamadas tanto a otras clases dentro de esta capa, como a clases de la capa inferior. Acceso a Datos . Como su nombre indica, es la capa que accede a datos. T\u00edpicamente es la capa que ejecuta las consultas contra BBDD, pero esto no tiene por qu\u00e9 ser obligadamente as\u00ed. Tambi\u00e9n entrar\u00edan en esa capa aquellas clases que consumen datos externos, por ejemplo de un servidor externo. Las clases de esta capa deben ser nodos finales , no pueden llamar a ninguna otra clase para ejecutar sus operaciones, ni siquiera de su misma capa. Estructura de proyecto En proyectos medianos o grandes, estructurar los directorios del proyecto en base a la estructura anteriormente descrita ser\u00eda muy complejo, ya que en cada uno de los niveles tendr\u00edamos muchas clases. Otras entidades Consejos sobre la estructura En base a esta divisi\u00f3n por capas que hemos comentado y el resto de entidades implicadas, hay una serie de reglas important\u00edsimas que debes seguir muy de cerca: Un Controlador NO debe contener l\u00f3gica en su clase. Solo est\u00e1 permitido que ejecute l\u00f3gica a trav\u00e9s de un objeto de la capa L\u00f3gica . NO puede ejecutar directamente operaciones de la capa Aceso a Datos , siempre debe pasar por la capa L\u00f3gica . NO debe enviar ni recibir del cliente objetos de tipo Entity . Es un buen lugar para realizar las conversiones de datos entre Entity y Dto . En teor\u00eda cada operaci\u00f3n deber\u00eda tener su propio Dto, aunque los podemos reutilizar entre operaciones similares. Debemos seguir una coherencia entre todas las URL de las operaciones. Por ejemplo si elegimos save para guardar, usemos esa palabra en todas las operaciones que sean de ese tipo. Evitad utilizar diferentes palabras save , guardar , persistir , actualizar para la misma acci\u00f3n. Un Servicio NO puede llamar a objetos de la la capa Controlador .","title":"Estructura y Clean Code"},{"location":"cleancode/#estructura-de-proyecto-y-clean-code","text":"","title":"Estructura de proyecto y Clean Code"},{"location":"cleancode/#angular","text":"Nota Antes de empezar y para puntualizar, Angular se considera un framework SPA Single-page application. En esta parte vamos a explicar los fundamentos de un proyecto en Angular y las recomendaciones existentes.","title":"Angular"},{"location":"cleancode/#estructura-y-funcionamiento","text":"","title":"Estructura y funcionamiento"},{"location":"cleancode/#ciclo-de-vida-de-angular","text":"El comportamiento de ciclo de vida de un componente Angular pasa por diferentes etapas que podemos ver en el esquema que mostramos a continuaci\u00f3n: Es importante tenerlo claro para saber que m\u00e9todos podemos utilizar para realizar operaciones con el componente.","title":"Ciclo de vida de Angular"},{"location":"cleancode/#carpetas-creadas-por-angular","text":"Al crear una aplicaci\u00f3n Angular, tendremos los siguientes directorios: node_modules: Todos los m\u00f3dulos de librar\u00edas usado por el proyecto. \\src\\app: Contiene todo el c\u00f3digo asociado al proyecto. \\src\\assets: Normalmente la carpeta usada para los recursos. \\src\\environments: Aqu\u00ed ir\u00e1n los ficheros relacionados con los entornos de desarrollos. Otros ficheros importantes de un proyecto de Angular Otros archivos que debemos tener en cuenta dentro del proyecto son: angular.json: Configuraci\u00f3n del propio CLI. La madre de todos los configuradores package.json: Dependencias de librer\u00edas y scripts","title":"Carpetas creadas por Angular"},{"location":"cleancode/#estructura-de-modulos","text":"Existe m\u00faltiples consensos al respecto de como estructurar un proyecto en Angular, pero al final, depende de los requisitos del proyecto. Una sugerencia de como hacerlo es la siguiente: - src\\app - core /* Componentes y utilidades comunes */ - header /* Estructura del header */ - footer /* Estructura del footer */ - domain1 /* M\u00f3dulo con los componentes del dominio1 */ - services /* Servicios con operaciones del dominio1 */ - models /* Modelos de datos del dominio1 */ - component1 /* Componente1 del dominio1 */ - componentX /* ComponenteX del dominio1 */ - domainX /* As\u00ed para el resto de dominios de la aplicaci\u00f3n */ Recordar, que esto es una sugerencia para una estructura de carpetas y componentes. No existe un estandar. ATENCI\u00d3N: Componentes gen\u00e9ricos Debemos tener en cuenta que a la hora de programar un componente core , lo ideal es pensar que sea un componente plug & play, es decir que si lo copias y lo llevas a otro proyecto funcione sin la necesidad de adaptarlo.","title":"Estructura de m\u00f3dulos"},{"location":"cleancode/#buenas-practicas-y-clean-code","text":"A continuaci\u00f3n veremos un listado de buenas pr\u00e1cticas de Angular y de c\u00f3digo limpio que deber\u00edamos intentar seguir en nuestro desarrollo.","title":"Buenas pr\u00e1cticas y Clean Code"},{"location":"cleancode/#estructura-de-archivos","text":"Antes de empezar con un proyecto lo ideal, es pararse y pensar en los requerimientos de una buena estructura, en un futuro lo agradecer\u00e1s.","title":"Estructura de archivos"},{"location":"cleancode/#nombres-claros","text":"Utilizar la S de los principios S.O.L.I.D para los nombres de variables, m\u00e9todos y dem\u00e1s c\u00f3digo. El efecto que produce este principio son clases con nombres muy descriptivos y por tanto largos. Tambi\u00e9n se recomienta utilizar kebab-case para los nombres de ficheros. Ej. hero-button.component.ts","title":"Nombres claros"},{"location":"cleancode/#organiza-tu-codigo","text":"Intenta organizar tu c\u00f3digo fuente: Lo m\u00e1s importante debe ir arriba. Primero propiedades, despu\u00e9s m\u00e9todos. Un Item para un archivo : cada archivo deber\u00eda contener solamente un componente, al igual que los servicios. Solo una responsabilidad : Cada clase o modulo deber\u00eda tener solamente una responsabilidad. El nombre correcto : las propiedades y m\u00e9todos deber\u00edan usar el sistema de camel case (ej: getUserByName) , al contrario, las clases (componentes, servicios, etc) deben usar upper camel case (ej: UserComponent) . Los componentes y servicios deben tener su respectivo sufijo: UserComponent, UserService. Imports : los archivos externos van primero.","title":"Organiza tu c\u00f3digo"},{"location":"cleancode/#usar-linters-prettier-eslint","text":"Un linter es una herramienta que nos ayuda a seguir las buenas pr\u00e1cticas o gu\u00edas de estilo de nuestro c\u00f3digo fuente. En este caso, para JavaScript, proveeremos de unos muy famosos. Una de las m\u00e1s famosas es la combinaci\u00f3n de Angular app to ESLint with Prettier, AirBnB Styleguide Recordar que a\u00f1adir este tipo de configuraci\u00f3n es opcional, pero necesaria para tener un buen c\u00f3digo de calidad.","title":"Usar linters Prettier &amp; ESLint"},{"location":"cleancode/#git-hooks","text":"Los Git Hooks son scripts de shell que se ejecutan autom\u00e1ticamente antes o despu\u00e9s de que Git ejecute un comando importante como Commit o Push. Para hacer uso de el es tan sencillo como: npm install husky --save-dev Y a\u00f1adir en el fichero lo siguiente: // package.json { \"husky\" : { \"hooks\" : { \"pre-commit\" : \"npm test\" , \"pre-push\" : \"npm test\" , \"...\" : \"...\" } } } Usar husky para el preformateo de c\u00f3digo antes de subirlo Es una buena pr\u00e1ctica que todo el equipo use el mismo est\u00e1ndar de formateo de codigo, con husky se puede solucionar.","title":"Git Hooks"},{"location":"cleancode/#utilizar-banana-in-the-box","text":"Como el nombre sugiere banana in the box se debe a la forma que tiene lo siguiente: [{}] Esto es una forma muy sencilla de trabajar los cambios en la forma de Two ways binding. Es decir, el padre informa de un valor u objeto y el hijo lo manipula y actualiza el estado/valor al padre inmediatamente. La forma de implementarlo es sencillo Padre: HTML: <my-input [(text)]=\"text\"></my-input> Hijo @ Input () value : string ; @ Output () valueChange = new EventEmitter < string > (); updateValue ( value ){ this . value = value ; this . valueChange . emit ( value ); } Prefijo Change Destacar que el prefijo 'Change' es necesario incluirlo en el Hijo para que funcione","title":"Utilizar Banana in the Box"},{"location":"cleancode/#correcto-uso-de-los-servicios","text":"Una buena practica es aconsejable no declarar los servicios en el provides, sino usar un decorador que forma parte de las ultimas versiones de Angular @ Injectable ({ providedIn : 'root' , }) export class HeroService { constructor () { } }","title":"Correcto uso de los servicios"},{"location":"cleancode/#lazy-load","text":"Lazy Load es un patr\u00f3n de dise\u00f1o que consiste en retrasar la carga o inicializaci\u00f3n desde el app-routing.module.ts A\u00f1adiremos un codigo parecido a este { path : 'customers' , loadChildren : () => import ( './customers/customers.module' ). then ( m => m . CustomersModule ) }, Con esto veremos que el m\u00f3dulo se cargar\u00e1 seg\u00fan se necesite.","title":"Lazy Load"},{"location":"cleancode/#springboot","text":"","title":"Springboot"},{"location":"cleancode/#estructura","text":"Aqu\u00ed tampoco existe nada estandarizado y oficial que hable sobre estructura de proyectos y nomenclatura de Springboot. Tan solo existen algunas sugerencias y buenas pr\u00e1cticas a la hora de desarrollar que te recomiendo que utilices en la medida de lo posible. Tip Piensa que el c\u00f3digo fuente que escribes hoy, es como un libro que se leer\u00e1 durante a\u00f1os. Alguien tendr\u00e1 que coger tu c\u00f3digo y leerlo en unos meses o a\u00f1os para hacer alguna modificaci\u00f3n y, como buenos desarrolladores que somos, tenemos la obligaci\u00f3n de facilitarle en todo lo posible la comprensi\u00f3n de ese c\u00f3digo fuente. Quiz\u00e1 esa persona futura podr\u00edas ser tu en unos meses y quedar\u00eda muy mal que no entendieras ni tu propio c\u00f3digo","title":"Estructura"},{"location":"cleancode/#estructura-en-capas","text":"Todos los proyectos web que construimos basados en Springboot se caracterizan por estar divididos en tres capas (a menos que utilicemos DDD para desarrollar que entonces existen infinitas capas ). Controlador . Es la capa m\u00e1s alta, la que tiene acceso directo con el cliente. En esta capa es donde se exponen las operaciones que queremos publicar y que el cliente puede consumir. Para realizar sus operaciones lo m\u00e1s normal es que realice llamadas a las clases de la capa inmediatamente inferior. L\u00f3gica . Tambi\u00e9n llamada capa de Servicios . Es la capa intermedia que da soporte a las operaciones que est\u00e1n expuestas y ejecutan toda la l\u00f3gica de negocio de la aplicaci\u00f3n. Para realizar sus operaciones puede realizar llamadas tanto a otras clases dentro de esta capa, como a clases de la capa inferior. Acceso a Datos . Como su nombre indica, es la capa que accede a datos. T\u00edpicamente es la capa que ejecuta las consultas contra BBDD, pero esto no tiene por qu\u00e9 ser obligadamente as\u00ed. Tambi\u00e9n entrar\u00edan en esa capa aquellas clases que consumen datos externos, por ejemplo de un servidor externo. Las clases de esta capa deben ser nodos finales , no pueden llamar a ninguna otra clase para ejecutar sus operaciones, ni siquiera de su misma capa.","title":"Estructura en capas"},{"location":"cleancode/#estructura-de-proyecto","text":"En proyectos medianos o grandes, estructurar los directorios del proyecto en base a la estructura anteriormente descrita ser\u00eda muy complejo, ya que en cada uno de los niveles tendr\u00edamos muchas clases.","title":"Estructura de proyecto"},{"location":"cleancode/#otras-entidades","text":"","title":"Otras entidades"},{"location":"cleancode/#consejos-sobre-la-estructura","text":"En base a esta divisi\u00f3n por capas que hemos comentado y el resto de entidades implicadas, hay una serie de reglas important\u00edsimas que debes seguir muy de cerca: Un Controlador NO debe contener l\u00f3gica en su clase. Solo est\u00e1 permitido que ejecute l\u00f3gica a trav\u00e9s de un objeto de la capa L\u00f3gica . NO puede ejecutar directamente operaciones de la capa Aceso a Datos , siempre debe pasar por la capa L\u00f3gica . NO debe enviar ni recibir del cliente objetos de tipo Entity . Es un buen lugar para realizar las conversiones de datos entre Entity y Dto . En teor\u00eda cada operaci\u00f3n deber\u00eda tener su propio Dto, aunque los podemos reutilizar entre operaciones similares. Debemos seguir una coherencia entre todas las URL de las operaciones. Por ejemplo si elegimos save para guardar, usemos esa palabra en todas las operaciones que sean de ese tipo. Evitad utilizar diferentes palabras save , guardar , persistir , actualizar para la misma acci\u00f3n. Un Servicio NO puede llamar a objetos de la la capa Controlador .","title":"Consejos sobre la estructura"},{"location":"create/","text":"Creaci\u00f3n de proyecto Por lo general necesitaremos un m\u00ednimo de dos proyectos para desarrollar una aplicaci\u00f3n: Por un lado tendremos un proyecto Springboot que se ejecutar\u00e1 en un servidor de aplicaciones, tipo Tomcat. Este proyecto tendr\u00e1 la l\u00f3gica de negocio de las operaciones, el acceso a los datos de la BBDD y cualquier integraci\u00f3n con servicios de terceros. La forma de exponer estas operaciones de negocio ser\u00e1 mediante endpoints de acceso, en concreto llamadas tipo REST. Por otro lado tendremos un proyecto Angular que se ejecutar\u00e1 en un servidor web de ficheros est\u00e1ticos, tipo Apache. Este proyecto ser\u00e1 c\u00f3digo javascript, css y html, que se ejecutar\u00e1 en el navegador Web y que realizar\u00e1 ciertas operaciones sencillas y validaciones en local y llamadas a nuestro servidor Springboot para ejecutar las operaciones de negocio. Puede haber otro tipo de proyectos dentro de la aplicaci\u00f3n, sobretodo si est\u00e1n basados en microservicios o tienen componentes batch, pero estos proyectos no vamos a verlos en el tutorial. Consejo Como norma cada uno de los proyectos que componen la aplicaci\u00f3n, deber\u00eda estar conectado a un repositorio de c\u00f3digo diferente para poder evolucionar y trabajar con cada uno de ellos de forma aislada sin afectar a los dem\u00e1s. As\u00ed adem\u00e1s podemos tener equipos aislados que trabajen con cada uno de los proyectos por separado. Info Durante todo el tutorial, voy a intentar separar la construcci\u00f3n del proyecto Angular de la construcci\u00f3n del proyecto Springboot, para terminar haciendo una integraci\u00f3n entre los dos. De esta forma podr\u00e1s comprobar como se puede desarrollar por separado cada uno de los dos proyectos sin ning\u00fan problema. Creaci\u00f3n de proyecto Angular La mayor\u00eda de los proyectos con Angular en los que trabajamos normalmente, suelen ser proyectos web usando las librer\u00edas mas comunes de angular, como angular material. Para crear un proyecto de Angular, es necesario tener instalado el CLI de Angular. Si no lo tienes instalado, por favor, acude a la secci\u00f3n Entorno de desarrollo y verifica que tienes instalado todo lo necesario. Nuevo proyecto Lo primero es crear un proyecto desde la consola mediante la herramienta Angular CLI. Para ello abrimos una consola de msdos donde tengamos instalado y enlazado Angular CLI, nos situamos en el directorio donde vamos a crear el proyecto y ejecutamos: ng new tutorial --strict=false Nos realizar\u00e1 varias preguntas. Would you like to add Angular routing? (y/N) Preferiblemente: y Which stylesheet format would you like to use? Preferiblemente: SCSS En el caso del tutorial como vamos a tener dos proyectos para nuestra aplicaci\u00f3n (front y back), para poder seguir correctamente las explicaciones, voy a renombrar la carpeta para poder diferenciarla del otro proyecto. A partir de ahora se llamar\u00e1 client . Info Si durante el desarrollo del proyecto necesitas a\u00f1adir nuevos m\u00f3dulos al proyecto Angular, ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor yarn (que es m\u00e1s eficiente que el propio gestio de npm), directamente en consola ejecuta el comando yarn y descargar\u00e1 e instalar\u00e1 las nuevas dependencias. Arrancar el proyecto Para arrancar el proyecto, tan solo necesitamos ejecutar en consola el siguiente comando siempre dentro del directorio creado por Angular CLI: ng serve Angular compilar\u00e1 el c\u00f3digo fuente, levantar\u00e1 un servidor local al que podremos acceder por defecto mediante la URL: http://localhost:4200/ Y ya podemos empezar a trabajar con Angular. Comandos de Angular CLI Si necesitas m\u00e1s informaci\u00f3n sobre los comandos que ofrece Angular CLI para poder crear aplicaciones, componentes, servicios, etc. los tienes disponibles en: https://angular.io/cli#command-overview Creaci\u00f3n de proyecto Springboot La mayor\u00eda de los proyectos Springboot en los que trabajamos normalmente, suelen ser proyectos web sencillos con pocas dependencias de terceros o incluso proyectos basados en microservicios que ejecutan pocas acciones. Ahora tienes dos formas de preparar el proyecto Springboot, descritas a continuaci\u00f3n. Escoge una de ellas, la que m\u00e1s te guste. (R\u00e1pido) - Uso de plantilla base Puedes descargarte una plantilla ya construida , con un proyecto generado a partir de Sprint Initializr y configurada con los pasos detallados en los puntos siguientes y as\u00ed te ahorras tiempo. Importar en eclipse El siguiente paso, ovbiamente es descomprimir el proyecto generado e importarlo como proyecto Maven. Abrimos el eclipse, pulsamos en File \u2192 Import y seleccionamos Existing Maven Projects . Buscamos el proyecto y le damos a importar. Con esto ya tendr\u00edamos todo configurado. (Detallado) - Crear con Initilizr Si has hecho el punto anterior, no es necesario que leas esto. Salta directamente al \u00faltimo punto de Arrancar el proyecto . Si sigues leyendo ver\u00e1s como configurar paso a paso un proyecto de cero, con las librer\u00edas que vamos a utilizar en el tutorial. \u00bfComo usarlo? Spring ha creado una p\u00e1gina interactiva que permite crear y configurar proyectos en diferentes lenguajes, con diferentes versiones de Spring Boot y a\u00f1adiendole los m\u00f3dulos que nosotros queramos. Esta p\u00e1gina est\u00e1 disponible desde Spring Initializr . Para seguir el ejemplo del tutorial, entraremos en la web y seleccionaremos los siguientes datos: Tipo de proyecto: Maven Lenguage: Java Versi\u00f3n Spring boot: 2.4.4 Group: com.capgemini.ccsw ArtifactId: tutorial Versi\u00f3n Java: 8 Dependencias: Spring Web, H2 Database Esto nos generar\u00e1 un proyecto que ya vendr\u00e1 configurado con Spring Web y H2 para crear una BBDD en memoria de ejemplo con la que trabajaremos durante el tutorial. Importar en eclipse El siguiente paso, ovbiamente es descomprimir el proyecto generado e importarlo como proyecto Maven. Abrimos el eclipse, pulsamos en File \u2192 Import y seleccionamos Existing Maven Projects . Buscamos el proyecto y le damos a importar. Configurar las dependencias Lo primero que vamos a hacer es a\u00f1adir las dependencias a librer\u00edas de devonfw. Abriremos el fichero pom.xml que nos ha generado el Spring Initilizr y a\u00f1adiremos las siguientes l\u00edneas: pom.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <parent> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-parent </artifactId> <version> 2.4.4 </version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId> com.capgemini.ccsw </groupId> <artifactId> tutorial </artifactId> <version> 0.0.1-SNAPSHOT </version> <name> tutorial </name> <description> Demo project for Spring Boot </description> <properties> <java.version> 1.8 </java.version> <devon4j.version> 2021.04.003 </devon4j.version> </properties> <dependencyManagement> <dependencies> <!-- BOM of devon4j --> <dependency> <groupId> com.devonfw.java.boms </groupId> <artifactId> devon4j-bom </artifactId> <version> ${devon4j.version} </version> <type> pom </type> <scope> import </scope> </dependency> </dependencies> </dependencyManagement> <dependencies> <!-- Bean-Mapping for conversion from TO to Entity and vice versa --> <dependency> <groupId> com.devonfw.java.modules </groupId> <artifactId> devon4j-beanmapping-orika </artifactId> </dependency> <!-- Rest Mappers --> <dependency> <groupId> com.devonfw.java.modules </groupId> <artifactId> devon4j-rest </artifactId> </dependency> <!-- JPA --> <dependency> <groupId> com.devonfw.java.starters </groupId> <artifactId> devon4j-starter-spring-data-jpa </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-web </artifactId> </dependency> <dependency> <groupId> com.h2database </groupId> <artifactId> h2 </artifactId> <scope> runtime </scope> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-test </artifactId> <scope> test </scope> <exclusions> <exclusion> <groupId> org.junit.vintage </groupId> <artifactId> junit-vintage-engine </artifactId> </exclusion> </exclusions> </dependency> </dependencies> <build> <plugins> <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> </plugin> </plugins> </build> </project> Hemos a\u00f1adido las dependencias de Devonfw-JPA ya que nos permite utilizar m\u00e1s funcionalidades extendidas sobre repositorios JPA. Adem\u00e1s de esa dependencia, hemos a\u00f1adido una utilidad para hacer mapeos entre objetos y para configurar los servicios Rest. Uso de defonfw Vamos a utilizar algunas librer\u00edas de devonfw (fwk Opensource desarrollado por Capgemini, entre otros) que nos facilitan la vida a la hora de desarrollar una aplicaci\u00f3n. Podr\u00edamos hacerlo directamente con los m\u00f3dulos de Spring pero hay ciertas utilidades que nos interesa usar de devonfw. Para m\u00e1s informaci\u00f3n puedes consultar su Web Oficial Configurar librerias devonfw El siguiente punto es crear las clases de configuraci\u00f3n para las librer\u00edas que hemos a\u00f1adido. Para ello vamos a crear un package de configuraci\u00f3n general de la aplicaci\u00f3n com.capgemini.ccsw.tutorial.config donde crearemos tres clases (dos de ellas dentro del subpaquete mapper ). BeansOrikaConfig.java mapper/BeanMapper.java mapper/BeanMapperImpl.java package com.capgemini.ccsw.tutorial.config ; import org.springframework.context.annotation.Bean ; import org.springframework.context.annotation.Configuration ; import com.capgemini.ccsw.tutorial.config.mapper.BeanMapper ; import com.capgemini.ccsw.tutorial.config.mapper.BeanMapperImpl ; import com.devonfw.module.beanmapping.common.base.BaseOrikaConfig ; import com.devonfw.module.json.common.base.ObjectMapperFactory ; import com.fasterxml.jackson.databind.Module ; import ma.glasnost.orika.MapperFactory ; /** * Java bean configuration for Orika. The method {@link #configureCustomMapping(MapperFactory)} from * {@link BaseOrikaConfig} can be overridden as per requirements. * @author ccsw */ @Configuration public class BeansOrikaConfig extends BaseOrikaConfig { /** * @return the {@link BeanMapper} implementation. */ @Override @Bean public BeanMapper getBeanMapper () { return new BeanMapperImpl (); } @Bean public Module configureObjectMapper () { ObjectMapperFactory objectMapper = new ObjectMapperFactory (); return objectMapper . getExtensionModule (); } } package com.capgemini.ccsw.tutorial.config.mapper ; import org.springframework.data.domain.Page ; /** * @author ccsw */ public interface BeanMapper extends com . devonfw . module . beanmapping . common . api . BeanMapper { /** * Mapea el gen\u00e9rico de un Page en otro tipo de gen\u00e9rico * @param <T> * @param source * @param targetClass * @return */ < T > Page < T > mapPage ( Page <?> source , Class < T > targetClass ); } package com.capgemini.ccsw.tutorial.config.mapper ; import java.util.List ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.PageImpl ; import com.devonfw.module.beanmapping.common.impl.orika.BeanMapperImplOrika ; /** * @author ccsw */ public class BeanMapperImpl extends BeanMapperImplOrika implements BeanMapper { /** * {@inheritDoc} */ public < T > Page < T > mapPage ( Page <?> source , Class < T > targetClass ) { if ( source == null ) { return null ; } List < T > list = mapList ( source . getContent (), targetClass ); return new PageImpl <> ( list , source . getPageable (), source . getTotalElements ()); } } Listo, ya podemos empezar a desarrollar nuestros servicios. Configurar la BBDD Por \u00faltimo, vamos a dejar configurada la BBDD en memoria. Para ello crearemos dos ficheros, de momento en blanco, dentro de src/main/resources/ : schema.sql \u2192 Ser\u00e1 el fichero que utilizaremos para crear el esquema de BBDD data.sql \u2192 Ser\u00e1 el fichero que utilizaremos para rellenar con datos iniciales el esquema de BBDD Estos ficheros no pueden estar vac\u00edos ya que si no dar\u00e1 un error al arrancar. Puedes a\u00f1adirle la siguiente query (que no hace nada) para que pueda arrancar el proyecto. select 1 from dual; Arrancar el proyecto Por \u00faltimo ya solo nos queda arrancar el proyecto creado. Para ello buscaremos la clase TutorialApplication.java (o la clase principal del proyecto) y con el bot\u00f3n derecho seleccionaremos Run As \u2192 Java Application. La aplicaci\u00f3n al estar basada en Springboot arrancar\u00e1 internamente un Tomcat embebido donde se despliegar\u00e1 el proyecto. Si hab\u00e9is seguido el tutorial la aplicaci\u00f3n estar\u00e1 disponible en http://localhost:8080 , aunque de momento aun no tenemos nada accesible.","title":"Creaci\u00f3n de proyecto"},{"location":"create/#creacion-de-proyecto","text":"Por lo general necesitaremos un m\u00ednimo de dos proyectos para desarrollar una aplicaci\u00f3n: Por un lado tendremos un proyecto Springboot que se ejecutar\u00e1 en un servidor de aplicaciones, tipo Tomcat. Este proyecto tendr\u00e1 la l\u00f3gica de negocio de las operaciones, el acceso a los datos de la BBDD y cualquier integraci\u00f3n con servicios de terceros. La forma de exponer estas operaciones de negocio ser\u00e1 mediante endpoints de acceso, en concreto llamadas tipo REST. Por otro lado tendremos un proyecto Angular que se ejecutar\u00e1 en un servidor web de ficheros est\u00e1ticos, tipo Apache. Este proyecto ser\u00e1 c\u00f3digo javascript, css y html, que se ejecutar\u00e1 en el navegador Web y que realizar\u00e1 ciertas operaciones sencillas y validaciones en local y llamadas a nuestro servidor Springboot para ejecutar las operaciones de negocio. Puede haber otro tipo de proyectos dentro de la aplicaci\u00f3n, sobretodo si est\u00e1n basados en microservicios o tienen componentes batch, pero estos proyectos no vamos a verlos en el tutorial. Consejo Como norma cada uno de los proyectos que componen la aplicaci\u00f3n, deber\u00eda estar conectado a un repositorio de c\u00f3digo diferente para poder evolucionar y trabajar con cada uno de ellos de forma aislada sin afectar a los dem\u00e1s. As\u00ed adem\u00e1s podemos tener equipos aislados que trabajen con cada uno de los proyectos por separado. Info Durante todo el tutorial, voy a intentar separar la construcci\u00f3n del proyecto Angular de la construcci\u00f3n del proyecto Springboot, para terminar haciendo una integraci\u00f3n entre los dos. De esta forma podr\u00e1s comprobar como se puede desarrollar por separado cada uno de los dos proyectos sin ning\u00fan problema.","title":"Creaci\u00f3n de proyecto"},{"location":"create/#creacion-de-proyecto-angular","text":"La mayor\u00eda de los proyectos con Angular en los que trabajamos normalmente, suelen ser proyectos web usando las librer\u00edas mas comunes de angular, como angular material. Para crear un proyecto de Angular, es necesario tener instalado el CLI de Angular. Si no lo tienes instalado, por favor, acude a la secci\u00f3n Entorno de desarrollo y verifica que tienes instalado todo lo necesario.","title":"Creaci\u00f3n de proyecto Angular"},{"location":"create/#nuevo-proyecto","text":"Lo primero es crear un proyecto desde la consola mediante la herramienta Angular CLI. Para ello abrimos una consola de msdos donde tengamos instalado y enlazado Angular CLI, nos situamos en el directorio donde vamos a crear el proyecto y ejecutamos: ng new tutorial --strict=false Nos realizar\u00e1 varias preguntas. Would you like to add Angular routing? (y/N) Preferiblemente: y Which stylesheet format would you like to use? Preferiblemente: SCSS En el caso del tutorial como vamos a tener dos proyectos para nuestra aplicaci\u00f3n (front y back), para poder seguir correctamente las explicaciones, voy a renombrar la carpeta para poder diferenciarla del otro proyecto. A partir de ahora se llamar\u00e1 client . Info Si durante el desarrollo del proyecto necesitas a\u00f1adir nuevos m\u00f3dulos al proyecto Angular, ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor yarn (que es m\u00e1s eficiente que el propio gestio de npm), directamente en consola ejecuta el comando yarn y descargar\u00e1 e instalar\u00e1 las nuevas dependencias.","title":"Nuevo proyecto"},{"location":"create/#arrancar-el-proyecto","text":"Para arrancar el proyecto, tan solo necesitamos ejecutar en consola el siguiente comando siempre dentro del directorio creado por Angular CLI: ng serve Angular compilar\u00e1 el c\u00f3digo fuente, levantar\u00e1 un servidor local al que podremos acceder por defecto mediante la URL: http://localhost:4200/ Y ya podemos empezar a trabajar con Angular. Comandos de Angular CLI Si necesitas m\u00e1s informaci\u00f3n sobre los comandos que ofrece Angular CLI para poder crear aplicaciones, componentes, servicios, etc. los tienes disponibles en: https://angular.io/cli#command-overview","title":"Arrancar el proyecto"},{"location":"create/#creacion-de-proyecto-springboot","text":"La mayor\u00eda de los proyectos Springboot en los que trabajamos normalmente, suelen ser proyectos web sencillos con pocas dependencias de terceros o incluso proyectos basados en microservicios que ejecutan pocas acciones. Ahora tienes dos formas de preparar el proyecto Springboot, descritas a continuaci\u00f3n. Escoge una de ellas, la que m\u00e1s te guste.","title":"Creaci\u00f3n de proyecto Springboot"},{"location":"create/#rapido-uso-de-plantilla-base","text":"Puedes descargarte una plantilla ya construida , con un proyecto generado a partir de Sprint Initializr y configurada con los pasos detallados en los puntos siguientes y as\u00ed te ahorras tiempo.","title":"(R\u00e1pido) - Uso de plantilla base"},{"location":"create/#importar-en-eclipse","text":"El siguiente paso, ovbiamente es descomprimir el proyecto generado e importarlo como proyecto Maven. Abrimos el eclipse, pulsamos en File \u2192 Import y seleccionamos Existing Maven Projects . Buscamos el proyecto y le damos a importar. Con esto ya tendr\u00edamos todo configurado.","title":"Importar en eclipse"},{"location":"create/#detallado-crear-con-initilizr","text":"Si has hecho el punto anterior, no es necesario que leas esto. Salta directamente al \u00faltimo punto de Arrancar el proyecto . Si sigues leyendo ver\u00e1s como configurar paso a paso un proyecto de cero, con las librer\u00edas que vamos a utilizar en el tutorial.","title":"(Detallado) - Crear con Initilizr"},{"location":"create/#como-usarlo","text":"Spring ha creado una p\u00e1gina interactiva que permite crear y configurar proyectos en diferentes lenguajes, con diferentes versiones de Spring Boot y a\u00f1adiendole los m\u00f3dulos que nosotros queramos. Esta p\u00e1gina est\u00e1 disponible desde Spring Initializr . Para seguir el ejemplo del tutorial, entraremos en la web y seleccionaremos los siguientes datos: Tipo de proyecto: Maven Lenguage: Java Versi\u00f3n Spring boot: 2.4.4 Group: com.capgemini.ccsw ArtifactId: tutorial Versi\u00f3n Java: 8 Dependencias: Spring Web, H2 Database Esto nos generar\u00e1 un proyecto que ya vendr\u00e1 configurado con Spring Web y H2 para crear una BBDD en memoria de ejemplo con la que trabajaremos durante el tutorial.","title":"\u00bfComo usarlo?"},{"location":"create/#importar-en-eclipse_1","text":"El siguiente paso, ovbiamente es descomprimir el proyecto generado e importarlo como proyecto Maven. Abrimos el eclipse, pulsamos en File \u2192 Import y seleccionamos Existing Maven Projects . Buscamos el proyecto y le damos a importar.","title":"Importar en eclipse"},{"location":"create/#configurar-las-dependencias","text":"Lo primero que vamos a hacer es a\u00f1adir las dependencias a librer\u00edas de devonfw. Abriremos el fichero pom.xml que nos ha generado el Spring Initilizr y a\u00f1adiremos las siguientes l\u00edneas: pom.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <parent> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-parent </artifactId> <version> 2.4.4 </version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId> com.capgemini.ccsw </groupId> <artifactId> tutorial </artifactId> <version> 0.0.1-SNAPSHOT </version> <name> tutorial </name> <description> Demo project for Spring Boot </description> <properties> <java.version> 1.8 </java.version> <devon4j.version> 2021.04.003 </devon4j.version> </properties> <dependencyManagement> <dependencies> <!-- BOM of devon4j --> <dependency> <groupId> com.devonfw.java.boms </groupId> <artifactId> devon4j-bom </artifactId> <version> ${devon4j.version} </version> <type> pom </type> <scope> import </scope> </dependency> </dependencies> </dependencyManagement> <dependencies> <!-- Bean-Mapping for conversion from TO to Entity and vice versa --> <dependency> <groupId> com.devonfw.java.modules </groupId> <artifactId> devon4j-beanmapping-orika </artifactId> </dependency> <!-- Rest Mappers --> <dependency> <groupId> com.devonfw.java.modules </groupId> <artifactId> devon4j-rest </artifactId> </dependency> <!-- JPA --> <dependency> <groupId> com.devonfw.java.starters </groupId> <artifactId> devon4j-starter-spring-data-jpa </artifactId> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-web </artifactId> </dependency> <dependency> <groupId> com.h2database </groupId> <artifactId> h2 </artifactId> <scope> runtime </scope> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-test </artifactId> <scope> test </scope> <exclusions> <exclusion> <groupId> org.junit.vintage </groupId> <artifactId> junit-vintage-engine </artifactId> </exclusion> </exclusions> </dependency> </dependencies> <build> <plugins> <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> </plugin> </plugins> </build> </project> Hemos a\u00f1adido las dependencias de Devonfw-JPA ya que nos permite utilizar m\u00e1s funcionalidades extendidas sobre repositorios JPA. Adem\u00e1s de esa dependencia, hemos a\u00f1adido una utilidad para hacer mapeos entre objetos y para configurar los servicios Rest. Uso de defonfw Vamos a utilizar algunas librer\u00edas de devonfw (fwk Opensource desarrollado por Capgemini, entre otros) que nos facilitan la vida a la hora de desarrollar una aplicaci\u00f3n. Podr\u00edamos hacerlo directamente con los m\u00f3dulos de Spring pero hay ciertas utilidades que nos interesa usar de devonfw. Para m\u00e1s informaci\u00f3n puedes consultar su Web Oficial","title":"Configurar las dependencias"},{"location":"create/#configurar-librerias-devonfw","text":"El siguiente punto es crear las clases de configuraci\u00f3n para las librer\u00edas que hemos a\u00f1adido. Para ello vamos a crear un package de configuraci\u00f3n general de la aplicaci\u00f3n com.capgemini.ccsw.tutorial.config donde crearemos tres clases (dos de ellas dentro del subpaquete mapper ). BeansOrikaConfig.java mapper/BeanMapper.java mapper/BeanMapperImpl.java package com.capgemini.ccsw.tutorial.config ; import org.springframework.context.annotation.Bean ; import org.springframework.context.annotation.Configuration ; import com.capgemini.ccsw.tutorial.config.mapper.BeanMapper ; import com.capgemini.ccsw.tutorial.config.mapper.BeanMapperImpl ; import com.devonfw.module.beanmapping.common.base.BaseOrikaConfig ; import com.devonfw.module.json.common.base.ObjectMapperFactory ; import com.fasterxml.jackson.databind.Module ; import ma.glasnost.orika.MapperFactory ; /** * Java bean configuration for Orika. The method {@link #configureCustomMapping(MapperFactory)} from * {@link BaseOrikaConfig} can be overridden as per requirements. * @author ccsw */ @Configuration public class BeansOrikaConfig extends BaseOrikaConfig { /** * @return the {@link BeanMapper} implementation. */ @Override @Bean public BeanMapper getBeanMapper () { return new BeanMapperImpl (); } @Bean public Module configureObjectMapper () { ObjectMapperFactory objectMapper = new ObjectMapperFactory (); return objectMapper . getExtensionModule (); } } package com.capgemini.ccsw.tutorial.config.mapper ; import org.springframework.data.domain.Page ; /** * @author ccsw */ public interface BeanMapper extends com . devonfw . module . beanmapping . common . api . BeanMapper { /** * Mapea el gen\u00e9rico de un Page en otro tipo de gen\u00e9rico * @param <T> * @param source * @param targetClass * @return */ < T > Page < T > mapPage ( Page <?> source , Class < T > targetClass ); } package com.capgemini.ccsw.tutorial.config.mapper ; import java.util.List ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.PageImpl ; import com.devonfw.module.beanmapping.common.impl.orika.BeanMapperImplOrika ; /** * @author ccsw */ public class BeanMapperImpl extends BeanMapperImplOrika implements BeanMapper { /** * {@inheritDoc} */ public < T > Page < T > mapPage ( Page <?> source , Class < T > targetClass ) { if ( source == null ) { return null ; } List < T > list = mapList ( source . getContent (), targetClass ); return new PageImpl <> ( list , source . getPageable (), source . getTotalElements ()); } } Listo, ya podemos empezar a desarrollar nuestros servicios.","title":"Configurar librerias devonfw"},{"location":"create/#configurar-la-bbdd","text":"Por \u00faltimo, vamos a dejar configurada la BBDD en memoria. Para ello crearemos dos ficheros, de momento en blanco, dentro de src/main/resources/ : schema.sql \u2192 Ser\u00e1 el fichero que utilizaremos para crear el esquema de BBDD data.sql \u2192 Ser\u00e1 el fichero que utilizaremos para rellenar con datos iniciales el esquema de BBDD Estos ficheros no pueden estar vac\u00edos ya que si no dar\u00e1 un error al arrancar. Puedes a\u00f1adirle la siguiente query (que no hace nada) para que pueda arrancar el proyecto. select 1 from dual;","title":"Configurar la BBDD"},{"location":"create/#arrancar-el-proyecto_1","text":"Por \u00faltimo ya solo nos queda arrancar el proyecto creado. Para ello buscaremos la clase TutorialApplication.java (o la clase principal del proyecto) y con el bot\u00f3n derecho seleccionaremos Run As \u2192 Java Application. La aplicaci\u00f3n al estar basada en Springboot arrancar\u00e1 internamente un Tomcat embebido donde se despliegar\u00e1 el proyecto. Si hab\u00e9is seguido el tutorial la aplicaci\u00f3n estar\u00e1 disponible en http://localhost:8080 , aunque de momento aun no tenemos nada accesible.","title":"Arrancar el proyecto"},{"location":"exercise/","text":"Ahora hazlo tu! Ahora vamos a ver si has comprendido bien el tutorial. Voy a poner dos ejercicios uno m\u00e1s sencillo que el otro para ver si eres capaz de llevarlos a cabo. \u00a1Vamos alla, mucha suerte! Nuestro amigo Ernesto Esvida ya tiene disponible su web para gestionar su cat\u00e1logo de juegos, autores y categor\u00edas, pero todav\u00eda le falta un poco m\u00e1s para poder hacer buen uso de su ludoteca. As\u00ed que nos ha pedido dos funcionalidades extra. Gesti\u00f3n de clientes Requisitos Por un lado necesita poder tener una base de datos de sus clientes. Para ello nos ha pedido que si podemos crearle una pantalla de CRUD sencilla, al igual que hicimos con las categor\u00edas donde \u00e9l pueda dar de alta a sus clientes. Nos ha pasado un esquema muy sencillo de lo que quiere, tan solo quiere guardar un listado de los nombres de sus clientes para tenerlos fichados , y nos ha hecho un par de pantallas sencillas muy similares a Categor\u00edas . Un listado sin filtros de ning\u00fan tipo ni paginaci\u00f3n. Un formulario de edici\u00f3n / alta, cuyo \u00fanico dato editable sea el nombre. Adem\u00e1s, la \u00fanica restricci\u00f3n que nos ha pedido es que NO podamos dar de alta a un cliente con el mismo nombre que otro existente. As\u00ed que deberemos comprobar el nombre, antes de guardar el cliente. Consejos Para empezar te dar\u00e9 unos consejos: Recuerda crear la tabla de la BBDD y sus datos Intenta primero hacer el listado completo, en el orden que m\u00e1s te guste: Angular o Springboot. Completa el listado conectando ambas capas. Termina el caso de uso haciendo las funcionalidades de edici\u00f3n, nuevo y borrado. Presta atenci\u00f3n a la validaci\u00f3n a la hora de guardar un cliente, NO se puede guardar si el nombre ya existe. Gesti\u00f3n de pr\u00e9stamos Requisitos Por otro lado, quiere hacer uso de su cat\u00e1logo de juegos y de sus clientes, y quiere saber que juegos ha prestado a cada cliente. Para ello nos ha pedido una p\u00e1gina bastante compleja donde se podr\u00e1 consultar diferente informaci\u00f3n y se permitir\u00e1 realizar el pr\u00e9stamo de los juegos. Nos ha pasado el siguiente boceto y requisitos: La pantalla tendr\u00e1 dos zonas: Una zona de filtrado donde se permitir\u00e1 filtrar por: T\u00edtulo del juego, que deber\u00e1 ser un combo seleccionable con los juegos del cat\u00e1logo de la Ludoteca. Cliente, que deber\u00e1 ser un combo seleccionable con los clientes dados de alta en la aplicaci\u00f3n. Fecha, que deber\u00e1 ser de tipo calendario y que permitir\u00e1 elegir una fecha de b\u00fasqueda. Al elegir un d\u00eda nos deber\u00e1 mostrar que juegos est\u00e1n prestados para dicho d\u00eda. OJO que los pr\u00e9stamos son con fecha de inicio y de fin, si elijo un d\u00eda intermedio deber\u00eda aparecer el elemento en la tabla. Una zona de listado paginado que deber\u00e1 mostrar El identificador del pr\u00e9stamo El nombre del juego prestado El nombre del cliente que lo solicit\u00f3 La fecha de inicio del pr\u00e9stamo La fecha de fin del pr\u00e9stamo Un bot\u00f3n que permite eliminar el pr\u00e9stamo Al pulsar el bot\u00f3n de Nuevo pr\u00e9stamo se abrir\u00e1 una pantalla donde se podr\u00e1 ingresar la siguiente informaci\u00f3n, toda ella obligatoria: Identificador, inicialmente vac\u00edo y en modo lectura Nombre del cliente, mediante un combo seleccionable Nombre del juego, mediante un combo seleccionable Fechas del pr\u00e9stamo, donde se podr\u00e1 introducir dos fechas, de inicio y fin del pr\u00e9stamo. Las validaciones son sencillas aunque laboriosas: La fecha de fin NO podr\u00e1 ser anterior a la fecha de inicio El periodo de pr\u00e9stamo m\u00e1ximo solo podr\u00e1 ser de 14 d\u00edas. Si el usuario quiere un pr\u00e9stamo para m\u00e1s de 14 d\u00edas la aplicaci\u00f3n no debe permitirlo mostrando una alerta al intentar guardar. El mismo juego no puede estar prestado a dos clientes distintos en un mismo d\u00eda. OJO que los pr\u00e9stamos tienen fecha de inicio y fecha fin, el juego no puede estar prestado a m\u00e1s de un cliente para ninguno de los d\u00edas que contemplan las fechas actuales del formulario. Un mismo cliente no puede tener prestados m\u00e1s de 2 juegos en un mismo d\u00eda. OJO que los pr\u00e9stamos tienen fecha de inicio y fecha fin, el cliente no puede tener m\u00e1s de dos pr\u00e9stamos para ninguno de los d\u00edas que contemplan las fechas actuales del formulario. Consejos Para empezar te dar\u00e9 unos consejos: Recuerda crear la tabla de la BBDD y sus datos Intenta primero hacer el listado paginado sin filtros, en el orden que m\u00e1s te guste: Angular o Springboot. Recuerda que se trata de un listado paginado, as\u00ed que deber\u00e1s utilizar el obtejo Page . Completa el listado conectando ambas capas. Ahora implementa los filtros, presta atenci\u00f3n al filtro de fecha, es el m\u00e1s complejo. Para la paginaci\u00f3n filtrada solo tienes que mezclar los conceptos que hemos visto en los puntos del tutorial anteriores y revisar Baeldung por si tienes dudas Implementa la pantalla de alta de pr\u00e9stamo, sin ninguna validaci\u00f3n. Cuando ya te funcione, intenta ir a\u00f1adiendo una a una las validaciones. Algunas de ellas pueden hacerse en frontend, mientras que otras deber\u00e1n validarse en backend \u00bfYa has terminado? Si has llegado a este punto es porque ya tienes terminado el tutorial. Por favor no te olvides de subir los proyectos a alg\u00fan repositorio Github propio (puedes revisar el anexo Tutorial b\u00e1sico de Git ) y av\u00edsarnos para que podamos echarle un ojo y darte sugerencias y feedback .","title":"Ahora hazlo tu!"},{"location":"exercise/#ahora-hazlo-tu","text":"Ahora vamos a ver si has comprendido bien el tutorial. Voy a poner dos ejercicios uno m\u00e1s sencillo que el otro para ver si eres capaz de llevarlos a cabo. \u00a1Vamos alla, mucha suerte! Nuestro amigo Ernesto Esvida ya tiene disponible su web para gestionar su cat\u00e1logo de juegos, autores y categor\u00edas, pero todav\u00eda le falta un poco m\u00e1s para poder hacer buen uso de su ludoteca. As\u00ed que nos ha pedido dos funcionalidades extra.","title":"Ahora hazlo tu!"},{"location":"exercise/#gestion-de-clientes","text":"","title":"Gesti\u00f3n de clientes"},{"location":"exercise/#requisitos","text":"Por un lado necesita poder tener una base de datos de sus clientes. Para ello nos ha pedido que si podemos crearle una pantalla de CRUD sencilla, al igual que hicimos con las categor\u00edas donde \u00e9l pueda dar de alta a sus clientes. Nos ha pasado un esquema muy sencillo de lo que quiere, tan solo quiere guardar un listado de los nombres de sus clientes para tenerlos fichados , y nos ha hecho un par de pantallas sencillas muy similares a Categor\u00edas . Un listado sin filtros de ning\u00fan tipo ni paginaci\u00f3n. Un formulario de edici\u00f3n / alta, cuyo \u00fanico dato editable sea el nombre. Adem\u00e1s, la \u00fanica restricci\u00f3n que nos ha pedido es que NO podamos dar de alta a un cliente con el mismo nombre que otro existente. As\u00ed que deberemos comprobar el nombre, antes de guardar el cliente.","title":"Requisitos"},{"location":"exercise/#consejos","text":"Para empezar te dar\u00e9 unos consejos: Recuerda crear la tabla de la BBDD y sus datos Intenta primero hacer el listado completo, en el orden que m\u00e1s te guste: Angular o Springboot. Completa el listado conectando ambas capas. Termina el caso de uso haciendo las funcionalidades de edici\u00f3n, nuevo y borrado. Presta atenci\u00f3n a la validaci\u00f3n a la hora de guardar un cliente, NO se puede guardar si el nombre ya existe.","title":"Consejos"},{"location":"exercise/#gestion-de-prestamos","text":"","title":"Gesti\u00f3n de pr\u00e9stamos"},{"location":"exercise/#requisitos_1","text":"Por otro lado, quiere hacer uso de su cat\u00e1logo de juegos y de sus clientes, y quiere saber que juegos ha prestado a cada cliente. Para ello nos ha pedido una p\u00e1gina bastante compleja donde se podr\u00e1 consultar diferente informaci\u00f3n y se permitir\u00e1 realizar el pr\u00e9stamo de los juegos. Nos ha pasado el siguiente boceto y requisitos: La pantalla tendr\u00e1 dos zonas: Una zona de filtrado donde se permitir\u00e1 filtrar por: T\u00edtulo del juego, que deber\u00e1 ser un combo seleccionable con los juegos del cat\u00e1logo de la Ludoteca. Cliente, que deber\u00e1 ser un combo seleccionable con los clientes dados de alta en la aplicaci\u00f3n. Fecha, que deber\u00e1 ser de tipo calendario y que permitir\u00e1 elegir una fecha de b\u00fasqueda. Al elegir un d\u00eda nos deber\u00e1 mostrar que juegos est\u00e1n prestados para dicho d\u00eda. OJO que los pr\u00e9stamos son con fecha de inicio y de fin, si elijo un d\u00eda intermedio deber\u00eda aparecer el elemento en la tabla. Una zona de listado paginado que deber\u00e1 mostrar El identificador del pr\u00e9stamo El nombre del juego prestado El nombre del cliente que lo solicit\u00f3 La fecha de inicio del pr\u00e9stamo La fecha de fin del pr\u00e9stamo Un bot\u00f3n que permite eliminar el pr\u00e9stamo Al pulsar el bot\u00f3n de Nuevo pr\u00e9stamo se abrir\u00e1 una pantalla donde se podr\u00e1 ingresar la siguiente informaci\u00f3n, toda ella obligatoria: Identificador, inicialmente vac\u00edo y en modo lectura Nombre del cliente, mediante un combo seleccionable Nombre del juego, mediante un combo seleccionable Fechas del pr\u00e9stamo, donde se podr\u00e1 introducir dos fechas, de inicio y fin del pr\u00e9stamo. Las validaciones son sencillas aunque laboriosas: La fecha de fin NO podr\u00e1 ser anterior a la fecha de inicio El periodo de pr\u00e9stamo m\u00e1ximo solo podr\u00e1 ser de 14 d\u00edas. Si el usuario quiere un pr\u00e9stamo para m\u00e1s de 14 d\u00edas la aplicaci\u00f3n no debe permitirlo mostrando una alerta al intentar guardar. El mismo juego no puede estar prestado a dos clientes distintos en un mismo d\u00eda. OJO que los pr\u00e9stamos tienen fecha de inicio y fecha fin, el juego no puede estar prestado a m\u00e1s de un cliente para ninguno de los d\u00edas que contemplan las fechas actuales del formulario. Un mismo cliente no puede tener prestados m\u00e1s de 2 juegos en un mismo d\u00eda. OJO que los pr\u00e9stamos tienen fecha de inicio y fecha fin, el cliente no puede tener m\u00e1s de dos pr\u00e9stamos para ninguno de los d\u00edas que contemplan las fechas actuales del formulario.","title":"Requisitos"},{"location":"exercise/#consejos_1","text":"Para empezar te dar\u00e9 unos consejos: Recuerda crear la tabla de la BBDD y sus datos Intenta primero hacer el listado paginado sin filtros, en el orden que m\u00e1s te guste: Angular o Springboot. Recuerda que se trata de un listado paginado, as\u00ed que deber\u00e1s utilizar el obtejo Page . Completa el listado conectando ambas capas. Ahora implementa los filtros, presta atenci\u00f3n al filtro de fecha, es el m\u00e1s complejo. Para la paginaci\u00f3n filtrada solo tienes que mezclar los conceptos que hemos visto en los puntos del tutorial anteriores y revisar Baeldung por si tienes dudas Implementa la pantalla de alta de pr\u00e9stamo, sin ninguna validaci\u00f3n. Cuando ya te funcione, intenta ir a\u00f1adiendo una a una las validaciones. Algunas de ellas pueden hacerse en frontend, mientras que otras deber\u00e1n validarse en backend","title":"Consejos"},{"location":"exercise/#ya-has-terminado","text":"Si has llegado a este punto es porque ya tienes terminado el tutorial. Por favor no te olvides de subir los proyectos a alg\u00fan repositorio Github propio (puedes revisar el anexo Tutorial b\u00e1sico de Git ) y av\u00edsarnos para que podamos echarle un ojo y darte sugerencias y feedback .","title":"\u00bfYa has terminado?"},{"location":"install/","text":"Entorno de desarrollo Herramientas que utilizaremos Las herramientas b\u00e1sicas que vamos a utilizar para el desarrollo del tutorial son: Para el desarrollo Back Eclide IDE Java 8 Maven (viene por defecto con Eclipse IDE) Postman Para el desarrollo Front Visual Studio Code Node Angular CLI Instalaci\u00f3n de herramientas para desarrollo Back Necesitamos instalar un IDE de desarrollo, en nuestro caso ser\u00e1 Eclipse IDE y la m\u00e1quina virtual de java necesaria para ejecutar el c\u00f3digo. Recomendamos Java8, que es la versi\u00f3n con la que est\u00e1 desarrollado el tutorial, aunque puedes instalar cualquier otra versi\u00f3n superior. Para instalar el IDE deber\u00e1s acceder a Eclide IDE y descargarte la \u00faltima versi\u00f3n del instalador. Una vez lo ejecutes te pedir\u00e1 el tipo de instalaci\u00f3n que deseas instalar. Por lo general con la de \"Eclipse IDE for Java Developers\" es suficiente. Con esta versi\u00f3n ya tiene integrado los plugins de Maven y Git. En la siguiente pantalla te pedir\u00e1 que elijas la versi\u00f3n de Java para instalar. Os recomendamos realizar el tutorial con la versi\u00f3n 8 de java , para versiones superiores no est\u00e1 probado y podr\u00eda dar alg\u00fan fallo. Una vez instalado eclipse, debes asegurarte que est\u00e1 usando por defecto la versi\u00f3n de Java 8. Para ello, abre el men\u00fa Window -> Preferences y dentro de la opci\u00f3n Java - Installed JREs verifica que es correcto. Si no fuera as\u00ed, a\u00f1ade la versi\u00f3n correcta y m\u00e1rcala como default . Instalaci\u00f3n de herramientas para desarrollo Front Ahora necesitamos instalar las herramientas para el desarrollo front. Instalaremos un IDE de desarrollo, a nosotros nos gusta mucho Visual Studio Code . Puedes entrar en su p\u00e1gina y descargarte la versi\u00f3n estable. Instalaremos Nodejs . Entrando en la p\u00e1gina de descargas e instalando la \u00faltima versi\u00f3n estable. Por \u00faltimo tendremos que instalar el CLI de Angular para desarrollar y compilar la aplicaci\u00f3n. Para poder instalarlo, tan solo hay que abrir una consola de msdos y ejecutar el comando: npm install -g @angular/cli Nodejs ya har\u00e1 el resto. Y con esto ya tendremos todo instalado, listo para empezar a crear los proyectos.","title":"Entorno de desarrollo"},{"location":"install/#entorno-de-desarrollo","text":"","title":"Entorno de desarrollo"},{"location":"install/#herramientas-que-utilizaremos","text":"Las herramientas b\u00e1sicas que vamos a utilizar para el desarrollo del tutorial son: Para el desarrollo Back Eclide IDE Java 8 Maven (viene por defecto con Eclipse IDE) Postman Para el desarrollo Front Visual Studio Code Node Angular CLI","title":"Herramientas que utilizaremos"},{"location":"install/#instalacion-de-herramientas-para-desarrollo-back","text":"Necesitamos instalar un IDE de desarrollo, en nuestro caso ser\u00e1 Eclipse IDE y la m\u00e1quina virtual de java necesaria para ejecutar el c\u00f3digo. Recomendamos Java8, que es la versi\u00f3n con la que est\u00e1 desarrollado el tutorial, aunque puedes instalar cualquier otra versi\u00f3n superior. Para instalar el IDE deber\u00e1s acceder a Eclide IDE y descargarte la \u00faltima versi\u00f3n del instalador. Una vez lo ejecutes te pedir\u00e1 el tipo de instalaci\u00f3n que deseas instalar. Por lo general con la de \"Eclipse IDE for Java Developers\" es suficiente. Con esta versi\u00f3n ya tiene integrado los plugins de Maven y Git. En la siguiente pantalla te pedir\u00e1 que elijas la versi\u00f3n de Java para instalar. Os recomendamos realizar el tutorial con la versi\u00f3n 8 de java , para versiones superiores no est\u00e1 probado y podr\u00eda dar alg\u00fan fallo. Una vez instalado eclipse, debes asegurarte que est\u00e1 usando por defecto la versi\u00f3n de Java 8. Para ello, abre el men\u00fa Window -> Preferences y dentro de la opci\u00f3n Java - Installed JREs verifica que es correcto. Si no fuera as\u00ed, a\u00f1ade la versi\u00f3n correcta y m\u00e1rcala como default .","title":"Instalaci\u00f3n de herramientas para desarrollo Back"},{"location":"install/#instalacion-de-herramientas-para-desarrollo-front","text":"Ahora necesitamos instalar las herramientas para el desarrollo front. Instalaremos un IDE de desarrollo, a nosotros nos gusta mucho Visual Studio Code . Puedes entrar en su p\u00e1gina y descargarte la versi\u00f3n estable. Instalaremos Nodejs . Entrando en la p\u00e1gina de descargas e instalando la \u00faltima versi\u00f3n estable. Por \u00faltimo tendremos que instalar el CLI de Angular para desarrollar y compilar la aplicaci\u00f3n. Para poder instalarlo, tan solo hay que abrir una consola de msdos y ejecutar el comando: npm install -g @angular/cli Nodejs ya har\u00e1 el resto. Y con esto ya tendremos todo instalado, listo para empezar a crear los proyectos.","title":"Instalaci\u00f3n de herramientas para desarrollo Front"},{"location":"thanks/","text":"Agradecimientos! Antes de empezar quer\u00edamos dar las gracias a todos los que hab\u00e9is participado de manera directa o indirecta en la elaboraci\u00f3n de este tutorial, y a todos aquellos que lo hab\u00e9is sufrido haciendolo. De verdad G R A C I A S Colaboradores Menci\u00f3n especial a las personas que han participado en el tutorial ya sea como testers, como promotores o como desarrolladores, por orden temporal de colaboraci\u00f3n: Carlos Aguilar ( @caaguila ) Jhonatan Core ( @corevill ) Carlos Navarro ( @DarkWarlord ) Cesar Cardona ( @Cazs03 ) Marina Valls ( @mvalemany ) Jaume Segarra ( @jaumesegarra ) Laura Medina ( @larulirea ) Yolanda Ubeda","title":"Agradecimientos!"},{"location":"thanks/#agradecimientos","text":"Antes de empezar quer\u00edamos dar las gracias a todos los que hab\u00e9is participado de manera directa o indirecta en la elaboraci\u00f3n de este tutorial, y a todos aquellos que lo hab\u00e9is sufrido haciendolo. De verdad G R A C I A S","title":"Agradecimientos!"},{"location":"thanks/#colaboradores","text":"Menci\u00f3n especial a las personas que han participado en el tutorial ya sea como testers, como promotores o como desarrolladores, por orden temporal de colaboraci\u00f3n: Carlos Aguilar ( @caaguila ) Jhonatan Core ( @corevill ) Carlos Navarro ( @DarkWarlord ) Cesar Cardona ( @Cazs03 ) Marina Valls ( @mvalemany ) Jaume Segarra ( @jaumesegarra ) Laura Medina ( @larulirea ) Yolanda Ubeda","title":"Colaboradores"},{"location":"usecases/","text":"Contexto de la aplicaci\u00f3n Nuestro amigo Ernesto Esvida es muy aficionado a los juegos de mesa y desde muy peque\u00f1o ha ido coleccionando muchos juegos. Hasta tal punto que ha decidido regentar una Ludoteca. Como la colecci\u00f3n de juegos era suya personal, toda la informaci\u00f3n del cat\u00e1logo de juegos la ten\u00eda perfectamente clasificado en fichas de cart\u00f3n. Pero ahora que va abrir su propio negocio, necesita digitalizar esa informaci\u00f3n y hacerla m\u00e1s accesible. Como es un buen amigo de la infancia, hemos decidido ayudar a Ernesto y colaborar haciendo una peque\u00f1a aplicaci\u00f3n web que le sirva de cat\u00e1logo de juegos. Es m\u00e1s o menos el mismo sistema que estaba utilizando, pero esta vez en digital. Por cierto, la Ludoteca al final se va a llamar Ludoteca T\u00e1n . Info Las im\u00e1genes que aparecen a continuaci\u00f3n son mockups o dise\u00f1os de alambre de las pantallas que vamos a desarrollar durante el tutorial. No quiere decir que el estilo final de las pantallas deba ser as\u00ed, ni mucho menos. Es simplemente una forma sencilla de ejemplificar como debe quedar m\u00e1s o menos una pantalla. Dise\u00f1o de BD Para el proyecto que vamos a crear vamos a modelizar y gestionar 3 entidades: GAME , CATEGORY y AUTHOR . Para la entidad GAME , Ernesto nos ha comentado que la informaci\u00f3n que est\u00e1 guardando en sus fichas es la siguiente: id (este dato no estaba originalmente en las fichas pero nos ser\u00e1 muy util para indexar y realizar b\u00fasquedas) title age category author La entidad CATEGORY estar\u00e1 compuesta por los siguientes campos: id (lo mismo que en GAME ) name La entidad AUTHOR estar\u00e1 compuesta por los siguientes campos: id (lo mismo que en GAME ) name nationality Comenzaremos con un caso b\u00e1sico que cumpla las siguientes premisas: un juego pertenece a una categor\u00eda y ha sido creado por un \u00fanico autor. Modelando este contexto quedar\u00eda algo similar a esto: Dise\u00f1o de pantallas Deber\u00edamos construir tres pantallas de mantenimiento CRUD (Create, Read, Update, Delete) y una pantalla de Login general para activar las acciones de administrador. M\u00e1s o menos las pantallas deber\u00edan quedar as\u00ed: Listado de juegos Edici\u00f3n de juego Listado de categor\u00edas Edici\u00f3n de categor\u00eda Listado de autores Edici\u00f3n de autor Pantalla de Login Dise\u00f1o funcional Por \u00faltimo vamos a definir un poco la funcionalidad b\u00e1sica que Ernesto necesita para iniciar su negocio. Aspectos generales El sistema tan solo tendr\u00e1 dos roles: usuario b\u00e1sico es el usuario an\u00f3nimo que accede a la web sin registrar. Solo tiene permisos para mostrar listados usuario administrador es el usuario que se registra en la aplicaci\u00f3n. Puede realizar las operaciones de alta, edici\u00f3n y borrado Por defecto cuando entras en la aplicaci\u00f3n tendr\u00e1s los privilegios de un usuario b\u00e1sico hasta que el usuario haga un login correcto con el usuario / password admin / admin . En ese momento pasara a ser un usuario administrador y podr\u00e1 realizar operaciones de alta, baja y modificaci\u00f3n. La estructura general de la aplicaci\u00f3n ser\u00e1: Una cabecer\u00e1 superior que contendr\u00e1: el logo y el nombre de la tienda un enlace a cada uno de los CRUD del sistema un bot\u00f3n de Sign in Zona de trabajo, donde cargaremos las pantallas que el usuario vaya abriendo Al pulsar sobre la funcionalidad de Sign in aparecer\u00e1 una ventana modal que preguntar\u00e1 usuario y password. Esto realizar\u00e1 una llamada al backend, donde se validar\u00e1 si el usuario es correcto. En caso de ser correcto, devolver\u00e1 un token jwt de acceso, que el cliente web deber\u00e1 guardar en sessionStorage para futuras peticiones En caso de no ser correcto, devolver\u00e1 un error de Usuario y/o password incorrectos Todas las operaciones del backend que permitan crear, modificar o borrar datos, deber\u00e1n estar securizadas para que no puedan ser accedidas sin haberse autenticado previamente. CRUD de Juegos Al acceder a esta pantalla se mostrar\u00e1 un listado de los juegos disponibles en el cat\u00e1logo de la BD. Esta tabla debe contener filtros en la parte superior, pero no debe estar paginada. Se debe poder filtrar por: nombre del juego. Donde el usuario podr\u00e1 poner cualquier texto y el filtrado ser\u00e1 todos aquellos juegos que contengan el texto buscado categor\u00eda del juego. Donde aparecer\u00e1 un desplegable que el usuario seleccionar de entre todas las categor\u00edas de juego que existan en la BD. Dos botones permitir\u00e1n realizar el filtrado de juegos (lanzando una nueva consulta a BD) o limpiar los filtros seleccionados (lanzando una consulta con los filtros vac\u00edos). En la tabla debe aparecer a modo de fichas. No hace falta que sea exactamente igual a la maqueta, no es un requisito determinar un ancho general de ficha por lo que pueden caber 2,3 o x fichas en una misma fila, depender\u00e1 del programador. Pero todas las fichas deben tener el mismo ancho: Un espacio destinado a una foto (de momento no pondremos nada en ese espacio) Una columna con la siguiente informaci\u00f3n: T\u00edtulo del juego, resaltado de alguna forma Edad recomendada Categor\u00eda del juego, mostraremos su nombre Autor del juego, mostraremos su nombre Nacionalidad del juego, mostraremos la nacionalidad del autor del juego Los juegos no se pueden eliminar, pero si se puede editar si el usuario pulsa en alguna de las fichas (solo en el caso de que el usuario tenga permisos). Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevos juegos (solo en el caso de que el usuario tenga permisos). Crear Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con cinco inputs: Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Identificador T\u00edtulo. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de T\u00edtulo Edad. Este input es obligatorio, es de tipo num\u00e9rico de 0 a 99, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Edad Categor\u00eda. Este input es obligatorio, ser\u00e1 un campo seleccionable donde aparecer\u00e1n todas las categor\u00edas de la BD, aparecer\u00e1 vac\u00edo por defecto. Con el placeholder de Categor\u00eda Autor. Este input es obligatorio, ser\u00e1 un campo seleccionable donde aparecer\u00e1n todos los autores de la BD, aparecer\u00e1 vac\u00edo por defecto. Con el placeholder de Autor Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. Editar Al pulsar en una de las fichas con un click simple, se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de Crear pero con los cinco campos rellenados con los datos de BD. CRUD de Categor\u00edas Al acceder a esta pantalla se mostrar\u00e1 un listado de las categor\u00edas que tenemos en la BD. La tabla no tiene filtros, puesto que tiene muy pocos registros. Tampoco estar\u00e1 paginada. En la tabla debe aparecer: identificador de la categor\u00eda nombre de la categor\u00eda bot\u00f3n de editar (solo en el caso de que el usuario tenga permisos) bot\u00f3n de borrar (solo en el caso de que el usuario tenga permisos) Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevas categor\u00edas (solo en el caso de que el usuario tenga permisos). Crear Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con dos inputs: Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Identificador Nombre. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Nombre Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. Editar Al pulsar el icono de editar se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de Crear pero con los dos campos rellenados con los datos de BD. Borrar Si el usuario pulsa el bot\u00f3n de borrar, se deber\u00e1 comprobar si esa categor\u00eda tiene alg\u00fan Juego asociado. En caso de tenerlo se le informar\u00e1 al usuario de que dicha categor\u00eda no se puede eliminar por tener asociado un juego. En caso de no estar asociada, se le preguntar\u00e1 al usuario mediante un mensaje de confirmaci\u00f3n si desea eliminar la categor\u00eda. Solo en caso de que la respuesta sea afirmativa, se lanzar\u00e1 el borrado f\u00edsico de la categor\u00eda en BD. CRUD de Autores Al acceder a esta pantalla se mostrar\u00e1 un listado de los autores que tenemos en la BD. La tabla no tiene filtros pero deber\u00e1 estar paginada en servidor. En la tabla debe aparecer: identificador del autor nombre del autor nacionalidad del autor bot\u00f3n de editar (solo en el caso de que el usuario tenga permisos) bot\u00f3n de borrar (solo en el caso de que el usuario tenga permisos) Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevos autores (solo en el caso de que el usuario tenga permisos). Crear Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con tres inputs: Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Identificador Nombre. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Nombre Nacionalidad. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Nacionalidad Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. Editar Al pulsar el icono de editar se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de Crear pero con los tres campos rellenados con los datos de BD. Borrar Si el usuario pulsa el bot\u00f3n de borrar, se deber\u00e1 comprobar si ese autor tiene alg\u00fan Juego asociado. En caso de tenerlo se le informar\u00e1 al usuario de que dicho autor no se puede eliminar por tener asociado un juego. En caso de no estar asociado, se le preguntar\u00e1 al usuario mediante un mensaje de confirmaci\u00f3n si desea eliminar el autor. Solo en caso de que la respuesta sea afirmativa, se lanzar\u00e1 el borrado f\u00edsico de la categor\u00eda en BD.","title":"Contexto de la aplicaci\u00f3n"},{"location":"usecases/#contexto-de-la-aplicacion","text":"Nuestro amigo Ernesto Esvida es muy aficionado a los juegos de mesa y desde muy peque\u00f1o ha ido coleccionando muchos juegos. Hasta tal punto que ha decidido regentar una Ludoteca. Como la colecci\u00f3n de juegos era suya personal, toda la informaci\u00f3n del cat\u00e1logo de juegos la ten\u00eda perfectamente clasificado en fichas de cart\u00f3n. Pero ahora que va abrir su propio negocio, necesita digitalizar esa informaci\u00f3n y hacerla m\u00e1s accesible. Como es un buen amigo de la infancia, hemos decidido ayudar a Ernesto y colaborar haciendo una peque\u00f1a aplicaci\u00f3n web que le sirva de cat\u00e1logo de juegos. Es m\u00e1s o menos el mismo sistema que estaba utilizando, pero esta vez en digital. Por cierto, la Ludoteca al final se va a llamar Ludoteca T\u00e1n . Info Las im\u00e1genes que aparecen a continuaci\u00f3n son mockups o dise\u00f1os de alambre de las pantallas que vamos a desarrollar durante el tutorial. No quiere decir que el estilo final de las pantallas deba ser as\u00ed, ni mucho menos. Es simplemente una forma sencilla de ejemplificar como debe quedar m\u00e1s o menos una pantalla.","title":"Contexto de la aplicaci\u00f3n"},{"location":"usecases/#diseno-de-bd","text":"Para el proyecto que vamos a crear vamos a modelizar y gestionar 3 entidades: GAME , CATEGORY y AUTHOR . Para la entidad GAME , Ernesto nos ha comentado que la informaci\u00f3n que est\u00e1 guardando en sus fichas es la siguiente: id (este dato no estaba originalmente en las fichas pero nos ser\u00e1 muy util para indexar y realizar b\u00fasquedas) title age category author La entidad CATEGORY estar\u00e1 compuesta por los siguientes campos: id (lo mismo que en GAME ) name La entidad AUTHOR estar\u00e1 compuesta por los siguientes campos: id (lo mismo que en GAME ) name nationality Comenzaremos con un caso b\u00e1sico que cumpla las siguientes premisas: un juego pertenece a una categor\u00eda y ha sido creado por un \u00fanico autor. Modelando este contexto quedar\u00eda algo similar a esto:","title":"Dise\u00f1o de BD"},{"location":"usecases/#diseno-de-pantallas","text":"Deber\u00edamos construir tres pantallas de mantenimiento CRUD (Create, Read, Update, Delete) y una pantalla de Login general para activar las acciones de administrador. M\u00e1s o menos las pantallas deber\u00edan quedar as\u00ed:","title":"Dise\u00f1o de pantallas"},{"location":"usecases/#listado-de-juegos","text":"","title":"Listado de juegos"},{"location":"usecases/#edicion-de-juego","text":"","title":"Edici\u00f3n de juego"},{"location":"usecases/#listado-de-categorias","text":"","title":"Listado de categor\u00edas"},{"location":"usecases/#edicion-de-categoria","text":"","title":"Edici\u00f3n de categor\u00eda"},{"location":"usecases/#listado-de-autores","text":"","title":"Listado de autores"},{"location":"usecases/#edicion-de-autor","text":"","title":"Edici\u00f3n de autor"},{"location":"usecases/#pantalla-de-login","text":"","title":"Pantalla de Login"},{"location":"usecases/#diseno-funcional","text":"Por \u00faltimo vamos a definir un poco la funcionalidad b\u00e1sica que Ernesto necesita para iniciar su negocio.","title":"Dise\u00f1o funcional"},{"location":"usecases/#aspectos-generales","text":"El sistema tan solo tendr\u00e1 dos roles: usuario b\u00e1sico es el usuario an\u00f3nimo que accede a la web sin registrar. Solo tiene permisos para mostrar listados usuario administrador es el usuario que se registra en la aplicaci\u00f3n. Puede realizar las operaciones de alta, edici\u00f3n y borrado Por defecto cuando entras en la aplicaci\u00f3n tendr\u00e1s los privilegios de un usuario b\u00e1sico hasta que el usuario haga un login correcto con el usuario / password admin / admin . En ese momento pasara a ser un usuario administrador y podr\u00e1 realizar operaciones de alta, baja y modificaci\u00f3n. La estructura general de la aplicaci\u00f3n ser\u00e1: Una cabecer\u00e1 superior que contendr\u00e1: el logo y el nombre de la tienda un enlace a cada uno de los CRUD del sistema un bot\u00f3n de Sign in Zona de trabajo, donde cargaremos las pantallas que el usuario vaya abriendo Al pulsar sobre la funcionalidad de Sign in aparecer\u00e1 una ventana modal que preguntar\u00e1 usuario y password. Esto realizar\u00e1 una llamada al backend, donde se validar\u00e1 si el usuario es correcto. En caso de ser correcto, devolver\u00e1 un token jwt de acceso, que el cliente web deber\u00e1 guardar en sessionStorage para futuras peticiones En caso de no ser correcto, devolver\u00e1 un error de Usuario y/o password incorrectos Todas las operaciones del backend que permitan crear, modificar o borrar datos, deber\u00e1n estar securizadas para que no puedan ser accedidas sin haberse autenticado previamente.","title":"Aspectos generales"},{"location":"usecases/#crud-de-juegos","text":"Al acceder a esta pantalla se mostrar\u00e1 un listado de los juegos disponibles en el cat\u00e1logo de la BD. Esta tabla debe contener filtros en la parte superior, pero no debe estar paginada. Se debe poder filtrar por: nombre del juego. Donde el usuario podr\u00e1 poner cualquier texto y el filtrado ser\u00e1 todos aquellos juegos que contengan el texto buscado categor\u00eda del juego. Donde aparecer\u00e1 un desplegable que el usuario seleccionar de entre todas las categor\u00edas de juego que existan en la BD. Dos botones permitir\u00e1n realizar el filtrado de juegos (lanzando una nueva consulta a BD) o limpiar los filtros seleccionados (lanzando una consulta con los filtros vac\u00edos). En la tabla debe aparecer a modo de fichas. No hace falta que sea exactamente igual a la maqueta, no es un requisito determinar un ancho general de ficha por lo que pueden caber 2,3 o x fichas en una misma fila, depender\u00e1 del programador. Pero todas las fichas deben tener el mismo ancho: Un espacio destinado a una foto (de momento no pondremos nada en ese espacio) Una columna con la siguiente informaci\u00f3n: T\u00edtulo del juego, resaltado de alguna forma Edad recomendada Categor\u00eda del juego, mostraremos su nombre Autor del juego, mostraremos su nombre Nacionalidad del juego, mostraremos la nacionalidad del autor del juego Los juegos no se pueden eliminar, pero si se puede editar si el usuario pulsa en alguna de las fichas (solo en el caso de que el usuario tenga permisos). Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevos juegos (solo en el caso de que el usuario tenga permisos). Crear Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con cinco inputs: Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Identificador T\u00edtulo. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de T\u00edtulo Edad. Este input es obligatorio, es de tipo num\u00e9rico de 0 a 99, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Edad Categor\u00eda. Este input es obligatorio, ser\u00e1 un campo seleccionable donde aparecer\u00e1n todas las categor\u00edas de la BD, aparecer\u00e1 vac\u00edo por defecto. Con el placeholder de Categor\u00eda Autor. Este input es obligatorio, ser\u00e1 un campo seleccionable donde aparecer\u00e1n todos los autores de la BD, aparecer\u00e1 vac\u00edo por defecto. Con el placeholder de Autor Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. Editar Al pulsar en una de las fichas con un click simple, se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de Crear pero con los cinco campos rellenados con los datos de BD.","title":"CRUD de Juegos"},{"location":"usecases/#crud-de-categorias","text":"Al acceder a esta pantalla se mostrar\u00e1 un listado de las categor\u00edas que tenemos en la BD. La tabla no tiene filtros, puesto que tiene muy pocos registros. Tampoco estar\u00e1 paginada. En la tabla debe aparecer: identificador de la categor\u00eda nombre de la categor\u00eda bot\u00f3n de editar (solo en el caso de que el usuario tenga permisos) bot\u00f3n de borrar (solo en el caso de que el usuario tenga permisos) Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevas categor\u00edas (solo en el caso de que el usuario tenga permisos). Crear Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con dos inputs: Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Identificador Nombre. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Nombre Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. Editar Al pulsar el icono de editar se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de Crear pero con los dos campos rellenados con los datos de BD. Borrar Si el usuario pulsa el bot\u00f3n de borrar, se deber\u00e1 comprobar si esa categor\u00eda tiene alg\u00fan Juego asociado. En caso de tenerlo se le informar\u00e1 al usuario de que dicha categor\u00eda no se puede eliminar por tener asociado un juego. En caso de no estar asociada, se le preguntar\u00e1 al usuario mediante un mensaje de confirmaci\u00f3n si desea eliminar la categor\u00eda. Solo en caso de que la respuesta sea afirmativa, se lanzar\u00e1 el borrado f\u00edsico de la categor\u00eda en BD.","title":"CRUD de Categor\u00edas"},{"location":"usecases/#crud-de-autores","text":"Al acceder a esta pantalla se mostrar\u00e1 un listado de los autores que tenemos en la BD. La tabla no tiene filtros pero deber\u00e1 estar paginada en servidor. En la tabla debe aparecer: identificador del autor nombre del autor nacionalidad del autor bot\u00f3n de editar (solo en el caso de que el usuario tenga permisos) bot\u00f3n de borrar (solo en el caso de que el usuario tenga permisos) Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevos autores (solo en el caso de que el usuario tenga permisos). Crear Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con tres inputs: Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Identificador Nombre. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Nombre Nacionalidad. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Nacionalidad Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. Editar Al pulsar el icono de editar se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de Crear pero con los tres campos rellenados con los datos de BD. Borrar Si el usuario pulsa el bot\u00f3n de borrar, se deber\u00e1 comprobar si ese autor tiene alg\u00fan Juego asociado. En caso de tenerlo se le informar\u00e1 al usuario de que dicho autor no se puede eliminar por tener asociado un juego. En caso de no estar asociado, se le preguntar\u00e1 al usuario mediante un mensaje de confirmaci\u00f3n si desea eliminar el autor. Solo en caso de que la respuesta sea afirmativa, se lanzar\u00e1 el borrado f\u00edsico de la categor\u00eda en BD.","title":"CRUD de Autores"},{"location":"appendix/dates/","text":"Fechas Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n. Como trabajar con las fechas El problema que presenta al trabajar con las fechas es que el navegador puede tener una zona horaria y el servidor estar en otra. Aqu\u00ed hay una deficiencia por parte de JavaScript que, al trabajar con fechas, le a\u00f1ade la zona horaria y no es posible de una forma optima remover la zona horaria del objeto Date. A s\u00ed que vamos a intentar de trabajar en estos casos con formateos de fecha preestablecidas Una propuesta es trabajar en el FRONT y Back con este formato \"dd/MM/yyyy HH:mm:ss\"","title":"Anexo. Fechas (TBC)"},{"location":"appendix/dates/#fechas","text":"Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n.","title":"Fechas"},{"location":"appendix/dates/#como-trabajar-con-las-fechas","text":"El problema que presenta al trabajar con las fechas es que el navegador puede tener una zona horaria y el servidor estar en otra. Aqu\u00ed hay una deficiencia por parte de JavaScript que, al trabajar con fechas, le a\u00f1ade la zona horaria y no es posible de una forma optima remover la zona horaria del objeto Date. A s\u00ed que vamos a intentar de trabajar en estos casos con formateos de fecha preestablecidas Una propuesta es trabajar en el FRONT y Back con este formato \"dd/MM/yyyy HH:mm:ss\"","title":"Como trabajar con las fechas"},{"location":"appendix/git/","text":"Tutorial b\u00e1sico de Git Cada vez se tiende m\u00e1s a utilizar repositorios de c\u00f3digo Git y, aunque no sea objeto de este tutorial Springboot-Angular, queremos hacer un resumen muy b\u00e1sico y sencillo de como utilizar Git. En el mercado existen multitud de herramientas para gestionar repositorios Git, podemos utilizar cualquiera de ellas, aunque desde devonfw se recomienda utilizar Git SCM . Adem\u00e1s, existen tambi\u00e9n multitud de servidores de c\u00f3digo que implementan repositorios Git, como podr\u00edan ser GitHub, GitLab, Bitbucket, etc. Todos ellos trabajan de la misma forma, as\u00ed que este resumen servir\u00e1 para todos ellos. Info Este anexo muestra un resumen muy sencillo y b\u00e1sico de los comandos m\u00e1s comunes que se utilizan en Git. Para ver detalles m\u00e1s avanzados o un tutorial completo te recomiendo que leas la guia de Atlassian . Funcionamiento b\u00e1sico Existen dos conceptos en Git que debes tener muy claros: las ramas y los repositorios. Vamos a ver como funciona cada uno de ellos. Ramas Por un lado tenemos las ramas de Git. El repositorio puede tener tantas ramas como se quiera, pero por lo general debe existir una rama maestra a menudo llamada develop o master , y luego muchas ramas con cada una de las funcionalidades desarrolladas. Las ramas siempre se deben crear a partir de una rama (en el ejemplo llamaremos develop ), con una foto concreta y determinada de esa rama. Esta rama deber\u00e1 tener un nombre que describa lo que va a contener esa rama (en el ejemplo feature/xxx ). Y por lo general, esa rama se mergear\u00e1 con otra rama del repositorio, que puede ser la rama de origen o cualquier otra (en el ejemplo ser\u00e1 con la rama origen develop ). As\u00ed pues, podemos tener algo as\u00ed: Las acciones de crear ramas y mergear ramas est\u00e1n explicadas m\u00e1s abajo. En este punto solo es necesario que seas conocedor de: existen ramas maestras --> que contienen el c\u00f3digo completo de la aplicaci\u00f3n existen ramas de desarrollo --> que generalmente se crean de una rama maestra en un punto temporal concreto en alg\u00fan momento esas ramas de desarrollo se deben mergear en una rama maestra ojo cuidado , cuando hay varias personas en el equipo trabajando, habr\u00e1n varias ramas de desarrollo que nazcan de diferentes puntos temporales y que habr\u00e1 que tener en cuenta para posibles conflictos. Recuerda que no est\u00e1s solo programando, hay m\u00e1s gente modificando el c\u00f3digo. Repositorios El otro concepto que debe queda claro, es el de repositorios. Por defecto, en Git, se trabaja con el repositorio local, en el que puedes crear ramas, modificar c\u00f3digo, mergear, etc. pero todos esos cambios que se hagan, ser\u00e1n todos en local, nadie m\u00e1s tendr\u00e1 acceso. Tambi\u00e9n existe el repositorio remoto, tambi\u00e9n llamado origin . Este repositorio es el que todos los integrantes del equipo utilizan como referencia. Existen acciones de Git que permite sincronizar los repositorios. En este punto solo es necesario que seas conocedor de: Los cambios que realices en local (en tu repositorio local) solo ser\u00e1n visibles por ti. Puedes crear ramas y borrarlas, pero solo tu las ver\u00e1s. Los cambios que se suban al repositorio remoto ser\u00e1n visibles para todos. Pueden haber ramas protegidas para que no se puedan modificar desde el equipo, t\u00edpicamente las ramas maestras. Estas ramas solo pueden modificarse previa validaci\u00f3n y pull request o merge request (depende de la aplicaci\u00f3n usada para Git). Existen acciones que permiten subir tus cambios de local a remoto. Recuerda que pueden existir ramas protegidas. Existen acciones que permiten actualizar tus ramas locales con los cambios remotos. Recuerda que no trabajas solo, es posible que tu repositorio local no est\u00e9 sincronizado, tus compa\u00f1eros han podido subir c\u00f3digo y deber\u00edas sincronizarte frecuentemente. Acciones m\u00e1s t\u00edpicas En la Gu\u00eda r\u00e1pida puedes ver m\u00e1s detalle de estas acciones pero por lo general: Lo primero es descargarse una copia del repositorio con todas sus ramas. Se descargar\u00eda de remoto a local. A partir de este momento se trabaja en local. Cada nueva funcionalidad deber\u00eda tener su rama asociada, por tanto, lo l\u00f3gico es crear una rama de desarrollo (t\u00edpicamente feature/xxx ) a partir de una rama maestra (t\u00edpicamente develop o master ). Se trabajar\u00eda de forma local con esa rama. Es buena pr\u00e1ctica que si llevas mucho tiempo con la rama creada, de vez en cuando, sincronices tu repositorio local con lo que exista en el repositorio remoto. Adem\u00e1s, como es posible que la rama maestra de la que part\u00eda haya cambiado, esos cambios deber\u00edas llevarlos tambi\u00e9n a tu rama en desarrollo. Con esto consigues que tu punto temporal sea m\u00e1s moderno y tengas menos conflictos. Recuerda que no est\u00e1s solo trabajando. Cuando lo tengas listo y antes de subir nada, deber\u00edas realizar una \u00faltima sincronizaci\u00f3n de remoto a local. Despu\u00e9s deber\u00edas hacer un merge de tus ramas locales de desarrollo con las ramas maestras locales de las que partieron, por los posibles cambios que alguien hubiera podido subir. Por \u00faltimo, una vez tengas todo actualizado, ya puedes subir el c\u00f3digo al repositorio remoto (tu rama de desarrollo), y solicitar un pull request o merge request contra la rama maestra que quieras modificar. Alguien, diferente a ti, debe revisar esa solicitud y aprobarla antes de que se realice todo el merge correcto en remoto. Y vuelta a empezar. Funcionamiento avanzado A continuaci\u00f3n vamos a describir estos mismos conceptos y acciones que hemos visto, pero m\u00e1s en profundidad para que veas como trabaja internamente Git. No es necesario que leas este punto, aunque es recomendable. Estructuras y flujo de trabajo Lo primero que debes conocer de Git es su funcionamiento b\u00e1sico de flujo de trabajo. Tu repositorio local est\u00e1 compuesto por tres \"estructuras\" que contienen los archivos y los cambios de los ficheros del repositorio. Working directory - Contiene los archivos con los que est\u00e1s trabajando localmente. Staging Area - Es un \u00e1rea intermedia donde vamos a\u00f1adiendo ficheros para ir agrupando modificaciones. Local Repository - Es el repositorio local donde tendr\u00e9mos el registro de todos los commits que hemos realizado. Por defecto apunta a HEAD que es el \u00faltimo commit registrado. Existen operaciones que nos permiten a\u00f1adir o borrar ficheros dentro de cada una de las estructuras desde otra estructura. As\u00ed pues, los comandos b\u00e1sicos dentro de nuestro repositorio local son los siguientes. add y commmit Puedes registrar los cambios realizados en tu working directory y a\u00f1adirlos al staging area usando el comando git add <filename> o si quieres a\u00f1adir todos los ficheros modificados git add . Este es el primer paso en el flujo de trabajo b\u00e1sico. Una vez tenemos los cambios registrados en el staging area podemos hacer un commit y persistirlos dentro del local repository mediante el comando git commit -m \"<Commit message>\" A partir de ese momento, los ficheros modificados y a\u00f1adidos al local repository se han persistido y se han a\u00f1adido a tu HEAD , aunque todav\u00eda siguen estando el local, no lo has enviado a ning\u00fan repositorio remoto. reset De la misma manera que se han a\u00f1adido ficheros a staging area o a local repository , podemos retirarlos de estas estructuras y volver a recuperar los ficheros que ten\u00edamos anteriormente en el working directory . Por ejemplo, si nos hemos equivocado al incluir ficheros en un commit o simplemente queremos deshacer los cambios que hemos realizado bastar\u00eda con lanzar el comando git reset --hard o si queremos volver a un commit concreto git reset <COMMIT> Trabajo con ramas Para complicarlo todo un poco m\u00e1s, el trabajo con git siempre se realiza mediante ramas. Estas ramas nos sirven para desarrollar funcionalidades aisladas unas de otras y poder hacer mezclas de c\u00f3digo de unas ramas a otras. Las ramas m\u00e1s comunes dentro de git suelen ser: master Esta ser\u00e1 la rama que contenga el c\u00f3digo fuente que tenemos en producci\u00f3n . release Esta ser\u00e1 la rama que contenga el c\u00f3digo fuente de cada una de las entregas parciales, no tiene porqu\u00e9 coincidir con la rama master . develop Esta ser\u00e1 la rama que contenga el c\u00f3digo fuente estable que est\u00e1 actualmente en desarrollo. feature/xxxx Estas ser\u00e1nn la rama que contengan el c\u00f3digo fuente de desarrollo de cada una de las funcionalidades. Generalmente estas ramas las crea cada desarrollador, las mantiene en local, hasta que las sube a remoto para realizar un merge a la rama develop . Siempre que trabajes con ramas debes tener en cuenta que al empezar tu desarrollo debes partir de una versi\u00f3n actualizada de la rama develop , y al terminar tu desarrollo debes solicitar un merge contra develop , para que tu funcionalidad est\u00e9 incorporada en la rama de desarrollo. Crear ramas Crear ramas en local es tan sencillo como ejecutar este comando: git checkout -b <NOMBRE_RAMA> Eso nos crear\u00e1 una rama con el nombre que le hayamos dicho y mover\u00e1 el Working Directory a dicha rama. Cambiar de rama Para cambiar de una rama a otra en local tan solo debemos ejecutar el comando: git checkout <NOMBRE_RAMA> La rama debe existir, sino se quejar\u00e1 de que no encuentra la rama. Este comando nos mover\u00e1 el Working Directory a la rama que le hayamos indicado. Si tenemos cambios en el Staging Area que no hayan sido movidos al Local Repository NO nos permitir\u00e1 movernos a la rama ya que perder\u00edamos los cambios. Antes de poder movernos debemos resetear los cambios o bien commitearlos . Remote repository Hasta aqu\u00ed es todo m\u00e1s o menos sencillo, trabajamos con nuestro repositorio local, creamos ramas, commiteamos o reseteamos cambios de c\u00f3digo, pero todo esto lo hacemos en local. Ahora necesitamos que esos cambios se distribuyan y puedan leerlos el resto de integrantes de nuestro equipo. Aqu\u00ed es donde entra en juego los repositorios remotos. Aqu\u00ed debemos tener MUY en cuenta que el c\u00f3digo que vamos a publicar en remoto SOLO es posible publicarlo desde el Local Repository . Es decir que para poder subir c\u00f3digo a remote antes debemos a\u00f1adirlo a Staging Area y hacer un commit para persistirlo en el Local Repository . clone Antes de empezar a tocar c\u00f3digo del proyecto podemos crear un Local Repository vac\u00edo o bien bajarnos un proyecto que ya exista en un Remote Repository . Esta \u00faltima opci\u00f3n es la m\u00e1s normal. Para bajarnos un proyecto desde remoto tan solo hay que ejecutar el comando: git clone <REMOTE_URL> Esto te crear\u00e1 una carpeta con el nombre del proyecto y dentro se descargar\u00e1 la estructura completa del repositorio y te mover\u00e1 al Working Directory todo el c\u00f3digo de la rama por defecto para ese repositorio. env\u00edo de cambios El env\u00edo de datos a un Remote Repository tan solo es posible realizarlo desde Local Repository (por lo que antes deber\u00e1s commitear cambios all\u00ed), y se debe ejecutar el comando: git push origin actualizar y fusionar En ocasiones (bastante habitual) ser\u00e1 necesario descargarse los cambios de un Remote Repository para poder trabajar con la \u00faltima versi\u00f3n. Para ello debemos ejecutar el comando: git pull El propio git realizar\u00e1 la fusi\u00f3n local del c\u00f3digo remoto con el c\u00f3digo de tu Working Directory . Pero en ocasiones, si se ha modificado el mismo fichero en remoto y en local, se puede producir un Conflicto . No pasa nada, tan solo tendr\u00e1s que abrir dicho fichero en conflicto y resolverlo manualmente dejando el c\u00f3digo mezclado correcto. Tambi\u00e9n es posible que el c\u00f3digo que queramos actualizar est\u00e9 en otra rama, si lo que necesitamos es fusionar el c\u00f3digo de otra rama con la rama actual, nos situaremos en la rama destino y ejecutaremos el comando: git merge <RAMA_ORIGEN> Esto har\u00e1 lo mismo que un pull en local y fusionar\u00e1 el c\u00f3digo de una rama en otra. Tambi\u00e9n es posible que se produzcan conflictos que deber\u00e1s resolver de forma manual. Merge Request Ya por \u00faltimo, como estamos trabajando con ramas, lo \u00fanico que hacemos es subir y bajar ramas, pero en alg\u00fan momento alguien debe fusionar el contenido de una rama en la rama develop , release o master , que son las ramas principales. Se podr\u00eda directamente usar el comando merge para eso, pero en la mayor\u00eda de los repositorios no esta permitido subir el c\u00f3digo de una rama principal, por lo que no podr\u00e1s hacer un merge y subirlo. Para eso existe otra opci\u00f3n que es la de Merge Request . Esta opci\u00f3n permite a un usuario solicitar que otro usuario verifique y valide que el c\u00f3digo de su rama es correcto y lo puede fusionar en Remote Repository con una rama principal. Al ser una operaci\u00f3n delicada, tan solo es posible ejecutarla a trav\u00e9s de la web del repositorio git. Por lo general existir\u00e1 una opci\u00f3n / bot\u00f3n que permitir\u00e1 hacer un Merge Request con una rama origen y una rama destino (generalmente una de las principales). A esa petici\u00f3n se le asignar\u00e1 un validador y se enviar\u00e1. El usuario validador verificar\u00e1 si es correcto o no y validar\u00e1 o rechazar\u00e1 la petici\u00f3n. En caso de validarla se fusionar\u00e1 autom\u00e1ticamente en remoto y todos los usuarios podr\u00e1n descargar los nuevos cambios desde la rama. \u00a1Cuidado! Siempre antes de solicitar un Merge Request debes comprobar que tienes actualizada la rama comparandola con la rama remota que queremos mergear, en nuestro ejemplo ser\u00e1 develop . Para actualizarla tu rama hay que seguir tres pasos muy sencillos: Cambias a la rama develop y descargarnos los cambios del repositorio remoto (git pull) Cambias a tu rama y ejecutar un merge desde develop hacia nuestra rama (git merge develop) Subes tus cambios a remoto (git add, git commit y git push) y ya puedes solcitar el Merge Request Gu\u00eda r\u00e1pida Los pasos b\u00e1sicos de utilizaci\u00f3n de git son sencillos. Primero nos bajamos el repositorio o lo creamos en local mediante los comandos git clone o git init Una vez estamos trabajando con nuestro repositorio local, cada vez que vayamos a comenzar una funcionalidad nueva, debemos crear una rama nueva siempre partiendo desde una rama maestra mediante el comando: (en nuestro ejemplo la rama maestra ser\u00e1 develop ) git checkout -b <rama> Cuando tengamos implementados los cambios que queremos realizar, hay que subirlos al staging y luego persistirlos en nuestro repositorio local. Esto lo hacemos con el comando git add . git commit -m \"<Commit message>\" Siempre antes de subir los cambios al repositorio remoto, hay que comprobar que tenemos actualizada nuestra rama comparandola con la rama remota que queremos mergear, en nuestro ejemplo ser\u00e1 develop . Por tanto tenemos que cambiar a la rama develop , descargarnos los cambios del repositorio remoto, volver a cambiar a nuestra rama y ejecutar un merge desde develop hacia nuestra rama, ejecutando estos comandos git checkout develop git pull git checkout <rama> git merge develop Ahora que ya tenemos actualizadas las ramas, tan solo nos basta subir nuestra rama a remoto, con el comando git push --set-upstream origin <rama> Por \u00faltimo accedemos al cliente web del repositorio y solicitamos un merge request contra develop . Para que sea validado y aprobado por otro compa\u00f1ero del equipo. Si en alg\u00fan momento necesitamos modificar nuestro c\u00f3digo del merge request antes de que haya sido aprobado, nos basta con repetir los pasos anteriores git add . git commit -m \"<Commit message>\" git push origin Una vez hayamos terminado el desarrollo y vayamos a empezar una nueva funcionalidad, volveremos al punto 2 de este listado y comenzaremos de nuevo los comando. Debemos recordad que tenemos que partir siempre de la rama develop y adem\u00e1s debe estar actualizada git pull .","title":"Anexo. Tutorial b\u00e1sico de Git"},{"location":"appendix/git/#tutorial-basico-de-git","text":"Cada vez se tiende m\u00e1s a utilizar repositorios de c\u00f3digo Git y, aunque no sea objeto de este tutorial Springboot-Angular, queremos hacer un resumen muy b\u00e1sico y sencillo de como utilizar Git. En el mercado existen multitud de herramientas para gestionar repositorios Git, podemos utilizar cualquiera de ellas, aunque desde devonfw se recomienda utilizar Git SCM . Adem\u00e1s, existen tambi\u00e9n multitud de servidores de c\u00f3digo que implementan repositorios Git, como podr\u00edan ser GitHub, GitLab, Bitbucket, etc. Todos ellos trabajan de la misma forma, as\u00ed que este resumen servir\u00e1 para todos ellos. Info Este anexo muestra un resumen muy sencillo y b\u00e1sico de los comandos m\u00e1s comunes que se utilizan en Git. Para ver detalles m\u00e1s avanzados o un tutorial completo te recomiendo que leas la guia de Atlassian .","title":"Tutorial b\u00e1sico de Git"},{"location":"appendix/git/#funcionamiento-basico","text":"Existen dos conceptos en Git que debes tener muy claros: las ramas y los repositorios. Vamos a ver como funciona cada uno de ellos.","title":"Funcionamiento b\u00e1sico"},{"location":"appendix/git/#ramas","text":"Por un lado tenemos las ramas de Git. El repositorio puede tener tantas ramas como se quiera, pero por lo general debe existir una rama maestra a menudo llamada develop o master , y luego muchas ramas con cada una de las funcionalidades desarrolladas. Las ramas siempre se deben crear a partir de una rama (en el ejemplo llamaremos develop ), con una foto concreta y determinada de esa rama. Esta rama deber\u00e1 tener un nombre que describa lo que va a contener esa rama (en el ejemplo feature/xxx ). Y por lo general, esa rama se mergear\u00e1 con otra rama del repositorio, que puede ser la rama de origen o cualquier otra (en el ejemplo ser\u00e1 con la rama origen develop ). As\u00ed pues, podemos tener algo as\u00ed: Las acciones de crear ramas y mergear ramas est\u00e1n explicadas m\u00e1s abajo. En este punto solo es necesario que seas conocedor de: existen ramas maestras --> que contienen el c\u00f3digo completo de la aplicaci\u00f3n existen ramas de desarrollo --> que generalmente se crean de una rama maestra en un punto temporal concreto en alg\u00fan momento esas ramas de desarrollo se deben mergear en una rama maestra ojo cuidado , cuando hay varias personas en el equipo trabajando, habr\u00e1n varias ramas de desarrollo que nazcan de diferentes puntos temporales y que habr\u00e1 que tener en cuenta para posibles conflictos. Recuerda que no est\u00e1s solo programando, hay m\u00e1s gente modificando el c\u00f3digo.","title":"Ramas"},{"location":"appendix/git/#repositorios","text":"El otro concepto que debe queda claro, es el de repositorios. Por defecto, en Git, se trabaja con el repositorio local, en el que puedes crear ramas, modificar c\u00f3digo, mergear, etc. pero todos esos cambios que se hagan, ser\u00e1n todos en local, nadie m\u00e1s tendr\u00e1 acceso. Tambi\u00e9n existe el repositorio remoto, tambi\u00e9n llamado origin . Este repositorio es el que todos los integrantes del equipo utilizan como referencia. Existen acciones de Git que permite sincronizar los repositorios. En este punto solo es necesario que seas conocedor de: Los cambios que realices en local (en tu repositorio local) solo ser\u00e1n visibles por ti. Puedes crear ramas y borrarlas, pero solo tu las ver\u00e1s. Los cambios que se suban al repositorio remoto ser\u00e1n visibles para todos. Pueden haber ramas protegidas para que no se puedan modificar desde el equipo, t\u00edpicamente las ramas maestras. Estas ramas solo pueden modificarse previa validaci\u00f3n y pull request o merge request (depende de la aplicaci\u00f3n usada para Git). Existen acciones que permiten subir tus cambios de local a remoto. Recuerda que pueden existir ramas protegidas. Existen acciones que permiten actualizar tus ramas locales con los cambios remotos. Recuerda que no trabajas solo, es posible que tu repositorio local no est\u00e9 sincronizado, tus compa\u00f1eros han podido subir c\u00f3digo y deber\u00edas sincronizarte frecuentemente.","title":"Repositorios"},{"location":"appendix/git/#acciones-mas-tipicas","text":"En la Gu\u00eda r\u00e1pida puedes ver m\u00e1s detalle de estas acciones pero por lo general: Lo primero es descargarse una copia del repositorio con todas sus ramas. Se descargar\u00eda de remoto a local. A partir de este momento se trabaja en local. Cada nueva funcionalidad deber\u00eda tener su rama asociada, por tanto, lo l\u00f3gico es crear una rama de desarrollo (t\u00edpicamente feature/xxx ) a partir de una rama maestra (t\u00edpicamente develop o master ). Se trabajar\u00eda de forma local con esa rama. Es buena pr\u00e1ctica que si llevas mucho tiempo con la rama creada, de vez en cuando, sincronices tu repositorio local con lo que exista en el repositorio remoto. Adem\u00e1s, como es posible que la rama maestra de la que part\u00eda haya cambiado, esos cambios deber\u00edas llevarlos tambi\u00e9n a tu rama en desarrollo. Con esto consigues que tu punto temporal sea m\u00e1s moderno y tengas menos conflictos. Recuerda que no est\u00e1s solo trabajando. Cuando lo tengas listo y antes de subir nada, deber\u00edas realizar una \u00faltima sincronizaci\u00f3n de remoto a local. Despu\u00e9s deber\u00edas hacer un merge de tus ramas locales de desarrollo con las ramas maestras locales de las que partieron, por los posibles cambios que alguien hubiera podido subir. Por \u00faltimo, una vez tengas todo actualizado, ya puedes subir el c\u00f3digo al repositorio remoto (tu rama de desarrollo), y solicitar un pull request o merge request contra la rama maestra que quieras modificar. Alguien, diferente a ti, debe revisar esa solicitud y aprobarla antes de que se realice todo el merge correcto en remoto. Y vuelta a empezar.","title":"Acciones m\u00e1s t\u00edpicas"},{"location":"appendix/git/#funcionamiento-avanzado","text":"A continuaci\u00f3n vamos a describir estos mismos conceptos y acciones que hemos visto, pero m\u00e1s en profundidad para que veas como trabaja internamente Git. No es necesario que leas este punto, aunque es recomendable.","title":"Funcionamiento avanzado"},{"location":"appendix/git/#estructuras-y-flujo-de-trabajo","text":"Lo primero que debes conocer de Git es su funcionamiento b\u00e1sico de flujo de trabajo. Tu repositorio local est\u00e1 compuesto por tres \"estructuras\" que contienen los archivos y los cambios de los ficheros del repositorio. Working directory - Contiene los archivos con los que est\u00e1s trabajando localmente. Staging Area - Es un \u00e1rea intermedia donde vamos a\u00f1adiendo ficheros para ir agrupando modificaciones. Local Repository - Es el repositorio local donde tendr\u00e9mos el registro de todos los commits que hemos realizado. Por defecto apunta a HEAD que es el \u00faltimo commit registrado. Existen operaciones que nos permiten a\u00f1adir o borrar ficheros dentro de cada una de las estructuras desde otra estructura. As\u00ed pues, los comandos b\u00e1sicos dentro de nuestro repositorio local son los siguientes.","title":"Estructuras y flujo de trabajo"},{"location":"appendix/git/#add-y-commmit","text":"Puedes registrar los cambios realizados en tu working directory y a\u00f1adirlos al staging area usando el comando git add <filename> o si quieres a\u00f1adir todos los ficheros modificados git add . Este es el primer paso en el flujo de trabajo b\u00e1sico. Una vez tenemos los cambios registrados en el staging area podemos hacer un commit y persistirlos dentro del local repository mediante el comando git commit -m \"<Commit message>\" A partir de ese momento, los ficheros modificados y a\u00f1adidos al local repository se han persistido y se han a\u00f1adido a tu HEAD , aunque todav\u00eda siguen estando el local, no lo has enviado a ning\u00fan repositorio remoto.","title":"add y commmit"},{"location":"appendix/git/#reset","text":"De la misma manera que se han a\u00f1adido ficheros a staging area o a local repository , podemos retirarlos de estas estructuras y volver a recuperar los ficheros que ten\u00edamos anteriormente en el working directory . Por ejemplo, si nos hemos equivocado al incluir ficheros en un commit o simplemente queremos deshacer los cambios que hemos realizado bastar\u00eda con lanzar el comando git reset --hard o si queremos volver a un commit concreto git reset <COMMIT>","title":"reset"},{"location":"appendix/git/#trabajo-con-ramas","text":"Para complicarlo todo un poco m\u00e1s, el trabajo con git siempre se realiza mediante ramas. Estas ramas nos sirven para desarrollar funcionalidades aisladas unas de otras y poder hacer mezclas de c\u00f3digo de unas ramas a otras. Las ramas m\u00e1s comunes dentro de git suelen ser: master Esta ser\u00e1 la rama que contenga el c\u00f3digo fuente que tenemos en producci\u00f3n . release Esta ser\u00e1 la rama que contenga el c\u00f3digo fuente de cada una de las entregas parciales, no tiene porqu\u00e9 coincidir con la rama master . develop Esta ser\u00e1 la rama que contenga el c\u00f3digo fuente estable que est\u00e1 actualmente en desarrollo. feature/xxxx Estas ser\u00e1nn la rama que contengan el c\u00f3digo fuente de desarrollo de cada una de las funcionalidades. Generalmente estas ramas las crea cada desarrollador, las mantiene en local, hasta que las sube a remoto para realizar un merge a la rama develop . Siempre que trabajes con ramas debes tener en cuenta que al empezar tu desarrollo debes partir de una versi\u00f3n actualizada de la rama develop , y al terminar tu desarrollo debes solicitar un merge contra develop , para que tu funcionalidad est\u00e9 incorporada en la rama de desarrollo.","title":"Trabajo con ramas"},{"location":"appendix/git/#crear-ramas","text":"Crear ramas en local es tan sencillo como ejecutar este comando: git checkout -b <NOMBRE_RAMA> Eso nos crear\u00e1 una rama con el nombre que le hayamos dicho y mover\u00e1 el Working Directory a dicha rama.","title":"Crear ramas"},{"location":"appendix/git/#cambiar-de-rama","text":"Para cambiar de una rama a otra en local tan solo debemos ejecutar el comando: git checkout <NOMBRE_RAMA> La rama debe existir, sino se quejar\u00e1 de que no encuentra la rama. Este comando nos mover\u00e1 el Working Directory a la rama que le hayamos indicado. Si tenemos cambios en el Staging Area que no hayan sido movidos al Local Repository NO nos permitir\u00e1 movernos a la rama ya que perder\u00edamos los cambios. Antes de poder movernos debemos resetear los cambios o bien commitearlos .","title":"Cambiar de rama"},{"location":"appendix/git/#remote-repository","text":"Hasta aqu\u00ed es todo m\u00e1s o menos sencillo, trabajamos con nuestro repositorio local, creamos ramas, commiteamos o reseteamos cambios de c\u00f3digo, pero todo esto lo hacemos en local. Ahora necesitamos que esos cambios se distribuyan y puedan leerlos el resto de integrantes de nuestro equipo. Aqu\u00ed es donde entra en juego los repositorios remotos. Aqu\u00ed debemos tener MUY en cuenta que el c\u00f3digo que vamos a publicar en remoto SOLO es posible publicarlo desde el Local Repository . Es decir que para poder subir c\u00f3digo a remote antes debemos a\u00f1adirlo a Staging Area y hacer un commit para persistirlo en el Local Repository .","title":"Remote repository"},{"location":"appendix/git/#clone","text":"Antes de empezar a tocar c\u00f3digo del proyecto podemos crear un Local Repository vac\u00edo o bien bajarnos un proyecto que ya exista en un Remote Repository . Esta \u00faltima opci\u00f3n es la m\u00e1s normal. Para bajarnos un proyecto desde remoto tan solo hay que ejecutar el comando: git clone <REMOTE_URL> Esto te crear\u00e1 una carpeta con el nombre del proyecto y dentro se descargar\u00e1 la estructura completa del repositorio y te mover\u00e1 al Working Directory todo el c\u00f3digo de la rama por defecto para ese repositorio.","title":"clone"},{"location":"appendix/git/#envio-de-cambios","text":"El env\u00edo de datos a un Remote Repository tan solo es posible realizarlo desde Local Repository (por lo que antes deber\u00e1s commitear cambios all\u00ed), y se debe ejecutar el comando: git push origin","title":"env\u00edo de cambios"},{"location":"appendix/git/#actualizar-y-fusionar","text":"En ocasiones (bastante habitual) ser\u00e1 necesario descargarse los cambios de un Remote Repository para poder trabajar con la \u00faltima versi\u00f3n. Para ello debemos ejecutar el comando: git pull El propio git realizar\u00e1 la fusi\u00f3n local del c\u00f3digo remoto con el c\u00f3digo de tu Working Directory . Pero en ocasiones, si se ha modificado el mismo fichero en remoto y en local, se puede producir un Conflicto . No pasa nada, tan solo tendr\u00e1s que abrir dicho fichero en conflicto y resolverlo manualmente dejando el c\u00f3digo mezclado correcto. Tambi\u00e9n es posible que el c\u00f3digo que queramos actualizar est\u00e9 en otra rama, si lo que necesitamos es fusionar el c\u00f3digo de otra rama con la rama actual, nos situaremos en la rama destino y ejecutaremos el comando: git merge <RAMA_ORIGEN> Esto har\u00e1 lo mismo que un pull en local y fusionar\u00e1 el c\u00f3digo de una rama en otra. Tambi\u00e9n es posible que se produzcan conflictos que deber\u00e1s resolver de forma manual.","title":"actualizar y fusionar"},{"location":"appendix/git/#merge-request","text":"Ya por \u00faltimo, como estamos trabajando con ramas, lo \u00fanico que hacemos es subir y bajar ramas, pero en alg\u00fan momento alguien debe fusionar el contenido de una rama en la rama develop , release o master , que son las ramas principales. Se podr\u00eda directamente usar el comando merge para eso, pero en la mayor\u00eda de los repositorios no esta permitido subir el c\u00f3digo de una rama principal, por lo que no podr\u00e1s hacer un merge y subirlo. Para eso existe otra opci\u00f3n que es la de Merge Request . Esta opci\u00f3n permite a un usuario solicitar que otro usuario verifique y valide que el c\u00f3digo de su rama es correcto y lo puede fusionar en Remote Repository con una rama principal. Al ser una operaci\u00f3n delicada, tan solo es posible ejecutarla a trav\u00e9s de la web del repositorio git. Por lo general existir\u00e1 una opci\u00f3n / bot\u00f3n que permitir\u00e1 hacer un Merge Request con una rama origen y una rama destino (generalmente una de las principales). A esa petici\u00f3n se le asignar\u00e1 un validador y se enviar\u00e1. El usuario validador verificar\u00e1 si es correcto o no y validar\u00e1 o rechazar\u00e1 la petici\u00f3n. En caso de validarla se fusionar\u00e1 autom\u00e1ticamente en remoto y todos los usuarios podr\u00e1n descargar los nuevos cambios desde la rama. \u00a1Cuidado! Siempre antes de solicitar un Merge Request debes comprobar que tienes actualizada la rama comparandola con la rama remota que queremos mergear, en nuestro ejemplo ser\u00e1 develop . Para actualizarla tu rama hay que seguir tres pasos muy sencillos: Cambias a la rama develop y descargarnos los cambios del repositorio remoto (git pull) Cambias a tu rama y ejecutar un merge desde develop hacia nuestra rama (git merge develop) Subes tus cambios a remoto (git add, git commit y git push) y ya puedes solcitar el Merge Request","title":"Merge Request"},{"location":"appendix/git/#guia-rapida","text":"Los pasos b\u00e1sicos de utilizaci\u00f3n de git son sencillos. Primero nos bajamos el repositorio o lo creamos en local mediante los comandos git clone o git init Una vez estamos trabajando con nuestro repositorio local, cada vez que vayamos a comenzar una funcionalidad nueva, debemos crear una rama nueva siempre partiendo desde una rama maestra mediante el comando: (en nuestro ejemplo la rama maestra ser\u00e1 develop ) git checkout -b <rama> Cuando tengamos implementados los cambios que queremos realizar, hay que subirlos al staging y luego persistirlos en nuestro repositorio local. Esto lo hacemos con el comando git add . git commit -m \"<Commit message>\" Siempre antes de subir los cambios al repositorio remoto, hay que comprobar que tenemos actualizada nuestra rama comparandola con la rama remota que queremos mergear, en nuestro ejemplo ser\u00e1 develop . Por tanto tenemos que cambiar a la rama develop , descargarnos los cambios del repositorio remoto, volver a cambiar a nuestra rama y ejecutar un merge desde develop hacia nuestra rama, ejecutando estos comandos git checkout develop git pull git checkout <rama> git merge develop Ahora que ya tenemos actualizadas las ramas, tan solo nos basta subir nuestra rama a remoto, con el comando git push --set-upstream origin <rama> Por \u00faltimo accedemos al cliente web del repositorio y solicitamos un merge request contra develop . Para que sea validado y aprobado por otro compa\u00f1ero del equipo. Si en alg\u00fan momento necesitamos modificar nuestro c\u00f3digo del merge request antes de que haya sido aprobado, nos basta con repetir los pasos anteriores git add . git commit -m \"<Commit message>\" git push origin Una vez hayamos terminado el desarrollo y vayamos a empezar una nueva funcionalidad, volveremos al punto 2 de este listado y comenzaremos de nuevo los comando. Debemos recordad que tenemos que partir siempre de la rama develop y adem\u00e1s debe estar actualizada git pull .","title":"Gu\u00eda r\u00e1pida"},{"location":"appendix/jpa/","text":"Funcionamiento Spring Data Este anexo no pretende explicar el funcionamiento interno de Spring Data, simplemente conocer un poco como utilizarlo y algunos peque\u00f1os tips que pueden ser interesantes. Funcionamiento b\u00e1sico Lo primero que deber\u00edas tener claro, es que hagas lo que hagas, al final todo termina lanzando una query nativa sobre la BBDD. Da igual que uses cualquier tipo de acelerador (luego veremos alguno), ya que al final Spring Data termina convirtiendo lo que hayas programado en una query nativa. Cuanta m\u00e1s informaci\u00f3n le proporciones a Spring Data, tendr\u00e1s m\u00e1s control sobre la query final, pero m\u00e1s dificil ser\u00e1 de mantener. Lo mejor es utilizar, siempre que se pueda, todos los automatismos y automagias posibles y dejar que Spring haga su faena. Habr\u00e1 ocasiones en que esto no nos sirva, en ese momento tendremos que decidir si queremos bajar el nivel de implementaci\u00f3n o queremos utilizar otra alternativa como procesos por streams. Derived Query Methods Para la realizaci\u00f3n de consultas a la base de datos, Spring Data nos ofrece un sencillo mecanismo que consiste en crear definiciones de m\u00e9todos con una sintaxis especifica, para luego traducirlas autom\u00e1ticamente a consultas nativas, por parte de Spring Data. Esto es muy \u00fatil, ya que convierte a la aplicaci\u00f3n en agn\u00f3sticos de la tecnolog\u00eda de BBDD utilizada y podemos migrar con facilidad entre las muchas soluciones disponibles en el mercado, delegando esta tarea en Spring. Esta es la opci\u00f3n m\u00e1s indicada en la mayor\u00eda de los casos, siempre que puedas deber\u00edas utilizar esta forma de realizar las consultas. Como parte negativa, en algunos casos en consultas m\u00e1s complejas la definici\u00f3n de los m\u00e9todos puede extenderse demasiado dificultando la lectura del c\u00f3digo. De esto tenemos alg\u00fan ejemplo por el tutorial, en el repositorio de GameRepository . Siguiendo el ejemplo del tutorial, si tuvieramos que recuperar los Game por el nombre del juego, se podr\u00eda crear un m\u00e9todo en el GameRepository de esta forma: List < Game > findByName ( String name ); Spring Data entender\u00eda que quieres recuperar un listado de Game que est\u00e1n filtrados por su propiedad Name y generar\u00eda la consulta SQL de forma autom\u00e1tica, sin tener que implementar nada. Se pueden contruir muchos m\u00e9todos diferentes, te recomiendo que leas un peque\u00f1o tutorial de Baeldung y profundices con la documentaci\u00f3n oficial donde podr\u00e1s ver todas las opciones. Anotaci\u00f3n @Query Otra forma de realizar consultas, esta vez menos autom\u00e1tica y m\u00e1s cercana a SQL, es la anotaci\u00f3n @Query. Existen dos opciones a la hora de usar la anotaci\u00f3n @Query . Esta anotaci\u00f3n ya la hemos usado en el tutorial, dentro del GameRepository . En primer lugar tenemos las consultas JPQL. Estas guardan un parecido con el lenguaje SQL pero al igual que en el caso anterior, son traducidas por Spring Data a la consulta final nativa. Su uso no est\u00e1 recomendado ya que estamos a\u00f1adiendo un nivel de concreci\u00f3n y por tanto estamos aumentando la complejidad del c\u00f3digo. Aun as\u00ed, es otra forma de generar consultas. Por otra parte, tambi\u00e9n es posible generar consultas nativas directamente dentro de esta anotaci\u00f3n interactuando de forma directa con la base de datos. Esta pr\u00e1ctica es altamente desaconsejable ya que crea acoplamientos con la tecnolog\u00eda de la BBDD utilizada y es una fuente de errores. Puedes ver m\u00e1s informaci\u00f3n de esta anotaci\u00f3n desde este peque\u00f1o tutorial de Baeldung . Acelerando las consultas En muchas ocasiones necesitamos obtener informaci\u00f3n que no est\u00e1 en una \u00fanica tabla por motivos de dise\u00f1o de la base de datos. Debemos plasmar esta casu\u00edstica con cuidado a nuestro modelo relacional para obtener resultados \u00f3ptimos en cuanto al rendimiento. Para ilustrar el caso vamos a recuperar los objetos utilizados en el tutorial Author , Gategory y Game . Si recuerdas, tenemos que un Game tiene asociado un Author y tiene asociada una Gategory . Cuando utilizamos el m\u00e9todo de filtrado find que construimos en el GameRepository , vemos que Spring Data traduce la @Query que hab\u00edamos dise\u00f1ado en una query SQL para recuperar los juegos. @Query ( \"select g from Game g where (:title is null or g.title like '%'||:title||'%') and (:category is null or g.category.id = :category)\" ) List < Game > find ( @Param ( \"title\" ) String title , @Param ( \"category\" ) Long category ); Esta @Query es la que utiliza Spring Data para traducir las propiedades a objetos de BBDD y mapear los resultados a objetos Java. Si tenemos activada la property spring.jpa.show-sql=true podremos ver las queries que est\u00e1 generando Spring Data. El resultado es el siguiente. Hibernate : select game0_ . id as id1_2_ , game0_ . age as age2_2_ , game0_ . author_id as author_i4_2_ , game0_ . category_id as category5_2_ , game0_ . title as title3_2_ from game game0_ where ( ? is null or game0_ . title like ( '%' ||?|| '%' )) and ( ? is null or game0_ . category_id =? ) Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Hibernate : select category0_ . id as id1_1_0_ , category0_ . name as name2_1_0_ from category category0_ where category0_ . id =? Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Hibernate : select category0_ . id as id1_1_0_ , category0_ . name as name2_1_0_ from category category0_ where category0_ . id =? Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Si te fijas ha generado una query SQL para filtrar los Game , pero luego cuando ha intentado construir los objetos Java, ha tenido que lanzar una serie de queries para recuperar los diferentes Author y Category a trav\u00e9s de sus id . Obviamente Spring Data es muy lista y cachea los resultados obtenidos para no tener que recuperarlos n veces, pero aun as\u00ed, lanza unas cuantas consultas. Esto penaliza el rendimiento de nuestra operaci\u00f3n, ya que tiene que lanzar n queries a BBDD que, aunque son muy \u00f3ptimas, incrementan unos milisegundos el tiempo total. Para evitar esta circunstancia, disponemos de la anotaci\u00f3n denominada @EnitityGraph la cual proporciona directrices a Spring Data sobre la forma en la que deseamos realizar la consulta, permitiendo que realice agrupaciones y uniones de tablas en una \u00fanica query que, aun siendo mas compleja, en muchos casos el rendimiento es mucho mejor que realizar m\u00faltiples interacciones con la BBDD. Siguiendo el ejemplo anterior podr\u00edamos utilizar la anotaci\u00f3n de esta forma: @Query ( \"select g from Game g where (:title is null or g.title like '%'||:title||'%') and (:category is null or g.category.id = :category)\" ) @EntityGraph ( attributePaths = { \"category\" , \"author\" }) List < Game > find ( @Param ( \"title\" ) String title , @Param ( \"category\" ) Long category ); Donde le estamos diciendo a Spring Data que cuando realice la query, haga el cruce con las propiedades category y author , que a su vez son entidades y por tanto mapean dos tablas de BBDD. El resultado es el siguiente: Hibernate : select game0_ . id as id1_2_0_ , category1_ . id as id1_1_1_ , author2_ . id as id1_0_2_ , game0_ . age as age2_2_0_ , game0_ . author_id as author_i4_2_0_ , game0_ . category_id as category5_2_0_ , game0_ . title as title3_2_0_ , category1_ . name as name2_1_1_ , author2_ . name as name2_0_2_ , author2_ . nationality as national3_0_2_ from game game0_ left outer join category category1_ on game0_ . category_id = category1_ . id left outer join author author2_ on game0_ . author_id = author2_ . id where ( ? is null or game0_ . title like ( '%' ||?|| '%' )) and ( ? is null or game0_ . category_id =? ) Una \u00fanica query, que es m\u00e1s compleja que la anterior, ya que hace dos cruces con tablas de BBDD, pero que nos evita tener que lanzar n queries diferentes para recuperar Author y Category . Generalmente, el uso de @EntityGraph acelera mucho los resultados y es muy recomendable utilizarlo para realizar los cruces inline. Se puede utilizar tanto con @Query como con Derived Query Methods . Puedes leer m\u00e1s informaci\u00f3n en este peque\u00f1o tutorial de Baeldung . Alternativa de Streams A partir de Java 8 disponemos de los Java Streams. Se trata de una herramienta que nos permite multitud de opciones relativas tratamiento y trasformaci\u00f3n de los datos manejados. En este apartado \u00fanicamente se menciona debido a que en muchas ocasiones cuando nos enfrentamos a consultas complejas, puede ser beneficioso evitar ofuscar las consultas y realizar las trasformaciones necesarias mediante los Streams. Un ejemplo de uso pr\u00e1ctico podr\u00eda ser, evitar usar la cl\u00e1usula IN de SQL en una determinada consulta que podr\u00eda penalizar notablemente el rendimiento de las consultas. En vez de eso se podr\u00eda utilizar el m\u00e9todo de JAVA filter sobre el conjunto de elementos para obtener el mismo resultado. Puedes leer m\u00e1s informaci\u00f3n en el tutorial de Baeldung . Specifications En algunos casos puede ocurrir que con las herramientas descritas anteriormente no tengamos suficiente alcance, bien porque las definiciones de los m\u00e9todos se complican y alargan demasiado o debido a que la consulta es demasiado gen\u00e9rica como para realizarlo de este modo. Para este caso se dispone de las Specifications que nos proveen de una forma de escribir consultas reutilizables mediante una API que ofrece una forma fluida de crear y combinar consultas complejas. Un ejemplo de caso de uso podr\u00eda ser un CRUD de una determinada entidad que debe poder filtrar por todos los atributos de esta, donde el tipo de filtrado viene especificado en la propia consulta y no siempre es requerido. En este caso no podr\u00edamos construir una consulta basada en definir un determinado m\u00e9todo ya no conocemos de ante mano que filtros ni que atributos vamos a recibir y deberemos recurrir al uso de las Specifications. Puedes leer m\u00e1s informaci\u00f3n en el tutorial de Baeldung .","title":"Anexo. Spring Data (JPA)"},{"location":"appendix/jpa/#funcionamiento-spring-data","text":"Este anexo no pretende explicar el funcionamiento interno de Spring Data, simplemente conocer un poco como utilizarlo y algunos peque\u00f1os tips que pueden ser interesantes.","title":"Funcionamiento Spring Data"},{"location":"appendix/jpa/#funcionamiento-basico","text":"Lo primero que deber\u00edas tener claro, es que hagas lo que hagas, al final todo termina lanzando una query nativa sobre la BBDD. Da igual que uses cualquier tipo de acelerador (luego veremos alguno), ya que al final Spring Data termina convirtiendo lo que hayas programado en una query nativa. Cuanta m\u00e1s informaci\u00f3n le proporciones a Spring Data, tendr\u00e1s m\u00e1s control sobre la query final, pero m\u00e1s dificil ser\u00e1 de mantener. Lo mejor es utilizar, siempre que se pueda, todos los automatismos y automagias posibles y dejar que Spring haga su faena. Habr\u00e1 ocasiones en que esto no nos sirva, en ese momento tendremos que decidir si queremos bajar el nivel de implementaci\u00f3n o queremos utilizar otra alternativa como procesos por streams.","title":"Funcionamiento b\u00e1sico"},{"location":"appendix/jpa/#derived-query-methods","text":"Para la realizaci\u00f3n de consultas a la base de datos, Spring Data nos ofrece un sencillo mecanismo que consiste en crear definiciones de m\u00e9todos con una sintaxis especifica, para luego traducirlas autom\u00e1ticamente a consultas nativas, por parte de Spring Data. Esto es muy \u00fatil, ya que convierte a la aplicaci\u00f3n en agn\u00f3sticos de la tecnolog\u00eda de BBDD utilizada y podemos migrar con facilidad entre las muchas soluciones disponibles en el mercado, delegando esta tarea en Spring. Esta es la opci\u00f3n m\u00e1s indicada en la mayor\u00eda de los casos, siempre que puedas deber\u00edas utilizar esta forma de realizar las consultas. Como parte negativa, en algunos casos en consultas m\u00e1s complejas la definici\u00f3n de los m\u00e9todos puede extenderse demasiado dificultando la lectura del c\u00f3digo. De esto tenemos alg\u00fan ejemplo por el tutorial, en el repositorio de GameRepository . Siguiendo el ejemplo del tutorial, si tuvieramos que recuperar los Game por el nombre del juego, se podr\u00eda crear un m\u00e9todo en el GameRepository de esta forma: List < Game > findByName ( String name ); Spring Data entender\u00eda que quieres recuperar un listado de Game que est\u00e1n filtrados por su propiedad Name y generar\u00eda la consulta SQL de forma autom\u00e1tica, sin tener que implementar nada. Se pueden contruir muchos m\u00e9todos diferentes, te recomiendo que leas un peque\u00f1o tutorial de Baeldung y profundices con la documentaci\u00f3n oficial donde podr\u00e1s ver todas las opciones.","title":"Derived Query Methods"},{"location":"appendix/jpa/#anotacion-query","text":"Otra forma de realizar consultas, esta vez menos autom\u00e1tica y m\u00e1s cercana a SQL, es la anotaci\u00f3n @Query. Existen dos opciones a la hora de usar la anotaci\u00f3n @Query . Esta anotaci\u00f3n ya la hemos usado en el tutorial, dentro del GameRepository . En primer lugar tenemos las consultas JPQL. Estas guardan un parecido con el lenguaje SQL pero al igual que en el caso anterior, son traducidas por Spring Data a la consulta final nativa. Su uso no est\u00e1 recomendado ya que estamos a\u00f1adiendo un nivel de concreci\u00f3n y por tanto estamos aumentando la complejidad del c\u00f3digo. Aun as\u00ed, es otra forma de generar consultas. Por otra parte, tambi\u00e9n es posible generar consultas nativas directamente dentro de esta anotaci\u00f3n interactuando de forma directa con la base de datos. Esta pr\u00e1ctica es altamente desaconsejable ya que crea acoplamientos con la tecnolog\u00eda de la BBDD utilizada y es una fuente de errores. Puedes ver m\u00e1s informaci\u00f3n de esta anotaci\u00f3n desde este peque\u00f1o tutorial de Baeldung .","title":"Anotaci\u00f3n @Query"},{"location":"appendix/jpa/#acelerando-las-consultas","text":"En muchas ocasiones necesitamos obtener informaci\u00f3n que no est\u00e1 en una \u00fanica tabla por motivos de dise\u00f1o de la base de datos. Debemos plasmar esta casu\u00edstica con cuidado a nuestro modelo relacional para obtener resultados \u00f3ptimos en cuanto al rendimiento. Para ilustrar el caso vamos a recuperar los objetos utilizados en el tutorial Author , Gategory y Game . Si recuerdas, tenemos que un Game tiene asociado un Author y tiene asociada una Gategory . Cuando utilizamos el m\u00e9todo de filtrado find que construimos en el GameRepository , vemos que Spring Data traduce la @Query que hab\u00edamos dise\u00f1ado en una query SQL para recuperar los juegos. @Query ( \"select g from Game g where (:title is null or g.title like '%'||:title||'%') and (:category is null or g.category.id = :category)\" ) List < Game > find ( @Param ( \"title\" ) String title , @Param ( \"category\" ) Long category ); Esta @Query es la que utiliza Spring Data para traducir las propiedades a objetos de BBDD y mapear los resultados a objetos Java. Si tenemos activada la property spring.jpa.show-sql=true podremos ver las queries que est\u00e1 generando Spring Data. El resultado es el siguiente. Hibernate : select game0_ . id as id1_2_ , game0_ . age as age2_2_ , game0_ . author_id as author_i4_2_ , game0_ . category_id as category5_2_ , game0_ . title as title3_2_ from game game0_ where ( ? is null or game0_ . title like ( '%' ||?|| '%' )) and ( ? is null or game0_ . category_id =? ) Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Hibernate : select category0_ . id as id1_1_0_ , category0_ . name as name2_1_0_ from category category0_ where category0_ . id =? Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Hibernate : select category0_ . id as id1_1_0_ , category0_ . name as name2_1_0_ from category category0_ where category0_ . id =? Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Hibernate : select author0_ . id as id1_0_0_ , author0_ . name as name2_0_0_ , author0_ . nationality as national3_0_0_ from author author0_ where author0_ . id =? Si te fijas ha generado una query SQL para filtrar los Game , pero luego cuando ha intentado construir los objetos Java, ha tenido que lanzar una serie de queries para recuperar los diferentes Author y Category a trav\u00e9s de sus id . Obviamente Spring Data es muy lista y cachea los resultados obtenidos para no tener que recuperarlos n veces, pero aun as\u00ed, lanza unas cuantas consultas. Esto penaliza el rendimiento de nuestra operaci\u00f3n, ya que tiene que lanzar n queries a BBDD que, aunque son muy \u00f3ptimas, incrementan unos milisegundos el tiempo total. Para evitar esta circunstancia, disponemos de la anotaci\u00f3n denominada @EnitityGraph la cual proporciona directrices a Spring Data sobre la forma en la que deseamos realizar la consulta, permitiendo que realice agrupaciones y uniones de tablas en una \u00fanica query que, aun siendo mas compleja, en muchos casos el rendimiento es mucho mejor que realizar m\u00faltiples interacciones con la BBDD. Siguiendo el ejemplo anterior podr\u00edamos utilizar la anotaci\u00f3n de esta forma: @Query ( \"select g from Game g where (:title is null or g.title like '%'||:title||'%') and (:category is null or g.category.id = :category)\" ) @EntityGraph ( attributePaths = { \"category\" , \"author\" }) List < Game > find ( @Param ( \"title\" ) String title , @Param ( \"category\" ) Long category ); Donde le estamos diciendo a Spring Data que cuando realice la query, haga el cruce con las propiedades category y author , que a su vez son entidades y por tanto mapean dos tablas de BBDD. El resultado es el siguiente: Hibernate : select game0_ . id as id1_2_0_ , category1_ . id as id1_1_1_ , author2_ . id as id1_0_2_ , game0_ . age as age2_2_0_ , game0_ . author_id as author_i4_2_0_ , game0_ . category_id as category5_2_0_ , game0_ . title as title3_2_0_ , category1_ . name as name2_1_1_ , author2_ . name as name2_0_2_ , author2_ . nationality as national3_0_2_ from game game0_ left outer join category category1_ on game0_ . category_id = category1_ . id left outer join author author2_ on game0_ . author_id = author2_ . id where ( ? is null or game0_ . title like ( '%' ||?|| '%' )) and ( ? is null or game0_ . category_id =? ) Una \u00fanica query, que es m\u00e1s compleja que la anterior, ya que hace dos cruces con tablas de BBDD, pero que nos evita tener que lanzar n queries diferentes para recuperar Author y Category . Generalmente, el uso de @EntityGraph acelera mucho los resultados y es muy recomendable utilizarlo para realizar los cruces inline. Se puede utilizar tanto con @Query como con Derived Query Methods . Puedes leer m\u00e1s informaci\u00f3n en este peque\u00f1o tutorial de Baeldung .","title":"Acelerando las consultas"},{"location":"appendix/jpa/#alternativa-de-streams","text":"A partir de Java 8 disponemos de los Java Streams. Se trata de una herramienta que nos permite multitud de opciones relativas tratamiento y trasformaci\u00f3n de los datos manejados. En este apartado \u00fanicamente se menciona debido a que en muchas ocasiones cuando nos enfrentamos a consultas complejas, puede ser beneficioso evitar ofuscar las consultas y realizar las trasformaciones necesarias mediante los Streams. Un ejemplo de uso pr\u00e1ctico podr\u00eda ser, evitar usar la cl\u00e1usula IN de SQL en una determinada consulta que podr\u00eda penalizar notablemente el rendimiento de las consultas. En vez de eso se podr\u00eda utilizar el m\u00e9todo de JAVA filter sobre el conjunto de elementos para obtener el mismo resultado. Puedes leer m\u00e1s informaci\u00f3n en el tutorial de Baeldung .","title":"Alternativa de Streams"},{"location":"appendix/jpa/#specifications","text":"En algunos casos puede ocurrir que con las herramientas descritas anteriormente no tengamos suficiente alcance, bien porque las definiciones de los m\u00e9todos se complican y alargan demasiado o debido a que la consulta es demasiado gen\u00e9rica como para realizarlo de este modo. Para este caso se dispone de las Specifications que nos proveen de una forma de escribir consultas reutilizables mediante una API que ofrece una forma fluida de crear y combinar consultas complejas. Un ejemplo de caso de uso podr\u00eda ser un CRUD de una determinada entidad que debe poder filtrar por todos los atributos de esta, donde el tipo de filtrado viene especificado en la propia consulta y no siempre es requerido. En este caso no podr\u00edamos construir una consulta basada en definir un determinado m\u00e9todo ya no conocemos de ante mano que filtros ni que atributos vamos a recibir y deberemos recurrir al uso de las Specifications. Puedes leer m\u00e1s informaci\u00f3n en el tutorial de Baeldung .","title":"Specifications"},{"location":"appendix/rest/","text":"Breve detalle sobre REST Antes de empezar vamos a hablar de operaciones REST. Estas operaciones son el punto de entrada a nuestra aplicaci\u00f3n y se pueden diferenciar dos claros elementos: Ruta hacia el recurso, lo que viene siendo la URL. Acci\u00f3n a realizar sobre el recurso, lo que viene siendo la operaci\u00f3n HTTP o el verbo. Ruta del recurso La ruta del recurso nos indica entre otras cosas, el endpoint y su posible jerarqu\u00eda sobre la que se va a realizar la operaci\u00f3n. Debe tener una ra\u00edz de recurso y si se requiere navegar por el recursos, la jerarqu\u00eda ir\u00e1 separada por barras. La URL nunca deber\u00eda tener verbos o acciones solamente recursos, identificadores o atributos. Por ejemplo en nuestro caso de Categor\u00edas , ser\u00edan correctas las siguientes rutas: /category /category/3 /category/?name=Dados Sin embargo, no ser\u00edan del todo correctas las rutas: /getCategory /findCategories /saveCategory /category/save A menudo, se integran datos identificadores o atributos de b\u00fasqueda dentro de la propia ruta. Podr\u00edamos definir la operaci\u00f3n category/3 para referirse a la Categor\u00eda con ID = 3, o category/?name=Dados para referirse a las categor\u00edas con nombre = Dados. A veces, estos datos tambi\u00e9n pueden ir como atributos en la URL o en el cuerpo de la petici\u00f3n, aunque se recomienda que siempre que sean identificadores vayan determinados en la propia URL. Si el dominio categor\u00eda tuviera hijos o relaciones con alg\u00fan otro dominio se podr\u00eda a\u00f1adir esas jerarqu\u00eda a la URL. Por ejemplo podr\u00edamos tener category/3/child/2 para referirnos al hijo de ID = 2 que tiene la Categor\u00eda de ID = 3, y as\u00ed sucesivamente. Acci\u00f3n sobre el recurso La acci\u00f3n sobre el recurso se determina mediante la operaci\u00f3n o verbo HTTP que se utiliza en el endpoint. Los verbos m\u00e1s usados ser\u00edan: GET . Cuando se quiere recuperar un recursos. POST . Cuando se quiere crear un recurso. Aunque a menudo se utiliza para realizar otras acciones de b\u00fasqueda o validaci\u00f3n. PUT . Cuando se quiere actualizar o modificar un recurso. Aunque a menudo se utiliza una sola operaci\u00f3n para crear o actualizar. En ese caso se utilizar\u00eda solamente POST . DELETE . Cuando se quiere eliminar un recurso. De esta forma tendr\u00edamos: GET /category/3 . Realizar\u00eda un acceso para recuperar la categor\u00eda 3. POST o PUT /category/3 . Realizar\u00eda un acceso para crear o modificar la categor\u00eda 3. Los datos a modificar deber\u00edan ir en el body. DELETE /category/3 . Realizar\u00eda un acceso para borrar la categor\u00eda 3. GET /category/?name=Dados . Realizar\u00eda un acceso para recuperar las categor\u00edas que tengan nombre = Dados. Excepciones a la regla A veces hay que ejecutar una operaci\u00f3n que no es 'estandar' en cuanto a verbos HTTP. Para ese caso, deberemos clarificar en la URL la acci\u00f3n que se debe realizar y si vamos a enviar datos deber\u00eda ser de tipo POST mientras que si simplemente se requiere una contestaci\u00f3n sin enviar datos ser\u00e1 de tipo GET . Por ejemplo POST /category/3/validate realizar\u00eda un acceso para ejecutar una validaci\u00f3n sobre los datos enviados en el body de la categor\u00eda 3.","title":"Anexo. Detalle REST"},{"location":"appendix/rest/#breve-detalle-sobre-rest","text":"Antes de empezar vamos a hablar de operaciones REST. Estas operaciones son el punto de entrada a nuestra aplicaci\u00f3n y se pueden diferenciar dos claros elementos: Ruta hacia el recurso, lo que viene siendo la URL. Acci\u00f3n a realizar sobre el recurso, lo que viene siendo la operaci\u00f3n HTTP o el verbo.","title":"Breve detalle sobre REST"},{"location":"appendix/rest/#ruta-del-recurso","text":"La ruta del recurso nos indica entre otras cosas, el endpoint y su posible jerarqu\u00eda sobre la que se va a realizar la operaci\u00f3n. Debe tener una ra\u00edz de recurso y si se requiere navegar por el recursos, la jerarqu\u00eda ir\u00e1 separada por barras. La URL nunca deber\u00eda tener verbos o acciones solamente recursos, identificadores o atributos. Por ejemplo en nuestro caso de Categor\u00edas , ser\u00edan correctas las siguientes rutas: /category /category/3 /category/?name=Dados Sin embargo, no ser\u00edan del todo correctas las rutas: /getCategory /findCategories /saveCategory /category/save A menudo, se integran datos identificadores o atributos de b\u00fasqueda dentro de la propia ruta. Podr\u00edamos definir la operaci\u00f3n category/3 para referirse a la Categor\u00eda con ID = 3, o category/?name=Dados para referirse a las categor\u00edas con nombre = Dados. A veces, estos datos tambi\u00e9n pueden ir como atributos en la URL o en el cuerpo de la petici\u00f3n, aunque se recomienda que siempre que sean identificadores vayan determinados en la propia URL. Si el dominio categor\u00eda tuviera hijos o relaciones con alg\u00fan otro dominio se podr\u00eda a\u00f1adir esas jerarqu\u00eda a la URL. Por ejemplo podr\u00edamos tener category/3/child/2 para referirnos al hijo de ID = 2 que tiene la Categor\u00eda de ID = 3, y as\u00ed sucesivamente.","title":"Ruta del recurso"},{"location":"appendix/rest/#accion-sobre-el-recurso","text":"La acci\u00f3n sobre el recurso se determina mediante la operaci\u00f3n o verbo HTTP que se utiliza en el endpoint. Los verbos m\u00e1s usados ser\u00edan: GET . Cuando se quiere recuperar un recursos. POST . Cuando se quiere crear un recurso. Aunque a menudo se utiliza para realizar otras acciones de b\u00fasqueda o validaci\u00f3n. PUT . Cuando se quiere actualizar o modificar un recurso. Aunque a menudo se utiliza una sola operaci\u00f3n para crear o actualizar. En ese caso se utilizar\u00eda solamente POST . DELETE . Cuando se quiere eliminar un recurso. De esta forma tendr\u00edamos: GET /category/3 . Realizar\u00eda un acceso para recuperar la categor\u00eda 3. POST o PUT /category/3 . Realizar\u00eda un acceso para crear o modificar la categor\u00eda 3. Los datos a modificar deber\u00edan ir en el body. DELETE /category/3 . Realizar\u00eda un acceso para borrar la categor\u00eda 3. GET /category/?name=Dados . Realizar\u00eda un acceso para recuperar las categor\u00edas que tengan nombre = Dados. Excepciones a la regla A veces hay que ejecutar una operaci\u00f3n que no es 'estandar' en cuanto a verbos HTTP. Para ese caso, deberemos clarificar en la URL la acci\u00f3n que se debe realizar y si vamos a enviar datos deber\u00eda ser de tipo POST mientras que si simplemente se requiere una contestaci\u00f3n sin enviar datos ser\u00e1 de tipo GET . Por ejemplo POST /category/3/validate realizar\u00eda un acceso para ejecutar una validaci\u00f3n sobre los datos enviados en el body de la categor\u00eda 3.","title":"Acci\u00f3n sobre el recurso"},{"location":"appendix/styles/","text":"Estilos Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n. Preprocesadores Un preprocesador de CSS es una herramienta que nos permite escribir pseudo-c\u00f3digo CSS que luego ser\u00e1 convertido a CSS real. Ese pseudo-c\u00f3digo se conforma de variables, condiciones, bucles o funciones. Podr\u00edamos decir que tenemos un lenguaje de programaci\u00f3n que genera CSS. Responsive web El dise\u00f1o web adaptable (tambi\u00e9n dise\u00f1o web adaptativo o responsivo; este \u00faltimo calco del ingl\u00e9s responsive web design), es una filosof\u00eda de dise\u00f1o y desarrollo cuyo objetivo es adaptar la apariencia de las p\u00e1ginas web al dispositivo que se est\u00e9 utilizando para visitarlas Metodolog\u00edas Las Metodolog\u00edas o Arquitecturas CSS nos ayudaran a escribir c\u00f3digo CSS m\u00e1s predecible, reutilizable, mantenible y escalable. oocss El objetivo de OOCSS es la idea de tratar los elementos de la p\u00e1gina como objetos , dando todas estas clases de objetos , tratando las clases de los objetos como entidades individuales en las hojas de estilo y tom\u00e1ndolas desde all\u00ed. http://oocss.org/ bem BEM significa Modificador de Bloques de Elementos (Block Element Modifier) por sus siglas en ingl\u00e9s. Sugiere una manera estructura de nombrar tus clases, basado en las propiedades del elemento en cuesti\u00f3n. https://en.bem.info/methodology/quick-start/ smacss La metodolog\u00eda SMACSS consigue categorizar reglas CSS en 5 tipos: http://smacss.com/ - Base - Dise\u00f1o - M\u00f3dulo - Estado - Tema","title":"Anexo. Estilos (TBC)"},{"location":"appendix/styles/#estilos","text":"Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n.","title":"Estilos"},{"location":"appendix/styles/#preprocesadores","text":"Un preprocesador de CSS es una herramienta que nos permite escribir pseudo-c\u00f3digo CSS que luego ser\u00e1 convertido a CSS real. Ese pseudo-c\u00f3digo se conforma de variables, condiciones, bucles o funciones. Podr\u00edamos decir que tenemos un lenguaje de programaci\u00f3n que genera CSS.","title":"Preprocesadores"},{"location":"appendix/styles/#responsive-web","text":"El dise\u00f1o web adaptable (tambi\u00e9n dise\u00f1o web adaptativo o responsivo; este \u00faltimo calco del ingl\u00e9s responsive web design), es una filosof\u00eda de dise\u00f1o y desarrollo cuyo objetivo es adaptar la apariencia de las p\u00e1ginas web al dispositivo que se est\u00e9 utilizando para visitarlas","title":"Responsive web"},{"location":"appendix/styles/#metodologias","text":"Las Metodolog\u00edas o Arquitecturas CSS nos ayudaran a escribir c\u00f3digo CSS m\u00e1s predecible, reutilizable, mantenible y escalable.","title":"Metodolog\u00edas"},{"location":"appendix/styles/#oocss","text":"El objetivo de OOCSS es la idea de tratar los elementos de la p\u00e1gina como objetos , dando todas estas clases de objetos , tratando las clases de los objetos como entidades individuales en las hojas de estilo y tom\u00e1ndolas desde all\u00ed. http://oocss.org/","title":"oocss"},{"location":"appendix/styles/#bem","text":"BEM significa Modificador de Bloques de Elementos (Block Element Modifier) por sus siglas en ingl\u00e9s. Sugiere una manera estructura de nombrar tus clases, basado en las propiedades del elemento en cuesti\u00f3n. https://en.bem.info/methodology/quick-start/","title":"bem"},{"location":"appendix/styles/#smacss","text":"La metodolog\u00eda SMACSS consigue categorizar reglas CSS en 5 tipos: http://smacss.com/ - Base - Dise\u00f1o - M\u00f3dulo - Estado - Tema","title":"smacss"},{"location":"appendix/tdd/","text":"TDD (Test Driven Development) Se trata de una pr\u00e1ctica de programaci\u00f3n que consiste en escribir primero las pruebas (generalmente unitarias), despu\u00e9s escribir el c\u00f3digo fuente que pase la prueba satisfactoriamente y, por \u00faltimo, refactorizar el c\u00f3digo escrito. Este ciclo se suele representar con la siguiente imagen: Con esta pr\u00e1ctica se consigue entre otras cosas: un c\u00f3digo m\u00e1s robusto, m\u00e1s seguro, m\u00e1s mantenible y una mayor rapidez en el desarrollo. Los pasos que se siguen son: Primero hay que escribir el test o los tests que cubran la funcionalidad que voy a implementar. Los test no solo deben probar los casos correctos, sino que deben probar los casos err\u00f3neos e incluso los casos en los que se provoca una excepci\u00f3n. Cuantos m\u00e1s test hagas, mejor probada y m\u00e1s robusta ser\u00e1 tu aplicaci\u00f3n. Adem\u00e1s, como efecto colateral, al escribir el test est\u00e1s pensando el dise\u00f1o de c\u00f3mo va a funcionar la aplicaci\u00f3n. En vez de liarte a programar como loco, te est\u00e1s forzando a pensar primero y ver cual es la mejor soluci\u00f3n. Por ejemplo para implementar una operaci\u00f3n de calculadora primero piensas en qu\u00e9 es lo que necesitar\u00e1s: una clase Calculadora con un m\u00e9todo que se llame Suma y que tenga dos par\u00e1metros. El segundo paso una vez tengo definido el test, que evidentemente fallar\u00e1 (e incluso a menudo ni siquiera compilar\u00e1), es implementar el c\u00f3digo necesario para que los tests funcionen. Aqu\u00ed muchas veces pecamos de querer implementar demasiadas cosas o pensando en que en un futuro necesitaremos modificar ciertas partes y lo dejamos ya preparado para ello. Hay que ir con mucho cuidado con las optimizaciones prematuras , a menudo no son necesarias y solo hacen que dificultar nuestro c\u00f3digo. Piensa en construir el m\u00ednimo c\u00f3digo que haga que tus tests funcionen correctamente. Adem\u00e1s, no es necesario que sea un c\u00f3digo demasiado purista y limpio. El \u00faltimo paso y a menudo el m\u00e1s olvidado es el Refactor . Una vez te has asegurado que tu c\u00f3digo funciona y que los tests funcionan correctamente (ojo no solo los tuyos sino todos los que ya existan en la aplicaci\u00f3n) llega el paso de sacarle brillo a tu c\u00f3digo. En este paso tienes que intentar mejorar tu c\u00f3digo, evitar duplicidades, evitar malos olores de programaci\u00f3n, eliminar posibles malos usos del lenguaje, etc. En definitiva que tu c\u00f3digo se lea y se entienda mejor. Si seguimos estos pasos a la hora de programar, nuestra aplicaci\u00f3n estar\u00e1 muy bien testada. Cada vez que hagamos un cambio tendremos una certeza muy elevada, de forma r\u00e1pida y sencilla, de si la aplicaci\u00f3n sigue funcionando o hemos roto algo. Y lo mejor de todo, las implementaciones que hagamos estar\u00e1n bien pensadas y dise\u00f1adas y acotadas realmente a lo que necesitamos.","title":"Anexo. TDD"},{"location":"appendix/tdd/#tdd-test-driven-development","text":"Se trata de una pr\u00e1ctica de programaci\u00f3n que consiste en escribir primero las pruebas (generalmente unitarias), despu\u00e9s escribir el c\u00f3digo fuente que pase la prueba satisfactoriamente y, por \u00faltimo, refactorizar el c\u00f3digo escrito. Este ciclo se suele representar con la siguiente imagen: Con esta pr\u00e1ctica se consigue entre otras cosas: un c\u00f3digo m\u00e1s robusto, m\u00e1s seguro, m\u00e1s mantenible y una mayor rapidez en el desarrollo. Los pasos que se siguen son: Primero hay que escribir el test o los tests que cubran la funcionalidad que voy a implementar. Los test no solo deben probar los casos correctos, sino que deben probar los casos err\u00f3neos e incluso los casos en los que se provoca una excepci\u00f3n. Cuantos m\u00e1s test hagas, mejor probada y m\u00e1s robusta ser\u00e1 tu aplicaci\u00f3n. Adem\u00e1s, como efecto colateral, al escribir el test est\u00e1s pensando el dise\u00f1o de c\u00f3mo va a funcionar la aplicaci\u00f3n. En vez de liarte a programar como loco, te est\u00e1s forzando a pensar primero y ver cual es la mejor soluci\u00f3n. Por ejemplo para implementar una operaci\u00f3n de calculadora primero piensas en qu\u00e9 es lo que necesitar\u00e1s: una clase Calculadora con un m\u00e9todo que se llame Suma y que tenga dos par\u00e1metros. El segundo paso una vez tengo definido el test, que evidentemente fallar\u00e1 (e incluso a menudo ni siquiera compilar\u00e1), es implementar el c\u00f3digo necesario para que los tests funcionen. Aqu\u00ed muchas veces pecamos de querer implementar demasiadas cosas o pensando en que en un futuro necesitaremos modificar ciertas partes y lo dejamos ya preparado para ello. Hay que ir con mucho cuidado con las optimizaciones prematuras , a menudo no son necesarias y solo hacen que dificultar nuestro c\u00f3digo. Piensa en construir el m\u00ednimo c\u00f3digo que haga que tus tests funcionen correctamente. Adem\u00e1s, no es necesario que sea un c\u00f3digo demasiado purista y limpio. El \u00faltimo paso y a menudo el m\u00e1s olvidado es el Refactor . Una vez te has asegurado que tu c\u00f3digo funciona y que los tests funcionan correctamente (ojo no solo los tuyos sino todos los que ya existan en la aplicaci\u00f3n) llega el paso de sacarle brillo a tu c\u00f3digo. En este paso tienes que intentar mejorar tu c\u00f3digo, evitar duplicidades, evitar malos olores de programaci\u00f3n, eliminar posibles malos usos del lenguaje, etc. En definitiva que tu c\u00f3digo se lea y se entienda mejor. Si seguimos estos pasos a la hora de programar, nuestra aplicaci\u00f3n estar\u00e1 muy bien testada. Cada vez que hagamos un cambio tendremos una certeza muy elevada, de forma r\u00e1pida y sencilla, de si la aplicaci\u00f3n sigue funcionando o hemos roto algo. Y lo mejor de todo, las implementaciones que hagamos estar\u00e1n bien pensadas y dise\u00f1adas y acotadas realmente a lo que necesitamos.","title":"TDD (Test Driven Development)"},{"location":"develop/step1/","text":"Desarrollo con Angular Ahora que ya tenemos listo tanto el proyecto back de SpringBoot (en el puerto 8080) como el proyecto front de Angular (en el puerto 4200), ya podemos empezar a codificar la soluci\u00f3n. Durante todo el tutorial vamos a intentar separar completamente la implementaci\u00f3n de front de la implementaci\u00f3n de back, para que quede claro como se debe realizar en cada una de las tecnolog\u00edas. Primeros pasos Antes de empezar Antes de empezar esta parte te recomendamos encarecidamente que hagas el tutorial que viene en la propia p\u00e1gina de Angular, donde explican algunos de los conceptos b\u00e1sicos y generales de las aplicaciones. Te servir\u00e1 mucho para conocer algunos de los aspectos y componentes que utilizamos durante este tutorial. Lo puedes visitar desde su web Tour of Heroes Si abrimos el proyecto con el IDE que tengamos (Visual Studio Code en el caso del tutorial) podemos ver que en la carpeta src/app existen unos ficheros ya creados por defecto. Estos ficheros son: app.component.ts \u2192 contiene el c\u00f3digo inicial del proyecto escrito en TypeScript. app.component.html \u2192 contiene la plantilla inicial del proyecto escrita en HTML. app.component.scss \u2192 contiene los estilos CSS privados de la plantilla inicial. Vamos a modificar este c\u00f3digo inicial para ver como funciona. Abrimos el fichero app.component.ts y modificamos la l\u00ednea donde se asigna un valor a la variable title . app.component.ts ... title = 'Tutorial de Angular + Springboot' ; ... Ahora abrimos el fichero app.component.html , borramos todo el c\u00f3digo de la plantilla y a\u00f1adimos el siguiente c\u00f3digo: app.component.html < h1 > {{title}} </ h1 > Las llaves dobles permiten hacen un binding entre el c\u00f3digo del componente y la plantilla. Es decir, en este caso ir\u00e1 al c\u00f3digo TypeScript y buscar\u00e1 el valor de la variable title . Consejo El binding tambi\u00e9n nos sirve para ejecutar los m\u00e9todos de TypeScript desde el c\u00f3digo HTML. Adem\u00e1s si el valor que contiene la variable se modificara durante la ejecuci\u00f3n de alg\u00fan m\u00e9todo, autom\u00e1ticamente el c\u00f3digo HTML refrescar\u00eda el nuevo valor de la variable title Si abrimos el navegador y accedemos a http://localhost:4200/ podremos ver el resultado del c\u00f3digo. Layout general Crear componente Lo primero que vamos a hacer es escoger un tema y una paleta de componentes para trabajar. Lo m\u00e1s c\u00f3modo es trabajar con Material que ya viene perfectamente integrado en Angular. Ejecutamos el comando y elegimos la paleta de colores que m\u00e1s nos guste o bien creamos una custom: ng add @angular/material Recuerda Al a\u00f1adir una nueva librer\u00eda tenemos que parar el servidor y volver a arrancarlo para que compile y precargue las nuevas dependencias. Una vez a\u00f1adida la dependencia, lo que queremos es crear una primera estructura inicial a la p\u00e1gina. Si te acuerdas cual era la estructura (y si no te acuerdas, vuelve a la secci\u00f3n Contexto de la aplicaci\u00f3n y lo revisas), ten\u00edamos una cabecera superior con un logo y t\u00edtulo y unas opciones de men\u00fa. Pues vamos a ello, crearemos esa estructura com\u00fan para toda la aplicaci\u00f3n. Este componente al ser algo core para toda la aplicaci\u00f3n deber\u00edamos crearlo dentro del m\u00f3dulo core como ya vimos anteriormente. Pero antes de todo, vamos a crear los m\u00f3dulos generales de la aplicaci\u00f3n, as\u00ed que ejecutamos en consola el comando que nos permite crear un m\u00f3dulo nuevo: ng generate module core Y a\u00f1adimos esos m\u00f3dulos al m\u00f3dulo padre de la aplicaci\u00f3n: app.module.ts import { BrowserModule } from '@angular/platform-browser' ; import { NgModule } from '@angular/core' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { BrowserAnimationsModule } from '@angular/platform-browser/animations' ; import { CoreModule } from './core/core.module' ; @NgModule ({ declarations : [ AppComponent ], imports : [ BrowserModule , AppRoutingModule , CoreModule , BrowserAnimationsModule , ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { } Y despu\u00e9s crearemos el componente header, dentro del m\u00f3dulo core. Para eso ejecutaremos el comando: ng generate component core/header C\u00f3digo de la pantalla Esto nos crear\u00e1 una carpeta con los ficheros del componente, donde tendremos que copiar el siguiente contenido: header.component.html header.component.scss < mat-toolbar > < mat-toolbar-row > < div class = \"header_container\" > < div class = \"header_title\" > < mat-icon > storefront </ mat-icon > Ludoteca Tan </ div > < div class = \"header_separator\" > | </ div > < div class = \"header_menu\" > < div class = \"header_button\" > < a routerLink = \"/games\" routerLinkActive = \"active\" > Cat\u00e1logo </ a > </ div > < div class = \"header_button\" > < a routerLink = \"/categories\" routerLinkActive = \"active\" > Categor\u00edas </ a > </ div > < div class = \"header_button\" > < a routerLink = \"/authors\" routerLinkActive = \"active\" > Autores </ a > </ div > </ div > < div class = \"header_login\" > < mat-icon > account_circle </ mat-icon > Sign in </ div > </ div > </ mat-toolbar-row > </ mat-toolbar > . mat-toolbar { background-color : blue ; color : white ; } . header_container { display : flex ; width : 100 % ; .header_title { .mat-icon { vertical-align : sub ; } } . header_separator { margin-left : 30 px ; margin-right : 30 px ; } . header_menu { flex-grow : 4 ; display : flex ; flex-direction : row ; .header_button { margin-left : 1 em ; margin-right : 1 em ; font-size : 16 px ; a { font-weight : lighter ; text-decoration : none ; cursor : pointer ; color : white ; } a : hover { color : grey ; } a . active { font-weight : normal ; text-decoration : underline ; color : lightyellow ; } } } . header_login { font-size : 16 px ; cursor : pointer ; .mat-icon { vertical-align : sub ; } } } Al utilizar etiquetas de material como mat-toolbar o mat-icon y routerLink necesitaremos importar las dependencias. Esto lo podemos hacer directamente en el m\u00f3dulo del que depende, es decir en el fichero core.module.ts core.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { MatIconModule } from '@angular/material/icon' ; import { MatToolbarModule } from '@angular/material/toolbar' ; import { HeaderComponent } from './header/header.component' ; import { RouterModule } from '@angular/router' ; @NgModule ({ declarations : [ HeaderComponent ], imports : [ CommonModule , RouterModule , MatIconModule , MatToolbarModule , ], exports : [ HeaderComponent ] }) export class CoreModule { } Adem\u00e1s de a\u00f1adir las dependencias, diremos que este m\u00f3dulo va a exportar el componente HeaderComponent para poder utilizarlo desde otras p\u00e1ginas. Ya por \u00faltimo solo nos queda modificar la p\u00e1gina general de la aplicaci\u00f3n app.component.html para a\u00f1adirle el componente HeaderComponent . app.component.html < div > < app-header ></ app-header > < div > < router-outlet ></ router-outlet > </ div > </ div > Vamos al navegador y refrescamos la p\u00e1gina, deber\u00eda aparecer una barra superior (Header) con las opciones de men\u00fa. Algo similar a esto: Recuerda Cuando se a\u00f1aden componentes a los ficheros html , siempre se deben utilizar los selectores definidos para el componente. En el caso anterior hemos a\u00f1adido app-header que es el mismo nombre selector que tiene el componente en el fichero header.component.ts . Adem\u00e1s, recuerda que para poder utilizar componentes de otros m\u00f3dulos, los debes exportar ya que de lo contrario tan solo podr\u00e1n utilizarse dentro del m\u00f3dulo donde se declaran. Creando un listado b\u00e1sico Crear componente Ya tenemos la estructura principal, ahora vamos a crear nuestra primera pantalla. Vamos a empezar por la de Categor\u00edas que es la m\u00e1s sencilla, ya que se trata de un listado, que muestra datos sin filtrar ni paginar. Como categor\u00edas es un dominio funcional de la aplicaci\u00f3n, vamos a crear un m\u00f3dulo que contenga toda la funcionalidad de ese dominio. Ejecutamos en consola: ng generate module category Y por tanto, al igual que hicimos anteriormente, hay que a\u00f1adir el m\u00f3dulo al fichero app.module.ts app.module.ts import { BrowserModule } from '@angular/platform-browser' ; import { NgModule } from '@angular/core' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { BrowserAnimationsModule } from '@angular/platform-browser/animations' ; import { CoreModule } from './core/core.module' ; import { CategoryModule } from './category/category.module' ; @NgModule ({ declarations : [ AppComponent ], imports : [ BrowserModule , AppRoutingModule , CoreModule , CategoryModule , BrowserAnimationsModule , ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { } Ahora todas las pantallas, componentes y servicios que creemos, referidos a este dominio funcional, deber\u00e1n ir dentro del modulo cagegory . Vamos a crear un primer componente que ser\u00e1 un listado de categor\u00edas. Para ello vamos a ejecutar el siguiente comando: ng generate component category/category-list Para terminar de configurar la aplicaci\u00f3n, vamos a a\u00f1adir la ruta del componente dentro del componente routing de Angular, para poder acceder a \u00e9l, para ello modificamos el fichero app-routing.module.ts app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { CategoryListComponent } from './category/category-list/category-list.component' ; const routes : Routes = [ { path : 'categories' , component : CategoryListComponent }, ]; @NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } Si abrimos el navegador y accedemos a http://localhost:4200/ podremos navegar mediante el men\u00fa Categor\u00edas el cual abrir\u00e1 el componente que acabamos de crear. C\u00f3digo de la pantalla Ahora vamos a construir la pantalla. Para manejar la informaci\u00f3n del listado, necesitamos almacenar los datos en un objeto de tipo model . Para ello crearemos un fichero en category\\model\\Category.ts donde implementaremos la clase necesaria. Esta clase ser\u00e1 la que utilizaremos en el c\u00f3digo html y ts de nuestro componente. Category.ts export class Category { id : number ; name : string ; } Tambi\u00e9n, escribiremos el c\u00f3digo de la pantalla de listado. category-list.component.html category-list.component.scss category-list.component.ts < div class = \"container\" > < h1 > Listado de Categor\u00edas </ h1 > < mat-table [ dataSource ]=\" dataSource \" > < ng-container matColumnDef = \"id\" > < mat-header-cell * matHeaderCellDef > Identificador </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.id}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"name\" > < mat-header-cell * matHeaderCellDef > Nombre categor\u00eda </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.name}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" >< mat-icon > edit </ mat-icon ></ button > < button mat-icon-button color = \"accent\" >< mat-icon > clear </ mat-icon ></ button > </ mat-cell > </ ng-container > < mat-header-row * matHeaderRowDef = \"displayedColumns; sticky: true\" ></ mat-header-row > < mat-row * matRowDef = \"let row; columns: displayedColumns;\" ></ mat-row > </ mat-table > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" > Nueva categor\u00eda </ button > </ div > </ div > . container { margin : 20 px ; mat-table { margin-top : 10 px ; margin-bottom : 20 px ; .mat-header-row { background-color : #f5f5f5 ; .mat-header-cell { text-transform : uppercase ; font-weight : bold ; color : #838383 ; } } . mat-column-id { flex : 0 0 20 % ; justify-content : center ; } . mat-column-action { flex : 0 0 10 % ; justify-content : center ; } } . buttons { text-align : right ; } } import { Component , OnInit } from '@angular/core' ; import { MatTableDataSource } from '@angular/material/table' ; import { Category } from '../model/Category' ; @Component ({ selector : 'app-category-list' , templateUrl : './category-list.component.html' , styleUrls : [ './category-list.component.scss' ] }) export class CategoryListComponent implements OnInit { dataSource = new MatTableDataSource < Category > (); displayedColumns : string [] = [ 'id' , 'name' , 'action' ]; constructor () { } ngOnInit () : void { } } El c\u00f3digo HTML es f\u00e1cil de seguir pero por si acaso: L\u00ednea 4: Creamos la tabla con la variable dataSource definida en el fichero .ts L\u00ednea 5: Definici\u00f3n de la primera columna, su cabecera y el dato que va a contener L\u00ednea 10: Definici\u00f3n de la segunda columna, su cabecera y el dato que va a contener L\u00ednea 15: Definici\u00f3n de la tercera columna, su cabecera vac\u00eda y los dos botones de acci\u00f3n L\u00ednea 23 y 24: Construcci\u00f3n de la cabecera y las filas Y ya por \u00faltimo, a\u00f1adimos los componentes que se han utilizado de Angular Material a las dependencias del m\u00f3dulo donde est\u00e1 definido el componente en este caso category\\category.module.ts : category.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { MatTableModule } from '@angular/material/table' ; import { MatIconModule } from '@angular/material/icon' ; import { MatButtonModule } from '@angular/material/button' ; import { CategoryListComponent } from './category-list/category-list.component' ; @NgModule ({ declarations : [ CategoryListComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule ], }) export class CategoryModule { } Si abrimos el navegador y accedemos a http://localhost:4200/ y pulsamos en el men\u00fa de Categor\u00edas obtendremos una pantalla con un listado vac\u00edo (solo con cabeceras) y un bot\u00f3n de crear Nueva Categor\u00eda que aun no hace nada. A\u00f1adiendo datos En este punto y para ver como responde el listado, vamos a a\u00f1adir datos. Si tuvieramos el backend implementado podr\u00edamos consultar los datos directamente de una operaci\u00f3n de negocio de backend, pero ahora mismo no lo tenemos implementado as\u00ed que para no bloquear el desarrollo vamos a mockear los datos. Creando un servicio En angular, cualquier acceso a datos debe pasar por un service , as\u00ed que vamos a crearnos uno para todas las operaciones de categor\u00edas. Vamos a la consola y ejecutamos: ng generate service category/category Esto nos crear\u00e1 un servicio, que adem\u00e1s podemos utilizarlo inyect\u00e1ndolo en cualquier componente que lo necesite. Implementando un servicio Vamos a implementar una operaci\u00f3n de negocio que recupere el listado de categor\u00edas y lo vamos a hacer de forma reactiva (as\u00edncrona) para simular una petici\u00f3n a backend. Modificamos los siguientes ficheros: category.service.ts category-list.component.ts import { Injectable } from '@angular/core' ; import { Observable } from 'rxjs' ; import { Category } from './model/Category' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor () { } getCategories () : Observable < Category [] > { return new Observable (); } } import { Component , OnInit } from '@angular/core' ; import { MatTableDataSource } from '@angular/material/table' ; import { Category } from '../model/Category' ; import { CategoryService } from '../category.service' ; @Component ({ selector : 'app-categories' , templateUrl : './categories.component.html' , styleUrls : [ './categories.component.scss' ] }) export class CategoriesComponent implements OnInit { dataSource = new MatTableDataSource < Category > (); displayedColumns : string [] = [ 'id' , 'name' , 'action' ]; constructor ( private categoryService : CategoryService , ) { } ngOnInit () : void { this . categoryService . getCategories (). subscribe ( categories => this . dataSource . data = categories ); } } Mockeando datos Como hemos comentado anteriormente, el backend todav\u00eda no est\u00e1 implementado as\u00ed que vamos a mockear datos. Nos crearemos un fichero mock-categories.ts dentro de model, con datos ficticios y modificaremos el servicio para que devuelva esos datos. De esta forma, cuando tengamos implementada la operaci\u00f3n de negocio en backend, tan solo tenemos que sustuir el c\u00f3digo que devuelve datos est\u00e1ticos por una llamada http. mock-categories.ts category.service.ts import { Category } from \"./Category\" ; export const CATEGORY_DATA : Category [] = [ { id : 1 , name : 'Dados' }, { id : 2 , name : 'Fichas' }, { id : 3 , name : 'Cartas' }, { id : 4 , name : 'Rol' }, { id : 5 , name : 'Tableros' }, { id : 6 , name : 'Tem\u00e1ticos' }, { id : 7 , name : 'Europeos' }, { id : 8 , name : 'Guerra' }, { id : 9 , name : 'Abstractos' }, ] import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; import { CATEGORY_DATA } from './model/mock-categories' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor () { } getCategories () : Observable < Category [] > { return of ( CATEGORY_DATA ); } } Si ahora refrescamos la p\u00e1gina web, veremos que el listado ya tiene datos con los que vamos a interactuar. Simulando las otras peticiones Para terminar, vamos a simular las otras dos peticiones, la de editar y la de borrar para cuando tengamos que utilizarlas. El servicio debe quedar m\u00e1s o menos as\u00ed: category.service.ts import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; import { CATEGORY_DATA } from './model/mock-categories' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor () { } getCategories () : Observable < Category [] > { return of ( CATEGORY_DATA ); } saveCategory ( category : Category ) : Observable < Category > { return of ( null ); } deleteCategory ( idCategory : number ) : Observable < any > { return of ( null ); } } A\u00f1adiendo acciones al listado Crear componente Ahora nos queda a\u00f1adir las acciones al listado: crear, editar y eliminar. Empezaremos primero por las acciones de crear y editar, que ambas deber\u00edan abrir una ventana modal con un formulario para poder modificar datos de la entidad Categor\u00eda . Como siempre, para crear un componente usamos el asistente de Angular, esta vez al tratarse de una pantalla que solo vamos a utilizar dentro del dominio de categor\u00edas, tiene sentido que lo creemos dentro de ese m\u00f3dulo: ng generate component category/category-edit Ahora vamos a hacer que se abra al pulsar el bot\u00f3n Nueva categor\u00eda . Para eso, vamos al fichero category-list.component.ts y a\u00f1adimos un nuevo m\u00e9todo: category-list.component.ts ... import { MatDialog } from '@angular/material/dialog' ; import { CategoryEditComponent } from '../category-edit/category-edit.component' ; ... constructor ( private categoryService : CategoryService , public dialog : MatDialog , ) { } ... createCategory () { const dialogRef = this . dialog . open ( CategoryEditComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } ... Para poder abrir un componente dentro de un dialogo necesitamos obtener en el constructor un MatDialog. De ah\u00ed que hayamos tenido que a\u00f1adirlo como import y en el constructor. Dentro del m\u00e9todo createCategory lo que hacemos es crear un dialogo con el componente CategoryEditComponent en su interior, pasarle unos datos de creaci\u00f3n, donde podemos poner estilos del dialog y un objeto data donde pondremos los datos que queremos pasar entre los componentes. Por \u00faltimo, nos suscribimos al evento afterClosed para ejecutar las acciones que creamos oportunas, en nuestro caso volveremos a cargar el listado inicial. Como hemos utilizado un MatDialog en el componente, necesitamos a\u00f1adirlo tambi\u00e9n al m\u00f3dulo, as\u00ed que abrimos el fichero category.module.ts y a\u00f1adimos: category.module.ts ... import { MAT_DIALOG_DATA , MatDialogModule } from '@angular/material/dialog' ; @NgModule ({ declarations : [ CategoryListComponent , CategoryEditComponent ], imports : [ ... MatDialogModule ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class CategoryModule { } Y ya por \u00faltimo enlazamos el click en el bot\u00f3n con el m\u00e9todo que acabamos de crear para abrir el dialogo. Modificamos el fichero category-list.component.html y a\u00f1adimos el evento click: category-list.component.html ... < div class = \"buttons\" > < button mat - flat - button color = \"primary\" ( click ) = \"createCategory()\" > Nueva categor\u00eda < /button> < /div> < /div> Si refrescamos el navegador y pulsamos el bot\u00f3n Nueva categor\u00eda veremos como se abre una ventana modal de tipo Dialog con el componente nuevo que hemos creado, aunque solo se leer\u00e1 category-edit works! que es el contenido por defecto del componente. C\u00f3digo del dialogo Ahora vamos a darle forma al formulario de editar y crear. Para ello vamos al html, ts y css del componente y pegamos el siguiente contenido: category-edit.component.html category-edit.component.scss category-edit.component.ts < div class = \"container\" > < h1 > Crear categor\u00eda </ h1 > < form > < mat-form-field > < mat-label > Identificador </ mat-label > < input type = \"number\" matInput placeholder = \"Identificador\" [( ngModel )]=\" category . id \" name = \"id\" disabled > </ mat-form-field > < mat-form-field > < mat-label > Nombre </ mat-label > < input type = \"text\" matInput placeholder = \"Nombre de categor\u00eda\" [( ngModel )]=\" category . name \" name = \"name\" required > < mat-error > El nombre no puede estar vac\u00edo </ mat-error > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onClose ()\" > Cerrar </ button > < button mat-flat-button color = \"primary\" ( click )=\" onSave ()\" > Guardar </ button > </ div > </ div > . container { min-width : 350 px ; max-width : 500 px ; width : 100 % ; form { display : flex ; flex-direction : column ; margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } import { Component , OnInit } from '@angular/core' ; import { MatDialogRef } from '@angular/material/dialog' ; import { CategoryService } from '../category.service' ; import { Category } from '../model/Category' ; @Component ({ selector : 'app-category-edit' , templateUrl : './category-edit.component.html' , styleUrls : [ './category-edit.component.scss' ] }) export class CategoryEditComponent implements OnInit { category : Category ; constructor ( public dialogRef : MatDialogRef < CategoryEditComponent > , private categoryService : CategoryService ) { } ngOnInit () : void { this . category = new Category (); } onSave () { this . categoryService . saveCategory ( this . category ). subscribe ( result => { this . dialogRef . close (); }); } onClose () { this . dialogRef . close (); } } Si te fijas en el c\u00f3digo TypeScript, hemos a\u00f1adido en el m\u00e9todo onSave una llamada al servicio de CategoryService que aunque no realice ninguna operaci\u00f3n de momento, por lo menos lo dejamos preparado para conectar con el servidor. Adem\u00e1s, como siempre, al utilizar componentes matInput , matForm , matError hay que a\u00f1adirlos como dependencias en el m\u00f3dulo category.module.ts : category.module.ts ... import { MAT_DIALOG_DATA , MatDialogModule } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatInputModule } from '@angular/material/input' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; @NgModule ({ declarations : [ CategoryListComponent , CategoryEditComponent ], imports : [ ... MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class CategoryModule { } Ahora podemos navegar y abrir el cuadro de dialogo mediante el bot\u00f3n Nueva categor\u00eda para ver como queda nuestro formulario. Utilizar el dialogo para editar El mismo componente que hemos utilizado para crear una nueva categor\u00eda, nos sirve tambi\u00e9n para editar una categor\u00eda existente. Tan solo tenemos que utilizar la funcionalidad que Angular nos proporciona y pasarle los datos a editar en la llamada de apertura del Dialog. Vamos a implementar funcionalidad sobre el icono editar , tendremos que modificar unos cuantos ficheros: category-list.component.html category-list.component.ts < div class = \"container\" > < h1 > Listado de Categor\u00edas </ h1 > < mat-table [ dataSource ]=\" dataSource \" > < ng-container matColumnDef = \"id\" > < mat-header-cell * matHeaderCellDef > Identificador </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.id}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"name\" > < mat-header-cell * matHeaderCellDef > Nombre categor\u00eda </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.name}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" > < mat-icon ( click )=\" editCategory ( element )\" > edit </ mat-icon > </ button > < button mat-icon-button color = \"accent\" >< mat-icon > clear </ mat-icon ></ button > </ mat-cell > </ ng-container > < mat-header-row * matHeaderRowDef = \"displayedColumns; sticky: true\" ></ mat-header-row > < mat-row * matRowDef = \"let row; columns: displayedColumns;\" ></ mat-row > </ mat-table > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createCategory ()\" > Nueva categor\u00eda </ button > </ div > </ div > export class CategoriesComponent implements OnInit { dataSource = new MatTableDataSource < Category > (); displayedColumns : string [] = [ 'id' , 'name' , 'action' ]; constructor ( private categoryService : CategoryService , public dialog : MatDialog , ) { } ngOnInit () : void { this . categoryService . getCategories (). subscribe ( categories => this . dataSource . data = categories ); } createCategory () { const dialogRef = this . dialog . open ( CategoryEditComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } editCategory ( category : Category ) { const dialogRef = this . dialog . open ( CategoryEditComponent , { data : { category : category } }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } } Y los Dialog: category-edit.component.html category-edit.component.ts < div class = \"container\" > < h1 * ngIf = \"category.id == null\" > Crear categor\u00eda < /h1> < h1 * ngIf = \"category.id != null\" > Modificar categor\u00eda < /h1> < form > < mat - form - field > ... import { Component , OnInit , Inject } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { CategoryService } from '../category.service' ; import { Category } from '../model/Category' ; @Component ({ selector : 'app-category-edit' , templateUrl : './category-edit.component.html' , styleUrls : [ './category-edit.component.scss' ] }) export class CategoryEditComponent implements OnInit { category : Category ; constructor ( public dialogRef : MatDialogRef < CategoryEditComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any , private categoryService : CategoryService ) { } ngOnInit () : void { if ( this . data . category != null ) { this . category = this . data . category ; } else { this . category = new Category (); } } onSave () { this . categoryService . saveCategory ( this . category ). subscribe ( result => { this . dialogRef . close (); }); } onClose () { this . dialogRef . close (); } } Navegando ahora por la p\u00e1gina y pulsando en el icono de editar, se deber\u00eda abrir una ventana con los datos que hemos seleccionado, similar a esta imagen: Si te fijas, al modificar los datos dentro de la ventana de di\u00e1logo se modifica tambi\u00e9n en el listado. Esto es porque estamos pasando el mismo objeto desde el listado a la ventana dialogo y al ser el listado y el formulario reactivos los dos, cualquier cambio sobre los datos se refresca directamente en la pantalla. Hay veces en la que este comportamiento nos interesa, pero en este caso no queremos que se modifique el listado. Para solucionarlo debemos hacer una copia del objeto, para que ambos modelos (formulario y listado) utilicen objetos diferentes. Es tan sencillo como modificar category-edit.component.ts y a\u00f1adirle una copia del dato category-edit.component.ts ... ngOnInit () : void { if ( this . data . category != null ) { this . category = Object . assign ({}, this . data . category ); } else { this . category = new Category (); } } ... Cuidado Hay que tener mucho cuidado con el binding de los objetos. Hay veces que al modificar un objeto NO queremos que se modifique en todas sus instancias y tenemos que poner especial cuidado en esos aspectos. Acci\u00f3n de borrado Por norma general, toda acci\u00f3n de borrado de un dato de pantalla requiere una confirmaci\u00f3n previa por parte del usuario. Es decir, para evitar que el dato se borre accidentalmente el usuario tendr\u00e1 que confirmar su acci\u00f3n. Por tanto vamos a crear un componente que nos permita pedir una confirmaci\u00f3n al usuario. Como esta pantalla de confirmaci\u00f3n va a ser algo com\u00fan a muchas acciones de borrado de nuestra aplicaci\u00f3n, vamos a crearla dentro del m\u00f3dulo core . Como siempre, ejecutamos el comando en consola: ng generate component core/dialog-confirmation E implementamos el c\u00f3digo que queremos que tenga el componente. Al ser un componente gen\u00e9rico vamos a aprovechar y leeremos las variables que le pasemos en data . dialog-confirmation.component.html dialog-confirmation.component.scss dialog-confirmation.component.ts < div class = \"container\" > < h1 > {{title}} </ h1 > < div [ innerHTML ]=\" description \" class = \"description\" ></ div > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onNo ()\" > No </ button > < button mat-flat-button color = \"primary\" ( click )=\" onYes ()\" > S\u00ed </ button > </ div > </ div > . container { min-width : 350 px ; max-width : 500 px ; width : 100 % ; .description { margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } import { Component , OnInit , Inject } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; @Component ({ selector : 'app-dialog-confirmation' , templateUrl : './dialog-confirmation.component.html' , styleUrls : [ './dialog-confirmation.component.scss' ] }) export class DialogConfirmationComponent implements OnInit { title : string ; description : string ; constructor ( public dialogRef : MatDialogRef < DialogConfirmationComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any ) { } ngOnInit () : void { this . title = this . data . title ; this . description = this . data . description ; } onYes () { this . dialogRef . close ( true ); } onNo () { this . dialogRef . close ( false ); } } Recuerda Recuerda que los componentes utilizados en el di\u00e1logo de confirmaci\u00f3n se deben a\u00f1adir al m\u00f3dulo padre al que pertenecen, en este caso a core.module.ts imports: [ CommonModule, RouterModule, MatIconModule, MatToolbarModule, MatDialogModule, MatButtonModule, ], providers: [ { provide: MAT_DIALOG_DATA, useValue: {}, }, ], Ya por \u00faltimo, una vez tenemos el componente gen\u00e9rico de dialogo, vamos a utilizarlo en nuestro listado al pulsar el bot\u00f3n eliminar: category-list.component.html category-list.component.ts ... < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" > < mat-icon ( click )=\" editCategory ( element )\" > edit </ mat-icon > </ button > < button mat-icon-button color = \"accent\" > < mat-icon ( click )=\" deleteCategory ( element )\" > clear </ mat-icon > </ button > </ mat-cell > </ ng-container > ... ... deleteCategory ( category : Category ) { const dialogRef = this . dialog . open ( DialogConfirmationComponent , { data : { title : \"Eliminar categor\u00eda\" , description : \"Atenci\u00f3n si borra la categor\u00eda se perder\u00e1n sus datos.<br> \u00bfDesea eliminar la categor\u00eda?\" } }); dialogRef . afterClosed (). subscribe ( result => { if ( result ) { this . categoryService . deleteCategory ( category . id ). subscribe ( result => { this . ngOnInit (); }); } }); } ... Aqu\u00ed tambi\u00e9n hemos realizado la llamada a categoryService , aunque no se realice ninguna acci\u00f3n, pero as\u00ed lo dejamos listo para enlazarlo. Llegados a este punto, ya solo nos queda enlazar las acciones de la pantalla con las operaciones de negocio del backend. Pero eso lo dejaremos para m\u00e1s adelante, primero hay que implementar las operaciones, en la siguiente secci\u00f3n.","title":"Code: Desarrollo con Angular"},{"location":"develop/step1/#desarrollo-con-angular","text":"Ahora que ya tenemos listo tanto el proyecto back de SpringBoot (en el puerto 8080) como el proyecto front de Angular (en el puerto 4200), ya podemos empezar a codificar la soluci\u00f3n. Durante todo el tutorial vamos a intentar separar completamente la implementaci\u00f3n de front de la implementaci\u00f3n de back, para que quede claro como se debe realizar en cada una de las tecnolog\u00edas.","title":"Desarrollo con Angular"},{"location":"develop/step1/#primeros-pasos","text":"Antes de empezar Antes de empezar esta parte te recomendamos encarecidamente que hagas el tutorial que viene en la propia p\u00e1gina de Angular, donde explican algunos de los conceptos b\u00e1sicos y generales de las aplicaciones. Te servir\u00e1 mucho para conocer algunos de los aspectos y componentes que utilizamos durante este tutorial. Lo puedes visitar desde su web Tour of Heroes Si abrimos el proyecto con el IDE que tengamos (Visual Studio Code en el caso del tutorial) podemos ver que en la carpeta src/app existen unos ficheros ya creados por defecto. Estos ficheros son: app.component.ts \u2192 contiene el c\u00f3digo inicial del proyecto escrito en TypeScript. app.component.html \u2192 contiene la plantilla inicial del proyecto escrita en HTML. app.component.scss \u2192 contiene los estilos CSS privados de la plantilla inicial. Vamos a modificar este c\u00f3digo inicial para ver como funciona. Abrimos el fichero app.component.ts y modificamos la l\u00ednea donde se asigna un valor a la variable title . app.component.ts ... title = 'Tutorial de Angular + Springboot' ; ... Ahora abrimos el fichero app.component.html , borramos todo el c\u00f3digo de la plantilla y a\u00f1adimos el siguiente c\u00f3digo: app.component.html < h1 > {{title}} </ h1 > Las llaves dobles permiten hacen un binding entre el c\u00f3digo del componente y la plantilla. Es decir, en este caso ir\u00e1 al c\u00f3digo TypeScript y buscar\u00e1 el valor de la variable title . Consejo El binding tambi\u00e9n nos sirve para ejecutar los m\u00e9todos de TypeScript desde el c\u00f3digo HTML. Adem\u00e1s si el valor que contiene la variable se modificara durante la ejecuci\u00f3n de alg\u00fan m\u00e9todo, autom\u00e1ticamente el c\u00f3digo HTML refrescar\u00eda el nuevo valor de la variable title Si abrimos el navegador y accedemos a http://localhost:4200/ podremos ver el resultado del c\u00f3digo.","title":"Primeros pasos"},{"location":"develop/step1/#layout-general","text":"","title":"Layout general"},{"location":"develop/step1/#crear-componente","text":"Lo primero que vamos a hacer es escoger un tema y una paleta de componentes para trabajar. Lo m\u00e1s c\u00f3modo es trabajar con Material que ya viene perfectamente integrado en Angular. Ejecutamos el comando y elegimos la paleta de colores que m\u00e1s nos guste o bien creamos una custom: ng add @angular/material Recuerda Al a\u00f1adir una nueva librer\u00eda tenemos que parar el servidor y volver a arrancarlo para que compile y precargue las nuevas dependencias. Una vez a\u00f1adida la dependencia, lo que queremos es crear una primera estructura inicial a la p\u00e1gina. Si te acuerdas cual era la estructura (y si no te acuerdas, vuelve a la secci\u00f3n Contexto de la aplicaci\u00f3n y lo revisas), ten\u00edamos una cabecera superior con un logo y t\u00edtulo y unas opciones de men\u00fa. Pues vamos a ello, crearemos esa estructura com\u00fan para toda la aplicaci\u00f3n. Este componente al ser algo core para toda la aplicaci\u00f3n deber\u00edamos crearlo dentro del m\u00f3dulo core como ya vimos anteriormente. Pero antes de todo, vamos a crear los m\u00f3dulos generales de la aplicaci\u00f3n, as\u00ed que ejecutamos en consola el comando que nos permite crear un m\u00f3dulo nuevo: ng generate module core Y a\u00f1adimos esos m\u00f3dulos al m\u00f3dulo padre de la aplicaci\u00f3n: app.module.ts import { BrowserModule } from '@angular/platform-browser' ; import { NgModule } from '@angular/core' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { BrowserAnimationsModule } from '@angular/platform-browser/animations' ; import { CoreModule } from './core/core.module' ; @NgModule ({ declarations : [ AppComponent ], imports : [ BrowserModule , AppRoutingModule , CoreModule , BrowserAnimationsModule , ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { } Y despu\u00e9s crearemos el componente header, dentro del m\u00f3dulo core. Para eso ejecutaremos el comando: ng generate component core/header","title":"Crear componente"},{"location":"develop/step1/#codigo-de-la-pantalla","text":"Esto nos crear\u00e1 una carpeta con los ficheros del componente, donde tendremos que copiar el siguiente contenido: header.component.html header.component.scss < mat-toolbar > < mat-toolbar-row > < div class = \"header_container\" > < div class = \"header_title\" > < mat-icon > storefront </ mat-icon > Ludoteca Tan </ div > < div class = \"header_separator\" > | </ div > < div class = \"header_menu\" > < div class = \"header_button\" > < a routerLink = \"/games\" routerLinkActive = \"active\" > Cat\u00e1logo </ a > </ div > < div class = \"header_button\" > < a routerLink = \"/categories\" routerLinkActive = \"active\" > Categor\u00edas </ a > </ div > < div class = \"header_button\" > < a routerLink = \"/authors\" routerLinkActive = \"active\" > Autores </ a > </ div > </ div > < div class = \"header_login\" > < mat-icon > account_circle </ mat-icon > Sign in </ div > </ div > </ mat-toolbar-row > </ mat-toolbar > . mat-toolbar { background-color : blue ; color : white ; } . header_container { display : flex ; width : 100 % ; .header_title { .mat-icon { vertical-align : sub ; } } . header_separator { margin-left : 30 px ; margin-right : 30 px ; } . header_menu { flex-grow : 4 ; display : flex ; flex-direction : row ; .header_button { margin-left : 1 em ; margin-right : 1 em ; font-size : 16 px ; a { font-weight : lighter ; text-decoration : none ; cursor : pointer ; color : white ; } a : hover { color : grey ; } a . active { font-weight : normal ; text-decoration : underline ; color : lightyellow ; } } } . header_login { font-size : 16 px ; cursor : pointer ; .mat-icon { vertical-align : sub ; } } } Al utilizar etiquetas de material como mat-toolbar o mat-icon y routerLink necesitaremos importar las dependencias. Esto lo podemos hacer directamente en el m\u00f3dulo del que depende, es decir en el fichero core.module.ts core.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { MatIconModule } from '@angular/material/icon' ; import { MatToolbarModule } from '@angular/material/toolbar' ; import { HeaderComponent } from './header/header.component' ; import { RouterModule } from '@angular/router' ; @NgModule ({ declarations : [ HeaderComponent ], imports : [ CommonModule , RouterModule , MatIconModule , MatToolbarModule , ], exports : [ HeaderComponent ] }) export class CoreModule { } Adem\u00e1s de a\u00f1adir las dependencias, diremos que este m\u00f3dulo va a exportar el componente HeaderComponent para poder utilizarlo desde otras p\u00e1ginas. Ya por \u00faltimo solo nos queda modificar la p\u00e1gina general de la aplicaci\u00f3n app.component.html para a\u00f1adirle el componente HeaderComponent . app.component.html < div > < app-header ></ app-header > < div > < router-outlet ></ router-outlet > </ div > </ div > Vamos al navegador y refrescamos la p\u00e1gina, deber\u00eda aparecer una barra superior (Header) con las opciones de men\u00fa. Algo similar a esto: Recuerda Cuando se a\u00f1aden componentes a los ficheros html , siempre se deben utilizar los selectores definidos para el componente. En el caso anterior hemos a\u00f1adido app-header que es el mismo nombre selector que tiene el componente en el fichero header.component.ts . Adem\u00e1s, recuerda que para poder utilizar componentes de otros m\u00f3dulos, los debes exportar ya que de lo contrario tan solo podr\u00e1n utilizarse dentro del m\u00f3dulo donde se declaran.","title":"C\u00f3digo de la pantalla"},{"location":"develop/step1/#creando-un-listado-basico","text":"","title":"Creando un listado b\u00e1sico"},{"location":"develop/step1/#crear-componente_1","text":"Ya tenemos la estructura principal, ahora vamos a crear nuestra primera pantalla. Vamos a empezar por la de Categor\u00edas que es la m\u00e1s sencilla, ya que se trata de un listado, que muestra datos sin filtrar ni paginar. Como categor\u00edas es un dominio funcional de la aplicaci\u00f3n, vamos a crear un m\u00f3dulo que contenga toda la funcionalidad de ese dominio. Ejecutamos en consola: ng generate module category Y por tanto, al igual que hicimos anteriormente, hay que a\u00f1adir el m\u00f3dulo al fichero app.module.ts app.module.ts import { BrowserModule } from '@angular/platform-browser' ; import { NgModule } from '@angular/core' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { BrowserAnimationsModule } from '@angular/platform-browser/animations' ; import { CoreModule } from './core/core.module' ; import { CategoryModule } from './category/category.module' ; @NgModule ({ declarations : [ AppComponent ], imports : [ BrowserModule , AppRoutingModule , CoreModule , CategoryModule , BrowserAnimationsModule , ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { } Ahora todas las pantallas, componentes y servicios que creemos, referidos a este dominio funcional, deber\u00e1n ir dentro del modulo cagegory . Vamos a crear un primer componente que ser\u00e1 un listado de categor\u00edas. Para ello vamos a ejecutar el siguiente comando: ng generate component category/category-list Para terminar de configurar la aplicaci\u00f3n, vamos a a\u00f1adir la ruta del componente dentro del componente routing de Angular, para poder acceder a \u00e9l, para ello modificamos el fichero app-routing.module.ts app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { CategoryListComponent } from './category/category-list/category-list.component' ; const routes : Routes = [ { path : 'categories' , component : CategoryListComponent }, ]; @NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } Si abrimos el navegador y accedemos a http://localhost:4200/ podremos navegar mediante el men\u00fa Categor\u00edas el cual abrir\u00e1 el componente que acabamos de crear.","title":"Crear componente"},{"location":"develop/step1/#codigo-de-la-pantalla_1","text":"Ahora vamos a construir la pantalla. Para manejar la informaci\u00f3n del listado, necesitamos almacenar los datos en un objeto de tipo model . Para ello crearemos un fichero en category\\model\\Category.ts donde implementaremos la clase necesaria. Esta clase ser\u00e1 la que utilizaremos en el c\u00f3digo html y ts de nuestro componente. Category.ts export class Category { id : number ; name : string ; } Tambi\u00e9n, escribiremos el c\u00f3digo de la pantalla de listado. category-list.component.html category-list.component.scss category-list.component.ts < div class = \"container\" > < h1 > Listado de Categor\u00edas </ h1 > < mat-table [ dataSource ]=\" dataSource \" > < ng-container matColumnDef = \"id\" > < mat-header-cell * matHeaderCellDef > Identificador </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.id}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"name\" > < mat-header-cell * matHeaderCellDef > Nombre categor\u00eda </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.name}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" >< mat-icon > edit </ mat-icon ></ button > < button mat-icon-button color = \"accent\" >< mat-icon > clear </ mat-icon ></ button > </ mat-cell > </ ng-container > < mat-header-row * matHeaderRowDef = \"displayedColumns; sticky: true\" ></ mat-header-row > < mat-row * matRowDef = \"let row; columns: displayedColumns;\" ></ mat-row > </ mat-table > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" > Nueva categor\u00eda </ button > </ div > </ div > . container { margin : 20 px ; mat-table { margin-top : 10 px ; margin-bottom : 20 px ; .mat-header-row { background-color : #f5f5f5 ; .mat-header-cell { text-transform : uppercase ; font-weight : bold ; color : #838383 ; } } . mat-column-id { flex : 0 0 20 % ; justify-content : center ; } . mat-column-action { flex : 0 0 10 % ; justify-content : center ; } } . buttons { text-align : right ; } } import { Component , OnInit } from '@angular/core' ; import { MatTableDataSource } from '@angular/material/table' ; import { Category } from '../model/Category' ; @Component ({ selector : 'app-category-list' , templateUrl : './category-list.component.html' , styleUrls : [ './category-list.component.scss' ] }) export class CategoryListComponent implements OnInit { dataSource = new MatTableDataSource < Category > (); displayedColumns : string [] = [ 'id' , 'name' , 'action' ]; constructor () { } ngOnInit () : void { } } El c\u00f3digo HTML es f\u00e1cil de seguir pero por si acaso: L\u00ednea 4: Creamos la tabla con la variable dataSource definida en el fichero .ts L\u00ednea 5: Definici\u00f3n de la primera columna, su cabecera y el dato que va a contener L\u00ednea 10: Definici\u00f3n de la segunda columna, su cabecera y el dato que va a contener L\u00ednea 15: Definici\u00f3n de la tercera columna, su cabecera vac\u00eda y los dos botones de acci\u00f3n L\u00ednea 23 y 24: Construcci\u00f3n de la cabecera y las filas Y ya por \u00faltimo, a\u00f1adimos los componentes que se han utilizado de Angular Material a las dependencias del m\u00f3dulo donde est\u00e1 definido el componente en este caso category\\category.module.ts : category.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { MatTableModule } from '@angular/material/table' ; import { MatIconModule } from '@angular/material/icon' ; import { MatButtonModule } from '@angular/material/button' ; import { CategoryListComponent } from './category-list/category-list.component' ; @NgModule ({ declarations : [ CategoryListComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule ], }) export class CategoryModule { } Si abrimos el navegador y accedemos a http://localhost:4200/ y pulsamos en el men\u00fa de Categor\u00edas obtendremos una pantalla con un listado vac\u00edo (solo con cabeceras) y un bot\u00f3n de crear Nueva Categor\u00eda que aun no hace nada.","title":"C\u00f3digo de la pantalla"},{"location":"develop/step1/#anadiendo-datos","text":"En este punto y para ver como responde el listado, vamos a a\u00f1adir datos. Si tuvieramos el backend implementado podr\u00edamos consultar los datos directamente de una operaci\u00f3n de negocio de backend, pero ahora mismo no lo tenemos implementado as\u00ed que para no bloquear el desarrollo vamos a mockear los datos.","title":"A\u00f1adiendo datos"},{"location":"develop/step1/#creando-un-servicio","text":"En angular, cualquier acceso a datos debe pasar por un service , as\u00ed que vamos a crearnos uno para todas las operaciones de categor\u00edas. Vamos a la consola y ejecutamos: ng generate service category/category Esto nos crear\u00e1 un servicio, que adem\u00e1s podemos utilizarlo inyect\u00e1ndolo en cualquier componente que lo necesite.","title":"Creando un servicio"},{"location":"develop/step1/#implementando-un-servicio","text":"Vamos a implementar una operaci\u00f3n de negocio que recupere el listado de categor\u00edas y lo vamos a hacer de forma reactiva (as\u00edncrona) para simular una petici\u00f3n a backend. Modificamos los siguientes ficheros: category.service.ts category-list.component.ts import { Injectable } from '@angular/core' ; import { Observable } from 'rxjs' ; import { Category } from './model/Category' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor () { } getCategories () : Observable < Category [] > { return new Observable (); } } import { Component , OnInit } from '@angular/core' ; import { MatTableDataSource } from '@angular/material/table' ; import { Category } from '../model/Category' ; import { CategoryService } from '../category.service' ; @Component ({ selector : 'app-categories' , templateUrl : './categories.component.html' , styleUrls : [ './categories.component.scss' ] }) export class CategoriesComponent implements OnInit { dataSource = new MatTableDataSource < Category > (); displayedColumns : string [] = [ 'id' , 'name' , 'action' ]; constructor ( private categoryService : CategoryService , ) { } ngOnInit () : void { this . categoryService . getCategories (). subscribe ( categories => this . dataSource . data = categories ); } }","title":"Implementando un servicio"},{"location":"develop/step1/#mockeando-datos","text":"Como hemos comentado anteriormente, el backend todav\u00eda no est\u00e1 implementado as\u00ed que vamos a mockear datos. Nos crearemos un fichero mock-categories.ts dentro de model, con datos ficticios y modificaremos el servicio para que devuelva esos datos. De esta forma, cuando tengamos implementada la operaci\u00f3n de negocio en backend, tan solo tenemos que sustuir el c\u00f3digo que devuelve datos est\u00e1ticos por una llamada http. mock-categories.ts category.service.ts import { Category } from \"./Category\" ; export const CATEGORY_DATA : Category [] = [ { id : 1 , name : 'Dados' }, { id : 2 , name : 'Fichas' }, { id : 3 , name : 'Cartas' }, { id : 4 , name : 'Rol' }, { id : 5 , name : 'Tableros' }, { id : 6 , name : 'Tem\u00e1ticos' }, { id : 7 , name : 'Europeos' }, { id : 8 , name : 'Guerra' }, { id : 9 , name : 'Abstractos' }, ] import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; import { CATEGORY_DATA } from './model/mock-categories' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor () { } getCategories () : Observable < Category [] > { return of ( CATEGORY_DATA ); } } Si ahora refrescamos la p\u00e1gina web, veremos que el listado ya tiene datos con los que vamos a interactuar.","title":"Mockeando datos"},{"location":"develop/step1/#simulando-las-otras-peticiones","text":"Para terminar, vamos a simular las otras dos peticiones, la de editar y la de borrar para cuando tengamos que utilizarlas. El servicio debe quedar m\u00e1s o menos as\u00ed: category.service.ts import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; import { CATEGORY_DATA } from './model/mock-categories' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor () { } getCategories () : Observable < Category [] > { return of ( CATEGORY_DATA ); } saveCategory ( category : Category ) : Observable < Category > { return of ( null ); } deleteCategory ( idCategory : number ) : Observable < any > { return of ( null ); } }","title":"Simulando las otras peticiones"},{"location":"develop/step1/#anadiendo-acciones-al-listado","text":"","title":"A\u00f1adiendo acciones al listado"},{"location":"develop/step1/#crear-componente_2","text":"Ahora nos queda a\u00f1adir las acciones al listado: crear, editar y eliminar. Empezaremos primero por las acciones de crear y editar, que ambas deber\u00edan abrir una ventana modal con un formulario para poder modificar datos de la entidad Categor\u00eda . Como siempre, para crear un componente usamos el asistente de Angular, esta vez al tratarse de una pantalla que solo vamos a utilizar dentro del dominio de categor\u00edas, tiene sentido que lo creemos dentro de ese m\u00f3dulo: ng generate component category/category-edit Ahora vamos a hacer que se abra al pulsar el bot\u00f3n Nueva categor\u00eda . Para eso, vamos al fichero category-list.component.ts y a\u00f1adimos un nuevo m\u00e9todo: category-list.component.ts ... import { MatDialog } from '@angular/material/dialog' ; import { CategoryEditComponent } from '../category-edit/category-edit.component' ; ... constructor ( private categoryService : CategoryService , public dialog : MatDialog , ) { } ... createCategory () { const dialogRef = this . dialog . open ( CategoryEditComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } ... Para poder abrir un componente dentro de un dialogo necesitamos obtener en el constructor un MatDialog. De ah\u00ed que hayamos tenido que a\u00f1adirlo como import y en el constructor. Dentro del m\u00e9todo createCategory lo que hacemos es crear un dialogo con el componente CategoryEditComponent en su interior, pasarle unos datos de creaci\u00f3n, donde podemos poner estilos del dialog y un objeto data donde pondremos los datos que queremos pasar entre los componentes. Por \u00faltimo, nos suscribimos al evento afterClosed para ejecutar las acciones que creamos oportunas, en nuestro caso volveremos a cargar el listado inicial. Como hemos utilizado un MatDialog en el componente, necesitamos a\u00f1adirlo tambi\u00e9n al m\u00f3dulo, as\u00ed que abrimos el fichero category.module.ts y a\u00f1adimos: category.module.ts ... import { MAT_DIALOG_DATA , MatDialogModule } from '@angular/material/dialog' ; @NgModule ({ declarations : [ CategoryListComponent , CategoryEditComponent ], imports : [ ... MatDialogModule ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class CategoryModule { } Y ya por \u00faltimo enlazamos el click en el bot\u00f3n con el m\u00e9todo que acabamos de crear para abrir el dialogo. Modificamos el fichero category-list.component.html y a\u00f1adimos el evento click: category-list.component.html ... < div class = \"buttons\" > < button mat - flat - button color = \"primary\" ( click ) = \"createCategory()\" > Nueva categor\u00eda < /button> < /div> < /div> Si refrescamos el navegador y pulsamos el bot\u00f3n Nueva categor\u00eda veremos como se abre una ventana modal de tipo Dialog con el componente nuevo que hemos creado, aunque solo se leer\u00e1 category-edit works! que es el contenido por defecto del componente.","title":"Crear componente"},{"location":"develop/step1/#codigo-del-dialogo","text":"Ahora vamos a darle forma al formulario de editar y crear. Para ello vamos al html, ts y css del componente y pegamos el siguiente contenido: category-edit.component.html category-edit.component.scss category-edit.component.ts < div class = \"container\" > < h1 > Crear categor\u00eda </ h1 > < form > < mat-form-field > < mat-label > Identificador </ mat-label > < input type = \"number\" matInput placeholder = \"Identificador\" [( ngModel )]=\" category . id \" name = \"id\" disabled > </ mat-form-field > < mat-form-field > < mat-label > Nombre </ mat-label > < input type = \"text\" matInput placeholder = \"Nombre de categor\u00eda\" [( ngModel )]=\" category . name \" name = \"name\" required > < mat-error > El nombre no puede estar vac\u00edo </ mat-error > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onClose ()\" > Cerrar </ button > < button mat-flat-button color = \"primary\" ( click )=\" onSave ()\" > Guardar </ button > </ div > </ div > . container { min-width : 350 px ; max-width : 500 px ; width : 100 % ; form { display : flex ; flex-direction : column ; margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } import { Component , OnInit } from '@angular/core' ; import { MatDialogRef } from '@angular/material/dialog' ; import { CategoryService } from '../category.service' ; import { Category } from '../model/Category' ; @Component ({ selector : 'app-category-edit' , templateUrl : './category-edit.component.html' , styleUrls : [ './category-edit.component.scss' ] }) export class CategoryEditComponent implements OnInit { category : Category ; constructor ( public dialogRef : MatDialogRef < CategoryEditComponent > , private categoryService : CategoryService ) { } ngOnInit () : void { this . category = new Category (); } onSave () { this . categoryService . saveCategory ( this . category ). subscribe ( result => { this . dialogRef . close (); }); } onClose () { this . dialogRef . close (); } } Si te fijas en el c\u00f3digo TypeScript, hemos a\u00f1adido en el m\u00e9todo onSave una llamada al servicio de CategoryService que aunque no realice ninguna operaci\u00f3n de momento, por lo menos lo dejamos preparado para conectar con el servidor. Adem\u00e1s, como siempre, al utilizar componentes matInput , matForm , matError hay que a\u00f1adirlos como dependencias en el m\u00f3dulo category.module.ts : category.module.ts ... import { MAT_DIALOG_DATA , MatDialogModule } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatInputModule } from '@angular/material/input' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; @NgModule ({ declarations : [ CategoryListComponent , CategoryEditComponent ], imports : [ ... MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class CategoryModule { } Ahora podemos navegar y abrir el cuadro de dialogo mediante el bot\u00f3n Nueva categor\u00eda para ver como queda nuestro formulario.","title":"C\u00f3digo del dialogo"},{"location":"develop/step1/#utilizar-el-dialogo-para-editar","text":"El mismo componente que hemos utilizado para crear una nueva categor\u00eda, nos sirve tambi\u00e9n para editar una categor\u00eda existente. Tan solo tenemos que utilizar la funcionalidad que Angular nos proporciona y pasarle los datos a editar en la llamada de apertura del Dialog. Vamos a implementar funcionalidad sobre el icono editar , tendremos que modificar unos cuantos ficheros: category-list.component.html category-list.component.ts < div class = \"container\" > < h1 > Listado de Categor\u00edas </ h1 > < mat-table [ dataSource ]=\" dataSource \" > < ng-container matColumnDef = \"id\" > < mat-header-cell * matHeaderCellDef > Identificador </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.id}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"name\" > < mat-header-cell * matHeaderCellDef > Nombre categor\u00eda </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.name}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" > < mat-icon ( click )=\" editCategory ( element )\" > edit </ mat-icon > </ button > < button mat-icon-button color = \"accent\" >< mat-icon > clear </ mat-icon ></ button > </ mat-cell > </ ng-container > < mat-header-row * matHeaderRowDef = \"displayedColumns; sticky: true\" ></ mat-header-row > < mat-row * matRowDef = \"let row; columns: displayedColumns;\" ></ mat-row > </ mat-table > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createCategory ()\" > Nueva categor\u00eda </ button > </ div > </ div > export class CategoriesComponent implements OnInit { dataSource = new MatTableDataSource < Category > (); displayedColumns : string [] = [ 'id' , 'name' , 'action' ]; constructor ( private categoryService : CategoryService , public dialog : MatDialog , ) { } ngOnInit () : void { this . categoryService . getCategories (). subscribe ( categories => this . dataSource . data = categories ); } createCategory () { const dialogRef = this . dialog . open ( CategoryEditComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } editCategory ( category : Category ) { const dialogRef = this . dialog . open ( CategoryEditComponent , { data : { category : category } }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } } Y los Dialog: category-edit.component.html category-edit.component.ts < div class = \"container\" > < h1 * ngIf = \"category.id == null\" > Crear categor\u00eda < /h1> < h1 * ngIf = \"category.id != null\" > Modificar categor\u00eda < /h1> < form > < mat - form - field > ... import { Component , OnInit , Inject } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { CategoryService } from '../category.service' ; import { Category } from '../model/Category' ; @Component ({ selector : 'app-category-edit' , templateUrl : './category-edit.component.html' , styleUrls : [ './category-edit.component.scss' ] }) export class CategoryEditComponent implements OnInit { category : Category ; constructor ( public dialogRef : MatDialogRef < CategoryEditComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any , private categoryService : CategoryService ) { } ngOnInit () : void { if ( this . data . category != null ) { this . category = this . data . category ; } else { this . category = new Category (); } } onSave () { this . categoryService . saveCategory ( this . category ). subscribe ( result => { this . dialogRef . close (); }); } onClose () { this . dialogRef . close (); } } Navegando ahora por la p\u00e1gina y pulsando en el icono de editar, se deber\u00eda abrir una ventana con los datos que hemos seleccionado, similar a esta imagen: Si te fijas, al modificar los datos dentro de la ventana de di\u00e1logo se modifica tambi\u00e9n en el listado. Esto es porque estamos pasando el mismo objeto desde el listado a la ventana dialogo y al ser el listado y el formulario reactivos los dos, cualquier cambio sobre los datos se refresca directamente en la pantalla. Hay veces en la que este comportamiento nos interesa, pero en este caso no queremos que se modifique el listado. Para solucionarlo debemos hacer una copia del objeto, para que ambos modelos (formulario y listado) utilicen objetos diferentes. Es tan sencillo como modificar category-edit.component.ts y a\u00f1adirle una copia del dato category-edit.component.ts ... ngOnInit () : void { if ( this . data . category != null ) { this . category = Object . assign ({}, this . data . category ); } else { this . category = new Category (); } } ... Cuidado Hay que tener mucho cuidado con el binding de los objetos. Hay veces que al modificar un objeto NO queremos que se modifique en todas sus instancias y tenemos que poner especial cuidado en esos aspectos.","title":"Utilizar el dialogo para editar"},{"location":"develop/step1/#accion-de-borrado","text":"Por norma general, toda acci\u00f3n de borrado de un dato de pantalla requiere una confirmaci\u00f3n previa por parte del usuario. Es decir, para evitar que el dato se borre accidentalmente el usuario tendr\u00e1 que confirmar su acci\u00f3n. Por tanto vamos a crear un componente que nos permita pedir una confirmaci\u00f3n al usuario. Como esta pantalla de confirmaci\u00f3n va a ser algo com\u00fan a muchas acciones de borrado de nuestra aplicaci\u00f3n, vamos a crearla dentro del m\u00f3dulo core . Como siempre, ejecutamos el comando en consola: ng generate component core/dialog-confirmation E implementamos el c\u00f3digo que queremos que tenga el componente. Al ser un componente gen\u00e9rico vamos a aprovechar y leeremos las variables que le pasemos en data . dialog-confirmation.component.html dialog-confirmation.component.scss dialog-confirmation.component.ts < div class = \"container\" > < h1 > {{title}} </ h1 > < div [ innerHTML ]=\" description \" class = \"description\" ></ div > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onNo ()\" > No </ button > < button mat-flat-button color = \"primary\" ( click )=\" onYes ()\" > S\u00ed </ button > </ div > </ div > . container { min-width : 350 px ; max-width : 500 px ; width : 100 % ; .description { margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } import { Component , OnInit , Inject } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; @Component ({ selector : 'app-dialog-confirmation' , templateUrl : './dialog-confirmation.component.html' , styleUrls : [ './dialog-confirmation.component.scss' ] }) export class DialogConfirmationComponent implements OnInit { title : string ; description : string ; constructor ( public dialogRef : MatDialogRef < DialogConfirmationComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any ) { } ngOnInit () : void { this . title = this . data . title ; this . description = this . data . description ; } onYes () { this . dialogRef . close ( true ); } onNo () { this . dialogRef . close ( false ); } } Recuerda Recuerda que los componentes utilizados en el di\u00e1logo de confirmaci\u00f3n se deben a\u00f1adir al m\u00f3dulo padre al que pertenecen, en este caso a core.module.ts imports: [ CommonModule, RouterModule, MatIconModule, MatToolbarModule, MatDialogModule, MatButtonModule, ], providers: [ { provide: MAT_DIALOG_DATA, useValue: {}, }, ], Ya por \u00faltimo, una vez tenemos el componente gen\u00e9rico de dialogo, vamos a utilizarlo en nuestro listado al pulsar el bot\u00f3n eliminar: category-list.component.html category-list.component.ts ... < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" > < mat-icon ( click )=\" editCategory ( element )\" > edit </ mat-icon > </ button > < button mat-icon-button color = \"accent\" > < mat-icon ( click )=\" deleteCategory ( element )\" > clear </ mat-icon > </ button > </ mat-cell > </ ng-container > ... ... deleteCategory ( category : Category ) { const dialogRef = this . dialog . open ( DialogConfirmationComponent , { data : { title : \"Eliminar categor\u00eda\" , description : \"Atenci\u00f3n si borra la categor\u00eda se perder\u00e1n sus datos.<br> \u00bfDesea eliminar la categor\u00eda?\" } }); dialogRef . afterClosed (). subscribe ( result => { if ( result ) { this . categoryService . deleteCategory ( category . id ). subscribe ( result => { this . ngOnInit (); }); } }); } ... Aqu\u00ed tambi\u00e9n hemos realizado la llamada a categoryService , aunque no se realice ninguna acci\u00f3n, pero as\u00ed lo dejamos listo para enlazarlo. Llegados a este punto, ya solo nos queda enlazar las acciones de la pantalla con las operaciones de negocio del backend. Pero eso lo dejaremos para m\u00e1s adelante, primero hay que implementar las operaciones, en la siguiente secci\u00f3n.","title":"Acci\u00f3n de borrado"},{"location":"develop/step2/","text":"Desarrollo con Springboot Ahora que ya tenemos listo tanto el proyecto back de SpringBoot (en el puerto 8080) como el proyecto front de Angular (en el puerto 4200), ya podemos empezar a codificar la soluci\u00f3n. Durante todo el tutorial vamos a intentar separar completamente la implementaci\u00f3n de front de la implementaci\u00f3n de back, para que quede claro como se debe realizar en cada una de las tecnolog\u00edas. Primeros pasos Antes de empezar Quiero hacer hincapi\u00e9 en Springboot tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. Tanto la propia web de Spring como en el portal de tutoriales de Baeldung puedes buscar casi cualquier ejemplo que necesites. Si has seguido el tutorial, en la creaci\u00f3n del proyecto ten\u00edas la posibilidad de crear un proyecto Springboot simple o descargarte una plantilla ya creada. De cualquiera de las dos maneras, tendr\u00e1s la misma estructura que veremos a continuaci\u00f3n. Estructurar el c\u00f3digo Vamos a hacer un breve refresco de la estructura del c\u00f3digo que ya se ha visto en puntos anteriores. Las clases deben estar agrupadas por \u00e1mbito funcional, en nuestro caso como vamos a hacer la funcionalidad de Categor\u00edas pues deber\u00eda estar todo dentro de un package del tipo com.capgemini.ccsw.tutorial.category . Adem\u00e1s, deber\u00edamos aplicar la separaci\u00f3n por capas como ya se vi\u00f3 en el esquema: La primera capa, la de Controlador , se encargar\u00e1 de procesar las peticiones y transformar datos. Esta capa llamar\u00e1 a la capa de L\u00f3gica de negocio que ejecutar\u00e1 las operaciones, ayud\u00e1ndose de otros objetos de esa misma capa de L\u00f3gica o bien de llamadas a datos a trav\u00e9s de la capa de Acceso a Datos Ahora s\u00ed, vamos a programar!. Capa de operaciones: Controller En esta capa es donde se definen las operaciones que pueden ser consumidas por los clientes. Se caracterizan por estar anotadas con las anotaciones @Controller o @RestController y por las anotaciones @RequestMapping que nos permiten definir las rutas de acceso. Recomendaci\u00f3n: Breve detalle REST Antes de continuar te recomiendo encarecidamente que leas el Anexo: Detalle REST donde se explica brevemente como estructurar los servicios REST que veremos a continuaci\u00f3n. Controller de ejemplo Vamos a crear una clase CategoryController.java dentro del package com.capgemini.ccsw.tutorial.category para definir las rutas de las operaciones. CategoryController.java package com.capgemini.ccsw.tutorial.category ; import java.util.List ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; /** * @author ccsw */ @RequestMapping ( value = \"/category\" ) @RestController public class CategoryController { /** * M\u00e9todo para recuperar todas las Category * @return */ @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public String prueba () { return \"Probando el Controller\" ; } } Ahora si arrancamos la aplicaci\u00f3n server, abrimos el Postman y creamos una petici\u00f3n GET a la url http://localhost:8080/category nos responder\u00e1 con el mensaje que hemos programado. Implementar operaciones Ahora que ya tenemos un controlador y una operacion de negocio ficticia, vamos a borrarla y a\u00f1adir las operaciones reales que consumir\u00e1 nuestra pantalla. Deberemos a\u00f1adir una operaci\u00f3n para listar, una para actualizar, una para guardar y una para borrar. Aunque para hacerlo m\u00e1s c\u00f3modo, utilizaremos la misma operaci\u00f3n para guardar y para actualizar. Adem\u00e1s, no vamos a trabajar directamente con datos simples, sino que usaremos objetos para recibir informaci\u00f3n y para enviar informaci\u00f3n. Estos objetos t\u00edpicamente se denominan DTO (Data Transfer Object) y nos sirven justamente para encapsular informaci\u00f3n que queremos transportar. En realidad no son m\u00e1s que clases pojo sencillas con propiedades, getters y setters. Para nuestro ejemplo crearemos una clase CategoryDto dentro del package com.capgemini.ccsw.tutorial.category.model con el siguiente contenido: CategoryDto.java package com.capgemini.ccsw.tutorial.category.model ; /** * @author ccsw */ public class CategoryDto { private Long id ; private String name ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } } A continuaci\u00f3n utilizaremos esta clase en nuestro Controller para implementar las tres operaciones de negocio. CategoryController.java package com.capgemini.ccsw.tutorial.category ; import java.util.ArrayList ; import java.util.HashMap ; import java.util.List ; import java.util.Map ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw */ @RequestMapping ( value = \"/category\" ) @RestController public class CategoryController { private long SEQUENCE = 1 ; private Map < Long , CategoryDto > categories = new HashMap < Long , CategoryDto > (); /** * M\u00e9todo para recuperar todas las Category * @return */ @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { return new ArrayList ( this . categories . values ()); } /** * M\u00e9todo para crear o actualizar una Category * @param id * @param dto * @return */ @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody CategoryDto dto ) { CategoryDto category ; if ( id == null ) { category = new CategoryDto (); category . setId ( this . SEQUENCE ++ ); this . categories . put ( category . getId (), category ); } else { category = this . categories . get ( id ); } category . setName ( dto . getName ()); } /** * M\u00e9todo para borrar una Category * @param id */ @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . categories . remove ( id ); } } Como todav\u00eda no tenemos acceso a BD, hemos creado una variable tipo HashMap y una variable Long, que simular\u00e1n una BD y una secuencia. Tambi\u00e9n hemos implementado tres operaciones GET, PUT y DELETE que realizan las acciones necesarias por nuestra pantalla. Ahora podr\u00edamos probarlo desde el Postman con cuatro ejemplo sencillos. F\u00edjate que el m\u00e9todo save tiene dos rutas. La ruta normal category/ y la ruta informada category/3 . Esto es porque hemos juntado la acci\u00f3n create y update en un mismo m\u00e9todo para facilitar el desarrollo. Es totalmente v\u00e1lido y funcional. Atenci\u00f3n Los datos que se reciben pueden venir informados como un par\u00e1metro en la URL Get, como una variable en el propio path o dentro del body de la petici\u00f3n. Cada uno de ellos se recupera con una anotaci\u00f3n especial: @RequestParam , @PathVariable y @RequestBody respectivamente. GET /category nos devuelve un listado de Categor\u00edas PUT /category nos sirve para insertar Categor\u00edas nuevas (si no tienen el id informado) o para actualizar Categor\u00edas (si tienen el id informado). F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no env\u00edas datos, te dar\u00e1 un error. DELETE /category nos sirve eliminar Categor\u00edas . F\u00edjate que el dato del ID que se env\u00eda est\u00e1 en el path. Prueba a jugar borrando categor\u00edas que no existen o modificando categor\u00edas que no existen. Tal y como est\u00e1 programado, el borrado no dar\u00e1 error, pero la modificaci\u00f3n deber\u00eda dar un NullPointerException al no existir el dato a modificar. Aspectos importantes Los aspectos importantes de la capa Controller son: La clase debe estar anotada con @Controller o @RestController . Mejor usar la \u00faltima anotaci\u00f3n ya que est\u00e1s diciendo que las operaciones son de tipo Rest y no har\u00e1 falta configurar nada La ruta general al controlador se define con el @RequestMapping global de la clase, aunque tambi\u00e9n se puede obviar esta anotaci\u00f3n y a\u00f1adir a cada una de las operaciones la ruta ra\u00edz. Los m\u00e9todos que queramos exponer como operaciones deben ir anotados tambi\u00e9n con @RequestMapping con la info: path \u2192 Que nos permite definir un path para la operaci\u00f3n, siempre sum\u00e1ndole el path de la clase (si es que tuviera) method \u2192 Que nos permite definir el verbo de http que vamos a atender. Podemos tener el mismo path con diferente method, sin problema. Por lo general utilizaremos: GET \u2192 Generalmente se usa para recuperar informaci\u00f3n POST \u2192 Se utiliza para hacer update y filtrados complejos de informaci\u00f3n PUT \u2192 Se utiliza para hacer save de informaci\u00f3n DELETE \u2192 Se utiliza para hacer borrados de informaci\u00f3n Capa de Servicio: Service Pero en realidad la cosa no funciona as\u00ed. Hemos implementado parte de la l\u00f3gica de negocio (las operaciones/acciones de guardado, borrado y listado) dentro de lo que ser\u00eda la capa de operaciones o servicios al cliente. Esta capa no debe ejecutar l\u00f3gica de negocio, tan solo debe hacer transformaciones de datos y enrutar peticiones, toda la l\u00f3gica deber\u00eda ir en la capa de servicio. Implementar servicios Pues vamos a arreglarlo. Vamos a crear un servicio y vamos a mover la l\u00f3gica de negocio al servicio. CategoryService.java CategoryServiceImpl.java CategoryController.java package com.capgemini.ccsw.tutorial.category ; import java.util.List ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw * */ public interface CategoryService { /** * M\u00e9todo para recuperar todas las Category * @return */ List < CategoryDto > findAll (); /** * M\u00e9todo para crear o actualizar una Category * @param dto * @return */ void save ( Long id , CategoryDto dto ); /** * M\u00e9todo para borrar una Category * @param id */ void delete ( Long id ); } package com.capgemini.ccsw.tutorial.category ; import java.util.ArrayList ; import java.util.HashMap ; import java.util.List ; import java.util.Map ; import org.springframework.stereotype.Service ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw * */ @Service public class CategoryServiceImpl implements CategoryService { private long SEQUENCE = 1 ; private Map < Long , CategoryDto > categories = new HashMap < Long , CategoryDto > (); /** * M\u00e9todo para recuperar todas las Category * @return */ public List < CategoryDto > findAll () { return new ArrayList ( this . categories . values ()); } /** * M\u00e9todo para crear o actualizar una Category * @param dto * @return */ public void save ( Long id , CategoryDto dto ) { CategoryDto category ; if ( id == null ) { category = new CategoryDto (); category . setId ( this . SEQUENCE ++ ); this . categories . put ( category . getId (), category ); } else { category = this . categories . get ( id ); } category . setName ( dto . getName ()); } /** * M\u00e9todo para borrar una Category * @param id */ public void delete ( Long id ) { this . categories . remove ( id ); } } package com.capgemini.ccsw.tutorial.category ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw */ @RequestMapping ( value = \"/category\" ) @RestController public class CategoryController { @Autowired private CategoryService categoryService ; /** * M\u00e9todo para recuperar todas las Category * @return */ @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { return this . categoryService . findAll (); } /** * M\u00e9todo para crear o actualizar una Category * @param dto * @return */ @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody CategoryDto dto ) { this . categoryService . save ( id , dto ); } /** * M\u00e9todo para borrar una Category * @param id */ @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . categoryService . delete ( id ); } } Ahora ya tenemos bien estructurado nuestro proyecto. Ya tenemos las dos capas necesarias Controladores y Servicios y cada uno se encarga de llevar a cabo su cometido de forma correcta. Aspectos importantes Los aspectos importantes de la capa Service son: Toda la l\u00f3gica de negocio, operaciones y dem\u00e1s debe estar implementada en los servicios. Los controladores simplemente invocan servicios y transforman ciertos datos. Es buena pr\u00e1ctica que la capa de servicios se implemente usando el patr\u00f3n fachada, esto quiere decir que necesitamos tener una Interface y al menos una implementaci\u00f3n de esa Interface. Y siempre siempre debemos interactuar con la Interface. Esto nos permitir\u00e1 a futuro poder sustituir la implementaci\u00f3n por otra diferente sin que el resto del c\u00f3digo se vea afectado. Especialmente \u00fatil cuando queremos mockear comportamientos en tests. La capa de servicio puede invocar a otros servicios en sus operaciones, pero nunca debe invocar a un controlador. Para crear un servicio se debe anotar mediante @Service y adem\u00e1s debe implementar la Interface del servicio. Un error muy com\u00fan al arrancar un proyecto y ver que no funcionan las llamadas, es porqu\u00e9 no existe la anotaci\u00f3n @Service o porqu\u00e9 no se ha implementado la Interface. La forma de inyectar y utilizar componentes manejados por Springboot es mediante la anotaci\u00f3n @Autowired . NO intentes crear un objeto de CategoryServiceImpl, ni hacer un new , ya que no estar\u00e1 manejado por Springboot y dar\u00e1 fallos de NullPointer. Lo mejor es dejar que Springboot lo gestione y utilizar las inyecciones de dependencias. Capa de Datos: Repository Pero no siempre vamos a acceder a los datos mediante un HasMap en memoria. En algunas ocasiones queremos que nuestro proyecto acceda a un servicio de datos como puede ser una BBDD, un servicio externo, un acceso a disco, etc. Estos accesos se deben hacer desde la capa de acceso a datos, y en concreto para nuestro ejemplo, lo haremos a trav\u00e9s de un Repository para que acceda a una BBDD. Creaci\u00f3n de BBDD Para el tutorial no necesitamos configurar una BBDD externa ni complicarnos demasiado. Vamos a utilizar una librer\u00eda muy \u00fatil llamada H2 que nos permite levantar una BBDD en memoria persistiendo los datos en memoria o en disco. Para esto, si te acuerdas de cuando creamos la aplicaci\u00f3n, existen unos ficheros que se encuentran dentro de la carpeta src/main/resources/ y que nos permiten ir depositando scripts versionados para que se ejecuten en orden una vez se levante la aplicaci\u00f3n. Vamos a crear los nuestros: schema.sql data.sql DROP TABLE IF EXISTS CATEGORY ; CREATE TABLE CATEGORY ( id BIGINT IDENTITY NOT NULL PRIMARY KEY , name VARCHAR ( 250 ) NOT NULL ); INSERT INTO CATEGORY ( id , name ) VALUES ( 1 , 'Eurogames' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 2 , 'Ameritrash' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 3 , 'Familiar' ); Implementar Entity Una vez creada la BBDD el siguiente paso es crear la entidad con la que vamos a persistir y recuperar informaci\u00f3n. Las entidades igual que los DTOs deber\u00edan estar agrupados dentro del package model de cada funcionalidad, as\u00ed que vamos a crear una nueva clase java. Category.java package com.capgemini.ccsw.tutorial.category.model ; import javax.persistence.Column ; import javax.persistence.Entity ; import javax.persistence.GeneratedValue ; import javax.persistence.GenerationType ; import javax.persistence.Id ; import javax.persistence.Table ; /** * @author ccsw */ @Entity @Table ( name = \"Category\" ) public class Category { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"name\" , nullable = false ) private String name ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } } Si te fijas, la Entity suele ser muy similar a un DTO, tiene unas propiedades y sus getters y setters. Pero a diferencia de los DTOs, esta clase tiene una serie de anotaciones que permiten a JPA hacer su magia y generar consultas SQL a la BBDD. En este ejemplo vemos 4 anotaciones importantes: @Entity \u2192 Le indica a Springboot que se trata de una clase que implementa una Entidad de BBDD. Sin esta anotaci\u00f3n no es posible hacer queries. @Table \u2192 Le indica a JPA el nombre y el schema de la tabla que representa esta clase. Por claridad se deber\u00eda poner siempre, aunque si el nombre de la tabla es igual al nombre de la clase no es necesaria la anotaci\u00f3n. @Id y @GeneratedValue \u2192 Le indica a JPA que esta propiedad es la que mapea una Primary Key y adem\u00e1s que esta PK se genera con la estrategia que se le indique en la anotaci\u00f3n @GeneratedValue , que puede ser: Generaci\u00f3n de PK por Secuence , la que utiliza Oracle, en este caso habr\u00e1 que indicarle un nombre de secuencia. Generaci\u00f3n de PK por Indentity , la que utiliza MySql o SQLServer, el auto-incremental. Generaci\u00f3n de PK por Table , en algunas BBDD se permite tener una tabla donde se almacenan como registros todas las secuencias. Generaci\u00f3n de PK Auto , elige la mejor estrategia en funci\u00f3n de la BBDD que hemos seleccionado. @Column \u2192 Le indica a JPA que esta propiedad mapea una columna de la tabla y le especifica el nombre de la columna. Al igual que la anotaci\u00f3nd de Table , esta anotaci\u00f3n no es necesaria aunque si es muy recomendable. Por claridad se deber\u00eda poner siempre, aunque si el nombre de la columna es igual al nombre de la propiedad no es necesaria la anotaci\u00f3n. Hay muchas otras anotaciones, pero estas son las b\u00e1sicas, ya ir\u00e1s aprendiendo otras. Consejo Para definir las PK de las tablas, intenta evitar una PK compuesta de m\u00e1s de una columna. La programaci\u00f3n se hace muy compleja y las magias que hace JPA en la oscuridad se complican mucho. Mi recomendaci\u00f3n es que siempre utilices una PK n\u00famerica, en la medida de lo posible, y si es necesario, crees \u00edndices compuestos de b\u00fasqueda o checks compuestos para evitar duplicidades. Implementar Repository Ahora que ya tenemos la entidad implementada, vamos a utilizarla para acceder a BBDD, y esto lo haremos con un Repository . Existen varias formas de utilizar los repositories, desde el todo autom\u00e1tico y magia de JPA hasta el repositorio manual en el que hay que codificar todo. En el tutorial voy a explicar varias formas de implementarlo para este CRUD y los siguientes CRUDs. Como ya se dijo en puntos anteriores, el acceso a datos se debe hacer siempre a trav\u00e9s de un Repository , as\u00ed que vamos a implementar uno. En esta capa, al igual que pasaba con los services, es recomendable utilizar el patr\u00f3n fachada, para poder sustituir implementaciones sin afectar al c\u00f3digo. CategoryRepository.java package com.capgemini.ccsw.tutorial.category ; import org.springframework.data.repository.CrudRepository ; import com.capgemini.ccsw.tutorial.category.model.Category ; /** * @author ccsw */ public interface CategoryRepository extends CrudRepository < Category , Long > { } \u00bfQue te parece?, sencillo, \u00bfno?. Spring ya tiene una implementaci\u00f3n por defecto de un CrudRepository, tan solo tenemos que crear una interface que extienda de la interface CrudRepository pasandole como tipos la Entity y el tipo de la Primary Key. Con eso Spring construye el resto y nos provee de los m\u00e9todos t\u00edpicos y necesarios para un CRUD. Ahora vamos a utilizarla en el Service , pero hay un problema. El Repository devuelve un objeto tipo Category y el Service y Controller devuelven un objeto tipo CategoryDto . Esto es porque en cada capa se debe con un \u00e1mbito de modelos diferente. Podr\u00edamos hacer que todo el back trabajara con Category que son entidades de persistencia, pero no es lo correcto y nos podr\u00eda llevar a cometer errores, o modificar el objeto y que sin que nosotros lo orden\u00e1semos se persistiera ese cambio en BBDD. El \u00e1mbito de trabajo de las capas con el que solemos trabajar y est\u00e1 m\u00e1s extendido es el siguiente: Los datos que vienen y van al cliente, deber\u00edan ser en la mayor\u00eda de los casos datos en formato json Al entrar en un Controller esos datos json se transforman en un DTO. Al salir del Controller hacia el cliente, esos DTOs se transforman en formato json. Estas conversiones son autom\u00e1ticas, las hace Springboot (en realidad las hace la librer\u00eda de jackson codehaus). Cuando un Controller ejecuta una llamada a un Service , generalmente le pasa sus datos en DTO, y el Service se encarga de transformar esto a una Entity . A la inversa, cuando un Service responde a un Controller , \u00e9l responde con una Entity y el Controller ya se encargar\u00e1 de transformarlo a DTO. Por \u00faltimo, para los Repository , siempre se trabaja de entrada y salida con objetos tipo Entity Parece un lio, pero ya ver\u00e1s como es muy sencillo ahora que veremos el ejemplo. Una \u00faltima cosa, para hacer esas transformaciones, las podemos hacer a mano usando getters y setters o bien utilizar el objeto BeanMapper que hemos configurado al principio como utilidad de Devonfw. El c\u00f3digo deber\u00eda quedar as\u00ed: CategoryServiceImpl.java CategoryService.java CategoryController.java package com.capgemini.ccsw.tutorial.category ; import java.util.List ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import com.capgemini.ccsw.tutorial.category.model.Category ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw * */ @Service public class CategoryServiceImpl implements CategoryService { @Autowired CategoryRepository categoryRepository ; /** * {@inheritDoc} */ @Override public List < Category > findAll () { return ( List < Category > ) this . categoryRepository . findAll (); } /** * {@inheritDoc} */ @Override public void save ( Long id , CategoryDto dto ) { Category categoria = null ; if ( id == null ) categoria = new Category (); else categoria = this . categoryRepository . findById ( id ). orElse ( null ); categoria . setName ( dto . getName ()); this . categoryRepository . save ( categoria ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) { this . categoryRepository . deleteById ( id ); } } package com.capgemini.ccsw.tutorial.category ; import java.util.List ; import com.capgemini.ccsw.tutorial.category.model.Category ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw * */ public interface CategoryService { /** * M\u00e9todo para recuperar todas las {@link com.capgemini.ccsw.tutorial.category.model.Category} * @return */ List < Category > findAll (); /** * M\u00e9todo para crear o actualizar una {@link com.capgemini.ccsw.tutorial.category.model.Category} * @param dto * @return */ void save ( Long id , CategoryDto dto ); /** * M\u00e9todo para borrar una {@link com.capgemini.ccsw.tutorial.category.model.Category} * @param id */ void delete ( Long id ); } package com.capgemini.ccsw.tutorial.category ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; import com.devonfw.module.beanmapping.common.api.BeanMapper ; /** * @author ccsw */ @RequestMapping ( value = \"/category\" ) @RestController public class CategoryController { @Autowired CategoryService categoryService ; @Autowired BeanMapper beanMapper ; /** * M\u00e9todo para recuperar todas las {@link com.capgemini.ccsw.tutorial.category.model.Category} * @return */ @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { return this . beanMapper . mapList ( this . categoryService . findAll (), CategoryDto . class ); } /** * M\u00e9todo para crear o actualizar una {@link com.capgemini.ccsw.tutorial.category.model.Category} * @param dto * @return */ @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody CategoryDto dto ) { this . categoryService . save ( id , dto ); } /** * M\u00e9todo para borrar una {@link com.capgemini.ccsw.tutorial.category.model.Category} * @param id */ @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . categoryService . delete ( id ); } } El Service no tiene nada raro, simplemente accede al Repository (siempre anotado como @Autowired ) y recupera datos o los guarda. F\u00edjate en el caso especial del save que la \u00fanica diferencia es que en un caso tendr\u00e1 id != null y por tanto internamente har\u00e1 un update, y en otro caso tendr\u00e1 id == null y por tanto internamente har\u00e1 un save. En cuanto a la interface, lo \u00fanico que cambiamos fue los objetos de respuesta, que ahora pasan a ser de tipo Category . Los de entrada se mantienen como CategoryDto . Por \u00faltimo, en el Controller se puede ver como se utiliza el conversor de BeanMapper (siempre anotado como @Autowired ), que permite traducir una lista a un tipo concreto, o un objeto \u00fanico a un tipo concreto. La forma de hacer estas conversiones siempre es por nombre de propiedad. Las propiedades del objeto destino se deben llamar igual que las propiedades del objeto origen. En caso contrario se quedar\u00e1n a null. Aspectos importantes Los aspectos importantes de la capa Repository son: Al igual que los Service , se debe utilizar el patr\u00f3n fachada, por lo que tendremos una Interface y posiblemente una implementaci\u00f3n. A menudo la implementaci\u00f3n la hace internamente Springboot, pero hay veces que podemos hacer una implementaci\u00f3n manual. Lo veremos en siguientes puntos. Los Repository trabajan siempre con Entity que no son m\u00e1s que mapeos de una tabla o de una vista que existe en BBDD. Los Repository no contienen l\u00f3gica de negocio, ni transformaciones, simplemente acceder a datos, persisten o devuelven informaci\u00f3n. Los Repository JAM\u00c1S deben llamar a otros Repository ni Service . Intenta que tus clases Entity sean lo m\u00e1s sencillas posible, sobre todo en cuanto a Primary Keys, se simplificar\u00e1 mucho el desarrollo. Capa de Testing: TDD Por \u00faltimo y aunque no es lo \u00faltimo que se desarrolla sino todo lo contrario, deber\u00eda ser lo primero en desarrollar, tenemos la bater\u00eda de pruebas. Hemos hecho desarrollado este primer caso de uso con una ordenaci\u00f3n peculiar con fines did\u00e1cticos, pero en realidad deber\u00edamos ir aplicando TDD (Test Driven Development) para el desarrollo. Si quieres aprender las reglas b\u00e1sicas de como aplicar TDD al desarrollo diario, te recomiendo que leas el Anexo. TDD . En este caso, y sin que sirva de precedente, ya tenemos implementados los m\u00e9todos de la aplicaci\u00f3n, y ahora vamos a testearlos. Existen muchas formas de testing en funci\u00f3n del componente o la capa que yo quiera testear. En realidad, a medida que vayas programando ir\u00e1s aprendiendo todas ellas, de momento me sirve con que hagas un test simple que pruebe las casu\u00edsticas de los m\u00e9todos. Lo primero ser\u00e1 conocer que queremos probar y para ello nos vamos a hacer una lista: Pruebas de listado, debe recuperar los elementos de la tabla Categor\u00eda Prueba de creaci\u00f3n, debe crear una nueva Categor\u00eda Prueba de modificaci\u00f3n correcta, debe modificar una Categor\u00eda existente Prueba de modificaci\u00f3n incorrecta, debe dar error al modificar una Categor\u00eda que no existe Prueba de borrado correcta, debe borrar una Categor\u00eda existente Prueba de borrado incorrecta, debe dar error al borrar una Categor\u00eda que no existe Se podr\u00edan hacer muchos m\u00e1s tests, pero creo que con esos son suficientes para que entiendas como se comporta esta capa. Si te fijas, hay que probar tanto los resultados correctos como los resultados incorrectos. El usuario no siempre se va a comportar como nosotros pensamos. Pues vamos a ello. Pruebas de listado Vamos a empezar haciendo una clase de test dentro de la carpeta src/test/java . No queremos que los test formen parte del c\u00f3digo productivo de la aplicaci\u00f3n, por eso utilizamos esa ruta que queda fuera del package general de la aplicaci\u00f3n. Crearemos la clase com.capgemini.ccsw.tutorial.category.CategoryTest . CategoryTest.java package com.capgemini.ccsw.tutorial.category ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.transaction.annotation.Transactional ; /** * @author ccsw */ @SpringBootTest @Transactional public class CategoryTest { } Esta clase es sencilla y tan solo tiene dos anotaciones de Springboot: @SpringBootTest . Esta anotaci\u00f3n lo que hace es inicializar el contexto de Spring cada vez que se inician los test de jUnit. Aunque el contexto tarda unos segundos en arrancar, lo bueno que tiene es que solo se inicializa una vez y se lanzan todos los jUnits en bater\u00eda con el mismo contexto. @Transactional . Esta anotaci\u00f3n le indica a Spring que los test van a ser transaccionales, y por tanto cuando termine la ejecuci\u00f3n de cada uno de los test, autom\u00e1ticamente por la anotaci\u00f3n de arriba, Spring har\u00e1 un rollback y dejar\u00e1 el estado de la BBDD como estaba inicialmente. Tambi\u00e9n nos faltar\u00e1 configurar la aplicaci\u00f3n de test al igual que hicimos con la aplicaci\u00f3n 'productiva'. Deberemos abrir el fichero src/test/resources/application.properties y a\u00f1adir la configuraci\u00f3n de la BBDD. Para este tutorial vamos a utilizar la misma BBDD que la aplicaci\u00f3n productiva, pero de normal la aplicaci\u00f3n se conectar\u00e1 a una BBDD, generalmente f\u00edsica, mientras que los test jUnit se conectar\u00e1n a otra BBDD, generalmente en memoria. application.properties #Database spring.jpa.hibernate.ddl-auto = none spring.datasource.driver-class-name = org.h2.Driver spring.datasource.url = jdbc:h2:mem:test;mode=mysql spring.datasource.username = sa spring.datasource.password = sa spring.jpa.database-platform = org.hibernate.dialect.H2Dialect Con todo esto ya podemos crear nuestro primer test. Iremos a la clase CategoryTest y a\u00f1adiremos un m\u00e9todo p\u00fablico. Los test siempre tienen que ser m\u00e9todos p\u00fablicos que devuelvan el tipo void . CategoryTest.java package com.capgemini.ccsw.tutorial.category ; import static org.junit.jupiter.api.Assertions.assertEquals ; import static org.junit.jupiter.api.Assertions.assertNotNull ; import java.util.List ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.transaction.annotation.Transactional ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; @SpringBootTest @Transactional public class CategoryTest { @Autowired private CategoryController categoryController ; @Test public void findAllShouldReturnAllCategoriesInDB () { assertNotNull ( categoryController ); long categoriesSize = 3 ; List < CategoryDto > categories = categoryController . findAll (); assertNotNull ( categories ); assertEquals ( categoriesSize , categories . size ()); } } Es muy importante marcar cada m\u00e9todo de prueba con la anotaci\u00f3n @Test , en caso contrario no se ejecutar\u00e1. Lo que se debe hacer en cada m\u00e9todo que implementemos es probar una y solo una acci\u00f3n. En el ejemplo anterior, hemos probado que llamando al m\u00e9todo findAll() comprobamos que realmente nos devuelve 3 resultados, que son los que hay en BBDD inicialmente. Muy importante: Nomenclatura de los tests La nomenclatura de los m\u00e9todos de test debe sigue una estructura determinada. Hay muchas formas de nombrar a los m\u00e9todos, pero nosotros solemos utilizar la estructura 'should', para indicar lo que va a hacer. En el ejemplo anterior el m\u00e9todo 'findAll' debe devolver 'AllCategoriesInDB'. De esta forma sabemos cual es la intenci\u00f3n del test, y si por cualquier motivo diera un fallo, sabemos que es lo que NO est\u00e1 funcionando de nuestra aplicaci\u00f3n. Para comprobar que el test funciona, podemos darle bot\u00f3n derecho sobre la clase de CategoryTest y pulsar en Run as -> JUnit Test . Si todo funciona correctamente, deber\u00e1 aparecer una pantalla de ejecuci\u00f3n y todos nuestros tests (en este caso solo uno) corriendo correctamente (en verde). Pruebas de creaci\u00f3n Vamos con los siguientes test, los que probar\u00e1n una creaci\u00f3n de una nueva Categor\u00eda . A\u00f1adimos el siguiente m\u00e9todo a la clase de test: CategoryTest.java @Test public void saveWithoutIdShouldCreateNewCategory () { assertNotNull ( categoryController ); String newCategoryName = \"Nueva Categoria\" ; long newCategoryId = 4 ; long newCategoriesSize = newCategoryId ; CategoryDto dto = new CategoryDto (); dto . setName ( newCategoryName ); categoryController . save ( null , dto ); List < CategoryDto > categories = categoryController . findAll (); assertNotNull ( categories ); assertEquals ( newCategoriesSize , categories . size ()); CategoryDto categorySearch = categories . stream (). filter ( item -> item . getId (). equals ( newCategoryId )). findFirst (). orElse ( null ); assertNotNull ( categorySearch ); assertEquals ( newCategoryName , categorySearch . getName ()); } En este caso, estamos construyendo un objeto CategoryDto para darle un nombre a la Categor\u00eda e invocamos al m\u00e9todo save pasandole un ID a nulo. Seguidamente, recuperamos de nuevo la lista de categor\u00edas y en este caso deber\u00eda tener 4 resultados. Hacemos un filtrado buscando la nueva Categor\u00eda que deber\u00eda tener un ID = 4 y deber\u00eda ser la que acabamos de crear. Si ejecutamos, veremos que ambos test ahora aparecen en verde. Pruebas de modificaci\u00f3n Para este caso de prueba, vamos a realizar dos test, como hemos comentado anteriormente. Tenemos que probar que es lo que pasa cuando intentamos modificar un elemento que existe pero tambi\u00e9n debemos probar que es lo que pasa cuando intentamos modificar un elemento que no existe. Empezamos con el sencillo, un test que pruebe una modificaci\u00f3n existente. CategoryTest.java @Test public void modifyWithExistsIdShouldModifyCategory () { assertNotNull ( categoryController ); String newCategoryName = \"Nueva Categoria\" ; long categoryId = 3 ; long categoriesSize = 3 ; CategoryDto dto = new CategoryDto (); dto . setName ( newCategoryName ); categoryController . save ( categoryId , dto ); List < CategoryDto > categories = categoryController . findAll (); assertNotNull ( categories ); assertEquals ( categoriesSize , categories . size ()); CategoryDto categorySearch = categories . stream (). filter ( item -> item . getId (). equals ( categoryId )). findFirst (). orElse ( null ); assertNotNull ( categorySearch ); assertEquals ( newCategoryName , categorySearch . getName ()); } La misma filosof\u00eda que en el test anterior pero esta vez modificamos la Categor\u00eda de ID = 3. Luego la filtramos y vemos que realmente se ha modificado. Adem\u00e1s comprobamos que el listado de todas los registros sigue siengo 3 y no se ha creado un nuevo registro. En el siguiente test, probaremos un resultado err\u00f3neo. Es un pel\u00edn m\u00e1s compleja, pero no mucho. CategoryTest.java @Test public void modifyWithNotExistsIdShouldThrowException () { assertNotNull ( categoryController ); String newCategoryName = \"Nueva Categoria\" ; long categoryId = 4 ; CategoryDto dto = new CategoryDto (); dto . setName ( newCategoryName ); assertThrows ( NullPointerException . class , () -> categoryController . save ( categoryId , dto )); } Intentamos modificar el ID = 4, que no deber\u00eda existir en BBDD y por tanto lo que se espera en el test es que lance un NullPointerException al llamar al m\u00e9todo save . Pruebas de borrado Ya por \u00faltimo implementamos las pruebas de borrado. CategoryTest.java @Test public void deleteWithExistsIdShouldDeleteCategory () { assertNotNull ( categoryController ); long newCategoriesSize = 2 ; long deleteCategoryId = 2 ; categoryController . delete ( deleteCategoryId ); List < CategoryDto > categories = categoryController . findAll (); assertNotNull ( categories ); assertEquals ( newCategoriesSize , categories . size ()); } @Test public void deleteWithNotExistsIdShouldThrowException () { assertNotNull ( categoryController ); long deleteCategoryId = 4 ; assertThrows ( Exception . class , () -> categoryController . delete ( deleteCategoryId )); } En el primer test, se comprueba que el listado tiene un tama\u00f1o de 2 (uno menos que el original) y en el segundo test se comprueba que con ID no v\u00e1lido, devuelve una Exception . Con esto tendr\u00edamos m\u00e1s o menos probados los casos b\u00e1sicos de nuestra aplicaci\u00f3n y tendr\u00edamos una peque\u00f1a red de seguridad que nos ayudar\u00eda por si a futuro necesitamos hacer alg\u00fan cambio o evolutivo. \u00bfQue hemos aprendido? Resumiendo un poco los pasos que hemos seguido: Hay que definir y agrupar por \u00e1mbito funcional, hemos creado el package com.capgemini.ccsw.tutorial.category para aglutinar todas las clases. Lo primero que debemos empezar a construir siempre son los test, aunque en este tutorial lo hemos hecho al rev\u00e9s solo con fines did\u00e1cticos. En los siguientes puntos lo haremos de forma correcta, y esto nos ayudar\u00e1 a pensar y dise\u00f1ar que es lo que queremos implementar realmente. La implementaci\u00f3n de la aplicaci\u00f3n se deber\u00eda separar por capas: Controller \u2192 Maneja las peticiones de entrada del cliente y realiza transformaciones. No ejecuta directamente l\u00f3gica de negocio, para eso utiliza llamadas a la siguiente capa. Service \u2192 Ejecuta la l\u00f3gica de negocio en sus m\u00e9todos o llamando a otros objetos de la misma capa. No ejecuta directamente accesos a datos, para eso utiliza la siguiente capa. Repository \u2192 Realiza los accesos a datos de lectura y escritura. NUNCA debe llamar a otros objetos de la misma capa ni de capas anteriores. Hay que tener en cuenta los objetos modelo que se mueven en cada capa. Generalmente son: Json \u2192 Los datos que vienen y van del cliente al Controller . DTO \u2192 Los datos se mueven dentro del Controller y sirven para invocar llamadas. Tambi\u00e9n son los datos que devuelve un Controller . Entity \u2192 Los datos que sirven para persistir y leer datos de una BBDD y que NUNCA deber\u00edan ir m\u00e1s all\u00e1 del Controller .","title":"Code: Desarrollo con Springboot"},{"location":"develop/step2/#desarrollo-con-springboot","text":"Ahora que ya tenemos listo tanto el proyecto back de SpringBoot (en el puerto 8080) como el proyecto front de Angular (en el puerto 4200), ya podemos empezar a codificar la soluci\u00f3n. Durante todo el tutorial vamos a intentar separar completamente la implementaci\u00f3n de front de la implementaci\u00f3n de back, para que quede claro como se debe realizar en cada una de las tecnolog\u00edas.","title":"Desarrollo con Springboot"},{"location":"develop/step2/#primeros-pasos","text":"Antes de empezar Quiero hacer hincapi\u00e9 en Springboot tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. Tanto la propia web de Spring como en el portal de tutoriales de Baeldung puedes buscar casi cualquier ejemplo que necesites. Si has seguido el tutorial, en la creaci\u00f3n del proyecto ten\u00edas la posibilidad de crear un proyecto Springboot simple o descargarte una plantilla ya creada. De cualquiera de las dos maneras, tendr\u00e1s la misma estructura que veremos a continuaci\u00f3n.","title":"Primeros pasos"},{"location":"develop/step2/#estructurar-el-codigo","text":"Vamos a hacer un breve refresco de la estructura del c\u00f3digo que ya se ha visto en puntos anteriores. Las clases deben estar agrupadas por \u00e1mbito funcional, en nuestro caso como vamos a hacer la funcionalidad de Categor\u00edas pues deber\u00eda estar todo dentro de un package del tipo com.capgemini.ccsw.tutorial.category . Adem\u00e1s, deber\u00edamos aplicar la separaci\u00f3n por capas como ya se vi\u00f3 en el esquema: La primera capa, la de Controlador , se encargar\u00e1 de procesar las peticiones y transformar datos. Esta capa llamar\u00e1 a la capa de L\u00f3gica de negocio que ejecutar\u00e1 las operaciones, ayud\u00e1ndose de otros objetos de esa misma capa de L\u00f3gica o bien de llamadas a datos a trav\u00e9s de la capa de Acceso a Datos Ahora s\u00ed, vamos a programar!.","title":"Estructurar el c\u00f3digo"},{"location":"develop/step2/#capa-de-operaciones-controller","text":"En esta capa es donde se definen las operaciones que pueden ser consumidas por los clientes. Se caracterizan por estar anotadas con las anotaciones @Controller o @RestController y por las anotaciones @RequestMapping que nos permiten definir las rutas de acceso. Recomendaci\u00f3n: Breve detalle REST Antes de continuar te recomiendo encarecidamente que leas el Anexo: Detalle REST donde se explica brevemente como estructurar los servicios REST que veremos a continuaci\u00f3n.","title":"Capa de operaciones: Controller"},{"location":"develop/step2/#controller-de-ejemplo","text":"Vamos a crear una clase CategoryController.java dentro del package com.capgemini.ccsw.tutorial.category para definir las rutas de las operaciones. CategoryController.java package com.capgemini.ccsw.tutorial.category ; import java.util.List ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; /** * @author ccsw */ @RequestMapping ( value = \"/category\" ) @RestController public class CategoryController { /** * M\u00e9todo para recuperar todas las Category * @return */ @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public String prueba () { return \"Probando el Controller\" ; } } Ahora si arrancamos la aplicaci\u00f3n server, abrimos el Postman y creamos una petici\u00f3n GET a la url http://localhost:8080/category nos responder\u00e1 con el mensaje que hemos programado.","title":"Controller de ejemplo"},{"location":"develop/step2/#implementar-operaciones","text":"Ahora que ya tenemos un controlador y una operacion de negocio ficticia, vamos a borrarla y a\u00f1adir las operaciones reales que consumir\u00e1 nuestra pantalla. Deberemos a\u00f1adir una operaci\u00f3n para listar, una para actualizar, una para guardar y una para borrar. Aunque para hacerlo m\u00e1s c\u00f3modo, utilizaremos la misma operaci\u00f3n para guardar y para actualizar. Adem\u00e1s, no vamos a trabajar directamente con datos simples, sino que usaremos objetos para recibir informaci\u00f3n y para enviar informaci\u00f3n. Estos objetos t\u00edpicamente se denominan DTO (Data Transfer Object) y nos sirven justamente para encapsular informaci\u00f3n que queremos transportar. En realidad no son m\u00e1s que clases pojo sencillas con propiedades, getters y setters. Para nuestro ejemplo crearemos una clase CategoryDto dentro del package com.capgemini.ccsw.tutorial.category.model con el siguiente contenido: CategoryDto.java package com.capgemini.ccsw.tutorial.category.model ; /** * @author ccsw */ public class CategoryDto { private Long id ; private String name ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } } A continuaci\u00f3n utilizaremos esta clase en nuestro Controller para implementar las tres operaciones de negocio. CategoryController.java package com.capgemini.ccsw.tutorial.category ; import java.util.ArrayList ; import java.util.HashMap ; import java.util.List ; import java.util.Map ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw */ @RequestMapping ( value = \"/category\" ) @RestController public class CategoryController { private long SEQUENCE = 1 ; private Map < Long , CategoryDto > categories = new HashMap < Long , CategoryDto > (); /** * M\u00e9todo para recuperar todas las Category * @return */ @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { return new ArrayList ( this . categories . values ()); } /** * M\u00e9todo para crear o actualizar una Category * @param id * @param dto * @return */ @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody CategoryDto dto ) { CategoryDto category ; if ( id == null ) { category = new CategoryDto (); category . setId ( this . SEQUENCE ++ ); this . categories . put ( category . getId (), category ); } else { category = this . categories . get ( id ); } category . setName ( dto . getName ()); } /** * M\u00e9todo para borrar una Category * @param id */ @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . categories . remove ( id ); } } Como todav\u00eda no tenemos acceso a BD, hemos creado una variable tipo HashMap y una variable Long, que simular\u00e1n una BD y una secuencia. Tambi\u00e9n hemos implementado tres operaciones GET, PUT y DELETE que realizan las acciones necesarias por nuestra pantalla. Ahora podr\u00edamos probarlo desde el Postman con cuatro ejemplo sencillos. F\u00edjate que el m\u00e9todo save tiene dos rutas. La ruta normal category/ y la ruta informada category/3 . Esto es porque hemos juntado la acci\u00f3n create y update en un mismo m\u00e9todo para facilitar el desarrollo. Es totalmente v\u00e1lido y funcional. Atenci\u00f3n Los datos que se reciben pueden venir informados como un par\u00e1metro en la URL Get, como una variable en el propio path o dentro del body de la petici\u00f3n. Cada uno de ellos se recupera con una anotaci\u00f3n especial: @RequestParam , @PathVariable y @RequestBody respectivamente. GET /category nos devuelve un listado de Categor\u00edas PUT /category nos sirve para insertar Categor\u00edas nuevas (si no tienen el id informado) o para actualizar Categor\u00edas (si tienen el id informado). F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no env\u00edas datos, te dar\u00e1 un error. DELETE /category nos sirve eliminar Categor\u00edas . F\u00edjate que el dato del ID que se env\u00eda est\u00e1 en el path. Prueba a jugar borrando categor\u00edas que no existen o modificando categor\u00edas que no existen. Tal y como est\u00e1 programado, el borrado no dar\u00e1 error, pero la modificaci\u00f3n deber\u00eda dar un NullPointerException al no existir el dato a modificar.","title":"Implementar operaciones"},{"location":"develop/step2/#aspectos-importantes","text":"Los aspectos importantes de la capa Controller son: La clase debe estar anotada con @Controller o @RestController . Mejor usar la \u00faltima anotaci\u00f3n ya que est\u00e1s diciendo que las operaciones son de tipo Rest y no har\u00e1 falta configurar nada La ruta general al controlador se define con el @RequestMapping global de la clase, aunque tambi\u00e9n se puede obviar esta anotaci\u00f3n y a\u00f1adir a cada una de las operaciones la ruta ra\u00edz. Los m\u00e9todos que queramos exponer como operaciones deben ir anotados tambi\u00e9n con @RequestMapping con la info: path \u2192 Que nos permite definir un path para la operaci\u00f3n, siempre sum\u00e1ndole el path de la clase (si es que tuviera) method \u2192 Que nos permite definir el verbo de http que vamos a atender. Podemos tener el mismo path con diferente method, sin problema. Por lo general utilizaremos: GET \u2192 Generalmente se usa para recuperar informaci\u00f3n POST \u2192 Se utiliza para hacer update y filtrados complejos de informaci\u00f3n PUT \u2192 Se utiliza para hacer save de informaci\u00f3n DELETE \u2192 Se utiliza para hacer borrados de informaci\u00f3n","title":"Aspectos importantes"},{"location":"develop/step2/#capa-de-servicio-service","text":"Pero en realidad la cosa no funciona as\u00ed. Hemos implementado parte de la l\u00f3gica de negocio (las operaciones/acciones de guardado, borrado y listado) dentro de lo que ser\u00eda la capa de operaciones o servicios al cliente. Esta capa no debe ejecutar l\u00f3gica de negocio, tan solo debe hacer transformaciones de datos y enrutar peticiones, toda la l\u00f3gica deber\u00eda ir en la capa de servicio.","title":"Capa de Servicio: Service"},{"location":"develop/step2/#implementar-servicios","text":"Pues vamos a arreglarlo. Vamos a crear un servicio y vamos a mover la l\u00f3gica de negocio al servicio. CategoryService.java CategoryServiceImpl.java CategoryController.java package com.capgemini.ccsw.tutorial.category ; import java.util.List ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw * */ public interface CategoryService { /** * M\u00e9todo para recuperar todas las Category * @return */ List < CategoryDto > findAll (); /** * M\u00e9todo para crear o actualizar una Category * @param dto * @return */ void save ( Long id , CategoryDto dto ); /** * M\u00e9todo para borrar una Category * @param id */ void delete ( Long id ); } package com.capgemini.ccsw.tutorial.category ; import java.util.ArrayList ; import java.util.HashMap ; import java.util.List ; import java.util.Map ; import org.springframework.stereotype.Service ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw * */ @Service public class CategoryServiceImpl implements CategoryService { private long SEQUENCE = 1 ; private Map < Long , CategoryDto > categories = new HashMap < Long , CategoryDto > (); /** * M\u00e9todo para recuperar todas las Category * @return */ public List < CategoryDto > findAll () { return new ArrayList ( this . categories . values ()); } /** * M\u00e9todo para crear o actualizar una Category * @param dto * @return */ public void save ( Long id , CategoryDto dto ) { CategoryDto category ; if ( id == null ) { category = new CategoryDto (); category . setId ( this . SEQUENCE ++ ); this . categories . put ( category . getId (), category ); } else { category = this . categories . get ( id ); } category . setName ( dto . getName ()); } /** * M\u00e9todo para borrar una Category * @param id */ public void delete ( Long id ) { this . categories . remove ( id ); } } package com.capgemini.ccsw.tutorial.category ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw */ @RequestMapping ( value = \"/category\" ) @RestController public class CategoryController { @Autowired private CategoryService categoryService ; /** * M\u00e9todo para recuperar todas las Category * @return */ @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { return this . categoryService . findAll (); } /** * M\u00e9todo para crear o actualizar una Category * @param dto * @return */ @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody CategoryDto dto ) { this . categoryService . save ( id , dto ); } /** * M\u00e9todo para borrar una Category * @param id */ @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . categoryService . delete ( id ); } } Ahora ya tenemos bien estructurado nuestro proyecto. Ya tenemos las dos capas necesarias Controladores y Servicios y cada uno se encarga de llevar a cabo su cometido de forma correcta.","title":"Implementar servicios"},{"location":"develop/step2/#aspectos-importantes_1","text":"Los aspectos importantes de la capa Service son: Toda la l\u00f3gica de negocio, operaciones y dem\u00e1s debe estar implementada en los servicios. Los controladores simplemente invocan servicios y transforman ciertos datos. Es buena pr\u00e1ctica que la capa de servicios se implemente usando el patr\u00f3n fachada, esto quiere decir que necesitamos tener una Interface y al menos una implementaci\u00f3n de esa Interface. Y siempre siempre debemos interactuar con la Interface. Esto nos permitir\u00e1 a futuro poder sustituir la implementaci\u00f3n por otra diferente sin que el resto del c\u00f3digo se vea afectado. Especialmente \u00fatil cuando queremos mockear comportamientos en tests. La capa de servicio puede invocar a otros servicios en sus operaciones, pero nunca debe invocar a un controlador. Para crear un servicio se debe anotar mediante @Service y adem\u00e1s debe implementar la Interface del servicio. Un error muy com\u00fan al arrancar un proyecto y ver que no funcionan las llamadas, es porqu\u00e9 no existe la anotaci\u00f3n @Service o porqu\u00e9 no se ha implementado la Interface. La forma de inyectar y utilizar componentes manejados por Springboot es mediante la anotaci\u00f3n @Autowired . NO intentes crear un objeto de CategoryServiceImpl, ni hacer un new , ya que no estar\u00e1 manejado por Springboot y dar\u00e1 fallos de NullPointer. Lo mejor es dejar que Springboot lo gestione y utilizar las inyecciones de dependencias.","title":"Aspectos importantes"},{"location":"develop/step2/#capa-de-datos-repository","text":"Pero no siempre vamos a acceder a los datos mediante un HasMap en memoria. En algunas ocasiones queremos que nuestro proyecto acceda a un servicio de datos como puede ser una BBDD, un servicio externo, un acceso a disco, etc. Estos accesos se deben hacer desde la capa de acceso a datos, y en concreto para nuestro ejemplo, lo haremos a trav\u00e9s de un Repository para que acceda a una BBDD.","title":"Capa de Datos: Repository"},{"location":"develop/step2/#creacion-de-bbdd","text":"Para el tutorial no necesitamos configurar una BBDD externa ni complicarnos demasiado. Vamos a utilizar una librer\u00eda muy \u00fatil llamada H2 que nos permite levantar una BBDD en memoria persistiendo los datos en memoria o en disco. Para esto, si te acuerdas de cuando creamos la aplicaci\u00f3n, existen unos ficheros que se encuentran dentro de la carpeta src/main/resources/ y que nos permiten ir depositando scripts versionados para que se ejecuten en orden una vez se levante la aplicaci\u00f3n. Vamos a crear los nuestros: schema.sql data.sql DROP TABLE IF EXISTS CATEGORY ; CREATE TABLE CATEGORY ( id BIGINT IDENTITY NOT NULL PRIMARY KEY , name VARCHAR ( 250 ) NOT NULL ); INSERT INTO CATEGORY ( id , name ) VALUES ( 1 , 'Eurogames' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 2 , 'Ameritrash' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 3 , 'Familiar' );","title":"Creaci\u00f3n de BBDD"},{"location":"develop/step2/#implementar-entity","text":"Una vez creada la BBDD el siguiente paso es crear la entidad con la que vamos a persistir y recuperar informaci\u00f3n. Las entidades igual que los DTOs deber\u00edan estar agrupados dentro del package model de cada funcionalidad, as\u00ed que vamos a crear una nueva clase java. Category.java package com.capgemini.ccsw.tutorial.category.model ; import javax.persistence.Column ; import javax.persistence.Entity ; import javax.persistence.GeneratedValue ; import javax.persistence.GenerationType ; import javax.persistence.Id ; import javax.persistence.Table ; /** * @author ccsw */ @Entity @Table ( name = \"Category\" ) public class Category { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"name\" , nullable = false ) private String name ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } } Si te fijas, la Entity suele ser muy similar a un DTO, tiene unas propiedades y sus getters y setters. Pero a diferencia de los DTOs, esta clase tiene una serie de anotaciones que permiten a JPA hacer su magia y generar consultas SQL a la BBDD. En este ejemplo vemos 4 anotaciones importantes: @Entity \u2192 Le indica a Springboot que se trata de una clase que implementa una Entidad de BBDD. Sin esta anotaci\u00f3n no es posible hacer queries. @Table \u2192 Le indica a JPA el nombre y el schema de la tabla que representa esta clase. Por claridad se deber\u00eda poner siempre, aunque si el nombre de la tabla es igual al nombre de la clase no es necesaria la anotaci\u00f3n. @Id y @GeneratedValue \u2192 Le indica a JPA que esta propiedad es la que mapea una Primary Key y adem\u00e1s que esta PK se genera con la estrategia que se le indique en la anotaci\u00f3n @GeneratedValue , que puede ser: Generaci\u00f3n de PK por Secuence , la que utiliza Oracle, en este caso habr\u00e1 que indicarle un nombre de secuencia. Generaci\u00f3n de PK por Indentity , la que utiliza MySql o SQLServer, el auto-incremental. Generaci\u00f3n de PK por Table , en algunas BBDD se permite tener una tabla donde se almacenan como registros todas las secuencias. Generaci\u00f3n de PK Auto , elige la mejor estrategia en funci\u00f3n de la BBDD que hemos seleccionado. @Column \u2192 Le indica a JPA que esta propiedad mapea una columna de la tabla y le especifica el nombre de la columna. Al igual que la anotaci\u00f3nd de Table , esta anotaci\u00f3n no es necesaria aunque si es muy recomendable. Por claridad se deber\u00eda poner siempre, aunque si el nombre de la columna es igual al nombre de la propiedad no es necesaria la anotaci\u00f3n. Hay muchas otras anotaciones, pero estas son las b\u00e1sicas, ya ir\u00e1s aprendiendo otras. Consejo Para definir las PK de las tablas, intenta evitar una PK compuesta de m\u00e1s de una columna. La programaci\u00f3n se hace muy compleja y las magias que hace JPA en la oscuridad se complican mucho. Mi recomendaci\u00f3n es que siempre utilices una PK n\u00famerica, en la medida de lo posible, y si es necesario, crees \u00edndices compuestos de b\u00fasqueda o checks compuestos para evitar duplicidades.","title":"Implementar Entity"},{"location":"develop/step2/#implementar-repository","text":"Ahora que ya tenemos la entidad implementada, vamos a utilizarla para acceder a BBDD, y esto lo haremos con un Repository . Existen varias formas de utilizar los repositories, desde el todo autom\u00e1tico y magia de JPA hasta el repositorio manual en el que hay que codificar todo. En el tutorial voy a explicar varias formas de implementarlo para este CRUD y los siguientes CRUDs. Como ya se dijo en puntos anteriores, el acceso a datos se debe hacer siempre a trav\u00e9s de un Repository , as\u00ed que vamos a implementar uno. En esta capa, al igual que pasaba con los services, es recomendable utilizar el patr\u00f3n fachada, para poder sustituir implementaciones sin afectar al c\u00f3digo. CategoryRepository.java package com.capgemini.ccsw.tutorial.category ; import org.springframework.data.repository.CrudRepository ; import com.capgemini.ccsw.tutorial.category.model.Category ; /** * @author ccsw */ public interface CategoryRepository extends CrudRepository < Category , Long > { } \u00bfQue te parece?, sencillo, \u00bfno?. Spring ya tiene una implementaci\u00f3n por defecto de un CrudRepository, tan solo tenemos que crear una interface que extienda de la interface CrudRepository pasandole como tipos la Entity y el tipo de la Primary Key. Con eso Spring construye el resto y nos provee de los m\u00e9todos t\u00edpicos y necesarios para un CRUD. Ahora vamos a utilizarla en el Service , pero hay un problema. El Repository devuelve un objeto tipo Category y el Service y Controller devuelven un objeto tipo CategoryDto . Esto es porque en cada capa se debe con un \u00e1mbito de modelos diferente. Podr\u00edamos hacer que todo el back trabajara con Category que son entidades de persistencia, pero no es lo correcto y nos podr\u00eda llevar a cometer errores, o modificar el objeto y que sin que nosotros lo orden\u00e1semos se persistiera ese cambio en BBDD. El \u00e1mbito de trabajo de las capas con el que solemos trabajar y est\u00e1 m\u00e1s extendido es el siguiente: Los datos que vienen y van al cliente, deber\u00edan ser en la mayor\u00eda de los casos datos en formato json Al entrar en un Controller esos datos json se transforman en un DTO. Al salir del Controller hacia el cliente, esos DTOs se transforman en formato json. Estas conversiones son autom\u00e1ticas, las hace Springboot (en realidad las hace la librer\u00eda de jackson codehaus). Cuando un Controller ejecuta una llamada a un Service , generalmente le pasa sus datos en DTO, y el Service se encarga de transformar esto a una Entity . A la inversa, cuando un Service responde a un Controller , \u00e9l responde con una Entity y el Controller ya se encargar\u00e1 de transformarlo a DTO. Por \u00faltimo, para los Repository , siempre se trabaja de entrada y salida con objetos tipo Entity Parece un lio, pero ya ver\u00e1s como es muy sencillo ahora que veremos el ejemplo. Una \u00faltima cosa, para hacer esas transformaciones, las podemos hacer a mano usando getters y setters o bien utilizar el objeto BeanMapper que hemos configurado al principio como utilidad de Devonfw. El c\u00f3digo deber\u00eda quedar as\u00ed: CategoryServiceImpl.java CategoryService.java CategoryController.java package com.capgemini.ccsw.tutorial.category ; import java.util.List ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import com.capgemini.ccsw.tutorial.category.model.Category ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw * */ @Service public class CategoryServiceImpl implements CategoryService { @Autowired CategoryRepository categoryRepository ; /** * {@inheritDoc} */ @Override public List < Category > findAll () { return ( List < Category > ) this . categoryRepository . findAll (); } /** * {@inheritDoc} */ @Override public void save ( Long id , CategoryDto dto ) { Category categoria = null ; if ( id == null ) categoria = new Category (); else categoria = this . categoryRepository . findById ( id ). orElse ( null ); categoria . setName ( dto . getName ()); this . categoryRepository . save ( categoria ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) { this . categoryRepository . deleteById ( id ); } } package com.capgemini.ccsw.tutorial.category ; import java.util.List ; import com.capgemini.ccsw.tutorial.category.model.Category ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw * */ public interface CategoryService { /** * M\u00e9todo para recuperar todas las {@link com.capgemini.ccsw.tutorial.category.model.Category} * @return */ List < Category > findAll (); /** * M\u00e9todo para crear o actualizar una {@link com.capgemini.ccsw.tutorial.category.model.Category} * @param dto * @return */ void save ( Long id , CategoryDto dto ); /** * M\u00e9todo para borrar una {@link com.capgemini.ccsw.tutorial.category.model.Category} * @param id */ void delete ( Long id ); } package com.capgemini.ccsw.tutorial.category ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; import com.devonfw.module.beanmapping.common.api.BeanMapper ; /** * @author ccsw */ @RequestMapping ( value = \"/category\" ) @RestController public class CategoryController { @Autowired CategoryService categoryService ; @Autowired BeanMapper beanMapper ; /** * M\u00e9todo para recuperar todas las {@link com.capgemini.ccsw.tutorial.category.model.Category} * @return */ @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { return this . beanMapper . mapList ( this . categoryService . findAll (), CategoryDto . class ); } /** * M\u00e9todo para crear o actualizar una {@link com.capgemini.ccsw.tutorial.category.model.Category} * @param dto * @return */ @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody CategoryDto dto ) { this . categoryService . save ( id , dto ); } /** * M\u00e9todo para borrar una {@link com.capgemini.ccsw.tutorial.category.model.Category} * @param id */ @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . categoryService . delete ( id ); } } El Service no tiene nada raro, simplemente accede al Repository (siempre anotado como @Autowired ) y recupera datos o los guarda. F\u00edjate en el caso especial del save que la \u00fanica diferencia es que en un caso tendr\u00e1 id != null y por tanto internamente har\u00e1 un update, y en otro caso tendr\u00e1 id == null y por tanto internamente har\u00e1 un save. En cuanto a la interface, lo \u00fanico que cambiamos fue los objetos de respuesta, que ahora pasan a ser de tipo Category . Los de entrada se mantienen como CategoryDto . Por \u00faltimo, en el Controller se puede ver como se utiliza el conversor de BeanMapper (siempre anotado como @Autowired ), que permite traducir una lista a un tipo concreto, o un objeto \u00fanico a un tipo concreto. La forma de hacer estas conversiones siempre es por nombre de propiedad. Las propiedades del objeto destino se deben llamar igual que las propiedades del objeto origen. En caso contrario se quedar\u00e1n a null.","title":"Implementar Repository"},{"location":"develop/step2/#aspectos-importantes_2","text":"Los aspectos importantes de la capa Repository son: Al igual que los Service , se debe utilizar el patr\u00f3n fachada, por lo que tendremos una Interface y posiblemente una implementaci\u00f3n. A menudo la implementaci\u00f3n la hace internamente Springboot, pero hay veces que podemos hacer una implementaci\u00f3n manual. Lo veremos en siguientes puntos. Los Repository trabajan siempre con Entity que no son m\u00e1s que mapeos de una tabla o de una vista que existe en BBDD. Los Repository no contienen l\u00f3gica de negocio, ni transformaciones, simplemente acceder a datos, persisten o devuelven informaci\u00f3n. Los Repository JAM\u00c1S deben llamar a otros Repository ni Service . Intenta que tus clases Entity sean lo m\u00e1s sencillas posible, sobre todo en cuanto a Primary Keys, se simplificar\u00e1 mucho el desarrollo.","title":"Aspectos importantes"},{"location":"develop/step2/#capa-de-testing-tdd","text":"Por \u00faltimo y aunque no es lo \u00faltimo que se desarrolla sino todo lo contrario, deber\u00eda ser lo primero en desarrollar, tenemos la bater\u00eda de pruebas. Hemos hecho desarrollado este primer caso de uso con una ordenaci\u00f3n peculiar con fines did\u00e1cticos, pero en realidad deber\u00edamos ir aplicando TDD (Test Driven Development) para el desarrollo. Si quieres aprender las reglas b\u00e1sicas de como aplicar TDD al desarrollo diario, te recomiendo que leas el Anexo. TDD . En este caso, y sin que sirva de precedente, ya tenemos implementados los m\u00e9todos de la aplicaci\u00f3n, y ahora vamos a testearlos. Existen muchas formas de testing en funci\u00f3n del componente o la capa que yo quiera testear. En realidad, a medida que vayas programando ir\u00e1s aprendiendo todas ellas, de momento me sirve con que hagas un test simple que pruebe las casu\u00edsticas de los m\u00e9todos. Lo primero ser\u00e1 conocer que queremos probar y para ello nos vamos a hacer una lista: Pruebas de listado, debe recuperar los elementos de la tabla Categor\u00eda Prueba de creaci\u00f3n, debe crear una nueva Categor\u00eda Prueba de modificaci\u00f3n correcta, debe modificar una Categor\u00eda existente Prueba de modificaci\u00f3n incorrecta, debe dar error al modificar una Categor\u00eda que no existe Prueba de borrado correcta, debe borrar una Categor\u00eda existente Prueba de borrado incorrecta, debe dar error al borrar una Categor\u00eda que no existe Se podr\u00edan hacer muchos m\u00e1s tests, pero creo que con esos son suficientes para que entiendas como se comporta esta capa. Si te fijas, hay que probar tanto los resultados correctos como los resultados incorrectos. El usuario no siempre se va a comportar como nosotros pensamos. Pues vamos a ello.","title":"Capa de Testing: TDD"},{"location":"develop/step2/#pruebas-de-listado","text":"Vamos a empezar haciendo una clase de test dentro de la carpeta src/test/java . No queremos que los test formen parte del c\u00f3digo productivo de la aplicaci\u00f3n, por eso utilizamos esa ruta que queda fuera del package general de la aplicaci\u00f3n. Crearemos la clase com.capgemini.ccsw.tutorial.category.CategoryTest . CategoryTest.java package com.capgemini.ccsw.tutorial.category ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.transaction.annotation.Transactional ; /** * @author ccsw */ @SpringBootTest @Transactional public class CategoryTest { } Esta clase es sencilla y tan solo tiene dos anotaciones de Springboot: @SpringBootTest . Esta anotaci\u00f3n lo que hace es inicializar el contexto de Spring cada vez que se inician los test de jUnit. Aunque el contexto tarda unos segundos en arrancar, lo bueno que tiene es que solo se inicializa una vez y se lanzan todos los jUnits en bater\u00eda con el mismo contexto. @Transactional . Esta anotaci\u00f3n le indica a Spring que los test van a ser transaccionales, y por tanto cuando termine la ejecuci\u00f3n de cada uno de los test, autom\u00e1ticamente por la anotaci\u00f3n de arriba, Spring har\u00e1 un rollback y dejar\u00e1 el estado de la BBDD como estaba inicialmente. Tambi\u00e9n nos faltar\u00e1 configurar la aplicaci\u00f3n de test al igual que hicimos con la aplicaci\u00f3n 'productiva'. Deberemos abrir el fichero src/test/resources/application.properties y a\u00f1adir la configuraci\u00f3n de la BBDD. Para este tutorial vamos a utilizar la misma BBDD que la aplicaci\u00f3n productiva, pero de normal la aplicaci\u00f3n se conectar\u00e1 a una BBDD, generalmente f\u00edsica, mientras que los test jUnit se conectar\u00e1n a otra BBDD, generalmente en memoria. application.properties #Database spring.jpa.hibernate.ddl-auto = none spring.datasource.driver-class-name = org.h2.Driver spring.datasource.url = jdbc:h2:mem:test;mode=mysql spring.datasource.username = sa spring.datasource.password = sa spring.jpa.database-platform = org.hibernate.dialect.H2Dialect Con todo esto ya podemos crear nuestro primer test. Iremos a la clase CategoryTest y a\u00f1adiremos un m\u00e9todo p\u00fablico. Los test siempre tienen que ser m\u00e9todos p\u00fablicos que devuelvan el tipo void . CategoryTest.java package com.capgemini.ccsw.tutorial.category ; import static org.junit.jupiter.api.Assertions.assertEquals ; import static org.junit.jupiter.api.Assertions.assertNotNull ; import java.util.List ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.transaction.annotation.Transactional ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; @SpringBootTest @Transactional public class CategoryTest { @Autowired private CategoryController categoryController ; @Test public void findAllShouldReturnAllCategoriesInDB () { assertNotNull ( categoryController ); long categoriesSize = 3 ; List < CategoryDto > categories = categoryController . findAll (); assertNotNull ( categories ); assertEquals ( categoriesSize , categories . size ()); } } Es muy importante marcar cada m\u00e9todo de prueba con la anotaci\u00f3n @Test , en caso contrario no se ejecutar\u00e1. Lo que se debe hacer en cada m\u00e9todo que implementemos es probar una y solo una acci\u00f3n. En el ejemplo anterior, hemos probado que llamando al m\u00e9todo findAll() comprobamos que realmente nos devuelve 3 resultados, que son los que hay en BBDD inicialmente. Muy importante: Nomenclatura de los tests La nomenclatura de los m\u00e9todos de test debe sigue una estructura determinada. Hay muchas formas de nombrar a los m\u00e9todos, pero nosotros solemos utilizar la estructura 'should', para indicar lo que va a hacer. En el ejemplo anterior el m\u00e9todo 'findAll' debe devolver 'AllCategoriesInDB'. De esta forma sabemos cual es la intenci\u00f3n del test, y si por cualquier motivo diera un fallo, sabemos que es lo que NO est\u00e1 funcionando de nuestra aplicaci\u00f3n. Para comprobar que el test funciona, podemos darle bot\u00f3n derecho sobre la clase de CategoryTest y pulsar en Run as -> JUnit Test . Si todo funciona correctamente, deber\u00e1 aparecer una pantalla de ejecuci\u00f3n y todos nuestros tests (en este caso solo uno) corriendo correctamente (en verde).","title":"Pruebas de listado"},{"location":"develop/step2/#pruebas-de-creacion","text":"Vamos con los siguientes test, los que probar\u00e1n una creaci\u00f3n de una nueva Categor\u00eda . A\u00f1adimos el siguiente m\u00e9todo a la clase de test: CategoryTest.java @Test public void saveWithoutIdShouldCreateNewCategory () { assertNotNull ( categoryController ); String newCategoryName = \"Nueva Categoria\" ; long newCategoryId = 4 ; long newCategoriesSize = newCategoryId ; CategoryDto dto = new CategoryDto (); dto . setName ( newCategoryName ); categoryController . save ( null , dto ); List < CategoryDto > categories = categoryController . findAll (); assertNotNull ( categories ); assertEquals ( newCategoriesSize , categories . size ()); CategoryDto categorySearch = categories . stream (). filter ( item -> item . getId (). equals ( newCategoryId )). findFirst (). orElse ( null ); assertNotNull ( categorySearch ); assertEquals ( newCategoryName , categorySearch . getName ()); } En este caso, estamos construyendo un objeto CategoryDto para darle un nombre a la Categor\u00eda e invocamos al m\u00e9todo save pasandole un ID a nulo. Seguidamente, recuperamos de nuevo la lista de categor\u00edas y en este caso deber\u00eda tener 4 resultados. Hacemos un filtrado buscando la nueva Categor\u00eda que deber\u00eda tener un ID = 4 y deber\u00eda ser la que acabamos de crear. Si ejecutamos, veremos que ambos test ahora aparecen en verde.","title":"Pruebas de creaci\u00f3n"},{"location":"develop/step2/#pruebas-de-modificacion","text":"Para este caso de prueba, vamos a realizar dos test, como hemos comentado anteriormente. Tenemos que probar que es lo que pasa cuando intentamos modificar un elemento que existe pero tambi\u00e9n debemos probar que es lo que pasa cuando intentamos modificar un elemento que no existe. Empezamos con el sencillo, un test que pruebe una modificaci\u00f3n existente. CategoryTest.java @Test public void modifyWithExistsIdShouldModifyCategory () { assertNotNull ( categoryController ); String newCategoryName = \"Nueva Categoria\" ; long categoryId = 3 ; long categoriesSize = 3 ; CategoryDto dto = new CategoryDto (); dto . setName ( newCategoryName ); categoryController . save ( categoryId , dto ); List < CategoryDto > categories = categoryController . findAll (); assertNotNull ( categories ); assertEquals ( categoriesSize , categories . size ()); CategoryDto categorySearch = categories . stream (). filter ( item -> item . getId (). equals ( categoryId )). findFirst (). orElse ( null ); assertNotNull ( categorySearch ); assertEquals ( newCategoryName , categorySearch . getName ()); } La misma filosof\u00eda que en el test anterior pero esta vez modificamos la Categor\u00eda de ID = 3. Luego la filtramos y vemos que realmente se ha modificado. Adem\u00e1s comprobamos que el listado de todas los registros sigue siengo 3 y no se ha creado un nuevo registro. En el siguiente test, probaremos un resultado err\u00f3neo. Es un pel\u00edn m\u00e1s compleja, pero no mucho. CategoryTest.java @Test public void modifyWithNotExistsIdShouldThrowException () { assertNotNull ( categoryController ); String newCategoryName = \"Nueva Categoria\" ; long categoryId = 4 ; CategoryDto dto = new CategoryDto (); dto . setName ( newCategoryName ); assertThrows ( NullPointerException . class , () -> categoryController . save ( categoryId , dto )); } Intentamos modificar el ID = 4, que no deber\u00eda existir en BBDD y por tanto lo que se espera en el test es que lance un NullPointerException al llamar al m\u00e9todo save .","title":"Pruebas de modificaci\u00f3n"},{"location":"develop/step2/#pruebas-de-borrado","text":"Ya por \u00faltimo implementamos las pruebas de borrado. CategoryTest.java @Test public void deleteWithExistsIdShouldDeleteCategory () { assertNotNull ( categoryController ); long newCategoriesSize = 2 ; long deleteCategoryId = 2 ; categoryController . delete ( deleteCategoryId ); List < CategoryDto > categories = categoryController . findAll (); assertNotNull ( categories ); assertEquals ( newCategoriesSize , categories . size ()); } @Test public void deleteWithNotExistsIdShouldThrowException () { assertNotNull ( categoryController ); long deleteCategoryId = 4 ; assertThrows ( Exception . class , () -> categoryController . delete ( deleteCategoryId )); } En el primer test, se comprueba que el listado tiene un tama\u00f1o de 2 (uno menos que el original) y en el segundo test se comprueba que con ID no v\u00e1lido, devuelve una Exception . Con esto tendr\u00edamos m\u00e1s o menos probados los casos b\u00e1sicos de nuestra aplicaci\u00f3n y tendr\u00edamos una peque\u00f1a red de seguridad que nos ayudar\u00eda por si a futuro necesitamos hacer alg\u00fan cambio o evolutivo.","title":"Pruebas de borrado"},{"location":"develop/step2/#que-hemos-aprendido","text":"Resumiendo un poco los pasos que hemos seguido: Hay que definir y agrupar por \u00e1mbito funcional, hemos creado el package com.capgemini.ccsw.tutorial.category para aglutinar todas las clases. Lo primero que debemos empezar a construir siempre son los test, aunque en este tutorial lo hemos hecho al rev\u00e9s solo con fines did\u00e1cticos. En los siguientes puntos lo haremos de forma correcta, y esto nos ayudar\u00e1 a pensar y dise\u00f1ar que es lo que queremos implementar realmente. La implementaci\u00f3n de la aplicaci\u00f3n se deber\u00eda separar por capas: Controller \u2192 Maneja las peticiones de entrada del cliente y realiza transformaciones. No ejecuta directamente l\u00f3gica de negocio, para eso utiliza llamadas a la siguiente capa. Service \u2192 Ejecuta la l\u00f3gica de negocio en sus m\u00e9todos o llamando a otros objetos de la misma capa. No ejecuta directamente accesos a datos, para eso utiliza la siguiente capa. Repository \u2192 Realiza los accesos a datos de lectura y escritura. NUNCA debe llamar a otros objetos de la misma capa ni de capas anteriores. Hay que tener en cuenta los objetos modelo que se mueven en cada capa. Generalmente son: Json \u2192 Los datos que vienen y van del cliente al Controller . DTO \u2192 Los datos se mueven dentro del Controller y sirven para invocar llamadas. Tambi\u00e9n son los datos que devuelve un Controller . Entity \u2192 Los datos que sirven para persistir y leer datos de una BBDD y que NUNCA deber\u00edan ir m\u00e1s all\u00e1 del Controller .","title":"\u00bfQue hemos aprendido?"},{"location":"develop/step3/","text":"Conectar Angular con las operaciones de Springboot Ya casi lo tenemos listo! Por un lado tenemos la aplicaci\u00f3n Angular funcionando con datos mockeados en local, y por otro lado tenemos el servidor Springboot con las operaciones funcionando y adem\u00e1s correctamente testeado. El siguiente paso, como es obvio ser\u00e1 hacer que Angular llame directamente al servidor Springboot para leer y escribir datos y eliminar los datos mockeados en Angular. Manos a la obra! Llamada del listado La idea es que el m\u00e9todo getCategories() de category.service.ts en lugar de devolver datos est\u00e1ticos, realice una llamada al servidor a la ruta http://localhost:8080/category . Abrimos el fichero y susituimos la l\u00ednea que antes devolv\u00eda los datos est\u00e1ticos por esto: category.service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor ( private http : HttpClient ) { } getCategories () : Observable < Category [] > { return this . http . get < Category [] > ( 'http://localhost:8080/category' ); } saveCategory ( category : Category ) : Observable < Category > { return of ( null ); } deleteCategory ( idCategory : number ) : Observable < any > { return of ( null ); } } Como hemos a\u00f1adido un componente nuevo HttpClient tenemos que a\u00f1adir la dependencial al m\u00f3dulo padre. services.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { MatTableModule } from '@angular/material/table' ; import { MatIconModule } from '@angular/material/icon' ; import { MatButtonModule } from '@angular/material/button' ; import { CategoryListComponent } from './category-list/category-list.component' ; import { CategoryEditComponent } from './category-edit/category-edit.component' ; import { MAT_DIALOG_DATA , MatDialogModule } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatInputModule } from '@angular/material/input' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; import { HttpClientModule } from '@angular/common/http' ; @NgModule ({ declarations : [ CategoryListComponent , CategoryEditComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule , MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , HttpClientModule , ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class CategoryModule { } Si ahora refrescas el navegador (recuerda tener arrancado tambi\u00e9n el servidor) y accedes a la pantalla de Categor\u00edas no saldr\u00e1 ning\u00fan resultado, pero si miras la consola ver\u00e1s un mensaje similar a este: Access to XMLHttpRequest at 'http://localhost:8080/category' from origin 'http://localhost:4200' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. Esto es debido a la pol\u00edtica de CORS, que impide que desde un dominio+puerto se tenga acceso indiscriminado a otro dominio+puerto diferente, y as\u00ed evita posibles ataques. Access Control Policy El error de CORS es muy habitual cuando se est\u00e1 trabajando en local y se tienen varios servidores levantados. Hay que tener mucho ojo con este filtro. Para m\u00e1s ver m\u00e1s informaci\u00f3n de como funciona y su casu\u00edstica visita Control de acceso HTTP . Para solucionarlo hay varias formas, pero la m\u00e1s c\u00f3moda en desarrollo es habilitar el permiso de CORS para cualquier origen en el servidor. Para ello vamos al c\u00f3digo de servidor y a\u00f1adimos una nueva anotaci\u00f3n: CategoryController.java package com.capgemini.ccsw.tutorial.category ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; import com.devonfw.module.beanmapping.common.api.BeanMapper ; /** * @author ccsw */ @RequestMapping ( value = \"/category\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class CategoryController { @Autowired CategoryService categoryService ; @Autowired BeanMapper beanMapper ; ... Ahora s\u00ed, si refrescamos ya deber\u00eda aparecer el listado con los datos que vienen del servidor. Llamada de guardado / edici\u00f3n Para la llamada de guardado har\u00edamos lo mismo, pero invocando la operaci\u00f3n de negocio put . category.service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor ( private http : HttpClient ) { } getCategories () : Observable < Category [] > { return this . http . get < Category [] > ( 'http://localhost:8080/category' ); } saveCategory ( category : Category ) : Observable < Category > { let url = 'http://localhost:8080/category' ; if ( category . id != null ) url += '/' + category . id ; return this . http . put < Category > ( url , category ); } deleteCategory ( idCategory : number ) : Observable < any > { return of ( null ); } } Ahora podemos probar a modificar o a\u00f1adir una nueva categor\u00eda desde la pantalla y deber\u00eda aparecer los nuevos datos en el listado. Llamada de borrado Y ya por \u00faltimo, la llamada de borrado, deber\u00edamos cambiarla e invocar a la operaci\u00f3n de negocio delete . category.service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor ( private http : HttpClient ) { } getCategories () : Observable < Category [] > { return this . http . get < Category [] > ( 'http://localhost:8080/category' ); } saveCategory ( category : Category ) : Observable < Category > { let url = 'http://localhost:8080/category' ; if ( category . id != null ) url += '/' + category . id ; return this . http . put < Category > ( url , category ); } deleteCategory ( idCategory : number ) : Observable < any > { return this . http . delete ( 'http://localhost:8080/category/' + idCategory ); } } Ahora podemos probar a modificar o a\u00f1adir una nueva categor\u00eda desde la pantalla y deber\u00eda aparecer los nuevos datos en el listado. Como ves, es bastante sencillo conectar server y client.","title":"Code: Conectar front con back"},{"location":"develop/step3/#conectar-angular-con-las-operaciones-de-springboot","text":"Ya casi lo tenemos listo! Por un lado tenemos la aplicaci\u00f3n Angular funcionando con datos mockeados en local, y por otro lado tenemos el servidor Springboot con las operaciones funcionando y adem\u00e1s correctamente testeado. El siguiente paso, como es obvio ser\u00e1 hacer que Angular llame directamente al servidor Springboot para leer y escribir datos y eliminar los datos mockeados en Angular. Manos a la obra!","title":"Conectar Angular con las operaciones de Springboot"},{"location":"develop/step3/#llamada-del-listado","text":"La idea es que el m\u00e9todo getCategories() de category.service.ts en lugar de devolver datos est\u00e1ticos, realice una llamada al servidor a la ruta http://localhost:8080/category . Abrimos el fichero y susituimos la l\u00ednea que antes devolv\u00eda los datos est\u00e1ticos por esto: category.service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor ( private http : HttpClient ) { } getCategories () : Observable < Category [] > { return this . http . get < Category [] > ( 'http://localhost:8080/category' ); } saveCategory ( category : Category ) : Observable < Category > { return of ( null ); } deleteCategory ( idCategory : number ) : Observable < any > { return of ( null ); } } Como hemos a\u00f1adido un componente nuevo HttpClient tenemos que a\u00f1adir la dependencial al m\u00f3dulo padre. services.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { MatTableModule } from '@angular/material/table' ; import { MatIconModule } from '@angular/material/icon' ; import { MatButtonModule } from '@angular/material/button' ; import { CategoryListComponent } from './category-list/category-list.component' ; import { CategoryEditComponent } from './category-edit/category-edit.component' ; import { MAT_DIALOG_DATA , MatDialogModule } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatInputModule } from '@angular/material/input' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; import { HttpClientModule } from '@angular/common/http' ; @NgModule ({ declarations : [ CategoryListComponent , CategoryEditComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule , MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , HttpClientModule , ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class CategoryModule { } Si ahora refrescas el navegador (recuerda tener arrancado tambi\u00e9n el servidor) y accedes a la pantalla de Categor\u00edas no saldr\u00e1 ning\u00fan resultado, pero si miras la consola ver\u00e1s un mensaje similar a este: Access to XMLHttpRequest at 'http://localhost:8080/category' from origin 'http://localhost:4200' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. Esto es debido a la pol\u00edtica de CORS, que impide que desde un dominio+puerto se tenga acceso indiscriminado a otro dominio+puerto diferente, y as\u00ed evita posibles ataques. Access Control Policy El error de CORS es muy habitual cuando se est\u00e1 trabajando en local y se tienen varios servidores levantados. Hay que tener mucho ojo con este filtro. Para m\u00e1s ver m\u00e1s informaci\u00f3n de como funciona y su casu\u00edstica visita Control de acceso HTTP . Para solucionarlo hay varias formas, pero la m\u00e1s c\u00f3moda en desarrollo es habilitar el permiso de CORS para cualquier origen en el servidor. Para ello vamos al c\u00f3digo de servidor y a\u00f1adimos una nueva anotaci\u00f3n: CategoryController.java package com.capgemini.ccsw.tutorial.category ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; import com.devonfw.module.beanmapping.common.api.BeanMapper ; /** * @author ccsw */ @RequestMapping ( value = \"/category\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class CategoryController { @Autowired CategoryService categoryService ; @Autowired BeanMapper beanMapper ; ... Ahora s\u00ed, si refrescamos ya deber\u00eda aparecer el listado con los datos que vienen del servidor.","title":"Llamada del listado"},{"location":"develop/step3/#llamada-de-guardado-edicion","text":"Para la llamada de guardado har\u00edamos lo mismo, pero invocando la operaci\u00f3n de negocio put . category.service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor ( private http : HttpClient ) { } getCategories () : Observable < Category [] > { return this . http . get < Category [] > ( 'http://localhost:8080/category' ); } saveCategory ( category : Category ) : Observable < Category > { let url = 'http://localhost:8080/category' ; if ( category . id != null ) url += '/' + category . id ; return this . http . put < Category > ( url , category ); } deleteCategory ( idCategory : number ) : Observable < any > { return of ( null ); } } Ahora podemos probar a modificar o a\u00f1adir una nueva categor\u00eda desde la pantalla y deber\u00eda aparecer los nuevos datos en el listado.","title":"Llamada de guardado / edici\u00f3n"},{"location":"develop/step3/#llamada-de-borrado","text":"Y ya por \u00faltimo, la llamada de borrado, deber\u00edamos cambiarla e invocar a la operaci\u00f3n de negocio delete . category.service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Category } from './model/Category' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor ( private http : HttpClient ) { } getCategories () : Observable < Category [] > { return this . http . get < Category [] > ( 'http://localhost:8080/category' ); } saveCategory ( category : Category ) : Observable < Category > { let url = 'http://localhost:8080/category' ; if ( category . id != null ) url += '/' + category . id ; return this . http . put < Category > ( url , category ); } deleteCategory ( idCategory : number ) : Observable < any > { return this . http . delete ( 'http://localhost:8080/category/' + idCategory ); } } Ahora podemos probar a modificar o a\u00f1adir una nueva categor\u00eda desde la pantalla y deber\u00eda aparecer los nuevos datos en el listado. Como ves, es bastante sencillo conectar server y client.","title":"Llamada de borrado"},{"location":"develop/step4/","text":"Desarrollo de un listado paginado Ya tienes tu primer listado desarrollado, tanto en front como en back. \u00bfHa sido sencillo, verdad?. Ahora vamos a implementar un listado un poco m\u00e1s complejo, este tiene datos paginados en servidor, esto quiere decir que no nos sirve un array de datos como en el anterior ejemplo. Para que un listado paginado en servidor funcione, el cliente debe enviar en cada petici\u00f3n que p\u00e1gina est\u00e1 solicitando y cual es el tama\u00f1o de la p\u00e1gina, para que el servidor devuelva solamente un subconjunto de datos, en lugar de devolver el listado completo. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades. Desarrollo Angular Crear modulo y componentes Vamos a desarrollar el listado de Autores as\u00ed que, debemos crear los componentes: ng generate module author ng generate component author/author-list ng generate component author/author-edit ng generate service author/author Este m\u00f3dulo lo vamos a a\u00f1adir a la aplicaci\u00f3n para que se cargue en el arranque. Abrimos el fichero app.module.ts y a\u00f1adimos el m\u00f3dulo: app.module.ts import { NgModule } from '@angular/core' ; import { BrowserModule } from '@angular/platform-browser' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { BrowserAnimationsModule } from '@angular/platform-browser/animations' ; import { CoreModule } from './core/core.module' ; import { CategoryModule } from './category/category.module' ; import { AuthorModule } from './author/author.module' ; @NgModule ({ declarations : [ AppComponent ], imports : [ BrowserModule , AppRoutingModule , CoreModule , CategoryModule , AuthorModule , BrowserAnimationsModule ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { } Crear el modelo Creamos el modelo en author/model/Author.ts con las propiedades necesarias para trabajar con la informaci\u00f3n de un autor: Author.ts export class Author { id : number ; name : string ; nationality : string ; } A\u00f1adir el punto de entrada A\u00f1adimos la ruta al men\u00fa para que podamos acceder a la pantalla: app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { CategoryListComponent } from './category/category-list/category-list.component' ; import { AuthorListComponent } from './author/author-list/author-list.component' ; const routes : Routes = [ { path : 'categories' , component : CategoriesComponent }, { path : 'authors' , component : AuthorListComponent }, ]; @NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } Implementar servicio Y realizamos las diferentes implementaciones. Empezaremos por el servicio. En este caso, hay un cambio sustancial con el anterior ejemplo. Al tratarse de un listado paginado, la operaci\u00f3n getAuthors necesita informaci\u00f3n extra acerca de que p\u00e1gina de datos debe mostrar, adem\u00e1s de que el resultado ya no ser\u00e1 un listado sino una p\u00e1gina. Por defecto el esquema de datos de Spring para la paginaci\u00f3n es como el siguiente: Esquema de datos de paginaci\u00f3n { \"content\" : [ ... <lis ta do co n los resul ta dos pagi na dos> ... ], \"pageable\" : { \"pageNumber\" : < n \u00famero de p\u00e1gi na empeza n do por 0 > , \"pageSize\" : < ta ma\u00f1o de p\u00e1gi na > , \"sort\" : [ { \"property\" : < n ombre de la propiedad a orde nar > , \"direction\" : <direcci\u00f3 n de la orde na ci\u00f3 n ASC / DESC> } ] }, \"totalElements\" : < nu mero t o tal de eleme nt os e n la ta bla> } As\u00ed que necesitamos poder enviar y recuperar esa informaci\u00f3n desde Angular, nos hace falta crear esos objetos. Los objetos de paginaci\u00f3n al ser comunes a toda la aplicaci\u00f3n, vamos a crearlos en core/model/page , mientras que la paginaci\u00f3n de AuthorPage.ts la crear\u00e9 en su propio model dentro de author/model . SortPage.ts Pageable.ts AuthorPage.ts export class SortPage { property : String ; direction : String ; } import { SortPage } from './SortPage' ; export class Pageable { pageNumber : number ; pageSize : number ; sort : SortPage []; } import { Pageable } from \"src/app/core/model/page/Pageable\" ; import { Author } from \"./Author\" ; export class AuthorPage { content : Author []; pageable : Pageable ; totalElements : number ; } Con estos objetos creados ya podemos implementar el servicio y sus datos mockeados. mock-authors.ts author.service.ts import { AuthorPage } from \"./AuthorPage\" ; export const AUTHOR_DATA : AuthorPage = { content : [ { id : 1 , name : 'Klaus Teuber' , nationality : 'Alemania' }, { id : 2 , name : 'Matt Leacock' , nationality : 'Estados Unidos' }, { id : 3 , name : 'Keng Leong Yeo' , nationality : 'Singapur' }, { id : 4 , name : 'Gil Hova' , nationality : 'Estados Unidos' }, { id : 5 , name : 'Kelly Adams' , nationality : 'Estados Unidos' }, { id : 6 , name : 'J. Alex Kavern' , nationality : 'Estados Unidos' }, { id : 7 , name : 'Corey Young' , nationality : 'Estados Unidos' }, ], pageable : { pageSize : 5 , pageNumber : 0 , sort : [ { property : \"id\" , direction : \"ASC\" } ] }, totalElements : 7 } import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Pageable } from '../core/model/page/Pageable' ; import { Author } from './model/Author' ; import { AuthorPage } from './model/AuthorPage' ; import { AUTHOR_DATA } from './model/mock-authors' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor () { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return of ( AUTHOR_DATA ); } saveAuthor ( author : Author ) : Observable < void > { return of ( null ); } deleteAuthor ( idAuthor : number ) : Observable < void > { return of ( null ); } } Implementar listado Ya tenemos el servicio con los datos, ahora vamos a por el listado paginado. author-list.component.html author-list.component.scss author-list.component.ts < div class = \"container\" > < h1 > Listado de Autores </ h1 > < mat-table [ dataSource ]=\" dataSource \" > < ng-container matColumnDef = \"id\" > < mat-header-cell * matHeaderCellDef > Identificador </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.id}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"name\" > < mat-header-cell * matHeaderCellDef > Nombre autor </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.name}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"nationality\" > < mat-header-cell * matHeaderCellDef > Nacionalidad </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.nationality}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" > < mat-icon ( click )=\" editAuthor ( element )\" > edit </ mat-icon > </ button > < button mat-icon-button color = \"accent\" > < mat-icon ( click )=\" deleteAuthor ( element )\" > clear </ mat-icon > </ button > </ mat-cell > </ ng-container > < mat-header-row * matHeaderRowDef = \"displayedColumns; sticky: true\" ></ mat-header-row > < mat-row * matRowDef = \"let row; columns: displayedColumns;\" ></ mat-row > </ mat-table > < mat-paginator ( page )=\" loadPage ($ event )\" [ pageSizeOptions ]=\"[ 5 , 10 , 20 ]\" [ pageIndex ]=\" pageNumber \" [ pageSize ]=\" pageSize \" [ length ]=\" totalElements \" showFirstLastButtons ></ mat-paginator > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createAuthor ()\" > Nuevo autor </ button > </ div > </ div > . container { margin : 20 px ; mat-table { margin-top : 10 px ; margin-bottom : 20 px ; .mat-header-row { background-color : #f5f5f5 ; .mat-header-cell { text-transform : uppercase ; font-weight : bold ; color : #838383 ; } } . mat-column-id { flex : 0 0 20 % ; justify-content : center ; } . mat-column-action { flex : 0 0 10 % ; justify-content : center ; } } . buttons { text-align : right ; } } import { Component , OnInit } from '@angular/core' ; import { MatDialog } from '@angular/material/dialog' ; import { PageEvent } from '@angular/material/paginator' ; import { MatTableDataSource } from '@angular/material/table' ; import { DialogConfirmationComponent } from 'src/app/core/dialog-confirmation/dialog-confirmation.component' ; import { Pageable } from 'src/app/core/model/page/Pageable' ; import { AuthorEditComponent } from '../author-edit/author-edit.component' ; import { AuthorService } from '../author.service' ; import { Author } from '../model/Author' ; @Component ({ selector : 'app-author-list' , templateUrl : './author-list.component.html' , styleUrls : [ './author-list.component.scss' ] }) export class AuthorListComponent implements OnInit { pageNumber : number = 0 ; pageSize : number = 5 ; totalElements : number = 0 ; dataSource = new MatTableDataSource < Author > (); displayedColumns : string [] = [ 'id' , 'name' , 'nationality' , 'action' ]; constructor ( private authorService : AuthorService , public dialog : MatDialog , ) { } ngOnInit () : void { this . loadPage (); } loadPage ( event? : PageEvent ) { let pageable : Pageable = { pageNumber : this.pageNumber , pageSize : this.pageSize , sort : [{ property : 'id' , direction : 'ASC' }] } if ( event != null ) { pageable . pageSize = event . pageSize pageable . pageNumber = event . pageIndex ; } this . authorService . getAuthors ( pageable ). subscribe ( data => { this . dataSource . data = data . content ; this . pageNumber = data . pageable . pageNumber ; this . pageSize = data . pageable . pageSize ; this . totalElements = data . totalElements ; }); } createAuthor () { const dialogRef = this . dialog . open ( AuthorEditComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } editAuthor ( author : Author ) { const dialogRef = this . dialog . open ( AuthorEditComponent , { data : { author : author } }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } deleteAuthor ( author : Author ) { const dialogRef = this . dialog . open ( DialogConfirmationComponent , { data : { title : \"Eliminar autor\" , description : \"Atenci\u00f3n si borra el autor se perder\u00e1n sus datos.<br> \u00bfDesea eliminar el autor?\" } }); dialogRef . afterClosed (). subscribe ( result => { if ( result ) { this . authorService . deleteAuthor ( author . id ). subscribe ( result => { this . ngOnInit (); }); } }); } } F\u00edjate como hemos a\u00f1adido la paginaci\u00f3n. Al HTML le hemos a\u00f1adido un componente nuevo mat-paginator , lo que nos va a obligar a a\u00f1adirlo al m\u00f3dulo tambi\u00e9n como dependencia. Ese componente le hemos definido un m\u00e9todo page que se ejecuta cada vez que la p\u00e1gina cambia, y unas propiedades con las que calcular\u00e1 la p\u00e1gina, el tama\u00f1o y el n\u00famero total de p\u00e1ginas. Al Typescript le hemos tenido que a\u00f1adir esas variables y hemos creado un m\u00e9todo para cargar datos que lo que hace es construir un objeto pageable con los valores actuales del componente paginador y lanza la petici\u00f3n con esos datos en el body. Obviamente al ser un mock no funcionar\u00e1 el cambio de p\u00e1gina y dem\u00e1s. Como siempre, a\u00f1adimos las dependencias al m\u00f3dulo, vamos a intentar a\u00f1adir todas las que vamos a necesitar a futuro. author.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { AuthorListComponent } from './author-list/author-list.component' ; import { AuthorEditComponent } from './author-edit/author-edit.component' ; import { MatTableModule } from '@angular/material/table' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; import { MatButtonModule } from '@angular/material/button' ; import { MatDialogModule , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatIconModule } from '@angular/material/icon' ; import { MatInputModule } from '@angular/material/input' ; import { MatPaginatorModule } from '@angular/material/paginator' ; @NgModule ({ declarations : [ AuthorListComponent , AuthorEditComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule , MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , MatPaginatorModule , ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class AuthorModule { } Deber\u00eda verse algo similar a esto: Implementar dialogo edici\u00f3n El \u00faltimo paso, es definir la pantalla de dialogo que realizar\u00e1 el alta y modificado de los datos de un Autor . author-edit.component.html author-edit.component.scss author-edit.component.ts < div class = \"container\" > < h1 * ngIf = \"author.id == null\" > Crear autor </ h1 > < h1 * ngIf = \"author.id != null\" > Modificar autor </ h1 > < form > < mat-form-field > < mat-label > Identificador </ mat-label > < input type = \"number\" matInput placeholder = \"Identificador\" [( ngModel )]=\" author . id \" name = \"id\" disabled > </ mat-form-field > < mat-form-field > < mat-label > Nombre </ mat-label > < input type = \"text\" matInput placeholder = \"Nombre del autor\" [( ngModel )]=\" author . name \" name = \"name\" required > < mat-error > El nombre no puede estar vac\u00edo </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Nacionalidad </ mat-label > < input type = \"text\" matInput placeholder = \"Nacionalidad del autor\" [( ngModel )]=\" author . nationality \" name = \"nationality\" required > < mat-error > La nacionalidad no puede estar vac\u00eda </ mat-error > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onClose ()\" > Cerrar </ button > < button mat-flat-button color = \"primary\" ( click )=\" onSave ()\" > Guardar </ button > </ div > </ div > . container { min-width : 350 px ; max-width : 500 px ; width : 100 % ; form { display : flex ; flex-direction : column ; margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } import { Component , Inject , OnInit } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { AuthorService } from '../author.service' ; import { Author } from '../model/Author' ; @Component ({ selector : 'app-author-edit' , templateUrl : './author-edit.component.html' , styleUrls : [ './author-edit.component.scss' ] }) export class AuthorEditComponent implements OnInit { author : Author ; constructor ( public dialogRef : MatDialogRef < AuthorEditComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any , private authorService : AuthorService ) { } ngOnInit () : void { if ( this . data . author != null ) { this . author = Object . assign ({}, this . data . author ); } else { this . author = new Author (); } } onSave () { this . authorService . saveAuthor ( this . author ). subscribe ( result => { this . dialogRef . close (); }); } onClose () { this . dialogRef . close (); } } Que deber\u00eda quedar algo as\u00ed: Desarrollo Springboot Modelos Lo primero que vamos a hacer es crear los modelos para trabajar con BBDD y con peticiones hacia el front. Adem\u00e1s, tambi\u00e9n tenemos que a\u00f1adir datos al script de inicializaci\u00f3n de BBDD. schema.sql data.sql Author.java AuthorDto.java DROP TABLE IF EXISTS CATEGORY ; CREATE TABLE CATEGORY ( id BIGINT IDENTITY NOT NULL PRIMARY KEY , name VARCHAR ( 250 ) NOT NULL ); DROP TABLE IF EXISTS AUTHOR ; CREATE TABLE AUTHOR ( id BIGINT IDENTITY NOT NULL PRIMARY KEY , name VARCHAR ( 400 ) NOT NULL , nationality VARCHAR ( 250 ) NOT NULL ); INSERT INTO CATEGORY ( id , name ) VALUES ( 1 , 'Eurogames' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 2 , 'Ameritrash' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 3 , 'Familiar' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 1 , 'Alan R. Moon' , 'US' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 2 , 'Vital Lacerda' , 'PT' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 3 , 'Simone Luciani' , 'IT' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 4 , 'Perepau Llistosella' , 'ES' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 5 , 'Michael Kiesling' , 'DE' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 6 , 'Phil Walker-Harding' , 'US' ); package com.capgemini.ccsw.tutorial.author.model ; import javax.persistence.Column ; import javax.persistence.Entity ; import javax.persistence.GeneratedValue ; import javax.persistence.GenerationType ; import javax.persistence.Id ; import javax.persistence.Table ; /** * @author ccsw */ @Entity @Table ( name = \"Author\" ) public class Author { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"name\" , nullable = false ) private String name ; @Column ( name = \"nationality\" ) private String nationality ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getid}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getname}. */ public void setName ( String name ) { this . name = name ; } /** * @return nationality */ public String getNationality () { return this . nationality ; } /** * @param nationality new value of {@link #getnationality}. */ public void setNationality ( String nationality ) { this . nationality = nationality ; } } package com.capgemini.ccsw.tutorial.author.model ; /** * @author ccsw */ public class AuthorDto { private Long id ; private String name ; private String nationality ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getid}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getname}. */ public void setName ( String name ) { this . name = name ; } /** * @return nationality */ public String getNationality () { return this . nationality ; } /** * @param nationality new value of {@link #getnationality}. */ public void setNationality ( String nationality ) { this . nationality = nationality ; } } TDD - Pruebas Para desarrollar todas las operaciones, empezaremos primero dise\u00f1ando las pruebas y luego implementando el c\u00f3digo necesario que haga funcionar correctamente esas pruebas. Para ir m\u00e1s r\u00e1pido vamos a poner todas las pruebas de golpe, pero realmente se deber\u00edan crear una a una e ir implementando el c\u00f3digo necesario para esa prueba. Para evitar tantas iteraciones en el tutorial las haremos todas de golpe. Vamos a pararnos a pensar un poco que necesitamos en la pantalla. Ahora mismo nos sirve con: Una consulta paginada, que reciba datos de la p\u00e1gina a consultar y devuelva los datos paginados Una operaci\u00f3n de guardado y modificaci\u00f3n Una operaci\u00f3n de borrado Para la primera prueba necesitaremos que hemos descrito (consulta paginada) se necesita un objeto que contenga los datos de la p\u00e1gina a consultar. As\u00ed que crearemos una clase AuthorSearchDto para utilizarlo como 'paginador'. Paginaci\u00f3n en Springframework Cuando utilicemos paginaci\u00f3n en Springframework, debemos recordar que ya vienen implementados algunos objetos que podemos utilizar y que nos facilitan la vida. Es el caso de Pageable y Page . El objeto Pageable no es m\u00e1s que una interface que le permite a Spring JPA saber que p\u00e1gina se quiere buscar, cual es el tama\u00f1o de p\u00e1gina y cuales son las propiedades de ordenaci\u00f3n que se debe lanzar en la consulta. El objeto PageRequest es una utilidad que permite crear objetos de tipo Pageable de forma sencilla. Se utiliza mucho para codificaci\u00f3n de test. El objeto Page no es m\u00e1s que un contenedor que engloba la informaci\u00f3n b\u00e1sica de la p\u00e1gina que se est\u00e1 consultando (n\u00famero de p\u00e1gina, tama\u00f1o de p\u00e1gina, n\u00famero total de resultados) y el conjunto de datos de la BBDD que contiene esa p\u00e1gina una vez han sido buscados y ordenados. Tambi\u00e9n crearemos una clase AuthorController dentro del package de com.capgemini.ccsw.tutorial.author con la implementaci\u00f3n de los m\u00e9todos vac\u00edos, para que no falle la compilaci\u00f3n. \u00a1Vamos a implementar test! AuthorSearchDto.java AuthorController.java AuthorTest.java package com.capgemini.ccsw.tutorial.author.model ; import org.springframework.data.domain.Pageable ; /** * @author ccsw */ public class AuthorSearchDto { private Pageable pageable ; /** * @return pageable */ public Pageable getPageable () { return this . pageable ; } /** * @param pageable new value of {@link #getPageable}. */ public void setPageable ( Pageable pageable ) { this . pageable = pageable ; } } package com.capgemini.ccsw.tutorial.author ; import org.springframework.data.domain.Page ; import com.capgemini.ccsw.tutorial.author.model.AuthorDto ; import com.capgemini.ccsw.tutorial.author.model.AuthorSearchDto ; /** * @author ccsw */ public class AuthorController { /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param dto * @return */ public Page < AuthorDto > findPage ( AuthorSearchDto dto ) { return null ; } /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param id * @param data datos de la entidad */ public void save ( Long id , AuthorDto data ) { } /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param id PK de la entidad */ public void delete ( Long id ) { } } package com.capgemini.ccsw.tutorial.author ; import static org.junit.jupiter.api.Assertions.assertEquals ; import static org.junit.jupiter.api.Assertions.assertNotNull ; import static org.junit.jupiter.api.Assertions.assertThrows ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.PageRequest ; import org.springframework.transaction.annotation.Transactional ; import com.capgemini.ccsw.tutorial.author.model.AuthorDto ; import com.capgemini.ccsw.tutorial.author.model.AuthorSearchDto ; @SpringBootTest @Transactional public class AuthorTest { private static final int TOTAL_AUTORS = 6 ; @Autowired private AuthorController authorController ; @Test public void findFirstPageWithFiveSizeShouldReturnFirstFiveResults () { int pageSize = 5 ; assertNotNull ( authorController ); AuthorSearchDto dto = new AuthorSearchDto (); dto . setPageable ( PageRequest . of ( 0 , pageSize )); Page < AuthorDto > resultPage = authorController . findPage ( dto ); assertNotNull ( resultPage ); assertEquals ( TOTAL_AUTORS , resultPage . getTotalElements ()); assertEquals ( pageSize , resultPage . getContent (). size ()); } @Test public void findSecondPageWithFiveSizeShouldReturnLastResult () { int pageSize = 5 ; int elementsCount = TOTAL_AUTORS - pageSize ; assertNotNull ( authorController ); AuthorSearchDto searchDto = new AuthorSearchDto (); searchDto . setPageable ( PageRequest . of ( 1 , pageSize )); Page < AuthorDto > resultPage = authorController . findPage ( searchDto ); assertNotNull ( resultPage ); assertEquals ( TOTAL_AUTORS , resultPage . getTotalElements ()); assertEquals ( elementsCount , resultPage . getContent (). size ()); } @Test public void saveWithoutIdShouldCreateNewAuthor () { assertNotNull ( authorController ); String newAuthorName = \"Nuevo Autor\" ; String newNationality = \"Nueva Nacionalidad\" ; long newAuthorId = TOTAL_AUTORS + 1 ; long newAuthorSize = TOTAL_AUTORS + 1 ; AuthorDto dto = new AuthorDto (); dto . setName ( newAuthorName ); dto . setNationality ( newNationality ); authorController . save ( null , dto ); AuthorSearchDto searchDto = new AuthorSearchDto (); searchDto . setPageable ( PageRequest . of ( 0 , ( int ) newAuthorSize )); Page < AuthorDto > resultPage = authorController . findPage ( searchDto ); assertNotNull ( resultPage ); assertEquals ( newAuthorSize , resultPage . getTotalElements ()); AuthorDto author = resultPage . getContent (). stream (). filter ( item -> item . getId (). equals ( newAuthorId )). findFirst (). orElse ( null ); assertNotNull ( author ); assertEquals ( newAuthorName , author . getName ()); } @Test public void modifyWithExistIdShouldModifyAuthor () { assertNotNull ( authorController ); String newAuthorName = \"Nuevo Autor\" ; String newNationality = \"Nueva Nacionalidad\" ; long authorId = 3 ; AuthorDto dto = new AuthorDto (); dto . setName ( newAuthorName ); dto . setNationality ( newNationality ); authorController . save ( authorId , dto ); AuthorSearchDto searchDto = new AuthorSearchDto (); searchDto . setPageable ( PageRequest . of ( 0 , ( int ) authorId )); Page < AuthorDto > resultPage = authorController . findPage ( searchDto ); assertNotNull ( resultPage ); assertEquals ( TOTAL_AUTORS , resultPage . getTotalElements ()); AuthorDto author = resultPage . getContent (). stream (). filter ( item -> item . getId (). equals ( authorId )). findFirst (). orElse ( null ); assertNotNull ( author ); assertEquals ( newAuthorName , author . getName ()); assertEquals ( newNationality , author . getNationality ()); } @Test public void modifyWithNotExistIdShouldThrowException () { assertNotNull ( authorController ); String newAuthorName = \"Nuevo Autor\" ; long authorId = TOTAL_AUTORS + 1 ; AuthorDto dto = new AuthorDto (); dto . setName ( newAuthorName ); assertThrows ( Exception . class , () -> authorController . save ( authorId , dto )); } @Test public void deleteWithExistsIdShouldDeleteCategory () { assertNotNull ( authorController ); long newAuthorsSize = TOTAL_AUTORS - 1 ; long deleteAuthorId = 6 ; authorController . delete ( deleteAuthorId ); AuthorSearchDto searchDto = new AuthorSearchDto (); searchDto . setPageable ( PageRequest . of ( 0 , TOTAL_AUTORS )); Page < AuthorDto > resultPage = authorController . findPage ( searchDto ); assertNotNull ( resultPage ); assertEquals ( newAuthorsSize , resultPage . getTotalElements ()); } @Test public void deleteWithNotExistsIdShouldThrowException () { assertNotNull ( authorController ); long deleteAuthorId = TOTAL_AUTORS + 1 ; assertThrows ( Exception . class , () -> authorController . delete ( deleteAuthorId )); } } Cuidado con las clases de Test Recuerda que el c\u00f3digo de aplicaci\u00f3n debe ir en src/main/java , mientras que las clases de test deben ir en src/test/java para que no se mezclen unas con otras y se empaquete todo en el artefacto final. En este caso AuthorTest.java va en el directorio de test src/test/java . Si ejecutamos los test, el resultado ser\u00e1 7 maravillosos test que fallan su ejecuci\u00f3n. Es normal, puesto que no hemos implementado nada de c\u00f3digo de aplicaci\u00f3n para corresponder esos test. Controller Si recuerdas, esta capa de Controller es la que tiene los endpoints de entrada a la aplicaci\u00f3n. Nosotros ya tenemos definidas 3 operaciones, que hemos dise\u00f1ado directamente desde los tests. Ahora vamos a implementar esos m\u00e9todos con el c\u00f3digo necesario para que los test funcionen correctamente, y teniendo en mente que debemos apoyarnos en las capas inferiores Service y Repository para repartir l\u00f3gica de negocio y acceso a datos. AuthorController.java AuthorService.java package com.capgemini.ccsw.tutorial.author ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.ccsw.tutorial.author.model.AuthorDto ; import com.capgemini.ccsw.tutorial.author.model.AuthorSearchDto ; import com.capgemini.ccsw.tutorial.config.mapper.BeanMapper ; /** * @author ccsw */ @RequestMapping ( value = \"/author\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class AuthorController { @Autowired AuthorService authorService ; @Autowired BeanMapper beanMapper ; /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param dto * @return */ @RequestMapping ( path = \"\" , method = RequestMethod . POST ) public Page < AuthorDto > findPage ( @RequestBody AuthorSearchDto dto ) { return this . beanMapper . mapPage ( this . authorService . findPage ( dto ), AuthorDto . class ); } /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param id * @param data datos de la entidad */ @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody AuthorDto data ) { this . authorService . save ( id , data ); } /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param id PK de la entidad */ @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . authorService . delete ( id ); } } package com.capgemini.ccsw.tutorial.author ; import org.springframework.data.domain.Page ; import com.capgemini.ccsw.tutorial.author.model.Author ; import com.capgemini.ccsw.tutorial.author.model.AuthorDto ; import com.capgemini.ccsw.tutorial.author.model.AuthorSearchDto ; /** * @author ccsw */ public interface AuthorService { /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param dto * @return */ Page < Author > findPage ( AuthorSearchDto dto ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param id * @param data */ void save ( Long id , AuthorDto data ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param id */ void delete ( Long id ); } Si te fijas, hemos trasladado toda la l\u00f3gica a llamadas al AuthorService que hemos inyectado, y para que no falle la compilaci\u00f3n hemos creado una interface con los m\u00e9todos necesarios. En la clase AuthorController es donde se hacen las conversiones de cara al cliente, pasaremos de un Page<Author> (modelo entidad) a un Page<AuthorDto> (modelo DTO) con la ayuda del beanMapper. Recuerda que al cliente no le deben llegar modelos entidades sino DTOs. Adem\u00e1s, el m\u00e9todo de carga findPage ya no es un m\u00e9todo de tipo GET , ahora es de tipo POST porque le tenemos que enviar los datos de la paginaci\u00f3n para que Spring JPA pueda hacer su magia. Ahora debemos implementar la siguiente capa. Service La siguiente capa que vamos a implementar es justamente la capa que contiene toda la l\u00f3gica de negocio, hace uso del Repository para acceder a los datos, y recibe llamadas generalmente de los Controller . AuthorServiceImpl.java AuthorRepository.java package com.capgemini.ccsw.tutorial.author ; import javax.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.stereotype.Service ; import com.capgemini.ccsw.tutorial.author.model.Author ; import com.capgemini.ccsw.tutorial.author.model.AuthorDto ; import com.capgemini.ccsw.tutorial.author.model.AuthorSearchDto ; /** * @author ccsw */ @Service @Transactional public class AuthorServiceImpl implements AuthorService { @Autowired AuthorRepository authorRepository ; /** * {@inheritDoc} */ @Override public Page < Author > findPage ( AuthorSearchDto dto ) { return this . authorRepository . findAll ( dto . getPageable ()); } /** * {@inheritDoc} */ @Override public void save ( Long id , AuthorDto data ) { Author author = null ; if ( id != null ) author = this . authorRepository . findById ( id ). orElse ( null ); else author = new Author (); BeanUtils . copyProperties ( data , author , \"id\" ); this . authorRepository . save ( author ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) { this . authorRepository . deleteById ( id ); } } package com.capgemini.ccsw.tutorial.author ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.Pageable ; import org.springframework.data.repository.CrudRepository ; import com.capgemini.ccsw.tutorial.author.model.Author ; /** * @author ccsw */ public interface AuthorRepository extends CrudRepository < Author , Long > { /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param page * @return */ Page < Author > findAll ( Pageable pageable ); } De nuevo pasa lo mismo que con la capa anterior, aqu\u00ed delegamos muchas operaciones de consulta y guardado de datos en AuthorRepository . Hemos tenido que crearlo como interface para que no falle la compilaci\u00f3n. Recuerda que cuando creamos un Repository es de gran ayuda hacerlo extender de CrudRepository<T, ID> ya que tiene muchos m\u00e9todos implementados de base que nos pueden servir, como el delete o el save . F\u00edjate tambi\u00e9n que cuando queremos copiar m\u00e1s de un dato de una clase a otra, tenemos una utilidad llamada BeanUtils que nos permite realizar esa copia (siempre que las propiedades de ambas clases se llamen igual). Adem\u00e1s, en nuestro ejemplo hemos ignorado el 'id' para que no nos copie un null a la clase destino. Repository Y llegamos a la \u00faltima capa, la que est\u00e1 m\u00e1s cerca de los datos finales. Tenemos la siguiente interface: AuthorRepository.java package com.capgemini.ccsw.tutorial.author ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.Pageable ; import org.springframework.data.repository.CrudRepository ; import com.capgemini.ccsw.tutorial.author.model.Author ; /** * @author ccsw */ public interface AuthorRepository extends CrudRepository < Author , Long > { /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param page * @return */ Page < Author > findAll ( Pageable pageable ); } Si te fijas, este Repository ya no est\u00e1 vac\u00edo como el anterior, no nos sirve con las operaciones b\u00e1sicas del CrudRepository en este caso hemos tenido que a\u00f1adir un m\u00e9todo nuevo al que pasandole un objeto de tipo Pageable nos devuelva una Page . Pues bien, resulta que la m\u00e1gina de Spring JPA en este caso har\u00e1 su trabajo y nosotros no necesitamos implementar ninguna query, Spring ya entiende que un findAll significa que debe recuperar todos los datos de la tabla Author (que es la tabla que tiene como generico en CrudRepository ) y adem\u00e1s deben estar paginados ya que el m\u00e9todo devuelve un objeto tipo Page . Nos ahorra tener que generar una sql para buscar una p\u00e1gina concreta de datos y hacer un count de la tabla para obtener el total de resultados. Para ver otros ejemplos y m\u00e1s informaci\u00f3n, visita la p\u00e1gina de QueryMethods . Realmente se puede hacer much\u00edsimas cosas con solo escribir el nombre del m\u00e9todo, sin tener que pensar ni teclear ninguna sql. Con esto ya lo tendr\u00edamos todo. Prueba de las operaciones Si ahora ejecutamos los test jUnit, veremos que todos funcionan y est\u00e1n en verde. Hemos implementado todas nuestras pruebas y la aplicaci\u00f3n es correcta. Aun as\u00ed, debemos realizar pruebas con el postman para ver los resultados que nos ofrece el back. Para ello, tienes que levantar la aplici\u00f3n y ejecutar las siguientes operaciones: POST /author { \"pageable\": { \"pageSize\" : 4, \"pageNumber\" : 0, \"sort\" : [ { \"property\": \"name\", \"direction\": \"ASC\" } ] } } Nos devuelve un listado paginado de Autores . F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no env\u00edas datos con formato Pageable , te dar\u00e1 un error. Tambi\u00e9n f\u00edjate que la respuesta es de tipo Page . Prueba a jugar con los datos de paginaci\u00f3n e incluso de ordenaci\u00f3n. No hemos programado ninguna SQL pero Spring hace su magia. PUT /author PUT /author/{id} { \"name\" : \"Nuevo autor\", \"nationality\" : \"Nueva nacionalidad\" } Nos sirve para insertar Autores nuevas (si no tienen el id informado) o para actualizar Autores (si tienen el id informado en la URL). F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no te dar\u00e1 un error. DELETE /author/{id} nos sirve eliminar Autores . F\u00edjate que el dato del ID que se env\u00eda est\u00e1 en el path. Conectar front con back Una vez implementado front y back, lo que nos queda es modificar el servicio del front para que conecte directamente con las operaciones ofrecidas por el back. author.service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Pageable } from '../core/model/page/Pageable' ; import { Author } from './model/Author' ; import { AuthorPage } from './model/AuthorPage' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor ( private http : HttpClient ) { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return this . http . post < AuthorPage > ( 'http://localhost:8080/author' , { pageable : pageable }); } saveAuthor ( author : Author ) : Observable < void > { let url = 'http://localhost:8080/author' ; if ( author . id != null ) url += '/' + author . id ; return this . http . put < void > ( url , author ); } deleteAuthor ( idAuthor : number ) : Observable < void > { return this . http . delete < void > ( 'http://localhost:8080/author/' + idAuthor ); } }","title":"Code: Listado paginado"},{"location":"develop/step4/#desarrollo-de-un-listado-paginado","text":"Ya tienes tu primer listado desarrollado, tanto en front como en back. \u00bfHa sido sencillo, verdad?. Ahora vamos a implementar un listado un poco m\u00e1s complejo, este tiene datos paginados en servidor, esto quiere decir que no nos sirve un array de datos como en el anterior ejemplo. Para que un listado paginado en servidor funcione, el cliente debe enviar en cada petici\u00f3n que p\u00e1gina est\u00e1 solicitando y cual es el tama\u00f1o de la p\u00e1gina, para que el servidor devuelva solamente un subconjunto de datos, en lugar de devolver el listado completo. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.","title":"Desarrollo de un listado paginado"},{"location":"develop/step4/#desarrollo-angular","text":"","title":"Desarrollo Angular"},{"location":"develop/step4/#crear-modulo-y-componentes","text":"Vamos a desarrollar el listado de Autores as\u00ed que, debemos crear los componentes: ng generate module author ng generate component author/author-list ng generate component author/author-edit ng generate service author/author Este m\u00f3dulo lo vamos a a\u00f1adir a la aplicaci\u00f3n para que se cargue en el arranque. Abrimos el fichero app.module.ts y a\u00f1adimos el m\u00f3dulo: app.module.ts import { NgModule } from '@angular/core' ; import { BrowserModule } from '@angular/platform-browser' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { BrowserAnimationsModule } from '@angular/platform-browser/animations' ; import { CoreModule } from './core/core.module' ; import { CategoryModule } from './category/category.module' ; import { AuthorModule } from './author/author.module' ; @NgModule ({ declarations : [ AppComponent ], imports : [ BrowserModule , AppRoutingModule , CoreModule , CategoryModule , AuthorModule , BrowserAnimationsModule ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { }","title":"Crear modulo y componentes"},{"location":"develop/step4/#crear-el-modelo","text":"Creamos el modelo en author/model/Author.ts con las propiedades necesarias para trabajar con la informaci\u00f3n de un autor: Author.ts export class Author { id : number ; name : string ; nationality : string ; }","title":"Crear el modelo"},{"location":"develop/step4/#anadir-el-punto-de-entrada","text":"A\u00f1adimos la ruta al men\u00fa para que podamos acceder a la pantalla: app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { CategoryListComponent } from './category/category-list/category-list.component' ; import { AuthorListComponent } from './author/author-list/author-list.component' ; const routes : Routes = [ { path : 'categories' , component : CategoriesComponent }, { path : 'authors' , component : AuthorListComponent }, ]; @NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { }","title":"A\u00f1adir el punto de entrada"},{"location":"develop/step4/#implementar-servicio","text":"Y realizamos las diferentes implementaciones. Empezaremos por el servicio. En este caso, hay un cambio sustancial con el anterior ejemplo. Al tratarse de un listado paginado, la operaci\u00f3n getAuthors necesita informaci\u00f3n extra acerca de que p\u00e1gina de datos debe mostrar, adem\u00e1s de que el resultado ya no ser\u00e1 un listado sino una p\u00e1gina. Por defecto el esquema de datos de Spring para la paginaci\u00f3n es como el siguiente: Esquema de datos de paginaci\u00f3n { \"content\" : [ ... <lis ta do co n los resul ta dos pagi na dos> ... ], \"pageable\" : { \"pageNumber\" : < n \u00famero de p\u00e1gi na empeza n do por 0 > , \"pageSize\" : < ta ma\u00f1o de p\u00e1gi na > , \"sort\" : [ { \"property\" : < n ombre de la propiedad a orde nar > , \"direction\" : <direcci\u00f3 n de la orde na ci\u00f3 n ASC / DESC> } ] }, \"totalElements\" : < nu mero t o tal de eleme nt os e n la ta bla> } As\u00ed que necesitamos poder enviar y recuperar esa informaci\u00f3n desde Angular, nos hace falta crear esos objetos. Los objetos de paginaci\u00f3n al ser comunes a toda la aplicaci\u00f3n, vamos a crearlos en core/model/page , mientras que la paginaci\u00f3n de AuthorPage.ts la crear\u00e9 en su propio model dentro de author/model . SortPage.ts Pageable.ts AuthorPage.ts export class SortPage { property : String ; direction : String ; } import { SortPage } from './SortPage' ; export class Pageable { pageNumber : number ; pageSize : number ; sort : SortPage []; } import { Pageable } from \"src/app/core/model/page/Pageable\" ; import { Author } from \"./Author\" ; export class AuthorPage { content : Author []; pageable : Pageable ; totalElements : number ; } Con estos objetos creados ya podemos implementar el servicio y sus datos mockeados. mock-authors.ts author.service.ts import { AuthorPage } from \"./AuthorPage\" ; export const AUTHOR_DATA : AuthorPage = { content : [ { id : 1 , name : 'Klaus Teuber' , nationality : 'Alemania' }, { id : 2 , name : 'Matt Leacock' , nationality : 'Estados Unidos' }, { id : 3 , name : 'Keng Leong Yeo' , nationality : 'Singapur' }, { id : 4 , name : 'Gil Hova' , nationality : 'Estados Unidos' }, { id : 5 , name : 'Kelly Adams' , nationality : 'Estados Unidos' }, { id : 6 , name : 'J. Alex Kavern' , nationality : 'Estados Unidos' }, { id : 7 , name : 'Corey Young' , nationality : 'Estados Unidos' }, ], pageable : { pageSize : 5 , pageNumber : 0 , sort : [ { property : \"id\" , direction : \"ASC\" } ] }, totalElements : 7 } import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Pageable } from '../core/model/page/Pageable' ; import { Author } from './model/Author' ; import { AuthorPage } from './model/AuthorPage' ; import { AUTHOR_DATA } from './model/mock-authors' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor () { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return of ( AUTHOR_DATA ); } saveAuthor ( author : Author ) : Observable < void > { return of ( null ); } deleteAuthor ( idAuthor : number ) : Observable < void > { return of ( null ); } }","title":"Implementar servicio"},{"location":"develop/step4/#implementar-listado","text":"Ya tenemos el servicio con los datos, ahora vamos a por el listado paginado. author-list.component.html author-list.component.scss author-list.component.ts < div class = \"container\" > < h1 > Listado de Autores </ h1 > < mat-table [ dataSource ]=\" dataSource \" > < ng-container matColumnDef = \"id\" > < mat-header-cell * matHeaderCellDef > Identificador </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.id}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"name\" > < mat-header-cell * matHeaderCellDef > Nombre autor </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.name}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"nationality\" > < mat-header-cell * matHeaderCellDef > Nacionalidad </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.nationality}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" > < mat-icon ( click )=\" editAuthor ( element )\" > edit </ mat-icon > </ button > < button mat-icon-button color = \"accent\" > < mat-icon ( click )=\" deleteAuthor ( element )\" > clear </ mat-icon > </ button > </ mat-cell > </ ng-container > < mat-header-row * matHeaderRowDef = \"displayedColumns; sticky: true\" ></ mat-header-row > < mat-row * matRowDef = \"let row; columns: displayedColumns;\" ></ mat-row > </ mat-table > < mat-paginator ( page )=\" loadPage ($ event )\" [ pageSizeOptions ]=\"[ 5 , 10 , 20 ]\" [ pageIndex ]=\" pageNumber \" [ pageSize ]=\" pageSize \" [ length ]=\" totalElements \" showFirstLastButtons ></ mat-paginator > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createAuthor ()\" > Nuevo autor </ button > </ div > </ div > . container { margin : 20 px ; mat-table { margin-top : 10 px ; margin-bottom : 20 px ; .mat-header-row { background-color : #f5f5f5 ; .mat-header-cell { text-transform : uppercase ; font-weight : bold ; color : #838383 ; } } . mat-column-id { flex : 0 0 20 % ; justify-content : center ; } . mat-column-action { flex : 0 0 10 % ; justify-content : center ; } } . buttons { text-align : right ; } } import { Component , OnInit } from '@angular/core' ; import { MatDialog } from '@angular/material/dialog' ; import { PageEvent } from '@angular/material/paginator' ; import { MatTableDataSource } from '@angular/material/table' ; import { DialogConfirmationComponent } from 'src/app/core/dialog-confirmation/dialog-confirmation.component' ; import { Pageable } from 'src/app/core/model/page/Pageable' ; import { AuthorEditComponent } from '../author-edit/author-edit.component' ; import { AuthorService } from '../author.service' ; import { Author } from '../model/Author' ; @Component ({ selector : 'app-author-list' , templateUrl : './author-list.component.html' , styleUrls : [ './author-list.component.scss' ] }) export class AuthorListComponent implements OnInit { pageNumber : number = 0 ; pageSize : number = 5 ; totalElements : number = 0 ; dataSource = new MatTableDataSource < Author > (); displayedColumns : string [] = [ 'id' , 'name' , 'nationality' , 'action' ]; constructor ( private authorService : AuthorService , public dialog : MatDialog , ) { } ngOnInit () : void { this . loadPage (); } loadPage ( event? : PageEvent ) { let pageable : Pageable = { pageNumber : this.pageNumber , pageSize : this.pageSize , sort : [{ property : 'id' , direction : 'ASC' }] } if ( event != null ) { pageable . pageSize = event . pageSize pageable . pageNumber = event . pageIndex ; } this . authorService . getAuthors ( pageable ). subscribe ( data => { this . dataSource . data = data . content ; this . pageNumber = data . pageable . pageNumber ; this . pageSize = data . pageable . pageSize ; this . totalElements = data . totalElements ; }); } createAuthor () { const dialogRef = this . dialog . open ( AuthorEditComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } editAuthor ( author : Author ) { const dialogRef = this . dialog . open ( AuthorEditComponent , { data : { author : author } }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } deleteAuthor ( author : Author ) { const dialogRef = this . dialog . open ( DialogConfirmationComponent , { data : { title : \"Eliminar autor\" , description : \"Atenci\u00f3n si borra el autor se perder\u00e1n sus datos.<br> \u00bfDesea eliminar el autor?\" } }); dialogRef . afterClosed (). subscribe ( result => { if ( result ) { this . authorService . deleteAuthor ( author . id ). subscribe ( result => { this . ngOnInit (); }); } }); } } F\u00edjate como hemos a\u00f1adido la paginaci\u00f3n. Al HTML le hemos a\u00f1adido un componente nuevo mat-paginator , lo que nos va a obligar a a\u00f1adirlo al m\u00f3dulo tambi\u00e9n como dependencia. Ese componente le hemos definido un m\u00e9todo page que se ejecuta cada vez que la p\u00e1gina cambia, y unas propiedades con las que calcular\u00e1 la p\u00e1gina, el tama\u00f1o y el n\u00famero total de p\u00e1ginas. Al Typescript le hemos tenido que a\u00f1adir esas variables y hemos creado un m\u00e9todo para cargar datos que lo que hace es construir un objeto pageable con los valores actuales del componente paginador y lanza la petici\u00f3n con esos datos en el body. Obviamente al ser un mock no funcionar\u00e1 el cambio de p\u00e1gina y dem\u00e1s. Como siempre, a\u00f1adimos las dependencias al m\u00f3dulo, vamos a intentar a\u00f1adir todas las que vamos a necesitar a futuro. author.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { AuthorListComponent } from './author-list/author-list.component' ; import { AuthorEditComponent } from './author-edit/author-edit.component' ; import { MatTableModule } from '@angular/material/table' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; import { MatButtonModule } from '@angular/material/button' ; import { MatDialogModule , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatIconModule } from '@angular/material/icon' ; import { MatInputModule } from '@angular/material/input' ; import { MatPaginatorModule } from '@angular/material/paginator' ; @NgModule ({ declarations : [ AuthorListComponent , AuthorEditComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule , MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , MatPaginatorModule , ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class AuthorModule { } Deber\u00eda verse algo similar a esto:","title":"Implementar listado"},{"location":"develop/step4/#implementar-dialogo-edicion","text":"El \u00faltimo paso, es definir la pantalla de dialogo que realizar\u00e1 el alta y modificado de los datos de un Autor . author-edit.component.html author-edit.component.scss author-edit.component.ts < div class = \"container\" > < h1 * ngIf = \"author.id == null\" > Crear autor </ h1 > < h1 * ngIf = \"author.id != null\" > Modificar autor </ h1 > < form > < mat-form-field > < mat-label > Identificador </ mat-label > < input type = \"number\" matInput placeholder = \"Identificador\" [( ngModel )]=\" author . id \" name = \"id\" disabled > </ mat-form-field > < mat-form-field > < mat-label > Nombre </ mat-label > < input type = \"text\" matInput placeholder = \"Nombre del autor\" [( ngModel )]=\" author . name \" name = \"name\" required > < mat-error > El nombre no puede estar vac\u00edo </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Nacionalidad </ mat-label > < input type = \"text\" matInput placeholder = \"Nacionalidad del autor\" [( ngModel )]=\" author . nationality \" name = \"nationality\" required > < mat-error > La nacionalidad no puede estar vac\u00eda </ mat-error > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onClose ()\" > Cerrar </ button > < button mat-flat-button color = \"primary\" ( click )=\" onSave ()\" > Guardar </ button > </ div > </ div > . container { min-width : 350 px ; max-width : 500 px ; width : 100 % ; form { display : flex ; flex-direction : column ; margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } import { Component , Inject , OnInit } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { AuthorService } from '../author.service' ; import { Author } from '../model/Author' ; @Component ({ selector : 'app-author-edit' , templateUrl : './author-edit.component.html' , styleUrls : [ './author-edit.component.scss' ] }) export class AuthorEditComponent implements OnInit { author : Author ; constructor ( public dialogRef : MatDialogRef < AuthorEditComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any , private authorService : AuthorService ) { } ngOnInit () : void { if ( this . data . author != null ) { this . author = Object . assign ({}, this . data . author ); } else { this . author = new Author (); } } onSave () { this . authorService . saveAuthor ( this . author ). subscribe ( result => { this . dialogRef . close (); }); } onClose () { this . dialogRef . close (); } } Que deber\u00eda quedar algo as\u00ed:","title":"Implementar dialogo edici\u00f3n"},{"location":"develop/step4/#desarrollo-springboot","text":"","title":"Desarrollo Springboot"},{"location":"develop/step4/#modelos","text":"Lo primero que vamos a hacer es crear los modelos para trabajar con BBDD y con peticiones hacia el front. Adem\u00e1s, tambi\u00e9n tenemos que a\u00f1adir datos al script de inicializaci\u00f3n de BBDD. schema.sql data.sql Author.java AuthorDto.java DROP TABLE IF EXISTS CATEGORY ; CREATE TABLE CATEGORY ( id BIGINT IDENTITY NOT NULL PRIMARY KEY , name VARCHAR ( 250 ) NOT NULL ); DROP TABLE IF EXISTS AUTHOR ; CREATE TABLE AUTHOR ( id BIGINT IDENTITY NOT NULL PRIMARY KEY , name VARCHAR ( 400 ) NOT NULL , nationality VARCHAR ( 250 ) NOT NULL ); INSERT INTO CATEGORY ( id , name ) VALUES ( 1 , 'Eurogames' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 2 , 'Ameritrash' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 3 , 'Familiar' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 1 , 'Alan R. Moon' , 'US' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 2 , 'Vital Lacerda' , 'PT' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 3 , 'Simone Luciani' , 'IT' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 4 , 'Perepau Llistosella' , 'ES' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 5 , 'Michael Kiesling' , 'DE' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 6 , 'Phil Walker-Harding' , 'US' ); package com.capgemini.ccsw.tutorial.author.model ; import javax.persistence.Column ; import javax.persistence.Entity ; import javax.persistence.GeneratedValue ; import javax.persistence.GenerationType ; import javax.persistence.Id ; import javax.persistence.Table ; /** * @author ccsw */ @Entity @Table ( name = \"Author\" ) public class Author { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"name\" , nullable = false ) private String name ; @Column ( name = \"nationality\" ) private String nationality ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getid}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getname}. */ public void setName ( String name ) { this . name = name ; } /** * @return nationality */ public String getNationality () { return this . nationality ; } /** * @param nationality new value of {@link #getnationality}. */ public void setNationality ( String nationality ) { this . nationality = nationality ; } } package com.capgemini.ccsw.tutorial.author.model ; /** * @author ccsw */ public class AuthorDto { private Long id ; private String name ; private String nationality ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getid}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getname}. */ public void setName ( String name ) { this . name = name ; } /** * @return nationality */ public String getNationality () { return this . nationality ; } /** * @param nationality new value of {@link #getnationality}. */ public void setNationality ( String nationality ) { this . nationality = nationality ; } }","title":"Modelos"},{"location":"develop/step4/#tdd-pruebas","text":"Para desarrollar todas las operaciones, empezaremos primero dise\u00f1ando las pruebas y luego implementando el c\u00f3digo necesario que haga funcionar correctamente esas pruebas. Para ir m\u00e1s r\u00e1pido vamos a poner todas las pruebas de golpe, pero realmente se deber\u00edan crear una a una e ir implementando el c\u00f3digo necesario para esa prueba. Para evitar tantas iteraciones en el tutorial las haremos todas de golpe. Vamos a pararnos a pensar un poco que necesitamos en la pantalla. Ahora mismo nos sirve con: Una consulta paginada, que reciba datos de la p\u00e1gina a consultar y devuelva los datos paginados Una operaci\u00f3n de guardado y modificaci\u00f3n Una operaci\u00f3n de borrado Para la primera prueba necesitaremos que hemos descrito (consulta paginada) se necesita un objeto que contenga los datos de la p\u00e1gina a consultar. As\u00ed que crearemos una clase AuthorSearchDto para utilizarlo como 'paginador'. Paginaci\u00f3n en Springframework Cuando utilicemos paginaci\u00f3n en Springframework, debemos recordar que ya vienen implementados algunos objetos que podemos utilizar y que nos facilitan la vida. Es el caso de Pageable y Page . El objeto Pageable no es m\u00e1s que una interface que le permite a Spring JPA saber que p\u00e1gina se quiere buscar, cual es el tama\u00f1o de p\u00e1gina y cuales son las propiedades de ordenaci\u00f3n que se debe lanzar en la consulta. El objeto PageRequest es una utilidad que permite crear objetos de tipo Pageable de forma sencilla. Se utiliza mucho para codificaci\u00f3n de test. El objeto Page no es m\u00e1s que un contenedor que engloba la informaci\u00f3n b\u00e1sica de la p\u00e1gina que se est\u00e1 consultando (n\u00famero de p\u00e1gina, tama\u00f1o de p\u00e1gina, n\u00famero total de resultados) y el conjunto de datos de la BBDD que contiene esa p\u00e1gina una vez han sido buscados y ordenados. Tambi\u00e9n crearemos una clase AuthorController dentro del package de com.capgemini.ccsw.tutorial.author con la implementaci\u00f3n de los m\u00e9todos vac\u00edos, para que no falle la compilaci\u00f3n. \u00a1Vamos a implementar test! AuthorSearchDto.java AuthorController.java AuthorTest.java package com.capgemini.ccsw.tutorial.author.model ; import org.springframework.data.domain.Pageable ; /** * @author ccsw */ public class AuthorSearchDto { private Pageable pageable ; /** * @return pageable */ public Pageable getPageable () { return this . pageable ; } /** * @param pageable new value of {@link #getPageable}. */ public void setPageable ( Pageable pageable ) { this . pageable = pageable ; } } package com.capgemini.ccsw.tutorial.author ; import org.springframework.data.domain.Page ; import com.capgemini.ccsw.tutorial.author.model.AuthorDto ; import com.capgemini.ccsw.tutorial.author.model.AuthorSearchDto ; /** * @author ccsw */ public class AuthorController { /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param dto * @return */ public Page < AuthorDto > findPage ( AuthorSearchDto dto ) { return null ; } /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param id * @param data datos de la entidad */ public void save ( Long id , AuthorDto data ) { } /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param id PK de la entidad */ public void delete ( Long id ) { } } package com.capgemini.ccsw.tutorial.author ; import static org.junit.jupiter.api.Assertions.assertEquals ; import static org.junit.jupiter.api.Assertions.assertNotNull ; import static org.junit.jupiter.api.Assertions.assertThrows ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.PageRequest ; import org.springframework.transaction.annotation.Transactional ; import com.capgemini.ccsw.tutorial.author.model.AuthorDto ; import com.capgemini.ccsw.tutorial.author.model.AuthorSearchDto ; @SpringBootTest @Transactional public class AuthorTest { private static final int TOTAL_AUTORS = 6 ; @Autowired private AuthorController authorController ; @Test public void findFirstPageWithFiveSizeShouldReturnFirstFiveResults () { int pageSize = 5 ; assertNotNull ( authorController ); AuthorSearchDto dto = new AuthorSearchDto (); dto . setPageable ( PageRequest . of ( 0 , pageSize )); Page < AuthorDto > resultPage = authorController . findPage ( dto ); assertNotNull ( resultPage ); assertEquals ( TOTAL_AUTORS , resultPage . getTotalElements ()); assertEquals ( pageSize , resultPage . getContent (). size ()); } @Test public void findSecondPageWithFiveSizeShouldReturnLastResult () { int pageSize = 5 ; int elementsCount = TOTAL_AUTORS - pageSize ; assertNotNull ( authorController ); AuthorSearchDto searchDto = new AuthorSearchDto (); searchDto . setPageable ( PageRequest . of ( 1 , pageSize )); Page < AuthorDto > resultPage = authorController . findPage ( searchDto ); assertNotNull ( resultPage ); assertEquals ( TOTAL_AUTORS , resultPage . getTotalElements ()); assertEquals ( elementsCount , resultPage . getContent (). size ()); } @Test public void saveWithoutIdShouldCreateNewAuthor () { assertNotNull ( authorController ); String newAuthorName = \"Nuevo Autor\" ; String newNationality = \"Nueva Nacionalidad\" ; long newAuthorId = TOTAL_AUTORS + 1 ; long newAuthorSize = TOTAL_AUTORS + 1 ; AuthorDto dto = new AuthorDto (); dto . setName ( newAuthorName ); dto . setNationality ( newNationality ); authorController . save ( null , dto ); AuthorSearchDto searchDto = new AuthorSearchDto (); searchDto . setPageable ( PageRequest . of ( 0 , ( int ) newAuthorSize )); Page < AuthorDto > resultPage = authorController . findPage ( searchDto ); assertNotNull ( resultPage ); assertEquals ( newAuthorSize , resultPage . getTotalElements ()); AuthorDto author = resultPage . getContent (). stream (). filter ( item -> item . getId (). equals ( newAuthorId )). findFirst (). orElse ( null ); assertNotNull ( author ); assertEquals ( newAuthorName , author . getName ()); } @Test public void modifyWithExistIdShouldModifyAuthor () { assertNotNull ( authorController ); String newAuthorName = \"Nuevo Autor\" ; String newNationality = \"Nueva Nacionalidad\" ; long authorId = 3 ; AuthorDto dto = new AuthorDto (); dto . setName ( newAuthorName ); dto . setNationality ( newNationality ); authorController . save ( authorId , dto ); AuthorSearchDto searchDto = new AuthorSearchDto (); searchDto . setPageable ( PageRequest . of ( 0 , ( int ) authorId )); Page < AuthorDto > resultPage = authorController . findPage ( searchDto ); assertNotNull ( resultPage ); assertEquals ( TOTAL_AUTORS , resultPage . getTotalElements ()); AuthorDto author = resultPage . getContent (). stream (). filter ( item -> item . getId (). equals ( authorId )). findFirst (). orElse ( null ); assertNotNull ( author ); assertEquals ( newAuthorName , author . getName ()); assertEquals ( newNationality , author . getNationality ()); } @Test public void modifyWithNotExistIdShouldThrowException () { assertNotNull ( authorController ); String newAuthorName = \"Nuevo Autor\" ; long authorId = TOTAL_AUTORS + 1 ; AuthorDto dto = new AuthorDto (); dto . setName ( newAuthorName ); assertThrows ( Exception . class , () -> authorController . save ( authorId , dto )); } @Test public void deleteWithExistsIdShouldDeleteCategory () { assertNotNull ( authorController ); long newAuthorsSize = TOTAL_AUTORS - 1 ; long deleteAuthorId = 6 ; authorController . delete ( deleteAuthorId ); AuthorSearchDto searchDto = new AuthorSearchDto (); searchDto . setPageable ( PageRequest . of ( 0 , TOTAL_AUTORS )); Page < AuthorDto > resultPage = authorController . findPage ( searchDto ); assertNotNull ( resultPage ); assertEquals ( newAuthorsSize , resultPage . getTotalElements ()); } @Test public void deleteWithNotExistsIdShouldThrowException () { assertNotNull ( authorController ); long deleteAuthorId = TOTAL_AUTORS + 1 ; assertThrows ( Exception . class , () -> authorController . delete ( deleteAuthorId )); } } Cuidado con las clases de Test Recuerda que el c\u00f3digo de aplicaci\u00f3n debe ir en src/main/java , mientras que las clases de test deben ir en src/test/java para que no se mezclen unas con otras y se empaquete todo en el artefacto final. En este caso AuthorTest.java va en el directorio de test src/test/java . Si ejecutamos los test, el resultado ser\u00e1 7 maravillosos test que fallan su ejecuci\u00f3n. Es normal, puesto que no hemos implementado nada de c\u00f3digo de aplicaci\u00f3n para corresponder esos test.","title":"TDD - Pruebas"},{"location":"develop/step4/#controller","text":"Si recuerdas, esta capa de Controller es la que tiene los endpoints de entrada a la aplicaci\u00f3n. Nosotros ya tenemos definidas 3 operaciones, que hemos dise\u00f1ado directamente desde los tests. Ahora vamos a implementar esos m\u00e9todos con el c\u00f3digo necesario para que los test funcionen correctamente, y teniendo en mente que debemos apoyarnos en las capas inferiores Service y Repository para repartir l\u00f3gica de negocio y acceso a datos. AuthorController.java AuthorService.java package com.capgemini.ccsw.tutorial.author ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.ccsw.tutorial.author.model.AuthorDto ; import com.capgemini.ccsw.tutorial.author.model.AuthorSearchDto ; import com.capgemini.ccsw.tutorial.config.mapper.BeanMapper ; /** * @author ccsw */ @RequestMapping ( value = \"/author\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class AuthorController { @Autowired AuthorService authorService ; @Autowired BeanMapper beanMapper ; /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param dto * @return */ @RequestMapping ( path = \"\" , method = RequestMethod . POST ) public Page < AuthorDto > findPage ( @RequestBody AuthorSearchDto dto ) { return this . beanMapper . mapPage ( this . authorService . findPage ( dto ), AuthorDto . class ); } /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param id * @param data datos de la entidad */ @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody AuthorDto data ) { this . authorService . save ( id , data ); } /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param id PK de la entidad */ @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . authorService . delete ( id ); } } package com.capgemini.ccsw.tutorial.author ; import org.springframework.data.domain.Page ; import com.capgemini.ccsw.tutorial.author.model.Author ; import com.capgemini.ccsw.tutorial.author.model.AuthorDto ; import com.capgemini.ccsw.tutorial.author.model.AuthorSearchDto ; /** * @author ccsw */ public interface AuthorService { /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param dto * @return */ Page < Author > findPage ( AuthorSearchDto dto ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param id * @param data */ void save ( Long id , AuthorDto data ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param id */ void delete ( Long id ); } Si te fijas, hemos trasladado toda la l\u00f3gica a llamadas al AuthorService que hemos inyectado, y para que no falle la compilaci\u00f3n hemos creado una interface con los m\u00e9todos necesarios. En la clase AuthorController es donde se hacen las conversiones de cara al cliente, pasaremos de un Page<Author> (modelo entidad) a un Page<AuthorDto> (modelo DTO) con la ayuda del beanMapper. Recuerda que al cliente no le deben llegar modelos entidades sino DTOs. Adem\u00e1s, el m\u00e9todo de carga findPage ya no es un m\u00e9todo de tipo GET , ahora es de tipo POST porque le tenemos que enviar los datos de la paginaci\u00f3n para que Spring JPA pueda hacer su magia. Ahora debemos implementar la siguiente capa.","title":"Controller"},{"location":"develop/step4/#service","text":"La siguiente capa que vamos a implementar es justamente la capa que contiene toda la l\u00f3gica de negocio, hace uso del Repository para acceder a los datos, y recibe llamadas generalmente de los Controller . AuthorServiceImpl.java AuthorRepository.java package com.capgemini.ccsw.tutorial.author ; import javax.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.stereotype.Service ; import com.capgemini.ccsw.tutorial.author.model.Author ; import com.capgemini.ccsw.tutorial.author.model.AuthorDto ; import com.capgemini.ccsw.tutorial.author.model.AuthorSearchDto ; /** * @author ccsw */ @Service @Transactional public class AuthorServiceImpl implements AuthorService { @Autowired AuthorRepository authorRepository ; /** * {@inheritDoc} */ @Override public Page < Author > findPage ( AuthorSearchDto dto ) { return this . authorRepository . findAll ( dto . getPageable ()); } /** * {@inheritDoc} */ @Override public void save ( Long id , AuthorDto data ) { Author author = null ; if ( id != null ) author = this . authorRepository . findById ( id ). orElse ( null ); else author = new Author (); BeanUtils . copyProperties ( data , author , \"id\" ); this . authorRepository . save ( author ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) { this . authorRepository . deleteById ( id ); } } package com.capgemini.ccsw.tutorial.author ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.Pageable ; import org.springframework.data.repository.CrudRepository ; import com.capgemini.ccsw.tutorial.author.model.Author ; /** * @author ccsw */ public interface AuthorRepository extends CrudRepository < Author , Long > { /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param page * @return */ Page < Author > findAll ( Pageable pageable ); } De nuevo pasa lo mismo que con la capa anterior, aqu\u00ed delegamos muchas operaciones de consulta y guardado de datos en AuthorRepository . Hemos tenido que crearlo como interface para que no falle la compilaci\u00f3n. Recuerda que cuando creamos un Repository es de gran ayuda hacerlo extender de CrudRepository<T, ID> ya que tiene muchos m\u00e9todos implementados de base que nos pueden servir, como el delete o el save . F\u00edjate tambi\u00e9n que cuando queremos copiar m\u00e1s de un dato de una clase a otra, tenemos una utilidad llamada BeanUtils que nos permite realizar esa copia (siempre que las propiedades de ambas clases se llamen igual). Adem\u00e1s, en nuestro ejemplo hemos ignorado el 'id' para que no nos copie un null a la clase destino.","title":"Service"},{"location":"develop/step4/#repository","text":"Y llegamos a la \u00faltima capa, la que est\u00e1 m\u00e1s cerca de los datos finales. Tenemos la siguiente interface: AuthorRepository.java package com.capgemini.ccsw.tutorial.author ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.Pageable ; import org.springframework.data.repository.CrudRepository ; import com.capgemini.ccsw.tutorial.author.model.Author ; /** * @author ccsw */ public interface AuthorRepository extends CrudRepository < Author , Long > { /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param page * @return */ Page < Author > findAll ( Pageable pageable ); } Si te fijas, este Repository ya no est\u00e1 vac\u00edo como el anterior, no nos sirve con las operaciones b\u00e1sicas del CrudRepository en este caso hemos tenido que a\u00f1adir un m\u00e9todo nuevo al que pasandole un objeto de tipo Pageable nos devuelva una Page . Pues bien, resulta que la m\u00e1gina de Spring JPA en este caso har\u00e1 su trabajo y nosotros no necesitamos implementar ninguna query, Spring ya entiende que un findAll significa que debe recuperar todos los datos de la tabla Author (que es la tabla que tiene como generico en CrudRepository ) y adem\u00e1s deben estar paginados ya que el m\u00e9todo devuelve un objeto tipo Page . Nos ahorra tener que generar una sql para buscar una p\u00e1gina concreta de datos y hacer un count de la tabla para obtener el total de resultados. Para ver otros ejemplos y m\u00e1s informaci\u00f3n, visita la p\u00e1gina de QueryMethods . Realmente se puede hacer much\u00edsimas cosas con solo escribir el nombre del m\u00e9todo, sin tener que pensar ni teclear ninguna sql. Con esto ya lo tendr\u00edamos todo.","title":"Repository"},{"location":"develop/step4/#prueba-de-las-operaciones","text":"Si ahora ejecutamos los test jUnit, veremos que todos funcionan y est\u00e1n en verde. Hemos implementado todas nuestras pruebas y la aplicaci\u00f3n es correcta. Aun as\u00ed, debemos realizar pruebas con el postman para ver los resultados que nos ofrece el back. Para ello, tienes que levantar la aplici\u00f3n y ejecutar las siguientes operaciones: POST /author { \"pageable\": { \"pageSize\" : 4, \"pageNumber\" : 0, \"sort\" : [ { \"property\": \"name\", \"direction\": \"ASC\" } ] } } Nos devuelve un listado paginado de Autores . F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no env\u00edas datos con formato Pageable , te dar\u00e1 un error. Tambi\u00e9n f\u00edjate que la respuesta es de tipo Page . Prueba a jugar con los datos de paginaci\u00f3n e incluso de ordenaci\u00f3n. No hemos programado ninguna SQL pero Spring hace su magia. PUT /author PUT /author/{id} { \"name\" : \"Nuevo autor\", \"nationality\" : \"Nueva nacionalidad\" } Nos sirve para insertar Autores nuevas (si no tienen el id informado) o para actualizar Autores (si tienen el id informado en la URL). F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no te dar\u00e1 un error. DELETE /author/{id} nos sirve eliminar Autores . F\u00edjate que el dato del ID que se env\u00eda est\u00e1 en el path.","title":"Prueba de las operaciones"},{"location":"develop/step4/#conectar-front-con-back","text":"Una vez implementado front y back, lo que nos queda es modificar el servicio del front para que conecte directamente con las operaciones ofrecidas por el back. author.service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Pageable } from '../core/model/page/Pageable' ; import { Author } from './model/Author' ; import { AuthorPage } from './model/AuthorPage' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor ( private http : HttpClient ) { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return this . http . post < AuthorPage > ( 'http://localhost:8080/author' , { pageable : pageable }); } saveAuthor ( author : Author ) : Observable < void > { let url = 'http://localhost:8080/author' ; if ( author . id != null ) url += '/' + author . id ; return this . http . put < void > ( url , author ); } deleteAuthor ( idAuthor : number ) : Observable < void > { return this . http . delete < void > ( 'http://localhost:8080/author/' + idAuthor ); } }","title":"Conectar front con back"},{"location":"develop/step5/","text":"Desarrollo de un listado filtrado En este punto ya tenemos dos listados, uno b\u00e1sico y otro paginado. Ahora vamos a implementar un listado un poco diferente, con filtros y con una presentaci\u00f3n un tanto distinta. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades. Desarrollo Angular Crear componentes Vamos a desarrollar el listado de Juegos . Este listado es un tanto peculiar, porque no tiene una tabla como tal, sino que tiene una tabla con \"tiles\" para cada uno de los juegos. Necesitaremos un componente para el listado y otro componente para el detalle del juego. Tambi\u00e9n necesitaremos otro componente para el dialogo de edici\u00f3n / alta. Manos a la obra: ng generate module game ng generate component game/game-list ng generate component game/game-list/game-item ng generate component game/game-edit ng generate service game/game Y a\u00f1adimos el nuevo m\u00f3dulo al app.module.ts como hemos hecho con el resto de m\u00f3dulos. Game.ts import { NgModule } from '@angular/core' ; import { BrowserModule } from '@angular/platform-browser' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { BrowserAnimationsModule } from '@angular/platform-browser/animations' ; import { CoreModule } from './core/core.module' ; import { CategoryModule } from './category/category.module' ; import { AuthorModule } from './author/author.module' ; import { GameModule } from './game/game.module' ; @NgModule ({ declarations : [ AppComponent ], imports : [ BrowserModule , AppRoutingModule , CoreModule , CategoryModule , AuthorModule , GameModule , BrowserAnimationsModule ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { } Crear el modelo Lo primero que vamos a hacer es crear el modelo en game/model/Game.ts con todas las propiedades necesarias para trabajar con un juego: Game.ts import { Category } from \"src/app/category/model/Category\" ; import { Author } from \"src/app/author/model/Author\" ; export class Game { id : number ; title : string ; age : number ; category : Category ; author : Author ; } Como ves, el juego tiene dos objetos para mapear categor\u00eda y autor. A\u00f1adir el punto de entrada A\u00f1adimos la ruta al men\u00fa para que podamos navegar a esta pantalla: app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { AuthorListComponent } from './author/author-list/author-list.component' ; import { CategoryListComponent } from './category/category-list/category-list.component' ; import { GameListComponent } from './game/game-list/game-list.component' ; const routes : Routes = [ { path : '' , redirectTo : '/games' , pathMatch : 'full' }, { path : 'categories' , component : CategoryListComponent }, { path : 'authors' , component : AuthorListComponent }, { path : 'games' , component : GameListComponent }, ]; @NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } Adem\u00e1s, hemos a\u00f1adido una regla adicional con el path vac\u00edo para indicar que si no pone ruta, por defecto la p\u00e1gina inicial redirija al path /games , que es nuevo path que hemos a\u00f1adido. Implementar servicio A continuaci\u00f3n implementamos el servicio y mockeamos datos de ejemplo: mock-games.ts game.service.ts import { Game } from \"./Game\" ; export const GAME_DATA : Game [] = [ { id : 1 , title : 'Juego 1' , age : 6 , category : { id : 1 , name : 'Categor\u00eda 1' }, author : { id : 1 , name : 'Autor 1' , nationality : 'Nacionalidad 1' } }, { id : 2 , title : 'Juego 2' , age : 8 , category : { id : 1 , name : 'Categor\u00eda 1' }, author : { id : 2 , name : 'Autor 2' , nationality : 'Nacionalidad 2' } }, { id : 3 , title : 'Juego 3' , age : 4 , category : { id : 1 , name : 'Categor\u00eda 1' }, author : { id : 3 , name : 'Autor 3' , nationality : 'Nacionalidad 3' } }, { id : 4 , title : 'Juego 4' , age : 10 , category : { id : 2 , name : 'Categor\u00eda 2' }, author : { id : 1 , name : 'Autor 1' , nationality : 'Nacionalidad 1' } }, { id : 5 , title : 'Juego 5' , age : 16 , category : { id : 2 , name : 'Categor\u00eda 2' }, author : { id : 2 , name : 'Autor 2' , nationality : 'Nacionalidad 2' } }, { id : 6 , title : 'Juego 6' , age : 16 , category : { id : 2 , name : 'Categor\u00eda 2' }, author : { id : 3 , name : 'Autor 3' , nationality : 'Nacionalidad 3' } }, { id : 7 , title : 'Juego 7' , age : 12 , category : { id : 3 , name : 'Categor\u00eda 3' }, author : { id : 1 , name : 'Autor 1' , nationality : 'Nacionalidad 1' } }, { id : 8 , title : 'Juego 8' , age : 14 , category : { id : 3 , name : 'Categor\u00eda 3' }, author : { id : 2 , name : 'Autor 2' , nationality : 'Nacionalidad 2' } }, ] import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Game } from './model/Game' ; import { GAME_DATA } from './model/mock-games' ; @Injectable ({ providedIn : 'root' }) export class GameService { constructor () { } getGames ( title? : String , categoryId? : number ) : Observable < Game [] > { return of ( GAME_DATA ); } saveGame ( game : Game ) : Observable < void > { return of ( null ); } } Implementar listado Ya tenemos las operaciones del servicio con datoos, as\u00ed que ahora vamos a por el listado filtrado. game-list.component.html game-list.component.scss game-list.component.ts < div class = \"container\" > < h1 > Cat\u00e1logo de juegos </ h1 > < div class = \"filters\" > < form > < mat-form-field > < mat-label > T\u00edtulo del juego </ mat-label > < input type = \"text\" matInput placeholder = \"T\u00edtulo del juego\" [( ngModel )]=\" filterTitle \" name = \"title\" > </ mat-form-field > < mat-form-field > < mat-label > Categor\u00eda del juego </ mat-label > < mat-select disableRipple [( ngModel )]=\" filterCategory \" name = \"category\" > < mat-option * ngFor = \"let category of categories\" [ value ]=\" category \" > {{category.name}} </ mat-option > </ mat-select > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onCleanFilter ()\" > Limpiar </ button > < button mat-stroked-button ( click )=\" onSearch ()\" > Filtrar </ button > </ div > </ div > < div class = \"game-list\" > < app-game-item * ngFor = \"let game of games; let i = index;\" ( click )=\" editGame ( game )\" > </ app-game-item > </ div > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createGame ()\" > Nuevo juego </ button > </ div > </ div > . container { margin : 20 px ; .filters { display : flex ; mat-form-field { width : 300 px ; margin-right : 20 px ; } . buttons { flex : auto ; align-self : center ; button { margin-left : 15 px ; } } } . game-list { margin-top : 20 px ; margin-bottom : 20 px ; display : flex ; flex-flow : wrap ; overflow : auto ; } . buttons { text-align : right ; } } button { width : 125 px ; } import { Component , OnInit } from '@angular/core' ; import { MatDialog } from '@angular/material/dialog' ; import { CategoryService } from 'src/app/category/category.service' ; import { Category } from 'src/app/category/model/Category' ; import { GameEditComponent } from '../game-edit/game-edit.component' ; import { GameService } from '../game.service' ; import { Game } from '../model/Game' ; @Component ({ selector : 'app-game-list' , templateUrl : './game-list.component.html' , styleUrls : [ './game-list.component.scss' ] }) export class GameListComponent implements OnInit { categories : Category []; games : Game []; filterCategory : Category ; filterTitle : string ; constructor ( private gameService : GameService , private categoryService : CategoryService , public dialog : MatDialog , ) { } ngOnInit () : void { this . gameService . getGames (). subscribe ( games => this . games = games ); this . categoryService . getCategories (). subscribe ( categories => this . categories = categories ); } onCleanFilter () : void { this . filterTitle = null ; this . filterCategory = null ; this . onSearch (); } onSearch () : void { let title = this . filterTitle ; let categoryId = this . filterCategory != null ? this.filterCategory.id : null ; this . gameService . getGames ( title , categoryId ). subscribe ( games => this . games = games ); } createGame () { const dialogRef = this . dialog . open ( GameEditComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } editGame ( game : Game ) { const dialogRef = this . dialog . open ( GameEditComponent , { data : { game : game } }); dialogRef . afterClosed (). subscribe ( result => { this . onSearch (); }); } } Recuerda, de nuevo, que todos los componentes de Angular que utilicemos hay que importarlos en el m\u00f3dulo padre correspondiente para que se puedan precargar correctamente. game.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { GameListComponent } from './game-list/game-list.component' ; import { GameEditComponent } from './game-edit/game-edit.component' ; import { GameItemComponent } from './game-list/game-item/game-item.component' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; import { MatButtonModule } from '@angular/material/button' ; import { MatOptionModule } from '@angular/material/core' ; import { MatDialogModule } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatIconModule } from '@angular/material/icon' ; import { MatInputModule } from '@angular/material/input' ; import { MatPaginatorModule } from '@angular/material/paginator' ; import { MatSelectModule } from '@angular/material/select' ; import { MatTableModule } from '@angular/material/table' ; import { MatCardModule } from '@angular/material/card' ; @NgModule ({ declarations : [ GameListComponent , GameEditComponent , GameItemComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule , MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , MatPaginatorModule , MatOptionModule , MatSelectModule , MatCardModule , ] }) export class GameModule { } Con todos estos cambios y si refrescamos el navegador, deber\u00eda verse una pantalla similar a esta: Tenemos una pantalla con una secci\u00f3n de filtros en la parte superior, donde podemos introducir un texto o seleccionar una categor\u00eda de un dropdown, un listado que de momento tiene todos los componentes b\u00e1sicos en una fila uno detr\u00e1s del otro, y un bot\u00f3n para crear juegos nuevos. Dropdown El componente Dropdown es uno de los componentes m\u00e1s utilizados en las pantallas y formularios de Angular. Ves familiariz\u00e1ndote con \u00e9l porque lo vas a usar mucho. Es bastante potente y medianamente sencillo de utilizar. Los datos del listado pueden ser din\u00e1micos (desde servidor) o est\u00e1ticos (si los valores ya los tienes prefijados). Implementar detalle del item Ahora vamos a implementar el detalle de cada uno de los items que forman el listado. Para ello lo primero que haremos ser\u00e1 pasarle la informaci\u00f3n del juego a cada componente como un dato de entrada Input hacia el componente. games.component.html < div class = \"container\" > < h1 > Cat\u00e1logo de juegos </ h1 > < div class = \"filters\" > < form > < mat-form-field > < mat-label > T\u00edtulo del juego </ mat-label > < input type = \"text\" matInput placeholder = \"T\u00edtulo del juego\" [( ngModel )]=\" filterName \" name = \"title\" > </ mat-form-field > < mat-form-field > < mat-label > Categor\u00eda del juego </ mat-label > < mat-select disableRipple [( ngModel )]=\" filterCategory \" name = \"category\" > < mat-option * ngFor = \"let category of categories\" [ value ]=\" category \" > {{category.name}} </ mat-option > </ mat-select > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onCleanFilter ()\" > Limpiar </ button > < button mat-stroked-button ( click )=\" onSearch ()\" > Filtrar </ button > </ div > </ div > < div class = \"game-list\" > < app-game-item * ngFor = \"let game of games; let i = index;\" ( click )=\" editGame ( game )\" [ game ]=\" game \" > </ app-game-item > </ div > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createGame ()\" > Nuevo juego </ button > </ div > </ div > Tambi\u00e9n vamos a necesitar una foto de ejemplo para poner dentro de la tarjeta detalle de los juegos. Vamos a utilizar esta imagen: Desc\u00e1rgala y d\u00e9jala dentro del proyecto en assets/foto.png . Y ya para terminar, implementamos el componente de detalle: game-item.component.html game-item.component.scss game-item.component.ts < div class = \"container\" > < mat-card > < div class = \"photo\" > < img src = \"./assets/foto.png\" > </ div > < div class = \"detail\" > < div class = \"title\" > {{game.title}} </ div > < div class = \"properties\" > < div >< i > Edad recomendada: </ i > +{{game.age}} </ div > < div >< i > Categor\u00eda: </ i > {{game.category.name}} </ div > < div >< i > Autor: </ i > {{game.author.name}} </ div > < div >< i > Nacionalidad: </ i > {{game.author.nationality}} </ div > </ div > </ div > </ mat-card > </ div > . container { display : flex ; width : 325 px ; mat-card { width : 100 % ; margin : 10 px ; display : flex ; .photo { margin-right : 10 px ; img { width : 80 px ; height : 80 px ; } } . detail { .title { font-size : 14 px ; font-weight : bold ; } . properties { font-size : 11 px ; div { height : 15 px ; } } } } } import { Component , OnInit , Input } from '@angular/core' ; import { Game } from '../../model/Game' ; @Component ({ selector : 'app-game-item' , templateUrl : './game-item.component.html' , styleUrls : [ './game-item.component.scss' ] }) export class GameItemComponent implements OnInit { @Input () game : Game ; constructor () { } ngOnInit () : void { } } Ahora si que deber\u00eda quedar algo similar a esta pantalla: Implementar dialogo de edici\u00f3n Ya solo nos falta el \u00faltimo paso, implementar el cuadro de edici\u00f3n / alta de un nuevo juego. Pero tenemos un peque\u00f1o problema, y es que al crear o editar un juego debemos seleccionar una Categor\u00eda y un Autor . Para la Categor\u00eda no tenemos ning\u00fan problema, pero para el Autor no tenemos un servicio que nos devuelva todos los autores, solo tenemos un servicio que nos devuelve una Page de autores. As\u00ed que lo primero que haremos ser\u00e1 implementar una operaci\u00f3n getAllAuthors para poder recuperar una lista. mock-authors-list.ts author.service.ts import { Author } from \"./Author\" ; export const AUTHOR_DATA_LIST : Author [] = [ { id : 1 , name : 'Klaus Teuber' , nationality : 'Alemania' }, { id : 2 , name : 'Matt Leacock' , nationality : 'Estados Unidos' }, { id : 3 , name : 'Keng Leong Yeo' , nationality : 'Singapur' }, { id : 4 , name : 'Gil Hova' , nationality : 'Estados Unidos' }, { id : 5 , name : 'Kelly Adams' , nationality : 'Estados Unidos' }, ] import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Pageable } from '../core/model/page/Pageable' ; import { Author } from './model/Author' ; import { AuthorPage } from './model/AuthorPage' ; import { AUTHOR_DATA_LIST } from './model/mock-authors-list' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor ( private http : HttpClient ) { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return this . http . post < AuthorPage > ( 'http://localhost:8080/author' , { pageable : pageable }); } saveAuthor ( author : Author ) : Observable < void > { let url = 'http://localhost:8080/author' ; if ( author . id != null ) url += '/' + author . id ; return this . http . put < void > ( url , author ); } deleteAuthor ( idAuthor : number ) : Observable < void > { return this . http . delete < void > ( 'http://localhost:8080/author/' + idAuthor ); } getAllAuthors () : Observable < Author [] > { return of ( AUTHOR_DATA_LIST ); } } Ahora s\u00ed que tenemos todo listo para implementar el cuadro de dialogo para dar de alta o editar juegos. game-edit.component.html game-edit.component.scss game-edit.component.ts < div class = \"container\" > < h1 * ngIf = \"game.id == null\" > Crear juego </ h1 > < h1 * ngIf = \"game.id != null\" > Modificar juego </ h1 > < form > < mat-form-field > < mat-label > Identificador </ mat-label > < input type = \"number\" matInput placeholder = \"Identificador\" [( ngModel )]=\" game . id \" name = \"id\" disabled > </ mat-form-field > < mat-form-field > < mat-label > T\u00edtulo </ mat-label > < input type = \"text\" matInput placeholder = \"T\u00edtulo del juego\" [( ngModel )]=\" game . title \" name = \"title\" required > < mat-error > El t\u00edtulo no puede estar vac\u00edo </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Edad recomendada </ mat-label > < input type = \"number\" matInput placeholder = \"Edad recomendada\" [( ngModel )]=\" game . age \" name = \"age\" required > < mat-error > La edad no puede estar vac\u00eda </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Categor\u00eda </ mat-label > < mat-select disableRipple [( ngModel )]=\" game . category \" name = \"category\" required > < mat-option * ngFor = \"let category of categories\" [ value ]=\" category \" > {{category.name}} </ mat-option > </ mat-select > < mat-error > La categor\u00eda no puede estar vac\u00eda </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Autor </ mat-label > < mat-select disableRipple [( ngModel )]=\" game . author \" name = \"author\" required > < mat-option * ngFor = \"let author of authors\" [ value ]=\" author \" > {{author.name}} </ mat-option > </ mat-select > < mat-error > El autor no puede estar vac\u00edo </ mat-error > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onClose ()\" > Cerrar </ button > < button mat-flat-button color = \"primary\" ( click )=\" onSave ()\" > Guardar </ button > </ div > </ div > . container { min-width : 350 px ; max-width : 500 px ; width : 100 % ; form { display : flex ; flex-direction : column ; margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } import { Component , Inject , OnInit } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { AuthorService } from 'src/app/author/author.service' ; import { Author } from 'src/app/author/model/Author' ; import { CategoryService } from 'src/app/category/category.service' ; import { Category } from 'src/app/category/model/Category' ; import { GameService } from '../game.service' ; import { Game } from '../model/Game' ; @Component ({ selector : 'app-game-edit' , templateUrl : './game-edit.component.html' , styleUrls : [ './game-edit.component.scss' ] }) export class GameEditComponent implements OnInit { game : Game ; authors : Author []; categories : Category []; constructor ( public dialogRef : MatDialogRef < GameEditComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any , private gameService : GameService , private categoryService : CategoryService , private authorService : AuthorService , ) { } ngOnInit () : void { if ( this . data . game != null ) { this . game = Object . assign ({}, this . data . game ); } else { this . game = new Game (); } this . categoryService . getCategories (). subscribe ( categories => { this . categories = categories ; if ( this . data . game . category != null ) { let categoryFilter : Category [] = categories . filter ( category => category . id == this . data . game . category . id ); if ( categoryFilter != null ) { this . game . category = categoryFilter [ 0 ]; } } } ); this . authorService . getAllAuthors (). subscribe ( authors => { this . authors = authors if ( this . data . game . author != null ) { let authorFilter : Author [] = authors . filter ( author => author . id == this . data . game . author . id ); if ( authorFilter != null ) { this . game . author = authorFilter [ 0 ]; } } } ); } onSave () { this . gameService . saveGame ( this . game ). subscribe ( result => { this . dialogRef . close (); }); } onClose () { this . dialogRef . close (); } } Como puedes ver, para rellenar los componentes seleccionables de dropdown, hemos realizado una consulta al servicio para recuperar todos los autores y categorias, y en la respuesta de cada uno de ellos, hemos buscado en los resultados cual es el que coincide con el ID enviado desde el listado, y ese es el que hemos fijado en el objeto Game . De esta forma, no estamos cogiendo directamente los datos del listado, sino que no estamos asegurando que los datos de autor y de categor\u00eda son los que vienen del servicio, siempre filtrando por su ID. Desarrollo Springboot Modelos Lo primero que vamos a hacer es crear los modelos para trabajar con BBDD y con peticiones hacia el front. Adem\u00e1s, tambi\u00e9n tenemos que a\u00f1adir datos al script de inicializaci\u00f3n de BBDD. schema.sql data.sql Game.java GameDto.java DROP TABLE IF EXISTS CATEGORY ; CREATE TABLE CATEGORY ( id BIGINT IDENTITY NOT NULL PRIMARY KEY , name VARCHAR ( 250 ) NOT NULL ); DROP TABLE IF EXISTS AUTHOR ; CREATE TABLE AUTHOR ( id BIGINT IDENTITY NOT NULL PRIMARY KEY , name VARCHAR ( 400 ) NOT NULL , nationality VARCHAR ( 250 ) NOT NULL ); DROP TABLE IF EXISTS GAME ; CREATE TABLE GAME ( id BIGINT IDENTITY NOT NULL PRIMARY KEY , title VARCHAR ( 250 ) NOT NULL , age VARCHAR ( 3 ) NOT NULL , category_id BIGINT DEFAULT NULL , author_id BIGINT DEFAULT NULL ); ALTER TABLE GAME ADD FOREIGN KEY ( category_id ) REFERENCES CATEGORY ( id ); ALTER TABLE GAME ADD FOREIGN KEY ( author_id ) REFERENCES AUTHOR ( id ); INSERT INTO CATEGORY ( id , name ) VALUES ( 1 , 'Eurogames' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 2 , 'Ameritrash' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 3 , 'Familiar' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 1 , 'Alan R. Moon' , 'US' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 2 , 'Vital Lacerda' , 'PT' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 3 , 'Simone Luciani' , 'IT' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 4 , 'Perepau Llistosella' , 'ES' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 5 , 'Michael Kiesling' , 'DE' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 6 , 'Phil Walker-Harding' , 'US' ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 1 , 'On Mars' , '14' , 1 , 2 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 2 , 'Aventureros al tren' , '8' , 3 , 1 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 3 , '1920: Wall Street' , '12' , 1 , 4 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 4 , 'Barrage' , '14' , 1 , 3 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 5 , 'Los viajes de Marco Polo' , '12' , 1 , 3 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 6 , 'Azul' , '8' , 3 , 5 ); package com.capgemini.ccsw.tutorial.game.model ; import javax.persistence.Column ; import javax.persistence.Entity ; import javax.persistence.GeneratedValue ; import javax.persistence.GenerationType ; import javax.persistence.Id ; import javax.persistence.JoinColumn ; import javax.persistence.ManyToOne ; import javax.persistence.Table ; import com.capgemini.ccsw.tutorial.author.model.Author ; import com.capgemini.ccsw.tutorial.category.model.Category ; /** * @author ccsw */ @Entity @Table ( name = \"Game\" ) public class Game { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"title\" , nullable = false ) private String title ; @Column ( name = \"age\" , nullable = false ) private String age ; @ManyToOne @JoinColumn ( name = \"category_id\" , nullable = false ) private Category category ; @ManyToOne @JoinColumn ( name = \"author_id\" , nullable = false ) private Author author ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return age */ public String getAge () { return this . age ; } /** * @param age new value of {@link #getAge}. */ public void setAge ( String age ) { this . age = age ; } /** * @return category */ public Category getCategory () { return this . category ; } /** * @param category new value of {@link #getCategory}. */ public void setCategory ( Category category ) { this . category = category ; } /** * @return author */ public Author getAuthor () { return this . author ; } /** * @param author new value of {@link #getAuthor}. */ public void setAuthor ( Author author ) { this . author = author ; } } package com.capgemini.ccsw.tutorial.game.model ; import com.capgemini.ccsw.tutorial.author.model.AuthorDto ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw */ public class GameDto { private Long id ; private String title ; private String age ; private CategoryDto category ; private AuthorDto author ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return age */ public String getAge () { return this . age ; } /** * @param age new value of {@link #getAge}. */ public void setAge ( String age ) { this . age = age ; } /** * @return category */ public CategoryDto getCategory () { return this . category ; } /** * @param category new value of {@link #getCategory}. */ public void setCategory ( CategoryDto category ) { this . category = category ; } /** * @return author */ public AuthorDto getAuthor () { return this . author ; } /** * @param author new value of {@link #getAuthor}. */ public void setAuthor ( AuthorDto author ) { this . author = author ; } } Relaciones anidadas F\u00edjate que tanto la Entity como el Dto tienen relaciones con Author y Category . Gracias a Spring JPA se pueden resolver de esta forma y tener toda la informaci\u00f3n de las relaciones hijas dentro del objeto padre. Muy importante recordar que en el mundo entity las relaciones ser\u00e1n con objetos Entity mientras que en el mundo dto las relaciones deben ser siempre con objetos Dto . La utilidad beanMapper ya har\u00e1 las conversiones necesarias, siempre que tengan el mismo nombre de propiedades. TDD - Pruebas Para desarrollar todas las operaciones, empezaremos primero dise\u00f1ando las pruebas y luego implementando el c\u00f3digo necesario que haga funcionar correctamente esas pruebas. Para ir m\u00e1s r\u00e1pido vamos a poner todas las pruebas de golpe, pero realmente se deber\u00edan crear una a una e ir implementando el c\u00f3digo necesario para esa prueba. Para evitar tantas iteraciones en el tutorial las haremos todas de golpe. Vamos a pararnos a pensar un poco que necesitamos en la pantalla. En este caso solo tenemos dos operaciones: Una consulta filtrada, que reciba datos de filtro opcionales (t\u00edtulo e idCategor\u00eda) y devuelva los datos ya filtrados Una operaci\u00f3n de guardado y modificaci\u00f3n De nuevo tendremos que desglosar esto en varios casos de prueba: Buscar un juego sin filtros Buscar un t\u00edtulo que exista Buscar una categor\u00eda que exista Buscar un t\u00edtulo y una categor\u00eda que existan Buscar un t\u00edtulo que no exista Buscar una categor\u00eda que no exista Buscar un t\u00edtulo y una categor\u00eda que no existan Crear un juego nuevo (en realidad deber\u00edamos probar diferentes combinaciones y errores) Modificar un juego que exista Modificar un juego que no exista Tambi\u00e9n crearemos una clase GameController dentro del package de com.capgemini.ccsw.tutorial.game con la implementaci\u00f3n de los m\u00e9todos vac\u00edos, para que no falle la compilaci\u00f3n. \u00a1Vamos a implementar test! GameController.java GameTest.java package com.capgemini.ccsw.tutorial.game ; import java.util.List ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.ccsw.tutorial.game.model.GameDto ; @RestController public class GameController { public List < GameDto > find ( String title , Long idCategory ) { return null ; } public void save ( Long id , GameDto dto ) { } } package com.capgemini.ccsw.tutorial.game ; import static org.junit.jupiter.api.Assertions.assertEquals ; import static org.junit.jupiter.api.Assertions.assertNotNull ; import static org.junit.jupiter.api.Assertions.assertThrows ; import java.util.List ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.transaction.annotation.Transactional ; import com.capgemini.ccsw.tutorial.author.model.AuthorDto ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; import com.capgemini.ccsw.tutorial.game.model.GameDto ; @SpringBootTest @Transactional public class GameTest { @Autowired private GameController gameController ; private final String notExistsTitle = \"NotExists\" ; private final String existsTitle = \"Aventureros\" ; private final Long notExistsCategory = 0 L ; private final Long existsCategory = 3L ; @Test public void findWithoutFiltersShouldReturnAllGamesInDB () { assertNotNull ( gameController ); int GAMES_WITH_FILTER = 6 ; List < GameDto > games = gameController . find ( null , null ); assertNotNull ( games ); assertEquals ( GAMES_WITH_FILTER , games . size ()); } @Test public void findExistsTitleShouldReturnGames () { assertNotNull ( gameController ); int GAMES_WITH_FILTER = 1 ; List < GameDto > games = gameController . find ( existsTitle , null ); assertNotNull ( games ); assertEquals ( GAMES_WITH_FILTER , games . size ()); } @Test public void findExistsCategoryShouldReturnGames () { assertNotNull ( gameController ); int GAMES_WITH_FILTER = 2 ; List < GameDto > games = gameController . find ( null , existsCategory ); assertNotNull ( games ); assertEquals ( GAMES_WITH_FILTER , games . size ()); } @Test public void findExistsTitleAndCategoryShouldReturnGames () { assertNotNull ( gameController ); int GAMES_WITH_FILTER = 1 ; List < GameDto > games = gameController . find ( existsTitle , existsCategory ); assertNotNull ( games ); assertEquals ( GAMES_WITH_FILTER , games . size ()); } @Test public void findNotExistsTitleShouldReturnEmpty () { assertNotNull ( gameController ); int GAMES_WITH_FILTER = 0 ; List < GameDto > games = gameController . find ( notExistsTitle , null ); assertNotNull ( games ); assertEquals ( GAMES_WITH_FILTER , games . size ()); } @Test public void findNotExistsCategoryShouldReturnEmpty () { assertNotNull ( gameController ); int GAMES_WITH_FILTER = 0 ; List < GameDto > games = gameController . find ( null , notExistsCategory ); assertNotNull ( games ); assertEquals ( GAMES_WITH_FILTER , games . size ()); } @Test public void findNotExistsTitleOrCategoryShouldReturnEmpty () { assertNotNull ( gameController ); int GAMES_WITH_FILTER = 0 ; List < GameDto > games = gameController . find ( notExistsTitle , notExistsCategory ); assertNotNull ( games ); assertEquals ( GAMES_WITH_FILTER , games . size ()); games = gameController . find ( notExistsTitle , existsCategory ); assertNotNull ( games ); assertEquals ( GAMES_WITH_FILTER , games . size ()); games = gameController . find ( existsTitle , notExistsCategory ); assertNotNull ( games ); assertEquals ( GAMES_WITH_FILTER , games . size ()); } @Test public void saveWithoutIdShouldCreateNewGame () { String newTitle = \"Nuevo juego\" ; GameDto dto = new GameDto (); AuthorDto authorDto = new AuthorDto (); authorDto . setId ( 1L ); CategoryDto categoryDto = new CategoryDto (); categoryDto . setId ( 1L ); dto . setTitle ( newTitle ); dto . setAge ( \"18\" ); dto . setAuthor ( authorDto ); dto . setCategory ( categoryDto ); List < GameDto > games = gameController . find ( newTitle , null ); assertNotNull ( games ); assertEquals ( 0 , games . size ()); gameController . save ( null , dto ); games = gameController . find ( newTitle , null ); assertNotNull ( games ); assertEquals ( 1 , games . size ()); } @Test public void modifyWithExistIdShouldModifyGame () { Long gameId = 1L ; String newTitle = \"Nuevo juego\" ; GameDto dto = new GameDto (); AuthorDto authorDto = new AuthorDto (); authorDto . setId ( 1L ); CategoryDto categoryDto = new CategoryDto (); categoryDto . setId ( 1L ); dto . setTitle ( newTitle ); dto . setAge ( \"18\" ); dto . setAuthor ( authorDto ); dto . setCategory ( categoryDto ); List < GameDto > games = gameController . find ( newTitle , null ); assertNotNull ( games ); assertEquals ( 0 , games . size ()); gameController . save ( gameId , dto ); games = gameController . find ( newTitle , null ); assertNotNull ( games ); assertEquals ( 1 , games . size ()); GameDto game = games . get ( 0 ); assertEquals ( gameId , game . getId ()); } @Test public void modifyWithNotExistIdShouldThrowException () { assertNotNull ( gameController ); String newTitle = \"Nuevo juego\" ; long gameId = 0 ; GameDto dto = new GameDto (); dto . setTitle ( newTitle ); assertThrows ( Exception . class , () -> gameController . save ( gameId , dto )); } } B\u00fasquedas en BBDD Siempre deber\u00edamos buscar a los hijos por primary keys, nunca hay que hacerlo por una descripci\u00f3n libre ya que el usuario podr\u00eda teclear el mismo nombre de diferentes formas y no habr\u00eda manera de buscar correctamente el resultado. As\u00ed que siempre que haya un dropdown, se debe filtrar por su ID. Si ahora ejecutas los jUnits, ver\u00e1s que en este caso hemos construido 10 pruebas, para cubrir los casos b\u00e1sicos del Controller , y todas ellas fallan la ejecuci\u00f3n. Vamos a seguir implementando el resto de capas para hacer que los test funcionen. Controller De nuevo para poder compilar esta capa, nos hace falta delegar sus operaciones de l\u00f3gica de negocio en un Service as\u00ed que lo crearemos al mismo tiempo que lo vamos necesitando. GameService.java GameController.java package com.capgemini.ccsw.tutorial.game ; import java.util.List ; import com.capgemini.ccsw.tutorial.game.model.Game ; import com.capgemini.ccsw.tutorial.game.model.GameDto ; /** * @author ccsw */ public interface GameService { /** * Recupera los juegos filtrando opcionalmente por t\u00edtulo y/o categor\u00eda * @param title * @param idCategory * @return */ List < Game > find ( String title , Long idCategory ); /** * Guarda o modifica un juego, dependiendo de si el id est\u00e1 o no informado * @param id * @param dto */ void save ( Long id , GameDto dto ); } package com.capgemini.ccsw.tutorial.game ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RequestParam ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.ccsw.tutorial.game.model.Game ; import com.capgemini.ccsw.tutorial.game.model.GameDto ; import com.devonfw.module.beanmapping.common.api.BeanMapper ; /** * @author ccsw */ @RequestMapping ( value = \"/game\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class GameController { @Autowired GameService gameService ; @Autowired BeanMapper beanMapper ; @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < GameDto > find ( @RequestParam ( value = \"title\" , required = false ) String title , @RequestParam ( value = \"idCategory\" , required = false ) Long idCategory ) { List < Game > games = gameService . find ( title , idCategory ); return beanMapper . mapList ( games , GameDto . class ); } @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody GameDto dto ) { gameService . save ( id , dto ); } } En esta ocasi\u00f3n, para el m\u00e9todo de b\u00fasqueda hemos decidido utilizar par\u00e1metros en la URL de tal forma que nos quedar\u00e1 algo as\u00ed http://localhost:8080/game/?title=xxx&idCategoria=yyy . Queremos recuperar el recurso Game que es el raiz de la ruta, pero filtrado por cero o varios par\u00e1metros. Service Siguiente paso, la capa de l\u00f3gica de negocio, es decir el Service , que por tanto har\u00e1 uso de un Repository . GameServiceImpl.java GameRepository.java package com.capgemini.ccsw.tutorial.game ; import java.util.List ; import javax.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import com.capgemini.ccsw.tutorial.game.model.Game ; import com.capgemini.ccsw.tutorial.game.model.GameDto ; /** * @author ccsw */ @Service @Transactional public class GameServiceImpl implements GameService { @Autowired GameRepository gameRepository ; /** * {@inheritDoc} */ @Override public List < Game > find ( String title , Long category ) { return this . gameRepository . find ( title , category ); } /** * {@inheritDoc} */ @Override public void save ( Long id , GameDto dto ) { Game game = null ; if ( id == null ) game = new Game (); else game = this . gameRepository . findById ( id ). orElse ( null ); BeanUtils . copyProperties ( dto , game , \"id\" , \"author\" , \"category\" ); this . gameRepository . save ( game ); } } package com.capgemini.ccsw.tutorial.game ; import java.util.List ; import org.springframework.data.repository.CrudRepository ; import com.capgemini.ccsw.tutorial.game.model.Game ; public interface GameRepository extends CrudRepository < Game , Long > { List < Game > find ( String title , Long category ); } Este servicio tiene dos peculiaridades, remarcadas en amarillo en la clase anterior. Por un lado tenemos la consulta, que no es un listado completo ni un listado paginado, sino que es un listado con filtros. Luego veremos como se hace eso, de momento lo dejaremos como un m\u00e9todo que recibe los dos filtros. La segunda peculiaridad es que de cliente nos est\u00e1 llegando un GameDto , que internamente tiene un AuthorDto y un CategoryDto , pero nosotros lo tenemos que traducir a entidades de BBDD. No sirve con copiar las propiedades tal cual, ya que entonces Spring lo que har\u00e1 ser\u00e1 crear un objeto nuevo y persistir ese objeto nuevo de Author y de Category . Adem\u00e1s, de cliente generalmente tan solo nos llega el ID de esos objetos hijo, y no el resto de informaci\u00f3n de la entidad. Por esos motivos lo hemos ignorado del copyProperties. Pero de alguna forma tendremos que setearle esos valores a la entidad Game . Si conocemos sus ID que es lo que generalmente llega, podemos recuperar esos objetos de BBDD y setearlos en el objeto Game . Si recuerdas las reglas b\u00e1sicas, un Repository debe pertenecer a un solo Service , por lo que en lugar de llamar a m\u00e9todos de los AuthorRepository y CategoryRepository desde nuestro GameServiceImpl , debemos llamar a m\u00e9todos expuestos en AuthorService y CategoryService , que son los que gestionan sus repositorios. Para ello necesitaremos crear esos m\u00e9todos get en los otros Services . Y ya sabes, para implementar nuevos m\u00e9todos, antes se deben hacer las pruebas jUnit. Recuerda que los test van en src/test/java AuthorServiceTest.java AuthorService.java AuthorServiceImpl.java package com.capgemini.ccsw.tutorial.author ; import static org.junit.jupiter.api.Assertions.assertEquals ; import static org.junit.jupiter.api.Assertions.assertNotNull ; import static org.junit.jupiter.api.Assertions.assertNull ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.transaction.annotation.Transactional ; import com.capgemini.ccsw.tutorial.author.model.Author ; @SpringBootTest @Transactional public class AuthorServiceTest { @Autowired private AuthorService authorService ; @Test public void getExistsAuthorIdShouldReturnAuthor () { assertNotNull ( authorService ); Long authorId = 1L ; Author author = authorService . get ( 1L ); assertNotNull ( author ); assertEquals ( authorId , author . getId ()); } @Test public void getNotExistsAuthorIdShouldReturnNull () { assertNotNull ( authorService ); Long authorId = 0 L ; Author author = authorService . get ( authorId ); assertNull ( author ); } } package com.capgemini.ccsw.tutorial.author ; import org.springframework.data.domain.Page ; import com.capgemini.ccsw.tutorial.author.model.Author ; import com.capgemini.ccsw.tutorial.author.model.AuthorDto ; import com.capgemini.ccsw.tutorial.author.model.AuthorSearchDto ; /** * @author ccsw */ public interface AuthorService { /** * Recupera un {@link com.capgemini.ccsw.tutorial.author.model.Author} a trav\u00e9s de su ID * @param id * @return */ Author get ( Long id ); /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param dto * @return */ Page < Author > findPage ( AuthorSearchDto dto ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param id * @param data */ void save ( Long id , AuthorDto data ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param id */ void delete ( Long id ); } package com.capgemini.ccsw.tutorial.author ; import javax.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.stereotype.Service ; import com.capgemini.ccsw.tutorial.author.model.Author ; import com.capgemini.ccsw.tutorial.author.model.AuthorDto ; import com.capgemini.ccsw.tutorial.author.model.AuthorSearchDto ; /** * @author ccsw */ @Service @Transactional public class AuthorServiceImpl implements AuthorService { @Autowired AuthorRepository authorRepository ; /** * {@inheritDoc} */ @Override public Author get ( Long id ) { return this . authorRepository . findById ( id ). orElse ( null ); } /** * {@inheritDoc} */ @Override public Page < Author > findPage ( AuthorSearchDto dto ) { return this . authorRepository . findAll ( dto . getPageable ()); } /** * {@inheritDoc} */ @Override public void save ( Long id , AuthorDto data ) { Author author = null ; if ( id != null ) author = this . get ( id ); else author = new Author (); BeanUtils . copyProperties ( data , author , \"id\" ); this . authorRepository . save ( author ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) { this . authorRepository . deleteById ( id ); } } Y lo mismo para categor\u00edas. CategoryServiceTest.java CategoryService.java CategoryServiceImpl.java package com.capgemini.ccsw.tutorial.category ; import static org.junit.jupiter.api.Assertions.assertEquals ; import static org.junit.jupiter.api.Assertions.assertNotNull ; import static org.junit.jupiter.api.Assertions.assertNull ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.transaction.annotation.Transactional ; import com.capgemini.ccsw.tutorial.category.model.Category ; @SpringBootTest @Transactional public class CategoryServiceTest { @Autowired private CategoryService categoryService ; @Test public void getExistsCategoryIdShouldReturnCategory () { assertNotNull ( categoryService ); Long categoryId = 1L ; Category category = categoryService . get ( 1L ); assertNotNull ( category ); assertEquals ( categoryId , category . getId ()); } @Test public void getNotExistsCategoryIdShouldReturnNull () { assertNotNull ( categoryService ); Long categoryId = 0 L ; Category category = categoryService . get ( categoryId ); assertNull ( category ); } } package com.capgemini.ccsw.tutorial.category ; import java.util.List ; import com.capgemini.ccsw.tutorial.category.model.Category ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw * */ public interface CategoryService { /** * Recupera una {@link com.capgemini.ccsw.tutorial.category.model.Category} a partir de su ID * @param id * @return */ Category get ( Long id ); /** * M\u00e9todo para recuperar todas las {@link com.capgemini.ccsw.tutorial.category.model.Category} * @return */ List < Category > findAll (); /** * M\u00e9todo para crear o actualizar una {@link com.capgemini.ccsw.tutorial.category.model.Category} * @param dto * @return */ void save ( Long id , CategoryDto dto ); /** * M\u00e9todo para borrar una {@link com.capgemini.ccsw.tutorial.category.model.Category} * @param id */ void delete ( Long id ); } package com.capgemini.ccsw.tutorial.category ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import com.capgemini.ccsw.tutorial.category.model.Category ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw * */ @Service public class CategoryServiceImpl implements CategoryService { @Autowired CategoryRepository categoryRepository ; /** * {@inheritDoc} */ @Override public Category get ( Long id ) { return this . categoryRepository . findById ( id ). orElse ( null ); } /** * {@inheritDoc} */ @Override public List < Category > findAll () { return ( List < Category > ) this . categoryRepository . findAll (); } /** * {@inheritDoc} */ @Override public void save ( Long id , CategoryDto dto ) { Category categoria = null ; if ( id == null ) categoria = new Category (); else categoria = this . get ( id ); categoria . setName ( dto . getName ()); this . categoryRepository . save ( categoria ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) { this . categoryRepository . deleteById ( id ); } } Clean Code A la hora de implementar m\u00e9todos nuevos, ten siempre presente el Clean Code . \u00a1No dupliques c\u00f3digo!, es muy importante de cara al futuro mantenimiento. Si en nuestro m\u00e9todo save hac\u00edamos uso de una operaci\u00f3n findById y ahora hemos creado una nueva operaci\u00f3n get , hagamos uso de esta nueva operaci\u00f3n y no repitamos el c\u00f3digo. Y ahora que ya tenemos los m\u00e9todos necesarios ya podemos implementar correctamente nuestro GameServiceImpl . GameServiceImpl.java package com.capgemini.ccsw.tutorial.game ; import java.util.List ; import javax.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import com.capgemini.ccsw.tutorial.author.AuthorService ; import com.capgemini.ccsw.tutorial.category.CategoryService ; import com.capgemini.ccsw.tutorial.game.model.Game ; import com.capgemini.ccsw.tutorial.game.model.GameDto ; /** * @author ccsw */ @Service @Transactional public class GameServiceImpl implements GameService { @Autowired GameRepository gameRepository ; @Autowired AuthorService authorService ; @Autowired CategoryService categoryService ; /** * {@inheritDoc} */ @Override public List < Game > find ( String title , Long category ) { return this . gameRepository . find ( title , category ); } /** * {@inheritDoc} */ @Override public void save ( Long id , GameDto dto ) { Game game = null ; if ( id == null ) game = new Game (); else game = this . gameRepository . findById ( id ). orElse ( null ); BeanUtils . copyProperties ( dto , game , \"id\" , \"author\" , \"category\" ); game . setAuthor ( authorService . get ( dto . getAuthor (). getId ())); game . setCategory ( categoryService . get ( dto . getCategory (). getId ())); this . gameRepository . save ( game ); } } Ahora si que tenemos la capa de l\u00f3gica de negocio terminada, podemos pasar a la siguiente capa. Repository Y llegamos a la \u00faltima capa donde, si recordamos, ten\u00edamos un m\u00e9todo find que recibe dos par\u00e1metros. Algo as\u00ed: GameRepository.java package com.capgemini.ccsw.tutorial.game ; import java.util.List ; import org.springframework.data.repository.CrudRepository ; import com.capgemini.ccsw.tutorial.game.model.Game ; public interface GameRepository extends CrudRepository < Game , Long > { List < Game > find ( String title , Long category ); } Para esta ocasi\u00f3n, vamos a necesitar un listado filtrado por t\u00edtulo o por categor\u00eda, as\u00ed que necesitaremos pasarle esos datos y filtrar la query. Para el t\u00edtulo vamos a buscar por una cadena contenida, as\u00ed que el par\u00e1metro ser\u00e1 de tipo String , mientras que para la categor\u00eda vamos a buscar por su primary key, as\u00ed que el par\u00e1metro ser\u00e1 de tipo Long . Existen varias estrategias para abordar esta implementaci\u00f3n. Podr\u00edamos utilizar los QueryMethods para que Spring JPA haga su magia, pero en esta ocasi\u00f3n ser\u00eda bastante complicado encontrar un predicado correcto. Tambi\u00e9n podr\u00edamos hacer una implementaci\u00f3n de la interface y hacer la consulta directamente con Criteria. Pero en esta ocasi\u00f3n vamos a utilizar otra magia que nos ofrece Spring JPA y es utilizar la anotaci\u00f3n @Query . Esta anotaci\u00f3n nos permite definir una consulta en SQL nativo o en JPQL (Java Persistence Query Language) y Spring JPA se encargar\u00e1 de realizar todo el mapeo y conversi\u00f3n de los datos de entrada y salida. Veamos un ejemplo y luego lo explicamos en detalle: GameRepository.java package com.capgemini.ccsw.tutorial.game ; import java.util.List ; import org.springframework.data.repository.CrudRepository ; import com.capgemini.ccsw.tutorial.game.model.Game ; public interface GameRepository extends CrudRepository < Game , Long > { @Query ( \"select g from Game g where (:title is null or g.title like '%'||:title||'%') and (:category is null or g.category.id = :category)\" ) List < Game > find ( @Param ( \"title\" ) String title , @Param ( \"category\" ) Long category ); } Si te fijas en las dos l\u00edneas que hemos modificado, por un lado hemos puesto nombre a los par\u00e1metros de entrada con la anotaci\u00f3n @Param. Esto solo nos sirve para poder utilizar los parametros dentro de la query. Por otro lado, hemos creado una query en un lenguaje similar a SQL, pero en lugar de hacer uso de tablas y columnas, hacemos uso de objetos entity y propiedades. Dentro del where hemos puesto las dos condiciones, o bien que el par\u00e1metro t\u00edtulo sea nulo o bien si no es nulo, que la propiedad contenga el texto del par\u00e1metro t\u00edtulo. Para categor\u00eda hemos hecho lo mismo. Con esta quuery, Spring JPA generar\u00e1 el SQL correcto y mapear\u00e1 los resultados a un listado de Game que es lo que queremos obtener. Es otra forma, bastante sencilla de implementar consultas a BBDD. Prueba de las operaciones Si ahora ejecutamos de nuevo los jUnits, vemos que todos los que hemos desarrollado en GameTest ya funcionan correctamente, e incluso el resto de test de la aplicaci\u00f3n tambi\u00e9n funcionan correctamente. Pruebas jUnit Cada vez que desarrollemos un caso de uso nuevo, debemos relanzar todas las pruebas autom\u00e1ticas que tenga la aplicaci\u00f3n. Es muy com\u00fan que al implementar alg\u00fan desarrollo nuevo, interfiramos de alguna forma en el funcionamiento de otra funcionalidad. Si lanzamos toda la bater\u00eda de pruebas, nos daremos cuenta si algo ha dejado de funcionar y podremos solucionarlo antes de llevar ese error a Producci\u00f3n. Las pruebas jUnit son nuestra red de seguridad. Adem\u00e1s de las pruebas autom\u00e1ticas, podemos ver como se comporta la aplicaci\u00f3n y que respuesta nos ofrece, lanzando peticiones Rest con Postman, como hemos hecho en los casos anteriores. As\u00ed que podemos levantar la aplicaci\u00f3n y lanzar las operaciones: GET http://localhost:8080/game GET http://localhost:8080/game?title=xxx GET http://localhost:8080/game?idCategory=xxx Nos devuelve un listado filtrado de Game . F\u00edjate bien en la petici\u00f3n donde env\u00edamos los filtros y la respuesta que tiene los objetos Category y Author inclu\u00eddos. PUT http://localhost:8080/game PUT http://localhost:8080/game/{id} { \"title\": \"Nuevo juego\", \"age\": \"18\", \"category\": { \"id\": 3 }, \"author\": { \"id\": 1 } } Nos sirve para insertar un Game nuevo (si no tienen el id informado) o para actualizar un Game (si tienen el id informado). F\u00edjate que para enlazar Category y Author tan solo hace falta el id de cada no de ellos, ya que en el m\u00e9todo save se hace una consulta get para recuperarlos por su id. Adem\u00e1s que no tendr\u00eda sentido enviar toda la informaci\u00f3n de esas entidades ya que no est\u00e1s dando de alta una Category ni un Author . Rendimiento en las consultas JPA En este punto te recomiendo que visites el Anexo. Funcionamiento JPA para conocer un poco m\u00e1s como funciona por dentro JPA y alg\u00fan peque\u00f1o truco que puede mejorar el rendimiento. Implementar listado Autores Antes de poder conectar front con back, si recuerdas, en la edici\u00f3n de un Game , nos hac\u00eda falta un listado de Author y un listado de Category . El segundo ya lo tenemos ya que lo reutilizaremos del listado de categor\u00edas que implementamos. Pero el primero no lo tenemos, porque en la pantalla que hicimos, se mostraban de forma paginada. As\u00ed que necesitamos implementar esa funcionalidad, y como siempre vamos de la capa de testing hacia las siguientes capas. Deber\u00edamos a\u00f1adir los siguientes m\u00e9todos: AuthorTest.java AuthorController.java AuthorService.java AuthorServiceImpl.java ... @Test public void findAllShouldReturnAllAuthorInDB () { assertNotNull ( authorController ); List < AuthorDto > authors = authorController . findAll (); assertNotNull ( authors ); assertEquals ( TOTAL_AUTORS , authors . size ()); } ... ... /** * Recupera un listado de autores * @return */ @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < AuthorDto > findAll () { List < Author > authors = this . authorService . findAll (); return this . beanMapper . mapList ( authors , AuthorDto . class ); } ... ... /** * Recupera un listado de autores * @return */ List < Author > findAll (); ... ... /** * {@inheritDoc} */ @Override public List < Author > findAll () { return ( List < Author > ) this . authorRepository . findAll (); } ... Ahora s\u00ed, todo listo para seguir al siguiente punto. Conectar front con back Una vez implementado front y back, lo que nos queda es modificar el servicio del front para que conecte directamente con las operaciones ofrecidas por el back. author-service.ts game-service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Pageable } from '../core/model/page/Pageable' ; import { Author } from './model/Author' ; import { AuthorPage } from './model/AuthorPage' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor ( private http : HttpClient ) { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return this . http . post < AuthorPage > ( 'http://localhost:8080/author' , { pageable : pageable }); } saveAuthor ( author : Author ) : Observable < void > { let url = 'http://localhost:8080/author' ; if ( author . id != null ) url += '/' + author . id ; return this . http . put < void > ( url , author ); } deleteAuthor ( idAuthor : number ) : Observable < void > { return this . http . delete < void > ( 'http://localhost:8080/author/' + idAuthor ); } getAllAuthors () : Observable < Author [] > { return this . http . get < Author [] > ( 'http://localhost:8080/author' ); } } import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Game } from './model/Game' ; @Injectable ({ providedIn : 'root' }) export class GameService { constructor ( private http : HttpClient ) { } getGames ( title? : String , categoryId? : number ) : Observable < Game [] > { return this . http . get < Game [] > ( this . composeFindUrl ( title , categoryId )); } saveGame ( game : Game ) : Observable < void > { let url = 'http://localhost:8080/game' ; if ( game . id != null ) { url += '/' + game . id ; } return this . http . put < void > ( url , game ); } private composeFindUrl ( title? : String , categoryId? : number ) : string { let params = '' ; if ( title != null ) { params += 'title=' + title ; } if ( categoryId != null ) { if ( params != '' ) params += \"&\" ; params += \"idCategory=\" + categoryId ; } let url = 'http://localhost:8080/game' if ( params == '' ) return url ; else return url + '?' + params ; } } Y ahora si, podemos navegar por la web y ver el resultado completo.","title":"Code: Listado filtrado"},{"location":"develop/step5/#desarrollo-de-un-listado-filtrado","text":"En este punto ya tenemos dos listados, uno b\u00e1sico y otro paginado. Ahora vamos a implementar un listado un poco diferente, con filtros y con una presentaci\u00f3n un tanto distinta. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.","title":"Desarrollo de un listado filtrado"},{"location":"develop/step5/#desarrollo-angular","text":"","title":"Desarrollo Angular"},{"location":"develop/step5/#crear-componentes","text":"Vamos a desarrollar el listado de Juegos . Este listado es un tanto peculiar, porque no tiene una tabla como tal, sino que tiene una tabla con \"tiles\" para cada uno de los juegos. Necesitaremos un componente para el listado y otro componente para el detalle del juego. Tambi\u00e9n necesitaremos otro componente para el dialogo de edici\u00f3n / alta. Manos a la obra: ng generate module game ng generate component game/game-list ng generate component game/game-list/game-item ng generate component game/game-edit ng generate service game/game Y a\u00f1adimos el nuevo m\u00f3dulo al app.module.ts como hemos hecho con el resto de m\u00f3dulos. Game.ts import { NgModule } from '@angular/core' ; import { BrowserModule } from '@angular/platform-browser' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { BrowserAnimationsModule } from '@angular/platform-browser/animations' ; import { CoreModule } from './core/core.module' ; import { CategoryModule } from './category/category.module' ; import { AuthorModule } from './author/author.module' ; import { GameModule } from './game/game.module' ; @NgModule ({ declarations : [ AppComponent ], imports : [ BrowserModule , AppRoutingModule , CoreModule , CategoryModule , AuthorModule , GameModule , BrowserAnimationsModule ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { }","title":"Crear componentes"},{"location":"develop/step5/#crear-el-modelo","text":"Lo primero que vamos a hacer es crear el modelo en game/model/Game.ts con todas las propiedades necesarias para trabajar con un juego: Game.ts import { Category } from \"src/app/category/model/Category\" ; import { Author } from \"src/app/author/model/Author\" ; export class Game { id : number ; title : string ; age : number ; category : Category ; author : Author ; } Como ves, el juego tiene dos objetos para mapear categor\u00eda y autor.","title":"Crear el modelo"},{"location":"develop/step5/#anadir-el-punto-de-entrada","text":"A\u00f1adimos la ruta al men\u00fa para que podamos navegar a esta pantalla: app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { AuthorListComponent } from './author/author-list/author-list.component' ; import { CategoryListComponent } from './category/category-list/category-list.component' ; import { GameListComponent } from './game/game-list/game-list.component' ; const routes : Routes = [ { path : '' , redirectTo : '/games' , pathMatch : 'full' }, { path : 'categories' , component : CategoryListComponent }, { path : 'authors' , component : AuthorListComponent }, { path : 'games' , component : GameListComponent }, ]; @NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } Adem\u00e1s, hemos a\u00f1adido una regla adicional con el path vac\u00edo para indicar que si no pone ruta, por defecto la p\u00e1gina inicial redirija al path /games , que es nuevo path que hemos a\u00f1adido.","title":"A\u00f1adir el punto de entrada"},{"location":"develop/step5/#implementar-servicio","text":"A continuaci\u00f3n implementamos el servicio y mockeamos datos de ejemplo: mock-games.ts game.service.ts import { Game } from \"./Game\" ; export const GAME_DATA : Game [] = [ { id : 1 , title : 'Juego 1' , age : 6 , category : { id : 1 , name : 'Categor\u00eda 1' }, author : { id : 1 , name : 'Autor 1' , nationality : 'Nacionalidad 1' } }, { id : 2 , title : 'Juego 2' , age : 8 , category : { id : 1 , name : 'Categor\u00eda 1' }, author : { id : 2 , name : 'Autor 2' , nationality : 'Nacionalidad 2' } }, { id : 3 , title : 'Juego 3' , age : 4 , category : { id : 1 , name : 'Categor\u00eda 1' }, author : { id : 3 , name : 'Autor 3' , nationality : 'Nacionalidad 3' } }, { id : 4 , title : 'Juego 4' , age : 10 , category : { id : 2 , name : 'Categor\u00eda 2' }, author : { id : 1 , name : 'Autor 1' , nationality : 'Nacionalidad 1' } }, { id : 5 , title : 'Juego 5' , age : 16 , category : { id : 2 , name : 'Categor\u00eda 2' }, author : { id : 2 , name : 'Autor 2' , nationality : 'Nacionalidad 2' } }, { id : 6 , title : 'Juego 6' , age : 16 , category : { id : 2 , name : 'Categor\u00eda 2' }, author : { id : 3 , name : 'Autor 3' , nationality : 'Nacionalidad 3' } }, { id : 7 , title : 'Juego 7' , age : 12 , category : { id : 3 , name : 'Categor\u00eda 3' }, author : { id : 1 , name : 'Autor 1' , nationality : 'Nacionalidad 1' } }, { id : 8 , title : 'Juego 8' , age : 14 , category : { id : 3 , name : 'Categor\u00eda 3' }, author : { id : 2 , name : 'Autor 2' , nationality : 'Nacionalidad 2' } }, ] import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Game } from './model/Game' ; import { GAME_DATA } from './model/mock-games' ; @Injectable ({ providedIn : 'root' }) export class GameService { constructor () { } getGames ( title? : String , categoryId? : number ) : Observable < Game [] > { return of ( GAME_DATA ); } saveGame ( game : Game ) : Observable < void > { return of ( null ); } }","title":"Implementar servicio"},{"location":"develop/step5/#implementar-listado","text":"Ya tenemos las operaciones del servicio con datoos, as\u00ed que ahora vamos a por el listado filtrado. game-list.component.html game-list.component.scss game-list.component.ts < div class = \"container\" > < h1 > Cat\u00e1logo de juegos </ h1 > < div class = \"filters\" > < form > < mat-form-field > < mat-label > T\u00edtulo del juego </ mat-label > < input type = \"text\" matInput placeholder = \"T\u00edtulo del juego\" [( ngModel )]=\" filterTitle \" name = \"title\" > </ mat-form-field > < mat-form-field > < mat-label > Categor\u00eda del juego </ mat-label > < mat-select disableRipple [( ngModel )]=\" filterCategory \" name = \"category\" > < mat-option * ngFor = \"let category of categories\" [ value ]=\" category \" > {{category.name}} </ mat-option > </ mat-select > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onCleanFilter ()\" > Limpiar </ button > < button mat-stroked-button ( click )=\" onSearch ()\" > Filtrar </ button > </ div > </ div > < div class = \"game-list\" > < app-game-item * ngFor = \"let game of games; let i = index;\" ( click )=\" editGame ( game )\" > </ app-game-item > </ div > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createGame ()\" > Nuevo juego </ button > </ div > </ div > . container { margin : 20 px ; .filters { display : flex ; mat-form-field { width : 300 px ; margin-right : 20 px ; } . buttons { flex : auto ; align-self : center ; button { margin-left : 15 px ; } } } . game-list { margin-top : 20 px ; margin-bottom : 20 px ; display : flex ; flex-flow : wrap ; overflow : auto ; } . buttons { text-align : right ; } } button { width : 125 px ; } import { Component , OnInit } from '@angular/core' ; import { MatDialog } from '@angular/material/dialog' ; import { CategoryService } from 'src/app/category/category.service' ; import { Category } from 'src/app/category/model/Category' ; import { GameEditComponent } from '../game-edit/game-edit.component' ; import { GameService } from '../game.service' ; import { Game } from '../model/Game' ; @Component ({ selector : 'app-game-list' , templateUrl : './game-list.component.html' , styleUrls : [ './game-list.component.scss' ] }) export class GameListComponent implements OnInit { categories : Category []; games : Game []; filterCategory : Category ; filterTitle : string ; constructor ( private gameService : GameService , private categoryService : CategoryService , public dialog : MatDialog , ) { } ngOnInit () : void { this . gameService . getGames (). subscribe ( games => this . games = games ); this . categoryService . getCategories (). subscribe ( categories => this . categories = categories ); } onCleanFilter () : void { this . filterTitle = null ; this . filterCategory = null ; this . onSearch (); } onSearch () : void { let title = this . filterTitle ; let categoryId = this . filterCategory != null ? this.filterCategory.id : null ; this . gameService . getGames ( title , categoryId ). subscribe ( games => this . games = games ); } createGame () { const dialogRef = this . dialog . open ( GameEditComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } editGame ( game : Game ) { const dialogRef = this . dialog . open ( GameEditComponent , { data : { game : game } }); dialogRef . afterClosed (). subscribe ( result => { this . onSearch (); }); } } Recuerda, de nuevo, que todos los componentes de Angular que utilicemos hay que importarlos en el m\u00f3dulo padre correspondiente para que se puedan precargar correctamente. game.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { GameListComponent } from './game-list/game-list.component' ; import { GameEditComponent } from './game-edit/game-edit.component' ; import { GameItemComponent } from './game-list/game-item/game-item.component' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; import { MatButtonModule } from '@angular/material/button' ; import { MatOptionModule } from '@angular/material/core' ; import { MatDialogModule } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatIconModule } from '@angular/material/icon' ; import { MatInputModule } from '@angular/material/input' ; import { MatPaginatorModule } from '@angular/material/paginator' ; import { MatSelectModule } from '@angular/material/select' ; import { MatTableModule } from '@angular/material/table' ; import { MatCardModule } from '@angular/material/card' ; @NgModule ({ declarations : [ GameListComponent , GameEditComponent , GameItemComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule , MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , MatPaginatorModule , MatOptionModule , MatSelectModule , MatCardModule , ] }) export class GameModule { } Con todos estos cambios y si refrescamos el navegador, deber\u00eda verse una pantalla similar a esta: Tenemos una pantalla con una secci\u00f3n de filtros en la parte superior, donde podemos introducir un texto o seleccionar una categor\u00eda de un dropdown, un listado que de momento tiene todos los componentes b\u00e1sicos en una fila uno detr\u00e1s del otro, y un bot\u00f3n para crear juegos nuevos. Dropdown El componente Dropdown es uno de los componentes m\u00e1s utilizados en las pantallas y formularios de Angular. Ves familiariz\u00e1ndote con \u00e9l porque lo vas a usar mucho. Es bastante potente y medianamente sencillo de utilizar. Los datos del listado pueden ser din\u00e1micos (desde servidor) o est\u00e1ticos (si los valores ya los tienes prefijados).","title":"Implementar listado"},{"location":"develop/step5/#implementar-detalle-del-item","text":"Ahora vamos a implementar el detalle de cada uno de los items que forman el listado. Para ello lo primero que haremos ser\u00e1 pasarle la informaci\u00f3n del juego a cada componente como un dato de entrada Input hacia el componente. games.component.html < div class = \"container\" > < h1 > Cat\u00e1logo de juegos </ h1 > < div class = \"filters\" > < form > < mat-form-field > < mat-label > T\u00edtulo del juego </ mat-label > < input type = \"text\" matInput placeholder = \"T\u00edtulo del juego\" [( ngModel )]=\" filterName \" name = \"title\" > </ mat-form-field > < mat-form-field > < mat-label > Categor\u00eda del juego </ mat-label > < mat-select disableRipple [( ngModel )]=\" filterCategory \" name = \"category\" > < mat-option * ngFor = \"let category of categories\" [ value ]=\" category \" > {{category.name}} </ mat-option > </ mat-select > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onCleanFilter ()\" > Limpiar </ button > < button mat-stroked-button ( click )=\" onSearch ()\" > Filtrar </ button > </ div > </ div > < div class = \"game-list\" > < app-game-item * ngFor = \"let game of games; let i = index;\" ( click )=\" editGame ( game )\" [ game ]=\" game \" > </ app-game-item > </ div > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createGame ()\" > Nuevo juego </ button > </ div > </ div > Tambi\u00e9n vamos a necesitar una foto de ejemplo para poner dentro de la tarjeta detalle de los juegos. Vamos a utilizar esta imagen: Desc\u00e1rgala y d\u00e9jala dentro del proyecto en assets/foto.png . Y ya para terminar, implementamos el componente de detalle: game-item.component.html game-item.component.scss game-item.component.ts < div class = \"container\" > < mat-card > < div class = \"photo\" > < img src = \"./assets/foto.png\" > </ div > < div class = \"detail\" > < div class = \"title\" > {{game.title}} </ div > < div class = \"properties\" > < div >< i > Edad recomendada: </ i > +{{game.age}} </ div > < div >< i > Categor\u00eda: </ i > {{game.category.name}} </ div > < div >< i > Autor: </ i > {{game.author.name}} </ div > < div >< i > Nacionalidad: </ i > {{game.author.nationality}} </ div > </ div > </ div > </ mat-card > </ div > . container { display : flex ; width : 325 px ; mat-card { width : 100 % ; margin : 10 px ; display : flex ; .photo { margin-right : 10 px ; img { width : 80 px ; height : 80 px ; } } . detail { .title { font-size : 14 px ; font-weight : bold ; } . properties { font-size : 11 px ; div { height : 15 px ; } } } } } import { Component , OnInit , Input } from '@angular/core' ; import { Game } from '../../model/Game' ; @Component ({ selector : 'app-game-item' , templateUrl : './game-item.component.html' , styleUrls : [ './game-item.component.scss' ] }) export class GameItemComponent implements OnInit { @Input () game : Game ; constructor () { } ngOnInit () : void { } } Ahora si que deber\u00eda quedar algo similar a esta pantalla:","title":"Implementar detalle del item"},{"location":"develop/step5/#implementar-dialogo-de-edicion","text":"Ya solo nos falta el \u00faltimo paso, implementar el cuadro de edici\u00f3n / alta de un nuevo juego. Pero tenemos un peque\u00f1o problema, y es que al crear o editar un juego debemos seleccionar una Categor\u00eda y un Autor . Para la Categor\u00eda no tenemos ning\u00fan problema, pero para el Autor no tenemos un servicio que nos devuelva todos los autores, solo tenemos un servicio que nos devuelve una Page de autores. As\u00ed que lo primero que haremos ser\u00e1 implementar una operaci\u00f3n getAllAuthors para poder recuperar una lista. mock-authors-list.ts author.service.ts import { Author } from \"./Author\" ; export const AUTHOR_DATA_LIST : Author [] = [ { id : 1 , name : 'Klaus Teuber' , nationality : 'Alemania' }, { id : 2 , name : 'Matt Leacock' , nationality : 'Estados Unidos' }, { id : 3 , name : 'Keng Leong Yeo' , nationality : 'Singapur' }, { id : 4 , name : 'Gil Hova' , nationality : 'Estados Unidos' }, { id : 5 , name : 'Kelly Adams' , nationality : 'Estados Unidos' }, ] import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Pageable } from '../core/model/page/Pageable' ; import { Author } from './model/Author' ; import { AuthorPage } from './model/AuthorPage' ; import { AUTHOR_DATA_LIST } from './model/mock-authors-list' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor ( private http : HttpClient ) { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return this . http . post < AuthorPage > ( 'http://localhost:8080/author' , { pageable : pageable }); } saveAuthor ( author : Author ) : Observable < void > { let url = 'http://localhost:8080/author' ; if ( author . id != null ) url += '/' + author . id ; return this . http . put < void > ( url , author ); } deleteAuthor ( idAuthor : number ) : Observable < void > { return this . http . delete < void > ( 'http://localhost:8080/author/' + idAuthor ); } getAllAuthors () : Observable < Author [] > { return of ( AUTHOR_DATA_LIST ); } } Ahora s\u00ed que tenemos todo listo para implementar el cuadro de dialogo para dar de alta o editar juegos. game-edit.component.html game-edit.component.scss game-edit.component.ts < div class = \"container\" > < h1 * ngIf = \"game.id == null\" > Crear juego </ h1 > < h1 * ngIf = \"game.id != null\" > Modificar juego </ h1 > < form > < mat-form-field > < mat-label > Identificador </ mat-label > < input type = \"number\" matInput placeholder = \"Identificador\" [( ngModel )]=\" game . id \" name = \"id\" disabled > </ mat-form-field > < mat-form-field > < mat-label > T\u00edtulo </ mat-label > < input type = \"text\" matInput placeholder = \"T\u00edtulo del juego\" [( ngModel )]=\" game . title \" name = \"title\" required > < mat-error > El t\u00edtulo no puede estar vac\u00edo </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Edad recomendada </ mat-label > < input type = \"number\" matInput placeholder = \"Edad recomendada\" [( ngModel )]=\" game . age \" name = \"age\" required > < mat-error > La edad no puede estar vac\u00eda </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Categor\u00eda </ mat-label > < mat-select disableRipple [( ngModel )]=\" game . category \" name = \"category\" required > < mat-option * ngFor = \"let category of categories\" [ value ]=\" category \" > {{category.name}} </ mat-option > </ mat-select > < mat-error > La categor\u00eda no puede estar vac\u00eda </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Autor </ mat-label > < mat-select disableRipple [( ngModel )]=\" game . author \" name = \"author\" required > < mat-option * ngFor = \"let author of authors\" [ value ]=\" author \" > {{author.name}} </ mat-option > </ mat-select > < mat-error > El autor no puede estar vac\u00edo </ mat-error > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onClose ()\" > Cerrar </ button > < button mat-flat-button color = \"primary\" ( click )=\" onSave ()\" > Guardar </ button > </ div > </ div > . container { min-width : 350 px ; max-width : 500 px ; width : 100 % ; form { display : flex ; flex-direction : column ; margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } import { Component , Inject , OnInit } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { AuthorService } from 'src/app/author/author.service' ; import { Author } from 'src/app/author/model/Author' ; import { CategoryService } from 'src/app/category/category.service' ; import { Category } from 'src/app/category/model/Category' ; import { GameService } from '../game.service' ; import { Game } from '../model/Game' ; @Component ({ selector : 'app-game-edit' , templateUrl : './game-edit.component.html' , styleUrls : [ './game-edit.component.scss' ] }) export class GameEditComponent implements OnInit { game : Game ; authors : Author []; categories : Category []; constructor ( public dialogRef : MatDialogRef < GameEditComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any , private gameService : GameService , private categoryService : CategoryService , private authorService : AuthorService , ) { } ngOnInit () : void { if ( this . data . game != null ) { this . game = Object . assign ({}, this . data . game ); } else { this . game = new Game (); } this . categoryService . getCategories (). subscribe ( categories => { this . categories = categories ; if ( this . data . game . category != null ) { let categoryFilter : Category [] = categories . filter ( category => category . id == this . data . game . category . id ); if ( categoryFilter != null ) { this . game . category = categoryFilter [ 0 ]; } } } ); this . authorService . getAllAuthors (). subscribe ( authors => { this . authors = authors if ( this . data . game . author != null ) { let authorFilter : Author [] = authors . filter ( author => author . id == this . data . game . author . id ); if ( authorFilter != null ) { this . game . author = authorFilter [ 0 ]; } } } ); } onSave () { this . gameService . saveGame ( this . game ). subscribe ( result => { this . dialogRef . close (); }); } onClose () { this . dialogRef . close (); } } Como puedes ver, para rellenar los componentes seleccionables de dropdown, hemos realizado una consulta al servicio para recuperar todos los autores y categorias, y en la respuesta de cada uno de ellos, hemos buscado en los resultados cual es el que coincide con el ID enviado desde el listado, y ese es el que hemos fijado en el objeto Game . De esta forma, no estamos cogiendo directamente los datos del listado, sino que no estamos asegurando que los datos de autor y de categor\u00eda son los que vienen del servicio, siempre filtrando por su ID.","title":"Implementar dialogo de edici\u00f3n"},{"location":"develop/step5/#desarrollo-springboot","text":"","title":"Desarrollo Springboot"},{"location":"develop/step5/#modelos","text":"Lo primero que vamos a hacer es crear los modelos para trabajar con BBDD y con peticiones hacia el front. Adem\u00e1s, tambi\u00e9n tenemos que a\u00f1adir datos al script de inicializaci\u00f3n de BBDD. schema.sql data.sql Game.java GameDto.java DROP TABLE IF EXISTS CATEGORY ; CREATE TABLE CATEGORY ( id BIGINT IDENTITY NOT NULL PRIMARY KEY , name VARCHAR ( 250 ) NOT NULL ); DROP TABLE IF EXISTS AUTHOR ; CREATE TABLE AUTHOR ( id BIGINT IDENTITY NOT NULL PRIMARY KEY , name VARCHAR ( 400 ) NOT NULL , nationality VARCHAR ( 250 ) NOT NULL ); DROP TABLE IF EXISTS GAME ; CREATE TABLE GAME ( id BIGINT IDENTITY NOT NULL PRIMARY KEY , title VARCHAR ( 250 ) NOT NULL , age VARCHAR ( 3 ) NOT NULL , category_id BIGINT DEFAULT NULL , author_id BIGINT DEFAULT NULL ); ALTER TABLE GAME ADD FOREIGN KEY ( category_id ) REFERENCES CATEGORY ( id ); ALTER TABLE GAME ADD FOREIGN KEY ( author_id ) REFERENCES AUTHOR ( id ); INSERT INTO CATEGORY ( id , name ) VALUES ( 1 , 'Eurogames' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 2 , 'Ameritrash' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 3 , 'Familiar' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 1 , 'Alan R. Moon' , 'US' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 2 , 'Vital Lacerda' , 'PT' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 3 , 'Simone Luciani' , 'IT' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 4 , 'Perepau Llistosella' , 'ES' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 5 , 'Michael Kiesling' , 'DE' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 6 , 'Phil Walker-Harding' , 'US' ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 1 , 'On Mars' , '14' , 1 , 2 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 2 , 'Aventureros al tren' , '8' , 3 , 1 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 3 , '1920: Wall Street' , '12' , 1 , 4 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 4 , 'Barrage' , '14' , 1 , 3 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 5 , 'Los viajes de Marco Polo' , '12' , 1 , 3 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 6 , 'Azul' , '8' , 3 , 5 ); package com.capgemini.ccsw.tutorial.game.model ; import javax.persistence.Column ; import javax.persistence.Entity ; import javax.persistence.GeneratedValue ; import javax.persistence.GenerationType ; import javax.persistence.Id ; import javax.persistence.JoinColumn ; import javax.persistence.ManyToOne ; import javax.persistence.Table ; import com.capgemini.ccsw.tutorial.author.model.Author ; import com.capgemini.ccsw.tutorial.category.model.Category ; /** * @author ccsw */ @Entity @Table ( name = \"Game\" ) public class Game { @Id @GeneratedValue ( strategy = GenerationType . IDENTITY ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"title\" , nullable = false ) private String title ; @Column ( name = \"age\" , nullable = false ) private String age ; @ManyToOne @JoinColumn ( name = \"category_id\" , nullable = false ) private Category category ; @ManyToOne @JoinColumn ( name = \"author_id\" , nullable = false ) private Author author ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return age */ public String getAge () { return this . age ; } /** * @param age new value of {@link #getAge}. */ public void setAge ( String age ) { this . age = age ; } /** * @return category */ public Category getCategory () { return this . category ; } /** * @param category new value of {@link #getCategory}. */ public void setCategory ( Category category ) { this . category = category ; } /** * @return author */ public Author getAuthor () { return this . author ; } /** * @param author new value of {@link #getAuthor}. */ public void setAuthor ( Author author ) { this . author = author ; } } package com.capgemini.ccsw.tutorial.game.model ; import com.capgemini.ccsw.tutorial.author.model.AuthorDto ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw */ public class GameDto { private Long id ; private String title ; private String age ; private CategoryDto category ; private AuthorDto author ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return age */ public String getAge () { return this . age ; } /** * @param age new value of {@link #getAge}. */ public void setAge ( String age ) { this . age = age ; } /** * @return category */ public CategoryDto getCategory () { return this . category ; } /** * @param category new value of {@link #getCategory}. */ public void setCategory ( CategoryDto category ) { this . category = category ; } /** * @return author */ public AuthorDto getAuthor () { return this . author ; } /** * @param author new value of {@link #getAuthor}. */ public void setAuthor ( AuthorDto author ) { this . author = author ; } } Relaciones anidadas F\u00edjate que tanto la Entity como el Dto tienen relaciones con Author y Category . Gracias a Spring JPA se pueden resolver de esta forma y tener toda la informaci\u00f3n de las relaciones hijas dentro del objeto padre. Muy importante recordar que en el mundo entity las relaciones ser\u00e1n con objetos Entity mientras que en el mundo dto las relaciones deben ser siempre con objetos Dto . La utilidad beanMapper ya har\u00e1 las conversiones necesarias, siempre que tengan el mismo nombre de propiedades.","title":"Modelos"},{"location":"develop/step5/#tdd-pruebas","text":"Para desarrollar todas las operaciones, empezaremos primero dise\u00f1ando las pruebas y luego implementando el c\u00f3digo necesario que haga funcionar correctamente esas pruebas. Para ir m\u00e1s r\u00e1pido vamos a poner todas las pruebas de golpe, pero realmente se deber\u00edan crear una a una e ir implementando el c\u00f3digo necesario para esa prueba. Para evitar tantas iteraciones en el tutorial las haremos todas de golpe. Vamos a pararnos a pensar un poco que necesitamos en la pantalla. En este caso solo tenemos dos operaciones: Una consulta filtrada, que reciba datos de filtro opcionales (t\u00edtulo e idCategor\u00eda) y devuelva los datos ya filtrados Una operaci\u00f3n de guardado y modificaci\u00f3n De nuevo tendremos que desglosar esto en varios casos de prueba: Buscar un juego sin filtros Buscar un t\u00edtulo que exista Buscar una categor\u00eda que exista Buscar un t\u00edtulo y una categor\u00eda que existan Buscar un t\u00edtulo que no exista Buscar una categor\u00eda que no exista Buscar un t\u00edtulo y una categor\u00eda que no existan Crear un juego nuevo (en realidad deber\u00edamos probar diferentes combinaciones y errores) Modificar un juego que exista Modificar un juego que no exista Tambi\u00e9n crearemos una clase GameController dentro del package de com.capgemini.ccsw.tutorial.game con la implementaci\u00f3n de los m\u00e9todos vac\u00edos, para que no falle la compilaci\u00f3n. \u00a1Vamos a implementar test! GameController.java GameTest.java package com.capgemini.ccsw.tutorial.game ; import java.util.List ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.ccsw.tutorial.game.model.GameDto ; @RestController public class GameController { public List < GameDto > find ( String title , Long idCategory ) { return null ; } public void save ( Long id , GameDto dto ) { } } package com.capgemini.ccsw.tutorial.game ; import static org.junit.jupiter.api.Assertions.assertEquals ; import static org.junit.jupiter.api.Assertions.assertNotNull ; import static org.junit.jupiter.api.Assertions.assertThrows ; import java.util.List ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.transaction.annotation.Transactional ; import com.capgemini.ccsw.tutorial.author.model.AuthorDto ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; import com.capgemini.ccsw.tutorial.game.model.GameDto ; @SpringBootTest @Transactional public class GameTest { @Autowired private GameController gameController ; private final String notExistsTitle = \"NotExists\" ; private final String existsTitle = \"Aventureros\" ; private final Long notExistsCategory = 0 L ; private final Long existsCategory = 3L ; @Test public void findWithoutFiltersShouldReturnAllGamesInDB () { assertNotNull ( gameController ); int GAMES_WITH_FILTER = 6 ; List < GameDto > games = gameController . find ( null , null ); assertNotNull ( games ); assertEquals ( GAMES_WITH_FILTER , games . size ()); } @Test public void findExistsTitleShouldReturnGames () { assertNotNull ( gameController ); int GAMES_WITH_FILTER = 1 ; List < GameDto > games = gameController . find ( existsTitle , null ); assertNotNull ( games ); assertEquals ( GAMES_WITH_FILTER , games . size ()); } @Test public void findExistsCategoryShouldReturnGames () { assertNotNull ( gameController ); int GAMES_WITH_FILTER = 2 ; List < GameDto > games = gameController . find ( null , existsCategory ); assertNotNull ( games ); assertEquals ( GAMES_WITH_FILTER , games . size ()); } @Test public void findExistsTitleAndCategoryShouldReturnGames () { assertNotNull ( gameController ); int GAMES_WITH_FILTER = 1 ; List < GameDto > games = gameController . find ( existsTitle , existsCategory ); assertNotNull ( games ); assertEquals ( GAMES_WITH_FILTER , games . size ()); } @Test public void findNotExistsTitleShouldReturnEmpty () { assertNotNull ( gameController ); int GAMES_WITH_FILTER = 0 ; List < GameDto > games = gameController . find ( notExistsTitle , null ); assertNotNull ( games ); assertEquals ( GAMES_WITH_FILTER , games . size ()); } @Test public void findNotExistsCategoryShouldReturnEmpty () { assertNotNull ( gameController ); int GAMES_WITH_FILTER = 0 ; List < GameDto > games = gameController . find ( null , notExistsCategory ); assertNotNull ( games ); assertEquals ( GAMES_WITH_FILTER , games . size ()); } @Test public void findNotExistsTitleOrCategoryShouldReturnEmpty () { assertNotNull ( gameController ); int GAMES_WITH_FILTER = 0 ; List < GameDto > games = gameController . find ( notExistsTitle , notExistsCategory ); assertNotNull ( games ); assertEquals ( GAMES_WITH_FILTER , games . size ()); games = gameController . find ( notExistsTitle , existsCategory ); assertNotNull ( games ); assertEquals ( GAMES_WITH_FILTER , games . size ()); games = gameController . find ( existsTitle , notExistsCategory ); assertNotNull ( games ); assertEquals ( GAMES_WITH_FILTER , games . size ()); } @Test public void saveWithoutIdShouldCreateNewGame () { String newTitle = \"Nuevo juego\" ; GameDto dto = new GameDto (); AuthorDto authorDto = new AuthorDto (); authorDto . setId ( 1L ); CategoryDto categoryDto = new CategoryDto (); categoryDto . setId ( 1L ); dto . setTitle ( newTitle ); dto . setAge ( \"18\" ); dto . setAuthor ( authorDto ); dto . setCategory ( categoryDto ); List < GameDto > games = gameController . find ( newTitle , null ); assertNotNull ( games ); assertEquals ( 0 , games . size ()); gameController . save ( null , dto ); games = gameController . find ( newTitle , null ); assertNotNull ( games ); assertEquals ( 1 , games . size ()); } @Test public void modifyWithExistIdShouldModifyGame () { Long gameId = 1L ; String newTitle = \"Nuevo juego\" ; GameDto dto = new GameDto (); AuthorDto authorDto = new AuthorDto (); authorDto . setId ( 1L ); CategoryDto categoryDto = new CategoryDto (); categoryDto . setId ( 1L ); dto . setTitle ( newTitle ); dto . setAge ( \"18\" ); dto . setAuthor ( authorDto ); dto . setCategory ( categoryDto ); List < GameDto > games = gameController . find ( newTitle , null ); assertNotNull ( games ); assertEquals ( 0 , games . size ()); gameController . save ( gameId , dto ); games = gameController . find ( newTitle , null ); assertNotNull ( games ); assertEquals ( 1 , games . size ()); GameDto game = games . get ( 0 ); assertEquals ( gameId , game . getId ()); } @Test public void modifyWithNotExistIdShouldThrowException () { assertNotNull ( gameController ); String newTitle = \"Nuevo juego\" ; long gameId = 0 ; GameDto dto = new GameDto (); dto . setTitle ( newTitle ); assertThrows ( Exception . class , () -> gameController . save ( gameId , dto )); } } B\u00fasquedas en BBDD Siempre deber\u00edamos buscar a los hijos por primary keys, nunca hay que hacerlo por una descripci\u00f3n libre ya que el usuario podr\u00eda teclear el mismo nombre de diferentes formas y no habr\u00eda manera de buscar correctamente el resultado. As\u00ed que siempre que haya un dropdown, se debe filtrar por su ID. Si ahora ejecutas los jUnits, ver\u00e1s que en este caso hemos construido 10 pruebas, para cubrir los casos b\u00e1sicos del Controller , y todas ellas fallan la ejecuci\u00f3n. Vamos a seguir implementando el resto de capas para hacer que los test funcionen.","title":"TDD - Pruebas"},{"location":"develop/step5/#controller","text":"De nuevo para poder compilar esta capa, nos hace falta delegar sus operaciones de l\u00f3gica de negocio en un Service as\u00ed que lo crearemos al mismo tiempo que lo vamos necesitando. GameService.java GameController.java package com.capgemini.ccsw.tutorial.game ; import java.util.List ; import com.capgemini.ccsw.tutorial.game.model.Game ; import com.capgemini.ccsw.tutorial.game.model.GameDto ; /** * @author ccsw */ public interface GameService { /** * Recupera los juegos filtrando opcionalmente por t\u00edtulo y/o categor\u00eda * @param title * @param idCategory * @return */ List < Game > find ( String title , Long idCategory ); /** * Guarda o modifica un juego, dependiendo de si el id est\u00e1 o no informado * @param id * @param dto */ void save ( Long id , GameDto dto ); } package com.capgemini.ccsw.tutorial.game ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RequestParam ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.ccsw.tutorial.game.model.Game ; import com.capgemini.ccsw.tutorial.game.model.GameDto ; import com.devonfw.module.beanmapping.common.api.BeanMapper ; /** * @author ccsw */ @RequestMapping ( value = \"/game\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class GameController { @Autowired GameService gameService ; @Autowired BeanMapper beanMapper ; @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < GameDto > find ( @RequestParam ( value = \"title\" , required = false ) String title , @RequestParam ( value = \"idCategory\" , required = false ) Long idCategory ) { List < Game > games = gameService . find ( title , idCategory ); return beanMapper . mapList ( games , GameDto . class ); } @RequestMapping ( path = { \"\" , \"/{id}\" }, method = RequestMethod . PUT ) public void save ( @PathVariable ( name = \"id\" , required = false ) Long id , @RequestBody GameDto dto ) { gameService . save ( id , dto ); } } En esta ocasi\u00f3n, para el m\u00e9todo de b\u00fasqueda hemos decidido utilizar par\u00e1metros en la URL de tal forma que nos quedar\u00e1 algo as\u00ed http://localhost:8080/game/?title=xxx&idCategoria=yyy . Queremos recuperar el recurso Game que es el raiz de la ruta, pero filtrado por cero o varios par\u00e1metros.","title":"Controller"},{"location":"develop/step5/#service","text":"Siguiente paso, la capa de l\u00f3gica de negocio, es decir el Service , que por tanto har\u00e1 uso de un Repository . GameServiceImpl.java GameRepository.java package com.capgemini.ccsw.tutorial.game ; import java.util.List ; import javax.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import com.capgemini.ccsw.tutorial.game.model.Game ; import com.capgemini.ccsw.tutorial.game.model.GameDto ; /** * @author ccsw */ @Service @Transactional public class GameServiceImpl implements GameService { @Autowired GameRepository gameRepository ; /** * {@inheritDoc} */ @Override public List < Game > find ( String title , Long category ) { return this . gameRepository . find ( title , category ); } /** * {@inheritDoc} */ @Override public void save ( Long id , GameDto dto ) { Game game = null ; if ( id == null ) game = new Game (); else game = this . gameRepository . findById ( id ). orElse ( null ); BeanUtils . copyProperties ( dto , game , \"id\" , \"author\" , \"category\" ); this . gameRepository . save ( game ); } } package com.capgemini.ccsw.tutorial.game ; import java.util.List ; import org.springframework.data.repository.CrudRepository ; import com.capgemini.ccsw.tutorial.game.model.Game ; public interface GameRepository extends CrudRepository < Game , Long > { List < Game > find ( String title , Long category ); } Este servicio tiene dos peculiaridades, remarcadas en amarillo en la clase anterior. Por un lado tenemos la consulta, que no es un listado completo ni un listado paginado, sino que es un listado con filtros. Luego veremos como se hace eso, de momento lo dejaremos como un m\u00e9todo que recibe los dos filtros. La segunda peculiaridad es que de cliente nos est\u00e1 llegando un GameDto , que internamente tiene un AuthorDto y un CategoryDto , pero nosotros lo tenemos que traducir a entidades de BBDD. No sirve con copiar las propiedades tal cual, ya que entonces Spring lo que har\u00e1 ser\u00e1 crear un objeto nuevo y persistir ese objeto nuevo de Author y de Category . Adem\u00e1s, de cliente generalmente tan solo nos llega el ID de esos objetos hijo, y no el resto de informaci\u00f3n de la entidad. Por esos motivos lo hemos ignorado del copyProperties. Pero de alguna forma tendremos que setearle esos valores a la entidad Game . Si conocemos sus ID que es lo que generalmente llega, podemos recuperar esos objetos de BBDD y setearlos en el objeto Game . Si recuerdas las reglas b\u00e1sicas, un Repository debe pertenecer a un solo Service , por lo que en lugar de llamar a m\u00e9todos de los AuthorRepository y CategoryRepository desde nuestro GameServiceImpl , debemos llamar a m\u00e9todos expuestos en AuthorService y CategoryService , que son los que gestionan sus repositorios. Para ello necesitaremos crear esos m\u00e9todos get en los otros Services . Y ya sabes, para implementar nuevos m\u00e9todos, antes se deben hacer las pruebas jUnit. Recuerda que los test van en src/test/java AuthorServiceTest.java AuthorService.java AuthorServiceImpl.java package com.capgemini.ccsw.tutorial.author ; import static org.junit.jupiter.api.Assertions.assertEquals ; import static org.junit.jupiter.api.Assertions.assertNotNull ; import static org.junit.jupiter.api.Assertions.assertNull ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.transaction.annotation.Transactional ; import com.capgemini.ccsw.tutorial.author.model.Author ; @SpringBootTest @Transactional public class AuthorServiceTest { @Autowired private AuthorService authorService ; @Test public void getExistsAuthorIdShouldReturnAuthor () { assertNotNull ( authorService ); Long authorId = 1L ; Author author = authorService . get ( 1L ); assertNotNull ( author ); assertEquals ( authorId , author . getId ()); } @Test public void getNotExistsAuthorIdShouldReturnNull () { assertNotNull ( authorService ); Long authorId = 0 L ; Author author = authorService . get ( authorId ); assertNull ( author ); } } package com.capgemini.ccsw.tutorial.author ; import org.springframework.data.domain.Page ; import com.capgemini.ccsw.tutorial.author.model.Author ; import com.capgemini.ccsw.tutorial.author.model.AuthorDto ; import com.capgemini.ccsw.tutorial.author.model.AuthorSearchDto ; /** * @author ccsw */ public interface AuthorService { /** * Recupera un {@link com.capgemini.ccsw.tutorial.author.model.Author} a trav\u00e9s de su ID * @param id * @return */ Author get ( Long id ); /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param dto * @return */ Page < Author > findPage ( AuthorSearchDto dto ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param id * @param data */ void save ( Long id , AuthorDto data ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.ccsw.tutorial.author.model.Author} * @param id */ void delete ( Long id ); } package com.capgemini.ccsw.tutorial.author ; import javax.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.stereotype.Service ; import com.capgemini.ccsw.tutorial.author.model.Author ; import com.capgemini.ccsw.tutorial.author.model.AuthorDto ; import com.capgemini.ccsw.tutorial.author.model.AuthorSearchDto ; /** * @author ccsw */ @Service @Transactional public class AuthorServiceImpl implements AuthorService { @Autowired AuthorRepository authorRepository ; /** * {@inheritDoc} */ @Override public Author get ( Long id ) { return this . authorRepository . findById ( id ). orElse ( null ); } /** * {@inheritDoc} */ @Override public Page < Author > findPage ( AuthorSearchDto dto ) { return this . authorRepository . findAll ( dto . getPageable ()); } /** * {@inheritDoc} */ @Override public void save ( Long id , AuthorDto data ) { Author author = null ; if ( id != null ) author = this . get ( id ); else author = new Author (); BeanUtils . copyProperties ( data , author , \"id\" ); this . authorRepository . save ( author ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) { this . authorRepository . deleteById ( id ); } } Y lo mismo para categor\u00edas. CategoryServiceTest.java CategoryService.java CategoryServiceImpl.java package com.capgemini.ccsw.tutorial.category ; import static org.junit.jupiter.api.Assertions.assertEquals ; import static org.junit.jupiter.api.Assertions.assertNotNull ; import static org.junit.jupiter.api.Assertions.assertNull ; import org.junit.jupiter.api.Test ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.boot.test.context.SpringBootTest ; import org.springframework.transaction.annotation.Transactional ; import com.capgemini.ccsw.tutorial.category.model.Category ; @SpringBootTest @Transactional public class CategoryServiceTest { @Autowired private CategoryService categoryService ; @Test public void getExistsCategoryIdShouldReturnCategory () { assertNotNull ( categoryService ); Long categoryId = 1L ; Category category = categoryService . get ( 1L ); assertNotNull ( category ); assertEquals ( categoryId , category . getId ()); } @Test public void getNotExistsCategoryIdShouldReturnNull () { assertNotNull ( categoryService ); Long categoryId = 0 L ; Category category = categoryService . get ( categoryId ); assertNull ( category ); } } package com.capgemini.ccsw.tutorial.category ; import java.util.List ; import com.capgemini.ccsw.tutorial.category.model.Category ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw * */ public interface CategoryService { /** * Recupera una {@link com.capgemini.ccsw.tutorial.category.model.Category} a partir de su ID * @param id * @return */ Category get ( Long id ); /** * M\u00e9todo para recuperar todas las {@link com.capgemini.ccsw.tutorial.category.model.Category} * @return */ List < Category > findAll (); /** * M\u00e9todo para crear o actualizar una {@link com.capgemini.ccsw.tutorial.category.model.Category} * @param dto * @return */ void save ( Long id , CategoryDto dto ); /** * M\u00e9todo para borrar una {@link com.capgemini.ccsw.tutorial.category.model.Category} * @param id */ void delete ( Long id ); } package com.capgemini.ccsw.tutorial.category ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import com.capgemini.ccsw.tutorial.category.model.Category ; import com.capgemini.ccsw.tutorial.category.model.CategoryDto ; /** * @author ccsw * */ @Service public class CategoryServiceImpl implements CategoryService { @Autowired CategoryRepository categoryRepository ; /** * {@inheritDoc} */ @Override public Category get ( Long id ) { return this . categoryRepository . findById ( id ). orElse ( null ); } /** * {@inheritDoc} */ @Override public List < Category > findAll () { return ( List < Category > ) this . categoryRepository . findAll (); } /** * {@inheritDoc} */ @Override public void save ( Long id , CategoryDto dto ) { Category categoria = null ; if ( id == null ) categoria = new Category (); else categoria = this . get ( id ); categoria . setName ( dto . getName ()); this . categoryRepository . save ( categoria ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) { this . categoryRepository . deleteById ( id ); } } Clean Code A la hora de implementar m\u00e9todos nuevos, ten siempre presente el Clean Code . \u00a1No dupliques c\u00f3digo!, es muy importante de cara al futuro mantenimiento. Si en nuestro m\u00e9todo save hac\u00edamos uso de una operaci\u00f3n findById y ahora hemos creado una nueva operaci\u00f3n get , hagamos uso de esta nueva operaci\u00f3n y no repitamos el c\u00f3digo. Y ahora que ya tenemos los m\u00e9todos necesarios ya podemos implementar correctamente nuestro GameServiceImpl . GameServiceImpl.java package com.capgemini.ccsw.tutorial.game ; import java.util.List ; import javax.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import com.capgemini.ccsw.tutorial.author.AuthorService ; import com.capgemini.ccsw.tutorial.category.CategoryService ; import com.capgemini.ccsw.tutorial.game.model.Game ; import com.capgemini.ccsw.tutorial.game.model.GameDto ; /** * @author ccsw */ @Service @Transactional public class GameServiceImpl implements GameService { @Autowired GameRepository gameRepository ; @Autowired AuthorService authorService ; @Autowired CategoryService categoryService ; /** * {@inheritDoc} */ @Override public List < Game > find ( String title , Long category ) { return this . gameRepository . find ( title , category ); } /** * {@inheritDoc} */ @Override public void save ( Long id , GameDto dto ) { Game game = null ; if ( id == null ) game = new Game (); else game = this . gameRepository . findById ( id ). orElse ( null ); BeanUtils . copyProperties ( dto , game , \"id\" , \"author\" , \"category\" ); game . setAuthor ( authorService . get ( dto . getAuthor (). getId ())); game . setCategory ( categoryService . get ( dto . getCategory (). getId ())); this . gameRepository . save ( game ); } } Ahora si que tenemos la capa de l\u00f3gica de negocio terminada, podemos pasar a la siguiente capa.","title":"Service"},{"location":"develop/step5/#repository","text":"Y llegamos a la \u00faltima capa donde, si recordamos, ten\u00edamos un m\u00e9todo find que recibe dos par\u00e1metros. Algo as\u00ed: GameRepository.java package com.capgemini.ccsw.tutorial.game ; import java.util.List ; import org.springframework.data.repository.CrudRepository ; import com.capgemini.ccsw.tutorial.game.model.Game ; public interface GameRepository extends CrudRepository < Game , Long > { List < Game > find ( String title , Long category ); } Para esta ocasi\u00f3n, vamos a necesitar un listado filtrado por t\u00edtulo o por categor\u00eda, as\u00ed que necesitaremos pasarle esos datos y filtrar la query. Para el t\u00edtulo vamos a buscar por una cadena contenida, as\u00ed que el par\u00e1metro ser\u00e1 de tipo String , mientras que para la categor\u00eda vamos a buscar por su primary key, as\u00ed que el par\u00e1metro ser\u00e1 de tipo Long . Existen varias estrategias para abordar esta implementaci\u00f3n. Podr\u00edamos utilizar los QueryMethods para que Spring JPA haga su magia, pero en esta ocasi\u00f3n ser\u00eda bastante complicado encontrar un predicado correcto. Tambi\u00e9n podr\u00edamos hacer una implementaci\u00f3n de la interface y hacer la consulta directamente con Criteria. Pero en esta ocasi\u00f3n vamos a utilizar otra magia que nos ofrece Spring JPA y es utilizar la anotaci\u00f3n @Query . Esta anotaci\u00f3n nos permite definir una consulta en SQL nativo o en JPQL (Java Persistence Query Language) y Spring JPA se encargar\u00e1 de realizar todo el mapeo y conversi\u00f3n de los datos de entrada y salida. Veamos un ejemplo y luego lo explicamos en detalle: GameRepository.java package com.capgemini.ccsw.tutorial.game ; import java.util.List ; import org.springframework.data.repository.CrudRepository ; import com.capgemini.ccsw.tutorial.game.model.Game ; public interface GameRepository extends CrudRepository < Game , Long > { @Query ( \"select g from Game g where (:title is null or g.title like '%'||:title||'%') and (:category is null or g.category.id = :category)\" ) List < Game > find ( @Param ( \"title\" ) String title , @Param ( \"category\" ) Long category ); } Si te fijas en las dos l\u00edneas que hemos modificado, por un lado hemos puesto nombre a los par\u00e1metros de entrada con la anotaci\u00f3n @Param. Esto solo nos sirve para poder utilizar los parametros dentro de la query. Por otro lado, hemos creado una query en un lenguaje similar a SQL, pero en lugar de hacer uso de tablas y columnas, hacemos uso de objetos entity y propiedades. Dentro del where hemos puesto las dos condiciones, o bien que el par\u00e1metro t\u00edtulo sea nulo o bien si no es nulo, que la propiedad contenga el texto del par\u00e1metro t\u00edtulo. Para categor\u00eda hemos hecho lo mismo. Con esta quuery, Spring JPA generar\u00e1 el SQL correcto y mapear\u00e1 los resultados a un listado de Game que es lo que queremos obtener. Es otra forma, bastante sencilla de implementar consultas a BBDD.","title":"Repository"},{"location":"develop/step5/#prueba-de-las-operaciones","text":"Si ahora ejecutamos de nuevo los jUnits, vemos que todos los que hemos desarrollado en GameTest ya funcionan correctamente, e incluso el resto de test de la aplicaci\u00f3n tambi\u00e9n funcionan correctamente. Pruebas jUnit Cada vez que desarrollemos un caso de uso nuevo, debemos relanzar todas las pruebas autom\u00e1ticas que tenga la aplicaci\u00f3n. Es muy com\u00fan que al implementar alg\u00fan desarrollo nuevo, interfiramos de alguna forma en el funcionamiento de otra funcionalidad. Si lanzamos toda la bater\u00eda de pruebas, nos daremos cuenta si algo ha dejado de funcionar y podremos solucionarlo antes de llevar ese error a Producci\u00f3n. Las pruebas jUnit son nuestra red de seguridad. Adem\u00e1s de las pruebas autom\u00e1ticas, podemos ver como se comporta la aplicaci\u00f3n y que respuesta nos ofrece, lanzando peticiones Rest con Postman, como hemos hecho en los casos anteriores. As\u00ed que podemos levantar la aplicaci\u00f3n y lanzar las operaciones: GET http://localhost:8080/game GET http://localhost:8080/game?title=xxx GET http://localhost:8080/game?idCategory=xxx Nos devuelve un listado filtrado de Game . F\u00edjate bien en la petici\u00f3n donde env\u00edamos los filtros y la respuesta que tiene los objetos Category y Author inclu\u00eddos. PUT http://localhost:8080/game PUT http://localhost:8080/game/{id} { \"title\": \"Nuevo juego\", \"age\": \"18\", \"category\": { \"id\": 3 }, \"author\": { \"id\": 1 } } Nos sirve para insertar un Game nuevo (si no tienen el id informado) o para actualizar un Game (si tienen el id informado). F\u00edjate que para enlazar Category y Author tan solo hace falta el id de cada no de ellos, ya que en el m\u00e9todo save se hace una consulta get para recuperarlos por su id. Adem\u00e1s que no tendr\u00eda sentido enviar toda la informaci\u00f3n de esas entidades ya que no est\u00e1s dando de alta una Category ni un Author . Rendimiento en las consultas JPA En este punto te recomiendo que visites el Anexo. Funcionamiento JPA para conocer un poco m\u00e1s como funciona por dentro JPA y alg\u00fan peque\u00f1o truco que puede mejorar el rendimiento.","title":"Prueba de las operaciones"},{"location":"develop/step5/#implementar-listado-autores","text":"Antes de poder conectar front con back, si recuerdas, en la edici\u00f3n de un Game , nos hac\u00eda falta un listado de Author y un listado de Category . El segundo ya lo tenemos ya que lo reutilizaremos del listado de categor\u00edas que implementamos. Pero el primero no lo tenemos, porque en la pantalla que hicimos, se mostraban de forma paginada. As\u00ed que necesitamos implementar esa funcionalidad, y como siempre vamos de la capa de testing hacia las siguientes capas. Deber\u00edamos a\u00f1adir los siguientes m\u00e9todos: AuthorTest.java AuthorController.java AuthorService.java AuthorServiceImpl.java ... @Test public void findAllShouldReturnAllAuthorInDB () { assertNotNull ( authorController ); List < AuthorDto > authors = authorController . findAll (); assertNotNull ( authors ); assertEquals ( TOTAL_AUTORS , authors . size ()); } ... ... /** * Recupera un listado de autores * @return */ @RequestMapping ( path = \"\" , method = RequestMethod . GET ) public List < AuthorDto > findAll () { List < Author > authors = this . authorService . findAll (); return this . beanMapper . mapList ( authors , AuthorDto . class ); } ... ... /** * Recupera un listado de autores * @return */ List < Author > findAll (); ... ... /** * {@inheritDoc} */ @Override public List < Author > findAll () { return ( List < Author > ) this . authorRepository . findAll (); } ... Ahora s\u00ed, todo listo para seguir al siguiente punto.","title":"Implementar listado Autores"},{"location":"develop/step5/#conectar-front-con-back","text":"Una vez implementado front y back, lo que nos queda es modificar el servicio del front para que conecte directamente con las operaciones ofrecidas por el back. author-service.ts game-service.ts import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Pageable } from '../core/model/page/Pageable' ; import { Author } from './model/Author' ; import { AuthorPage } from './model/AuthorPage' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor ( private http : HttpClient ) { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return this . http . post < AuthorPage > ( 'http://localhost:8080/author' , { pageable : pageable }); } saveAuthor ( author : Author ) : Observable < void > { let url = 'http://localhost:8080/author' ; if ( author . id != null ) url += '/' + author . id ; return this . http . put < void > ( url , author ); } deleteAuthor ( idAuthor : number ) : Observable < void > { return this . http . delete < void > ( 'http://localhost:8080/author/' + idAuthor ); } getAllAuthors () : Observable < Author [] > { return this . http . get < Author [] > ( 'http://localhost:8080/author' ); } } import { HttpClient } from '@angular/common/http' ; import { Injectable } from '@angular/core' ; import { Observable , of } from 'rxjs' ; import { Game } from './model/Game' ; @Injectable ({ providedIn : 'root' }) export class GameService { constructor ( private http : HttpClient ) { } getGames ( title? : String , categoryId? : number ) : Observable < Game [] > { return this . http . get < Game [] > ( this . composeFindUrl ( title , categoryId )); } saveGame ( game : Game ) : Observable < void > { let url = 'http://localhost:8080/game' ; if ( game . id != null ) { url += '/' + game . id ; } return this . http . put < void > ( url , game ); } private composeFindUrl ( title? : String , categoryId? : number ) : string { let params = '' ; if ( title != null ) { params += 'title=' + title ; } if ( categoryId != null ) { if ( params != '' ) params += \"&\" ; params += \"idCategory=\" + categoryId ; } let url = 'http://localhost:8080/game' if ( params == '' ) return url ; else return url + '?' + params ; } } Y ahora si, podemos navegar por la web y ver el resultado completo.","title":"Conectar front con back"},{"location":"develop/step6/","text":"Validaciones Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n. Validaciones en Angular Validaciones en Springboot","title":"Anexo. Validaciones (TBC)"},{"location":"develop/step6/#validaciones","text":"Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n.","title":"Validaciones"},{"location":"develop/step6/#validaciones-en-angular","text":"","title":"Validaciones en Angular"},{"location":"develop/step6/#validaciones-en-springboot","text":"","title":"Validaciones en Springboot"},{"location":"develop/step7/","text":"Seguridad Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n.","title":"Anexo. Crear Login (TBC)"},{"location":"develop/step7/#seguridad","text":"Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n.","title":"Seguridad"}]}