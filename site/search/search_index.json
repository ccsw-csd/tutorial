{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bienvenido! Si est\u00e1s leyendo esto es porque tienes mucha fuerza de voluntad y unas enormes ganas de aprender a desarrollar con el stack tecnol\u00f3gico de devonfw (Java Spring Boot + Angular) o porque te han mandando hacer este tutorial en tu etapa de formaci\u00f3n. En cualquier caso, te agradecemos el esfuerzo que est\u00e1s haciendo y te deseamos suerte . Por favor, si detectas que hay algo incorrecto en el tutorial, que no funciona o que est\u00e1 mal escrito, contacta con nosotros para que podamos solventarlo para futuras lecturas. Env\u00edanos un issue aqu\u00ed . \u00bfQue vamos a hacer? Durante este tutorial, vamos a crear una aplicaci\u00f3n web paso a paso con Spring Boot para la parte servidora y con Angular para la parte frontal. Intentar\u00e9 comentar todo lo m\u00e1s detallado posible, pero si echas en falta alguna explicaci\u00f3n por favor, escr\u00edbenos un issue aqu\u00ed para que podamos a\u00f1adirla. \u00bfComo lo vamos a hacer? En primer lugar te comentar\u00e9 brevemente las herramientas que usaremos en el tutorial y la forma de instalarlas (altamente recomendado). Luego veremos un vistazo general de lo que vamos a construir para que tengas un contexto general de la aplicaci\u00f3n. Y por \u00faltimo desarrollaremos paso a paso el back y el front de la aplicaci\u00f3n. Durante todo el tutorial intentar\u00e9 dar unas pautas y consejos de buenas pr\u00e1cticas que todos deber\u00edamos adoptar, en la medida de lo posible, para homogeneizar el desarrollo de todos los proyectos. \u00bfY luego qu\u00e9? Pues al final del tutorial, expondremos unos ejercicios pr\u00e1cticos para que los resuelvas tu mismo, aplicando los conocimientos adquiridos en el tutorial. Para ver si has comprendido correctamente todo lo aqu\u00ed descrito. No te preocupes, no es un examen","title":"Bienvenido!"},{"location":"#bienvenido","text":"Si est\u00e1s leyendo esto es porque tienes mucha fuerza de voluntad y unas enormes ganas de aprender a desarrollar con el stack tecnol\u00f3gico de devonfw (Java Spring Boot + Angular) o porque te han mandando hacer este tutorial en tu etapa de formaci\u00f3n. En cualquier caso, te agradecemos el esfuerzo que est\u00e1s haciendo y te deseamos suerte . Por favor, si detectas que hay algo incorrecto en el tutorial, que no funciona o que est\u00e1 mal escrito, contacta con nosotros para que podamos solventarlo para futuras lecturas. Env\u00edanos un issue aqu\u00ed .","title":"Bienvenido!"},{"location":"#que-vamos-a-hacer","text":"Durante este tutorial, vamos a crear una aplicaci\u00f3n web paso a paso con Spring Boot para la parte servidora y con Angular para la parte frontal. Intentar\u00e9 comentar todo lo m\u00e1s detallado posible, pero si echas en falta alguna explicaci\u00f3n por favor, escr\u00edbenos un issue aqu\u00ed para que podamos a\u00f1adirla.","title":"\u00bfQue vamos a hacer?"},{"location":"#como-lo-vamos-a-hacer","text":"En primer lugar te comentar\u00e9 brevemente las herramientas que usaremos en el tutorial y la forma de instalarlas (altamente recomendado). Luego veremos un vistazo general de lo que vamos a construir para que tengas un contexto general de la aplicaci\u00f3n. Y por \u00faltimo desarrollaremos paso a paso el back y el front de la aplicaci\u00f3n. Durante todo el tutorial intentar\u00e9 dar unas pautas y consejos de buenas pr\u00e1cticas que todos deber\u00edamos adoptar, en la medida de lo posible, para homogeneizar el desarrollo de todos los proyectos.","title":"\u00bfComo lo vamos a hacer?"},{"location":"#y-luego-que","text":"Pues al final del tutorial, expondremos unos ejercicios pr\u00e1cticos para que los resuelvas tu mismo, aplicando los conocimientos adquiridos en el tutorial. Para ver si has comprendido correctamente todo lo aqu\u00ed descrito. No te preocupes, no es un examen","title":"\u00bfY luego qu\u00e9?"},{"location":"cleancode/","text":"Estructura de proyecto y Clean Code Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n. Angular Nota Antes de empezar y para puntualizar, Angular se considera un framework SPA Single-page application. En esta parte vamos a explicar los fundamentos de un proyecto en Angular y las recomendaciones existentes. Estructura y funcionamiento Ciclo de vida de Angular El comportamiento de ciclo de vida de un componente Angular pasa por diferentes etapas que podemos ver en el esquema que mostramos a continuaci\u00f3n: Es importante tenerlo claro para saber que m\u00e9todos podemos utilizar para realizar operaciones con el componente. Carpetas creadas por Angular Al crear una aplicaci\u00f3n Angular, tendremos los siguientes directorios: node_modules: Todos los m\u00f3dulos de librar\u00edas usado por el proyecto. \\src\\app: Contiene todo el c\u00f3digo asociado al proyecto. \\src\\assets: Normalmente la carpeta usada para los recursos. \\src\\environments: Aqu\u00ed ir\u00e1n los ficheros relacionados con los entornos de desarrollos. Otros ficheros importantes de un proyecto de Angular Otros archivos que debemos tener en cuenta dentro del proyecto son: angular.json: Configuraci\u00f3n del propio CLI. La madre de todos los configuradores package.json: Dependencias de librer\u00edas y scripts Estructura de m\u00f3dulos Existe m\u00faltiples consensos al respecto de como estructurar un proyecto en Angular, pero al final, depende de los requisitos del proyecto. Una sugerencia de como hacerlo es la siguiente: - src\\app - shared /* Componentes y utilidades comunes */ - core /* Componentes core como autenticaci\u00f3n y layout */ - header /* Estructura del header */ - footer /* Estructura del footer */ - services /* Servicios de acceso a operaciones Rest */ - models /* Modelos de datos para componentes y servicios */ Recordar, que esto es una sugerencia para una estructura de carpetas y componentes. No existe un estandar. ATENCI\u00d3N: Componentes gen\u00e9ricos Debemos tener en cuenta que a la hora de programar un componente shared , lo ideal es pensar que sea un componente plug & play, es decir que si lo copias y lo llevas a otro proyecto funcione sin la necesidad de adaptarlo. Buenas pr\u00e1cticas y Clean Code A continuaci\u00f3n veremos un listado de buenas pr\u00e1cticas de Angular y de c\u00f3digo limpio que deber\u00edamos intentar seguir en nuestro desarrollo. Estructura de archivos Antes de empezar con un proyecto lo ideal, es pararse y pensar en los requerimientos de una buena estructura, en un futuro lo agradecer\u00e1s. Nombres claros Utilizar la S de los principios S.O.L.I.D para los nombres de variables, m\u00e9todos y dem\u00e1s c\u00f3digo. El efecto que produce este principio son clases con nombres muy descriptivos y por tanto largos. Tambi\u00e9n se recomienta utilizar kebab-case para los nombres de ficheros. Ej. hero-button.component.ts Organiza tu c\u00f3digo Intenta organizar tu c\u00f3digo fuente: Lo m\u00e1s importante debe ir arriba. Primero propiedades, despu\u00e9s m\u00e9todos. Un Item para un archivo : cada archivo deber\u00eda contener solamente un componente, al igual que los servicios. Solo una responsabilidad : Cada clase o modulo deber\u00eda tener solamente una responsabilidad. El nombre correcto : las propiedades y m\u00e9todos deber\u00edan usar el sistema de camel case (ej: getUserByName) , al contrario, las clases (componentes, servicios, etc) deben usar upper camel case (ej: UserComponent) . Los componentes y servicios deben tener su respectivo sufijo: UserComponent, UserService. Imports : los archivos externos van primero. Usar linters Prettier & ESLint Un linter es una herramienta que nos ayuda a seguir las buenas pr\u00e1cticas o gu\u00edas de estilo de nuestro c\u00f3digo fuente. En este caso, para JavaScript, proveeremos de unos muy famosos. Una de las m\u00e1s famosas es la combinaci\u00f3n de Angular app to ESLint with Prettier, AirBnB Styleguide Recordar que a\u00f1adir este tipo de configuraci\u00f3n es opcional, pero necesaria para tener un buen c\u00f3digo de calidad. Git Hooks Los Git Hooks son scripts de shell que se ejecutan autom\u00e1ticamente antes o despu\u00e9s de que Git ejecute un comando importante como Commit o Push. Para hacer uso de el es tan sencillo como: npm install husky --save-dev Y a\u00f1adir en el fichero lo siguiente: // package.json { \"husky\" : { \"hooks\" : { \"pre-commit\" : \"npm test\" , \"pre-push\" : \"npm test\" , \"...\" : \"...\" } } } Usar husky para el preformateo de c\u00f3digo antes de subirlo Es una buena pr\u00e1ctica que todo el equipo use el mismo est\u00e1ndar de formateo de codigo, con husky se puede solucionar. Utilizar Banana in the Box Como el nombre sugiere banana in the box se debe a la forma que tiene lo siguiente: [{}] Esto es una forma muy sencilla de trabajar los cambios en la forma de Two ways binding. Es decir, el padre informa de un valor u objeto y el hijo lo manipula y actualiza el estado/valor al padre inmediatamente. La forma de implementarlo es sencillo Padre: HTML: <my-input [(text)]=\"text\"></my-input> Hijo @ Input () value : string ; @ Output () valueChange = new EventEmitter < string > (); updateValue ( value ){ this . value = value ; this . valueChange . emit ( value ); } Prefijo Change Destacar que el prefijo 'Change' es necesario incluirlo en el Hijo para que funcione Correcto uso de los servicios Una buena practica es aconsejable no declarar los servicios en el provides, sino usar un decorador que forma parte de las ultimas versiones de Angular @ Injectable ({ providedIn : 'root' , }) export class HeroService { constructor () { } } Lazy Load Lazy Load es un patr\u00f3n de dise\u00f1o que consiste en retrasar la carga o inicializaci\u00f3n desde el app-routing.module.ts A\u00f1adiremos un codigo parecido a este { path : 'customers' , loadChildren : () => import ( './customers/customers.module' ). then ( m => m . CustomersModule ) }, Con esto veremos que el m\u00f3dulo se cargar\u00e1 seg\u00fan se necesite. Springboot Estructura Aqu\u00ed tampoco existe nada estandarizado y oficial que hable sobre estructura de proyectos y nomenclatura de Springboot. Tan solo existen algunas sugerencias y buenas pr\u00e1cticas a la hora de desarrollar que te recomiendo que utilices en la medida de lo posible. Tip Piensa que el c\u00f3digo fuente que escribes hoy, es como un libro que se leer\u00e1 durante a\u00f1os. Alguien tendr\u00e1 que coger tu c\u00f3digo y leerlo en unos meses o a\u00f1os para hacer alguna modificaci\u00f3n y, como buenos desarrolladores que somos, tenemos la obligaci\u00f3n de facilitarle en todo lo posible la comprensi\u00f3n de ese c\u00f3digo fuente. Quiz\u00e1 esa persona futura podr\u00edas ser tu en unos meses y quedar\u00eda muy mal que no entendieras ni tu propio c\u00f3digo Estructura en capas Todos los proyectos web que construimos basados en Springboot se caracterizan por estar divididos en tres capas (a menos que utilicemos DDD para desarrollar que entonces existen infinitas capas ). Controlador . Es la capa m\u00e1s alta, la que tiene acceso directo con el cliente. En esta capa es donde se exponen las operaciones que queremos publicar y que el cliente puede consumir. Para realizar sus operaciones lo m\u00e1s normal es que realice llamadas a las clases de la capa inmediatamente inferior. L\u00f3gica . Tambi\u00e9n llamada capa de Servicios . Es la capa intermedia que da soporte a las operaciones que est\u00e1n expuestas y ejecutan toda la l\u00f3gica de negocio de la aplicaci\u00f3n. Para realizar sus operaciones puede realizar llamadas tanto a otras clases dentro de esta capa, como a clases de la capa inferior. Acceso a Datos . Como su nombre indica, es la capa que accede a datos. T\u00edpicamente es la capa que ejecuta las consultas contra BBDD, pero esto no tiene por qu\u00e9 ser obligadamente as\u00ed. Tambi\u00e9n entrar\u00edan en esa capa aquellas clases que consumen datos externos, por ejemplo de un servidor externo. Las clases de esta capa deben ser nodos finales , no pueden llamar a ninguna otra clase para ejecutar sus operaciones, ni siquiera de su misma capa. Estructura de proyecto En proyectos medianos o grandes, estructurar los directorios del proyecto en base a la estructura anteriormente descrita ser\u00eda muy complejo, ya que en cada uno de los niveles tendr\u00edamos muchas clases. Otras entidades Consejos sobre la estructura En base a esta divisi\u00f3n por capas que hemos comentado y el resto de entidades implicadas, hay una serie de reglas important\u00edsimas que debes seguir muy de cerca: Un Controlador NO debe contener l\u00f3gica en su clase. Solo est\u00e1 permitido que ejecute l\u00f3gica a trav\u00e9s de un objeto de la capa L\u00f3gica . NO puede ejecutar directamente operaciones de la capa Aceso a Datos , siempre debe pasar por la capa L\u00f3gica . NO debe enviar ni recibir del cliente objetos de tipo Entity . Es un buen lugar para realizar las conversiones de datos entre Entity y Dto . En teor\u00eda cada operaci\u00f3n deber\u00eda tener su propio Dto, aunque los podemos reutilizar entre operaciones similares. Debemos seguir una coherencia entre todas las URL de las operaciones. Por ejemplo si elegimos save para guardar, usemos esa palabra en todas las operaciones que sean de ese tipo. Evitad utilizar diferentes palabras save , guardar , persistir , actualizar para la misma acci\u00f3n. Un Servicio NO puede llamar a objetos de la la capa Controlador . Puede","title":"Estructura y Clean Code"},{"location":"cleancode/#estructura-de-proyecto-y-clean-code","text":"Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n.","title":"Estructura de proyecto y Clean Code"},{"location":"cleancode/#angular","text":"Nota Antes de empezar y para puntualizar, Angular se considera un framework SPA Single-page application. En esta parte vamos a explicar los fundamentos de un proyecto en Angular y las recomendaciones existentes.","title":"Angular"},{"location":"cleancode/#estructura-y-funcionamiento","text":"","title":"Estructura y funcionamiento"},{"location":"cleancode/#ciclo-de-vida-de-angular","text":"El comportamiento de ciclo de vida de un componente Angular pasa por diferentes etapas que podemos ver en el esquema que mostramos a continuaci\u00f3n: Es importante tenerlo claro para saber que m\u00e9todos podemos utilizar para realizar operaciones con el componente.","title":"Ciclo de vida de Angular"},{"location":"cleancode/#carpetas-creadas-por-angular","text":"Al crear una aplicaci\u00f3n Angular, tendremos los siguientes directorios: node_modules: Todos los m\u00f3dulos de librar\u00edas usado por el proyecto. \\src\\app: Contiene todo el c\u00f3digo asociado al proyecto. \\src\\assets: Normalmente la carpeta usada para los recursos. \\src\\environments: Aqu\u00ed ir\u00e1n los ficheros relacionados con los entornos de desarrollos. Otros ficheros importantes de un proyecto de Angular Otros archivos que debemos tener en cuenta dentro del proyecto son: angular.json: Configuraci\u00f3n del propio CLI. La madre de todos los configuradores package.json: Dependencias de librer\u00edas y scripts","title":"Carpetas creadas por Angular"},{"location":"cleancode/#estructura-de-modulos","text":"Existe m\u00faltiples consensos al respecto de como estructurar un proyecto en Angular, pero al final, depende de los requisitos del proyecto. Una sugerencia de como hacerlo es la siguiente: - src\\app - shared /* Componentes y utilidades comunes */ - core /* Componentes core como autenticaci\u00f3n y layout */ - header /* Estructura del header */ - footer /* Estructura del footer */ - services /* Servicios de acceso a operaciones Rest */ - models /* Modelos de datos para componentes y servicios */ Recordar, que esto es una sugerencia para una estructura de carpetas y componentes. No existe un estandar. ATENCI\u00d3N: Componentes gen\u00e9ricos Debemos tener en cuenta que a la hora de programar un componente shared , lo ideal es pensar que sea un componente plug & play, es decir que si lo copias y lo llevas a otro proyecto funcione sin la necesidad de adaptarlo.","title":"Estructura de m\u00f3dulos"},{"location":"cleancode/#buenas-practicas-y-clean-code","text":"A continuaci\u00f3n veremos un listado de buenas pr\u00e1cticas de Angular y de c\u00f3digo limpio que deber\u00edamos intentar seguir en nuestro desarrollo.","title":"Buenas pr\u00e1cticas y Clean Code"},{"location":"cleancode/#estructura-de-archivos","text":"Antes de empezar con un proyecto lo ideal, es pararse y pensar en los requerimientos de una buena estructura, en un futuro lo agradecer\u00e1s.","title":"Estructura de archivos"},{"location":"cleancode/#nombres-claros","text":"Utilizar la S de los principios S.O.L.I.D para los nombres de variables, m\u00e9todos y dem\u00e1s c\u00f3digo. El efecto que produce este principio son clases con nombres muy descriptivos y por tanto largos. Tambi\u00e9n se recomienta utilizar kebab-case para los nombres de ficheros. Ej. hero-button.component.ts","title":"Nombres claros"},{"location":"cleancode/#organiza-tu-codigo","text":"Intenta organizar tu c\u00f3digo fuente: Lo m\u00e1s importante debe ir arriba. Primero propiedades, despu\u00e9s m\u00e9todos. Un Item para un archivo : cada archivo deber\u00eda contener solamente un componente, al igual que los servicios. Solo una responsabilidad : Cada clase o modulo deber\u00eda tener solamente una responsabilidad. El nombre correcto : las propiedades y m\u00e9todos deber\u00edan usar el sistema de camel case (ej: getUserByName) , al contrario, las clases (componentes, servicios, etc) deben usar upper camel case (ej: UserComponent) . Los componentes y servicios deben tener su respectivo sufijo: UserComponent, UserService. Imports : los archivos externos van primero.","title":"Organiza tu c\u00f3digo"},{"location":"cleancode/#usar-linters-prettier-eslint","text":"Un linter es una herramienta que nos ayuda a seguir las buenas pr\u00e1cticas o gu\u00edas de estilo de nuestro c\u00f3digo fuente. En este caso, para JavaScript, proveeremos de unos muy famosos. Una de las m\u00e1s famosas es la combinaci\u00f3n de Angular app to ESLint with Prettier, AirBnB Styleguide Recordar que a\u00f1adir este tipo de configuraci\u00f3n es opcional, pero necesaria para tener un buen c\u00f3digo de calidad.","title":"Usar linters Prettier &amp; ESLint"},{"location":"cleancode/#git-hooks","text":"Los Git Hooks son scripts de shell que se ejecutan autom\u00e1ticamente antes o despu\u00e9s de que Git ejecute un comando importante como Commit o Push. Para hacer uso de el es tan sencillo como: npm install husky --save-dev Y a\u00f1adir en el fichero lo siguiente: // package.json { \"husky\" : { \"hooks\" : { \"pre-commit\" : \"npm test\" , \"pre-push\" : \"npm test\" , \"...\" : \"...\" } } } Usar husky para el preformateo de c\u00f3digo antes de subirlo Es una buena pr\u00e1ctica que todo el equipo use el mismo est\u00e1ndar de formateo de codigo, con husky se puede solucionar.","title":"Git Hooks"},{"location":"cleancode/#utilizar-banana-in-the-box","text":"Como el nombre sugiere banana in the box se debe a la forma que tiene lo siguiente: [{}] Esto es una forma muy sencilla de trabajar los cambios en la forma de Two ways binding. Es decir, el padre informa de un valor u objeto y el hijo lo manipula y actualiza el estado/valor al padre inmediatamente. La forma de implementarlo es sencillo Padre: HTML: <my-input [(text)]=\"text\"></my-input> Hijo @ Input () value : string ; @ Output () valueChange = new EventEmitter < string > (); updateValue ( value ){ this . value = value ; this . valueChange . emit ( value ); } Prefijo Change Destacar que el prefijo 'Change' es necesario incluirlo en el Hijo para que funcione","title":"Utilizar Banana in the Box"},{"location":"cleancode/#correcto-uso-de-los-servicios","text":"Una buena practica es aconsejable no declarar los servicios en el provides, sino usar un decorador que forma parte de las ultimas versiones de Angular @ Injectable ({ providedIn : 'root' , }) export class HeroService { constructor () { } }","title":"Correcto uso de los servicios"},{"location":"cleancode/#lazy-load","text":"Lazy Load es un patr\u00f3n de dise\u00f1o que consiste en retrasar la carga o inicializaci\u00f3n desde el app-routing.module.ts A\u00f1adiremos un codigo parecido a este { path : 'customers' , loadChildren : () => import ( './customers/customers.module' ). then ( m => m . CustomersModule ) }, Con esto veremos que el m\u00f3dulo se cargar\u00e1 seg\u00fan se necesite.","title":"Lazy Load"},{"location":"cleancode/#springboot","text":"","title":"Springboot"},{"location":"cleancode/#estructura","text":"Aqu\u00ed tampoco existe nada estandarizado y oficial que hable sobre estructura de proyectos y nomenclatura de Springboot. Tan solo existen algunas sugerencias y buenas pr\u00e1cticas a la hora de desarrollar que te recomiendo que utilices en la medida de lo posible. Tip Piensa que el c\u00f3digo fuente que escribes hoy, es como un libro que se leer\u00e1 durante a\u00f1os. Alguien tendr\u00e1 que coger tu c\u00f3digo y leerlo en unos meses o a\u00f1os para hacer alguna modificaci\u00f3n y, como buenos desarrolladores que somos, tenemos la obligaci\u00f3n de facilitarle en todo lo posible la comprensi\u00f3n de ese c\u00f3digo fuente. Quiz\u00e1 esa persona futura podr\u00edas ser tu en unos meses y quedar\u00eda muy mal que no entendieras ni tu propio c\u00f3digo","title":"Estructura"},{"location":"cleancode/#estructura-en-capas","text":"Todos los proyectos web que construimos basados en Springboot se caracterizan por estar divididos en tres capas (a menos que utilicemos DDD para desarrollar que entonces existen infinitas capas ). Controlador . Es la capa m\u00e1s alta, la que tiene acceso directo con el cliente. En esta capa es donde se exponen las operaciones que queremos publicar y que el cliente puede consumir. Para realizar sus operaciones lo m\u00e1s normal es que realice llamadas a las clases de la capa inmediatamente inferior. L\u00f3gica . Tambi\u00e9n llamada capa de Servicios . Es la capa intermedia que da soporte a las operaciones que est\u00e1n expuestas y ejecutan toda la l\u00f3gica de negocio de la aplicaci\u00f3n. Para realizar sus operaciones puede realizar llamadas tanto a otras clases dentro de esta capa, como a clases de la capa inferior. Acceso a Datos . Como su nombre indica, es la capa que accede a datos. T\u00edpicamente es la capa que ejecuta las consultas contra BBDD, pero esto no tiene por qu\u00e9 ser obligadamente as\u00ed. Tambi\u00e9n entrar\u00edan en esa capa aquellas clases que consumen datos externos, por ejemplo de un servidor externo. Las clases de esta capa deben ser nodos finales , no pueden llamar a ninguna otra clase para ejecutar sus operaciones, ni siquiera de su misma capa.","title":"Estructura en capas"},{"location":"cleancode/#estructura-de-proyecto","text":"En proyectos medianos o grandes, estructurar los directorios del proyecto en base a la estructura anteriormente descrita ser\u00eda muy complejo, ya que en cada uno de los niveles tendr\u00edamos muchas clases.","title":"Estructura de proyecto"},{"location":"cleancode/#otras-entidades","text":"","title":"Otras entidades"},{"location":"cleancode/#consejos-sobre-la-estructura","text":"En base a esta divisi\u00f3n por capas que hemos comentado y el resto de entidades implicadas, hay una serie de reglas important\u00edsimas que debes seguir muy de cerca: Un Controlador NO debe contener l\u00f3gica en su clase. Solo est\u00e1 permitido que ejecute l\u00f3gica a trav\u00e9s de un objeto de la capa L\u00f3gica . NO puede ejecutar directamente operaciones de la capa Aceso a Datos , siempre debe pasar por la capa L\u00f3gica . NO debe enviar ni recibir del cliente objetos de tipo Entity . Es un buen lugar para realizar las conversiones de datos entre Entity y Dto . En teor\u00eda cada operaci\u00f3n deber\u00eda tener su propio Dto, aunque los podemos reutilizar entre operaciones similares. Debemos seguir una coherencia entre todas las URL de las operaciones. Por ejemplo si elegimos save para guardar, usemos esa palabra en todas las operaciones que sean de ese tipo. Evitad utilizar diferentes palabras save , guardar , persistir , actualizar para la misma acci\u00f3n. Un Servicio NO puede llamar a objetos de la la capa Controlador . Puede","title":"Consejos sobre la estructura"},{"location":"create/","text":"Creaci\u00f3n de proyecto Por lo general necesitaremos un m\u00ednimo de dos proyectos para desarrollar una aplicaci\u00f3n: Por un lado tendremos un proyecto Springboot que se ejecutar\u00e1 en un servidor de aplicaciones, tipo Tomcat. Este proyecto tendr\u00e1 la l\u00f3gica de negocio de las operaciones, el acceso a los datos de la BBDD y cualquier integraci\u00f3n con servicios de terceros. La forma de exponer estas operaciones de negocio ser\u00e1 mediante endpoints de acceso, en concreto llamadas tipo REST. Por otro lado tendremos un proyecto Angular que se ejecutar\u00e1 en un servidor web de ficheros est\u00e1ticos, tipo Apache. Este proyecto ser\u00e1 c\u00f3digo javascript, css y html, que se ejecutar\u00e1 en el navegador Web y que realizar\u00e1 ciertas operaciones sencillas y validaciones en local y llamadas a nuestro servidor Springboot para ejecutar las operaciones de negocio. Puede haber otro tipo de proyectos dentro de la aplicaci\u00f3n, sobretodo si est\u00e1n basados en microservicios o tienen componentes batch, pero estos tipos los veremos en el tutorial. Consejo Como norma cada uno de los proyectos que componen la aplicaci\u00f3n, deber\u00eda estar conectado a un repositorio de c\u00f3digo diferente para poder evolucionar y trabajar con cada uno de ellos de forma aislada sin afectar a los dem\u00e1s. As\u00ed adem\u00e1s podemos tener equipos aislados que trabajen con cada uno de los proyectos por separado. Info Durante todo el tutorial, voy a intentar separar la construcci\u00f3n del proyecto Angular de la construcci\u00f3n del proyecto Springboot, para terminar haciendo una integraci\u00f3n entre los dos. De esta forma podr\u00e1s comprobar como se puede desarrollar por separado cada uno de los dos proyectos sin ning\u00fan problema. Creaci\u00f3n de proyecto Angular La mayor\u00eda de los proyectos con Angular en los que trabajamos normalmente, suelen ser proyectos web usando las librer\u00edas mas comunes de angular, como angular material. Para crear un proyecto de Angular, es necesario tener instalado el CLI de Angular. Si no lo tienes instalado, por favor, acude a la secci\u00f3n Entorno de desarrollo y verifica que tienes instalado todo lo necesario. Nuevo proyecto Lo primero es crear un proyecto desde la consola mediante la herramienta Angular CLI. Para ello abrimos una consola, nos situamos en el directorio donde vamos a crear el proyecto y ejecutamos: ng new tutorial Nos realizar\u00e1 varias preguntas. Would you like to add Angular routing? (y/N) Preferiblemente: y Which stylesheet format would you like to use? Preferiblemente: SCSS En el caso del tutorial como vamos a tener dos proyectos para nuestra aplicaci\u00f3n (front y back), para poder seguir correctamente las explicaciones, voy a renombrar la carpeta para poder diferenciarla del otro proyecto. A partir de ahora se llamar\u00e1 front . Info Si durante el desarrollo del proyecto necesitas a\u00f1adir nuevos m\u00f3dulos al proyecto Angular, ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor yarn (que es m\u00e1s eficiente que el propio gestio de npm), directamente en consola ejecuta el comando yarn y descargar\u00e1 e instalar\u00e1 las nuevas dependencias. Arrancar el proyecto Para arrancar el proyecto, tan solo necesitamos ejecutar en consola el siguiente comando: ng serve Angular compilar\u00e1 el c\u00f3digo fuente, levantar\u00e1 un servidor local al que podremos acceder por defecto mediante la URL: http://localhost:4200/ Y ya podemos empezar a trabajar con Angular. Comandos de Angular CLI Si necesitas m\u00e1s informaci\u00f3n sobre los comandos que ofrece Angular CLI para poder crear aplicaciones, componentes, servicios, etc. los tienes disponibles en: https://angular.io/cli#command-overview Creaci\u00f3n de proyecto Springboot La mayor\u00eda de los proyectos Springboot en los que trabajamos normalmente, suelen ser proyectos web sencillos con pocas dependencias de terceros o incluso proyectos basados en microservicios que ejecutan pocas acciones. Creaci\u00f3n con Devonfw Podemos crear una estructura de proyecto con todas las dependencias activadas y configuradas a trav\u00e9s de devonfw . En el tutorial vamos a utilizar un proyecto simple de Springboot, pero queremos que conozcas que con devonfw tambi\u00e9n se puede crear. Si quieres saber m\u00e1s, visita el punto de Anexo en esta misma secci\u00f3n. Nota Est\u00e1 bien tener una plantilla de generaci\u00f3n de proyecto con Devonfw a modo de ejemplo donde podamos consultar, pero es mucho m\u00e1s sencillo crear una aplicaci\u00f3n vac\u00eda e ir a\u00f1adiendole las necesidades de nuestro proyecto a medida que nos vayan haciendo falta. Por eso te recomendamos que pases al punto de Spring Initializr Creaci\u00f3n con Spring Initilizr Este m\u00e9todo es mucho m\u00e1s recomendable si lo que quieres es tener un proyecto m\u00ednimo y sencillo, sin muchas dependencias. Spring Initializr Spring ha creado una p\u00e1gina interactiva que permite crear y configurar proyectos en diferentes lenguajes, con diferentes versiones de Spring Boot y a\u00f1adiendole los m\u00f3dulos que nosotros queramos. Esta p\u00e1gina est\u00e1 disponible desde Spring Initializr . Para seguir el ejemplo del tutorial, entraremos en la web y seleccionaremos los siguientes datos: Tipo de proyecto: Maven Lenguage: Java Versi\u00f3n Spring boot: 2.3.0 (o la que exista por defecto) Group: com.capgemini.coedevon ArtifactId: tutorial Versi\u00f3n Java: 8 Dependencias: Spring Web, Spring Data JPA, H2 Database y Flyway Esto nos generar\u00e1 un proyecto que ya vendr\u00e1 configurado con Spring Web, Spring Data para acceder a BBDD, y H2 junto con Flyway para crear una BBDD en memoria de ejemplo con la que trabajaremos durante el tutorial. Importar en eclipse El siguiente paso, ovbiamente es descomprimir el proyecto generado e importarlo como proyecto Maven. Abrimos el eclipse, pulsamos en File \u2192 Import y seleccionamos Existing Maven Projects . Buscamos el proyecto y le damos a importar. Configurar el proyecto En realidad el proyecto est\u00e1 configurado completamente con las propiedades por defecto que vienen en Spring boot. Tan solo para poder arrancar el proyecto nos har\u00e1 falta un fichero de creaci\u00f3n de BBDD que utiliza flyway al arrancar y ser\u00e1 necesario tenerlo disponible. Crearemos dos ficheros, de momento en blanco, dentro de src/main/resources/db/migration : V0001__Create_Schema.sql \u2192 Ser\u00e1 el fichero que utilizaremos para crear el esquema de BBDD V0002__Create_Data.sql \u2192 Ser\u00e1 el fichero que utilizaremos para rellenar con datos iniciales el esquema de BBDD Plantilla de proyecto Puedes descargarte una plantilla ya construida , con Sprint Initializr y configurada con los pasos que hemos visto en esta secci\u00f3n. Arrancar el proyecto Por \u00faltimo ya solo nos queda arrancar el proyecto creado. Para ello buscaremos la clase TutorialApplication.java y con el bot\u00f3n derecho seleccionaremos Run As \u2192 Java Application. La aplicaci\u00f3n al estar basada en Springboot arrancar\u00e1 internamente un Tomcat embebido donde se despliegar\u00e1 el proyecto. Si hab\u00e9is seguido el tutorial la aplicaci\u00f3n estar\u00e1 disponible en http://localhost:8080 , aunque de momento aun no tenemos nada accesible. Anexo. Creaci\u00f3n con Devonfw Podemos utilizar la plantilla de creaci\u00f3n que nos ofrece Devonfw a trav\u00e9s de su gu\u00eda de desarrollo. Concretamente podemos seguir estos pasos: Creating a new application . El problema que tiene esta plantilla es que genera un proyecto totalmente configurado y que tiene activadas un conjunto muy grande de librer\u00edas. La mayor\u00eda de estas librer\u00edas no las utilizaremos jam\u00e1s en ning\u00fan proyecto e incluso hay configuraci\u00f3n de seguridad que tampoco vamos a utilizar por norma general o la tendremos que modificar para adaptarla a nuestra situaci\u00f3n (proyecto, entorno, cliente, etc.). Ejecuci\u00f3n de arquetipo Aun as\u00ed, si quieres crear un proyecto con devonfw es muy sencillo, puedes seguir estos pasos: Nos situamos en la carpeta que queramos que contenga nuestro proyecto y ejecutamos una consola de comandos. Para ello hacemos clic derecho y seleccionamos la opci\u00f3n Open devonfw CMD shell here y se nos abrir\u00e1 la consola. En la consola de devon, tecleamos el siguiente comando: devon java create com.capgemini.coedevon.tutorial . Veremos como el propio framework se descarga todo lo necesario y en breves momentos tendremos todo listo. Esto nos crear\u00e1 un proyecto de devon4j, con el nombre de paquete com.capgemini.coedevon.tutorial , el id de grupo com.capgemini.coedevon , el id de artefacto tutorial , la versi\u00f3n 1.0.0-SNAPSHOT y una base de datos h2 ya preconfigurada. Una vez haya terminado, teclearemos lo siguiente: cd tutorial y nos posicionar\u00e1 sobre la carpeta ra\u00edz del proyecto. Estando en la carpeta ra\u00edz del proyecto, tecleamos lo siguiente: devon eclipse y nos arrancar\u00e1 Eclipse. O tambien puedes descargarte una plantilla ya construida de devonfw.","title":"Creaci\u00f3n de proyecto"},{"location":"create/#creacion-de-proyecto","text":"Por lo general necesitaremos un m\u00ednimo de dos proyectos para desarrollar una aplicaci\u00f3n: Por un lado tendremos un proyecto Springboot que se ejecutar\u00e1 en un servidor de aplicaciones, tipo Tomcat. Este proyecto tendr\u00e1 la l\u00f3gica de negocio de las operaciones, el acceso a los datos de la BBDD y cualquier integraci\u00f3n con servicios de terceros. La forma de exponer estas operaciones de negocio ser\u00e1 mediante endpoints de acceso, en concreto llamadas tipo REST. Por otro lado tendremos un proyecto Angular que se ejecutar\u00e1 en un servidor web de ficheros est\u00e1ticos, tipo Apache. Este proyecto ser\u00e1 c\u00f3digo javascript, css y html, que se ejecutar\u00e1 en el navegador Web y que realizar\u00e1 ciertas operaciones sencillas y validaciones en local y llamadas a nuestro servidor Springboot para ejecutar las operaciones de negocio. Puede haber otro tipo de proyectos dentro de la aplicaci\u00f3n, sobretodo si est\u00e1n basados en microservicios o tienen componentes batch, pero estos tipos los veremos en el tutorial. Consejo Como norma cada uno de los proyectos que componen la aplicaci\u00f3n, deber\u00eda estar conectado a un repositorio de c\u00f3digo diferente para poder evolucionar y trabajar con cada uno de ellos de forma aislada sin afectar a los dem\u00e1s. As\u00ed adem\u00e1s podemos tener equipos aislados que trabajen con cada uno de los proyectos por separado. Info Durante todo el tutorial, voy a intentar separar la construcci\u00f3n del proyecto Angular de la construcci\u00f3n del proyecto Springboot, para terminar haciendo una integraci\u00f3n entre los dos. De esta forma podr\u00e1s comprobar como se puede desarrollar por separado cada uno de los dos proyectos sin ning\u00fan problema.","title":"Creaci\u00f3n de proyecto"},{"location":"create/#creacion-de-proyecto-angular","text":"La mayor\u00eda de los proyectos con Angular en los que trabajamos normalmente, suelen ser proyectos web usando las librer\u00edas mas comunes de angular, como angular material. Para crear un proyecto de Angular, es necesario tener instalado el CLI de Angular. Si no lo tienes instalado, por favor, acude a la secci\u00f3n Entorno de desarrollo y verifica que tienes instalado todo lo necesario.","title":"Creaci\u00f3n de proyecto Angular"},{"location":"create/#nuevo-proyecto","text":"Lo primero es crear un proyecto desde la consola mediante la herramienta Angular CLI. Para ello abrimos una consola, nos situamos en el directorio donde vamos a crear el proyecto y ejecutamos: ng new tutorial Nos realizar\u00e1 varias preguntas. Would you like to add Angular routing? (y/N) Preferiblemente: y Which stylesheet format would you like to use? Preferiblemente: SCSS En el caso del tutorial como vamos a tener dos proyectos para nuestra aplicaci\u00f3n (front y back), para poder seguir correctamente las explicaciones, voy a renombrar la carpeta para poder diferenciarla del otro proyecto. A partir de ahora se llamar\u00e1 front . Info Si durante el desarrollo del proyecto necesitas a\u00f1adir nuevos m\u00f3dulos al proyecto Angular, ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor yarn (que es m\u00e1s eficiente que el propio gestio de npm), directamente en consola ejecuta el comando yarn y descargar\u00e1 e instalar\u00e1 las nuevas dependencias.","title":"Nuevo proyecto"},{"location":"create/#arrancar-el-proyecto","text":"Para arrancar el proyecto, tan solo necesitamos ejecutar en consola el siguiente comando: ng serve Angular compilar\u00e1 el c\u00f3digo fuente, levantar\u00e1 un servidor local al que podremos acceder por defecto mediante la URL: http://localhost:4200/ Y ya podemos empezar a trabajar con Angular. Comandos de Angular CLI Si necesitas m\u00e1s informaci\u00f3n sobre los comandos que ofrece Angular CLI para poder crear aplicaciones, componentes, servicios, etc. los tienes disponibles en: https://angular.io/cli#command-overview","title":"Arrancar el proyecto"},{"location":"create/#creacion-de-proyecto-springboot","text":"La mayor\u00eda de los proyectos Springboot en los que trabajamos normalmente, suelen ser proyectos web sencillos con pocas dependencias de terceros o incluso proyectos basados en microservicios que ejecutan pocas acciones.","title":"Creaci\u00f3n de proyecto Springboot"},{"location":"create/#creacion-con-devonfw","text":"Podemos crear una estructura de proyecto con todas las dependencias activadas y configuradas a trav\u00e9s de devonfw . En el tutorial vamos a utilizar un proyecto simple de Springboot, pero queremos que conozcas que con devonfw tambi\u00e9n se puede crear. Si quieres saber m\u00e1s, visita el punto de Anexo en esta misma secci\u00f3n. Nota Est\u00e1 bien tener una plantilla de generaci\u00f3n de proyecto con Devonfw a modo de ejemplo donde podamos consultar, pero es mucho m\u00e1s sencillo crear una aplicaci\u00f3n vac\u00eda e ir a\u00f1adiendole las necesidades de nuestro proyecto a medida que nos vayan haciendo falta. Por eso te recomendamos que pases al punto de Spring Initializr","title":"Creaci\u00f3n con Devonfw"},{"location":"create/#creacion-con-spring-initilizr","text":"Este m\u00e9todo es mucho m\u00e1s recomendable si lo que quieres es tener un proyecto m\u00ednimo y sencillo, sin muchas dependencias.","title":"Creaci\u00f3n con Spring Initilizr"},{"location":"create/#spring-initializr","text":"Spring ha creado una p\u00e1gina interactiva que permite crear y configurar proyectos en diferentes lenguajes, con diferentes versiones de Spring Boot y a\u00f1adiendole los m\u00f3dulos que nosotros queramos. Esta p\u00e1gina est\u00e1 disponible desde Spring Initializr . Para seguir el ejemplo del tutorial, entraremos en la web y seleccionaremos los siguientes datos: Tipo de proyecto: Maven Lenguage: Java Versi\u00f3n Spring boot: 2.3.0 (o la que exista por defecto) Group: com.capgemini.coedevon ArtifactId: tutorial Versi\u00f3n Java: 8 Dependencias: Spring Web, Spring Data JPA, H2 Database y Flyway Esto nos generar\u00e1 un proyecto que ya vendr\u00e1 configurado con Spring Web, Spring Data para acceder a BBDD, y H2 junto con Flyway para crear una BBDD en memoria de ejemplo con la que trabajaremos durante el tutorial.","title":"Spring Initializr"},{"location":"create/#importar-en-eclipse","text":"El siguiente paso, ovbiamente es descomprimir el proyecto generado e importarlo como proyecto Maven. Abrimos el eclipse, pulsamos en File \u2192 Import y seleccionamos Existing Maven Projects . Buscamos el proyecto y le damos a importar.","title":"Importar en eclipse"},{"location":"create/#configurar-el-proyecto","text":"En realidad el proyecto est\u00e1 configurado completamente con las propiedades por defecto que vienen en Spring boot. Tan solo para poder arrancar el proyecto nos har\u00e1 falta un fichero de creaci\u00f3n de BBDD que utiliza flyway al arrancar y ser\u00e1 necesario tenerlo disponible. Crearemos dos ficheros, de momento en blanco, dentro de src/main/resources/db/migration : V0001__Create_Schema.sql \u2192 Ser\u00e1 el fichero que utilizaremos para crear el esquema de BBDD V0002__Create_Data.sql \u2192 Ser\u00e1 el fichero que utilizaremos para rellenar con datos iniciales el esquema de BBDD","title":"Configurar el proyecto"},{"location":"create/#plantilla-de-proyecto","text":"Puedes descargarte una plantilla ya construida , con Sprint Initializr y configurada con los pasos que hemos visto en esta secci\u00f3n.","title":"Plantilla de proyecto"},{"location":"create/#arrancar-el-proyecto_1","text":"Por \u00faltimo ya solo nos queda arrancar el proyecto creado. Para ello buscaremos la clase TutorialApplication.java y con el bot\u00f3n derecho seleccionaremos Run As \u2192 Java Application. La aplicaci\u00f3n al estar basada en Springboot arrancar\u00e1 internamente un Tomcat embebido donde se despliegar\u00e1 el proyecto. Si hab\u00e9is seguido el tutorial la aplicaci\u00f3n estar\u00e1 disponible en http://localhost:8080 , aunque de momento aun no tenemos nada accesible.","title":"Arrancar el proyecto"},{"location":"create/#anexo-creacion-con-devonfw","text":"Podemos utilizar la plantilla de creaci\u00f3n que nos ofrece Devonfw a trav\u00e9s de su gu\u00eda de desarrollo. Concretamente podemos seguir estos pasos: Creating a new application . El problema que tiene esta plantilla es que genera un proyecto totalmente configurado y que tiene activadas un conjunto muy grande de librer\u00edas. La mayor\u00eda de estas librer\u00edas no las utilizaremos jam\u00e1s en ning\u00fan proyecto e incluso hay configuraci\u00f3n de seguridad que tampoco vamos a utilizar por norma general o la tendremos que modificar para adaptarla a nuestra situaci\u00f3n (proyecto, entorno, cliente, etc.).","title":"Anexo. Creaci\u00f3n con Devonfw"},{"location":"create/#ejecucion-de-arquetipo","text":"Aun as\u00ed, si quieres crear un proyecto con devonfw es muy sencillo, puedes seguir estos pasos: Nos situamos en la carpeta que queramos que contenga nuestro proyecto y ejecutamos una consola de comandos. Para ello hacemos clic derecho y seleccionamos la opci\u00f3n Open devonfw CMD shell here y se nos abrir\u00e1 la consola. En la consola de devon, tecleamos el siguiente comando: devon java create com.capgemini.coedevon.tutorial . Veremos como el propio framework se descarga todo lo necesario y en breves momentos tendremos todo listo. Esto nos crear\u00e1 un proyecto de devon4j, con el nombre de paquete com.capgemini.coedevon.tutorial , el id de grupo com.capgemini.coedevon , el id de artefacto tutorial , la versi\u00f3n 1.0.0-SNAPSHOT y una base de datos h2 ya preconfigurada. Una vez haya terminado, teclearemos lo siguiente: cd tutorial y nos posicionar\u00e1 sobre la carpeta ra\u00edz del proyecto. Estando en la carpeta ra\u00edz del proyecto, tecleamos lo siguiente: devon eclipse y nos arrancar\u00e1 Eclipse. O tambien puedes descargarte una plantilla ya construida de devonfw.","title":"Ejecuci\u00f3n de arquetipo"},{"location":"exercise/","text":"Ahora hazlo tu! Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n.","title":"Ahora hazlo tu!"},{"location":"exercise/#ahora-hazlo-tu","text":"Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n.","title":"Ahora hazlo tu!"},{"location":"install/","text":"Entorno de desarrollo Herramientas que utilizaremos Las herramientas b\u00e1sicas que vamos a utilizar para el desarrollo del tutorial son: Para el desarrollo Back Eclipse Java 8+ Maven Para el desarrollo Front Visual Studio Code Node Yarn Angular CLI Puedes instalarte estas herramientas por tu cuenta y configurarlas una a una, o puedes instalarte el entorno de desarrollo de devonfw con todo configurado y listo para usarse. Instalaci\u00f3n del entorno devonfw A continuaci\u00f3n se explican los pasos a seguir para la instalaci\u00f3n de Devon en nuestro equipo. Nos aseguramos que tenemos en nuestro equipo el siguiente software instalado: 7-Zip Git y curl . Ojo, es muy importante que tengamos seteada la variable GIT_HOME, de lo contrario fallar\u00e1 la instalaci\u00f3n de devonfw. Descargamos la \u00faltima versi\u00f3n de los scripts de instalaci\u00f3n de Devon desde aqu\u00ed. Una vez descargado, tendremos un fichero con extensi\u00f3n .tar.gz. Descomprimimos con 7-Zip y obtendremos un fichero con extensi\u00f3n .tar. Por \u00faltimo, volveremos a descomprimir el fichero *.tar y ya tendremos una carpeta con los scripts. Renombramos dicha carpeta (por ejemplo: devon) y la copiamos en C:\\, qued\u00e1ndonos una ruta del estilo C:\\devon. Atenci\u00f3n Si no tenemos definida la variable de entorno GIT_HOME, el proceso fallar\u00e1 y nos dar\u00e1 un error que no ecuentra \"bin/bash.exe\". Aseguraos de que la variable exista. Aparecer\u00e1 un mensaje para introducir la URL para descargar los settings, como el siguiente: Simplemente pulsado la tecla Enter y el proceso continuar\u00e1. A continuaci\u00f3n, el instalador se va a descargar todo el software necesario para tener todo el paquete de herramientas listo. Se trata de una descarga de software larga y posiblemente lenta, por lo que deberemos armarnos de paciencia. Una vez haya terminado el proceso, nos dirigimos a nuestra carpeta de instalaci\u00f3n y ya podremos arrancar nuestro entorno de desarrollo Eclipse. Para ello ejecutaremos el fichero eclipse-main.bat . Una vez comprobemos que arranca, ya lo podemos cerrar.","title":"Entorno de desarrollo"},{"location":"install/#entorno-de-desarrollo","text":"","title":"Entorno de desarrollo"},{"location":"install/#herramientas-que-utilizaremos","text":"Las herramientas b\u00e1sicas que vamos a utilizar para el desarrollo del tutorial son: Para el desarrollo Back Eclipse Java 8+ Maven Para el desarrollo Front Visual Studio Code Node Yarn Angular CLI Puedes instalarte estas herramientas por tu cuenta y configurarlas una a una, o puedes instalarte el entorno de desarrollo de devonfw con todo configurado y listo para usarse.","title":"Herramientas que utilizaremos"},{"location":"install/#instalacion-del-entorno-devonfw","text":"A continuaci\u00f3n se explican los pasos a seguir para la instalaci\u00f3n de Devon en nuestro equipo. Nos aseguramos que tenemos en nuestro equipo el siguiente software instalado: 7-Zip Git y curl . Ojo, es muy importante que tengamos seteada la variable GIT_HOME, de lo contrario fallar\u00e1 la instalaci\u00f3n de devonfw. Descargamos la \u00faltima versi\u00f3n de los scripts de instalaci\u00f3n de Devon desde aqu\u00ed. Una vez descargado, tendremos un fichero con extensi\u00f3n .tar.gz. Descomprimimos con 7-Zip y obtendremos un fichero con extensi\u00f3n .tar. Por \u00faltimo, volveremos a descomprimir el fichero *.tar y ya tendremos una carpeta con los scripts. Renombramos dicha carpeta (por ejemplo: devon) y la copiamos en C:\\, qued\u00e1ndonos una ruta del estilo C:\\devon. Atenci\u00f3n Si no tenemos definida la variable de entorno GIT_HOME, el proceso fallar\u00e1 y nos dar\u00e1 un error que no ecuentra \"bin/bash.exe\". Aseguraos de que la variable exista. Aparecer\u00e1 un mensaje para introducir la URL para descargar los settings, como el siguiente: Simplemente pulsado la tecla Enter y el proceso continuar\u00e1. A continuaci\u00f3n, el instalador se va a descargar todo el software necesario para tener todo el paquete de herramientas listo. Se trata de una descarga de software larga y posiblemente lenta, por lo que deberemos armarnos de paciencia. Una vez haya terminado el proceso, nos dirigimos a nuestra carpeta de instalaci\u00f3n y ya podremos arrancar nuestro entorno de desarrollo Eclipse. Para ello ejecutaremos el fichero eclipse-main.bat . Una vez comprobemos que arranca, ya lo podemos cerrar.","title":"Instalaci\u00f3n del entorno devonfw"},{"location":"usecases/","text":"Contexto de la aplicaci\u00f3n Nuestro amigo Ernesto Esvida es muy aficionado a los juegos de mesa y desde muy peque\u00f1o ha ido coleccionando muchos juegos. Hasta tal punto que ha decidido regentar una Ludoteca. Como la colecci\u00f3n de juegos era suya personal, toda la informaci\u00f3n del cat\u00e1logo de juegos la ten\u00eda perfectamente clasificado en fichas de cart\u00f3n. Pero ahora que va abrir su propio negocio, necesita digitalizar esa informaci\u00f3n y hacerla m\u00e1s accesible. Como es un buen amigo de la infancia, hemos decidido ayudar a Ernesto y colaborar haciendo una peque\u00f1a aplicaci\u00f3n web que le sirva de cat\u00e1logo de juegos. Es m\u00e1s o menos el mismo sistema que estaba utilizando, pero esta vez en digital. Por cierto, la Ludoteca al final se va a llamar Ludoteca T\u00e1n . Dise\u00f1o de BD Para el proyecto que vamos a crear vamos a modelizar y gestionar 3 entidades: GAME , CATEGORY y AUTHOR . Para la entidad GAME , Ernesto nos ha comentado que la informaci\u00f3n que est\u00e1 guardando en sus fichas es la siguiente: id (este dato no estaba originalmente en las fichas pero nos ser\u00e1 muy util para indexar y realizar b\u00fasquedas) title age category author La entidad CATEGORY estar\u00e1 compuesta por los siguientes campos: id (lo mismo que en GAME ) name La entidad AUTHOR estar\u00e1 compuesta por los siguientes campos: id (lo mismo que en GAME ) name nationality Comenzaremos con un caso b\u00e1sico que cumpla las siguientes premisas: un juego pertenece a una categor\u00eda y ha sido creado por un \u00fanico autor. Modelando este contexto quedar\u00eda algo similar a esto: Dise\u00f1o de pantallas Deber\u00edamos construir tres pantallas de mantenimiento CRUD (Create, Read, Update, Delete) y una pantalla de Login general para activar las acciones de administrador. M\u00e1s o menos las pantallas deber\u00edan quedar as\u00ed: Listado de juegos Edici\u00f3n de juego Listado de categor\u00edas Edici\u00f3n de categor\u00eda Listado de autores Edici\u00f3n de autor Pantalla de Login Dise\u00f1o funcional Por \u00faltimo vamos a definir un poco la funcionalidad b\u00e1sica que Ernesto necesita para iniciar su negocio. Aspectos generales El sistema tan solo tendr\u00e1 dos roles: usuario b\u00e1sico es el usuario an\u00f3nimo que accede a la web sin registrar. Solo tiene permisos para mostrar listados usuario administrador es el usuario que se registra en la aplicaci\u00f3n. Puede realizar las operaciones de alta, edici\u00f3n y borrado Por defecto cuando entras en la aplicaci\u00f3n tendr\u00e1s los privilegios de un usuario b\u00e1sico hasta que el usuario haga un login correcto con el usuario / password admin / admin . En ese momento pasara a ser un usuario administrador y podr\u00e1 realizar operaciones de alta, baja y modificaci\u00f3n. La estructura general de la aplicaci\u00f3n ser\u00e1: Una cabecer\u00e1 superior que contendr\u00e1: el logo y el nombre de la tienda un enlace a cada uno de los CRUD del sistema un bot\u00f3n de Sign in Zona de trabajo, donde cargaremos las pantallas que el usuario vaya abriendo Al pulsar sobre la funcionalidad de Sign in aparecer\u00e1 una ventana modal que preguntar\u00e1 usuario y password. Esto realizar\u00e1 una llamada al backend, donde se validar\u00e1 si el usuario es correcto. En caso de ser correcto, devolver\u00e1 un token jwt de acceso, que el cliente web deber\u00e1 guardar en sessionStorage para futuras peticiones En caso de no ser correcto, devolver\u00e1 un error de Usuario y/o password incorrectos Todas las operaciones del backend que permitan crear, modificar o borrar datos, deber\u00e1n estar securizadas para que no puedan ser accedidas sin haberse autenticado previamente. CRUD de Juegos Al acceder a esta pantalla se mostrar\u00e1 un listado de los juegos disponibles en el cat\u00e1logo de la BD. Esta tabla debe contener filtros en la parte superior, pero no debe estar paginada. Se debe poder filtrar por: nombre del juego. Donde el usuario podr\u00e1 poner cualquier texto y el filtrado ser\u00e1 todos aquellos juegos que contengan el texto buscado categor\u00eda del juego. Donde aparecer\u00e1 un desplegable que el usuario seleccionar de entre todas las categor\u00edas de juego que existan en la BD. Dos botones permitir\u00e1n realizar el filtrado de juegos (lanzando una nueva consulta a BD) o limpiar los filtros seleccionados (lanzando una consulta con los filtros vac\u00edos). En la tabla debe aparecer a modo de fichas. No hace falta que sea exactamente igual a la maqueta, no es un requisito determinar un ancho general de ficha por lo que pueden caber 2,3 o x fichas en una misma fila, depender\u00e1 del programador. Pero todas las fichas deben tener el mismo ancho: Un espacio destinado a una foto (de momento no pondremos nada en ese espacio) Una columna con la siguiente informaci\u00f3n: T\u00edtulo del juego, resaltado de alguna forma Edad recomendada Categor\u00eda del juego, mostraremos su nombre Autor del juego, mostraremos su nombre Nacionalidad del juego, mostraremos la nacionalidad del autor del juego Los juegos no se pueden eliminar, pero si se puede editar si el usuario pulsa en alguna de las fichas (solo en el caso de que el usuario tenga permisos). Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevos juegos (solo en el caso de que el usuario tenga permisos). Crear Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con cinco inputs: Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Identificador T\u00edtulo. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de T\u00edtulo Edad. Este input es obligatorio, es de tipo num\u00e9rico de 0 a 99, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Edad Categor\u00eda. Este input es obligatorio, ser\u00e1 un campo seleccionable donde aparecer\u00e1n todas las categor\u00edas de la BD, aparecer\u00e1 vac\u00edo por defecto. Con el placeholder de Categor\u00eda Autor. Este input es obligatorio, ser\u00e1 un campo seleccionable donde aparecer\u00e1n todos los autores de la BD, aparecer\u00e1 vac\u00edo por defecto. Con el placeholder de Autor Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. Editar Al pulsar en una de las fichas con un click simple, se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de Crear pero con los cinco campos rellenados con los datos de BD. CRUD de Categor\u00edas Al acceder a esta pantalla se mostrar\u00e1 un listado de las categor\u00edas que tenemos en la BD. La tabla no tiene filtros, puesto que tiene muy pocos registros. Tampoco estar\u00e1 paginada. En la tabla debe aparecer: identificador de la categor\u00eda nombre de la categor\u00eda bot\u00f3n de editar (solo en el caso de que el usuario tenga permisos) bot\u00f3n de borrar (solo en el caso de que el usuario tenga permisos) Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevas categor\u00edas (solo en el caso de que el usuario tenga permisos). Crear Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con dos inputs: Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Identificador Nombre. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Nombre Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. Editar Al pulsar el icono de editar se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de Crear pero con los dos campos rellenados con los datos de BD. Borrar Si el usuario pulsa el bot\u00f3n de borrar, se deber\u00e1 comprobar si esa categor\u00eda tiene alg\u00fan Juego asociado. En caso de tenerlo se le informar\u00e1 al usuario de que dicha categor\u00eda no se puede eliminar por tener asociado un juego. En caso de no estar asociada, se le preguntar\u00e1 al usuario mediante un mensaje de confirmaci\u00f3n si desea eliminar la categor\u00eda. Solo en caso de que la respuesta sea afirmativa, se lanzar\u00e1 el borrado f\u00edsico de la categor\u00eda en BD. CRUD de Autores Al acceder a esta pantalla se mostrar\u00e1 un listado de los autores que tenemos en la BD. La tabla no tiene filtros pero deber\u00e1 estar paginada en servidor. En la tabla debe aparecer: identificador del autor nombre del autor nacionalidad del autor bot\u00f3n de editar (solo en el caso de que el usuario tenga permisos) bot\u00f3n de borrar (solo en el caso de que el usuario tenga permisos) Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevos autores (solo en el caso de que el usuario tenga permisos). Crear Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con tres inputs: Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Identificador Nombre. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Nombre Nacionalidad. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Nacionalidad Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. Editar Al pulsar el icono de editar se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de Crear pero con los tres campos rellenados con los datos de BD. Borrar Si el usuario pulsa el bot\u00f3n de borrar, se deber\u00e1 comprobar si ese autor tiene alg\u00fan Juego asociado. En caso de tenerlo se le informar\u00e1 al usuario de que dicho autor no se puede eliminar por tener asociado un juego. En caso de no estar asociado, se le preguntar\u00e1 al usuario mediante un mensaje de confirmaci\u00f3n si desea eliminar el autor. Solo en caso de que la respuesta sea afirmativa, se lanzar\u00e1 el borrado f\u00edsico de la categor\u00eda en BD.","title":"Contexto de la aplicaci\u00f3n"},{"location":"usecases/#contexto-de-la-aplicacion","text":"Nuestro amigo Ernesto Esvida es muy aficionado a los juegos de mesa y desde muy peque\u00f1o ha ido coleccionando muchos juegos. Hasta tal punto que ha decidido regentar una Ludoteca. Como la colecci\u00f3n de juegos era suya personal, toda la informaci\u00f3n del cat\u00e1logo de juegos la ten\u00eda perfectamente clasificado en fichas de cart\u00f3n. Pero ahora que va abrir su propio negocio, necesita digitalizar esa informaci\u00f3n y hacerla m\u00e1s accesible. Como es un buen amigo de la infancia, hemos decidido ayudar a Ernesto y colaborar haciendo una peque\u00f1a aplicaci\u00f3n web que le sirva de cat\u00e1logo de juegos. Es m\u00e1s o menos el mismo sistema que estaba utilizando, pero esta vez en digital. Por cierto, la Ludoteca al final se va a llamar Ludoteca T\u00e1n .","title":"Contexto de la aplicaci\u00f3n"},{"location":"usecases/#diseno-de-bd","text":"Para el proyecto que vamos a crear vamos a modelizar y gestionar 3 entidades: GAME , CATEGORY y AUTHOR . Para la entidad GAME , Ernesto nos ha comentado que la informaci\u00f3n que est\u00e1 guardando en sus fichas es la siguiente: id (este dato no estaba originalmente en las fichas pero nos ser\u00e1 muy util para indexar y realizar b\u00fasquedas) title age category author La entidad CATEGORY estar\u00e1 compuesta por los siguientes campos: id (lo mismo que en GAME ) name La entidad AUTHOR estar\u00e1 compuesta por los siguientes campos: id (lo mismo que en GAME ) name nationality Comenzaremos con un caso b\u00e1sico que cumpla las siguientes premisas: un juego pertenece a una categor\u00eda y ha sido creado por un \u00fanico autor. Modelando este contexto quedar\u00eda algo similar a esto:","title":"Dise\u00f1o de BD"},{"location":"usecases/#diseno-de-pantallas","text":"Deber\u00edamos construir tres pantallas de mantenimiento CRUD (Create, Read, Update, Delete) y una pantalla de Login general para activar las acciones de administrador. M\u00e1s o menos las pantallas deber\u00edan quedar as\u00ed:","title":"Dise\u00f1o de pantallas"},{"location":"usecases/#listado-de-juegos","text":"","title":"Listado de juegos"},{"location":"usecases/#edicion-de-juego","text":"","title":"Edici\u00f3n de juego"},{"location":"usecases/#listado-de-categorias","text":"","title":"Listado de categor\u00edas"},{"location":"usecases/#edicion-de-categoria","text":"","title":"Edici\u00f3n de categor\u00eda"},{"location":"usecases/#listado-de-autores","text":"","title":"Listado de autores"},{"location":"usecases/#edicion-de-autor","text":"","title":"Edici\u00f3n de autor"},{"location":"usecases/#pantalla-de-login","text":"","title":"Pantalla de Login"},{"location":"usecases/#diseno-funcional","text":"Por \u00faltimo vamos a definir un poco la funcionalidad b\u00e1sica que Ernesto necesita para iniciar su negocio.","title":"Dise\u00f1o funcional"},{"location":"usecases/#aspectos-generales","text":"El sistema tan solo tendr\u00e1 dos roles: usuario b\u00e1sico es el usuario an\u00f3nimo que accede a la web sin registrar. Solo tiene permisos para mostrar listados usuario administrador es el usuario que se registra en la aplicaci\u00f3n. Puede realizar las operaciones de alta, edici\u00f3n y borrado Por defecto cuando entras en la aplicaci\u00f3n tendr\u00e1s los privilegios de un usuario b\u00e1sico hasta que el usuario haga un login correcto con el usuario / password admin / admin . En ese momento pasara a ser un usuario administrador y podr\u00e1 realizar operaciones de alta, baja y modificaci\u00f3n. La estructura general de la aplicaci\u00f3n ser\u00e1: Una cabecer\u00e1 superior que contendr\u00e1: el logo y el nombre de la tienda un enlace a cada uno de los CRUD del sistema un bot\u00f3n de Sign in Zona de trabajo, donde cargaremos las pantallas que el usuario vaya abriendo Al pulsar sobre la funcionalidad de Sign in aparecer\u00e1 una ventana modal que preguntar\u00e1 usuario y password. Esto realizar\u00e1 una llamada al backend, donde se validar\u00e1 si el usuario es correcto. En caso de ser correcto, devolver\u00e1 un token jwt de acceso, que el cliente web deber\u00e1 guardar en sessionStorage para futuras peticiones En caso de no ser correcto, devolver\u00e1 un error de Usuario y/o password incorrectos Todas las operaciones del backend que permitan crear, modificar o borrar datos, deber\u00e1n estar securizadas para que no puedan ser accedidas sin haberse autenticado previamente.","title":"Aspectos generales"},{"location":"usecases/#crud-de-juegos","text":"Al acceder a esta pantalla se mostrar\u00e1 un listado de los juegos disponibles en el cat\u00e1logo de la BD. Esta tabla debe contener filtros en la parte superior, pero no debe estar paginada. Se debe poder filtrar por: nombre del juego. Donde el usuario podr\u00e1 poner cualquier texto y el filtrado ser\u00e1 todos aquellos juegos que contengan el texto buscado categor\u00eda del juego. Donde aparecer\u00e1 un desplegable que el usuario seleccionar de entre todas las categor\u00edas de juego que existan en la BD. Dos botones permitir\u00e1n realizar el filtrado de juegos (lanzando una nueva consulta a BD) o limpiar los filtros seleccionados (lanzando una consulta con los filtros vac\u00edos). En la tabla debe aparecer a modo de fichas. No hace falta que sea exactamente igual a la maqueta, no es un requisito determinar un ancho general de ficha por lo que pueden caber 2,3 o x fichas en una misma fila, depender\u00e1 del programador. Pero todas las fichas deben tener el mismo ancho: Un espacio destinado a una foto (de momento no pondremos nada en ese espacio) Una columna con la siguiente informaci\u00f3n: T\u00edtulo del juego, resaltado de alguna forma Edad recomendada Categor\u00eda del juego, mostraremos su nombre Autor del juego, mostraremos su nombre Nacionalidad del juego, mostraremos la nacionalidad del autor del juego Los juegos no se pueden eliminar, pero si se puede editar si el usuario pulsa en alguna de las fichas (solo en el caso de que el usuario tenga permisos). Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevos juegos (solo en el caso de que el usuario tenga permisos). Crear Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con cinco inputs: Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Identificador T\u00edtulo. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de T\u00edtulo Edad. Este input es obligatorio, es de tipo num\u00e9rico de 0 a 99, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Edad Categor\u00eda. Este input es obligatorio, ser\u00e1 un campo seleccionable donde aparecer\u00e1n todas las categor\u00edas de la BD, aparecer\u00e1 vac\u00edo por defecto. Con el placeholder de Categor\u00eda Autor. Este input es obligatorio, ser\u00e1 un campo seleccionable donde aparecer\u00e1n todos los autores de la BD, aparecer\u00e1 vac\u00edo por defecto. Con el placeholder de Autor Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. Editar Al pulsar en una de las fichas con un click simple, se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de Crear pero con los cinco campos rellenados con los datos de BD.","title":"CRUD de Juegos"},{"location":"usecases/#crud-de-categorias","text":"Al acceder a esta pantalla se mostrar\u00e1 un listado de las categor\u00edas que tenemos en la BD. La tabla no tiene filtros, puesto que tiene muy pocos registros. Tampoco estar\u00e1 paginada. En la tabla debe aparecer: identificador de la categor\u00eda nombre de la categor\u00eda bot\u00f3n de editar (solo en el caso de que el usuario tenga permisos) bot\u00f3n de borrar (solo en el caso de que el usuario tenga permisos) Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevas categor\u00edas (solo en el caso de que el usuario tenga permisos). Crear Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con dos inputs: Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Identificador Nombre. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Nombre Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. Editar Al pulsar el icono de editar se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de Crear pero con los dos campos rellenados con los datos de BD. Borrar Si el usuario pulsa el bot\u00f3n de borrar, se deber\u00e1 comprobar si esa categor\u00eda tiene alg\u00fan Juego asociado. En caso de tenerlo se le informar\u00e1 al usuario de que dicha categor\u00eda no se puede eliminar por tener asociado un juego. En caso de no estar asociada, se le preguntar\u00e1 al usuario mediante un mensaje de confirmaci\u00f3n si desea eliminar la categor\u00eda. Solo en caso de que la respuesta sea afirmativa, se lanzar\u00e1 el borrado f\u00edsico de la categor\u00eda en BD.","title":"CRUD de Categor\u00edas"},{"location":"usecases/#crud-de-autores","text":"Al acceder a esta pantalla se mostrar\u00e1 un listado de los autores que tenemos en la BD. La tabla no tiene filtros pero deber\u00e1 estar paginada en servidor. En la tabla debe aparecer: identificador del autor nombre del autor nacionalidad del autor bot\u00f3n de editar (solo en el caso de que el usuario tenga permisos) bot\u00f3n de borrar (solo en el caso de que el usuario tenga permisos) Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevos autores (solo en el caso de que el usuario tenga permisos). Crear Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con tres inputs: Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Identificador Nombre. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Nombre Nacionalidad. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de Nacionalidad Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. Editar Al pulsar el icono de editar se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de Crear pero con los tres campos rellenados con los datos de BD. Borrar Si el usuario pulsa el bot\u00f3n de borrar, se deber\u00e1 comprobar si ese autor tiene alg\u00fan Juego asociado. En caso de tenerlo se le informar\u00e1 al usuario de que dicho autor no se puede eliminar por tener asociado un juego. En caso de no estar asociado, se le preguntar\u00e1 al usuario mediante un mensaje de confirmaci\u00f3n si desea eliminar el autor. Solo en caso de que la respuesta sea afirmativa, se lanzar\u00e1 el borrado f\u00edsico de la categor\u00eda en BD.","title":"CRUD de Autores"},{"location":"appendix/dates/","text":"Fechas Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n. Como trabajar con las fechas El problema que presenta al trabajar con las fechas es que el navegador puede tener una zona horaria y el servidor estar en otra. Aqu\u00ed hay una deficiencia por parte de JavaScript que, al trabajar con fechas, le a\u00f1ade la zona horaria y no es posible de una forma optima remover la zona horaria del objeto Date. A s\u00ed que vamos a intentar de trabajar en estos casos con formateos de fecha preestablecidas Una propuesta es trabajar en el FRONT y Back con este formato \"dd/MM/yyyy HH:mm:ss\"","title":"Anexo. Fechas"},{"location":"appendix/dates/#fechas","text":"Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n.","title":"Fechas"},{"location":"appendix/dates/#como-trabajar-con-las-fechas","text":"El problema que presenta al trabajar con las fechas es que el navegador puede tener una zona horaria y el servidor estar en otra. Aqu\u00ed hay una deficiencia por parte de JavaScript que, al trabajar con fechas, le a\u00f1ade la zona horaria y no es posible de una forma optima remover la zona horaria del objeto Date. A s\u00ed que vamos a intentar de trabajar en estos casos con formateos de fecha preestablecidas Una propuesta es trabajar en el FRONT y Back con este formato \"dd/MM/yyyy HH:mm:ss\"","title":"Como trabajar con las fechas"},{"location":"appendix/styles/","text":"Estilos Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n. Preprocesadores Un preprocesador de CSS es una herramienta que nos permite escribir pseudo-c\u00f3digo CSS que luego ser\u00e1 convertido a CSS real. Ese pseudo-c\u00f3digo se conforma de variables, condiciones, bucles o funciones. Podr\u00edamos decir que tenemos un lenguaje de programaci\u00f3n que genera CSS. Responsive web El dise\u00f1o web adaptable (tambi\u00e9n dise\u00f1o web adaptativo o responsivo; este \u00faltimo calco del ingl\u00e9s responsive web design), es una filosof\u00eda de dise\u00f1o y desarrollo cuyo objetivo es adaptar la apariencia de las p\u00e1ginas web al dispositivo que se est\u00e9 utilizando para visitarlas Metodolog\u00edas Las Metodolog\u00edas o Arquitecturas CSS nos ayudaran a escribir c\u00f3digo CSS m\u00e1s predecible, reutilizable, mantenible y escalable. oocss El objetivo de OOCSS es la idea de tratar los elementos de la p\u00e1gina como objetos , dando todas estas clases de objetos , tratando las clases de los objetos como entidades individuales en las hojas de estilo y tom\u00e1ndolas desde all\u00ed. http://oocss.org/ bem BEM significa Modificador de Bloques de Elementos (Block Element Modifier) por sus siglas en ingl\u00e9s. Sugiere una manera estructura de nombrar tus clases, basado en las propiedades del elemento en cuesti\u00f3n. https://en.bem.info/methodology/quick-start/ smacss La metodolog\u00eda SMACSS consigue categorizar reglas CSS en 5 tipos: http://smacss.com/ - Base - Dise\u00f1o - M\u00f3dulo - Estado - Tema","title":"Anexo. Estilos"},{"location":"appendix/styles/#estilos","text":"Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n.","title":"Estilos"},{"location":"appendix/styles/#preprocesadores","text":"Un preprocesador de CSS es una herramienta que nos permite escribir pseudo-c\u00f3digo CSS que luego ser\u00e1 convertido a CSS real. Ese pseudo-c\u00f3digo se conforma de variables, condiciones, bucles o funciones. Podr\u00edamos decir que tenemos un lenguaje de programaci\u00f3n que genera CSS.","title":"Preprocesadores"},{"location":"appendix/styles/#responsive-web","text":"El dise\u00f1o web adaptable (tambi\u00e9n dise\u00f1o web adaptativo o responsivo; este \u00faltimo calco del ingl\u00e9s responsive web design), es una filosof\u00eda de dise\u00f1o y desarrollo cuyo objetivo es adaptar la apariencia de las p\u00e1ginas web al dispositivo que se est\u00e9 utilizando para visitarlas","title":"Responsive web"},{"location":"appendix/styles/#metodologias","text":"Las Metodolog\u00edas o Arquitecturas CSS nos ayudaran a escribir c\u00f3digo CSS m\u00e1s predecible, reutilizable, mantenible y escalable.","title":"Metodolog\u00edas"},{"location":"appendix/styles/#oocss","text":"El objetivo de OOCSS es la idea de tratar los elementos de la p\u00e1gina como objetos , dando todas estas clases de objetos , tratando las clases de los objetos como entidades individuales en las hojas de estilo y tom\u00e1ndolas desde all\u00ed. http://oocss.org/","title":"oocss"},{"location":"appendix/styles/#bem","text":"BEM significa Modificador de Bloques de Elementos (Block Element Modifier) por sus siglas en ingl\u00e9s. Sugiere una manera estructura de nombrar tus clases, basado en las propiedades del elemento en cuesti\u00f3n. https://en.bem.info/methodology/quick-start/","title":"bem"},{"location":"appendix/styles/#smacss","text":"La metodolog\u00eda SMACSS consigue categorizar reglas CSS en 5 tipos: http://smacss.com/ - Base - Dise\u00f1o - M\u00f3dulo - Estado - Tema","title":"smacss"},{"location":"develop/step1/","text":"Desarrollo con Angular Ahora que ya tenemos listo tanto el proyecto back de SpringBoot (en el puerto 8080) como el proyecto front de Angular (en el puerto 4200), ya podemos empezar a codificar la soluci\u00f3n. Durante todo el tutorial vamos a intentar separar completamente la implementaci\u00f3n de front de la implementaci\u00f3n de back, para que quede claro como se debe realizar en cada una de las tecnolog\u00edas. Primeros pasos Antes de empezar Antes de empezar esta parte te recomendamos encarecidamente que hagas el tutorial que viene en la propia p\u00e1gina de Angular, donde explican algunos de los conceptos b\u00e1sicos y generales de las aplicaciones. Te servir\u00e1 mucho para conocer algunos de los aspectos y componentes que utilizamos durante este tutorial. Lo puedes visitar desde su web Tour of Heroes Si abrimos el proyecto con el IDE que tengamos (Visual Studio Code en el caso del tutorial) podemos ver que en la carpeta src/app existen unos ficheros ya creados por defecto. Estos ficheros son: app.component.ts \u2192 contiene el c\u00f3digo inicial del proyecto escrito en TypeScript. app.component.html \u2192 contiene la plantilla inicial del proyecto escrita en HTML. app.component.scss \u2192 contiene los estilos CSS privados de la plantilla inicial. Vamos a modificar este c\u00f3digo inicial para ver como funciona. Abrimos el fichero app.component.ts y modificamos la l\u00ednea donde se asigna un valor a la variable title . app.component.ts ... title = 'Tutorial de Angular + Springboot' ; ... Ahora abrimos el fichero app.component.html , borramos todo el c\u00f3digo de la plantilla y a\u00f1adimos el siguiente c\u00f3digo: app.component.html < h1 > {{title}} </ h1 > Las llaves dobles permiten hacen un binding entre el c\u00f3digo del componente y la plantilla. Es decir, en este caso ir\u00e1 al c\u00f3digo TypeScript y buscar\u00e1 el valor de la variable title . Consejo El binding tambi\u00e9n nos sirve para ejecutar los m\u00e9todos de TypeScript desde el c\u00f3digo HTML. Adem\u00e1s si el valor que contiene la variable se modificara durante la ejecuci\u00f3n de alg\u00fan m\u00e9todo, autom\u00e1ticamente el c\u00f3digo HTML refrescar\u00eda el nuevo valor de la variable title Si abrimos el navegador y accedemos a http://localhost:4200/ podremos ver el resultado del c\u00f3digo. Layout general Crear componente Lo primero que vamos a hacer es escoger un tema y una paleta de componentes para trabajar. Lo m\u00e1s c\u00f3modo es trabajar con Material que ya viene perfectamente integrado en Angular. Ejecutamos el comando y elegimos la paleta de colores que m\u00e1s nos guste o bien creamos una custom: ng add @angular/material Recuerda Al a\u00f1adir una nueva librer\u00eda tenemos que parar el servidor y volver a arrancarlo para que compile y precargue las nuevas dependencias. Una vez a\u00f1adida la dependencia, lo que queremos es crear una primera estructura inicial a la p\u00e1gina. Si te acuerdas cual era la estructura (y si no te acuerdas, vuelve a la secci\u00f3n Contexto de la aplicaci\u00f3n y lo revisas), ten\u00edamos una cabecera superior con un logo y t\u00edtulo y unas opciones de men\u00fa. Pues vamos a ello, crearemos esa estructura com\u00fan para toda la aplicaci\u00f3n. Este componente al ser algo core para toda la aplicaci\u00f3n deber\u00edamos crearlo dentro del m\u00f3dulo core como ya vimos anteriormente. Pero antes de todo, vamos a crear los m\u00f3dulos generales de la aplicaci\u00f3n, as\u00ed que ejecutamos en consola el comando que nos permite crear un m\u00f3dulo nuevo: ng generate module shared ng generate module core ng generate module models ng generate module services ng generate module views Y a\u00f1adimos esos m\u00f3dulos al m\u00f3dulo padre de la aplicaci\u00f3n: app.module.ts import { BrowserModule } from '@angular/platform-browser' ; import { NgModule } from '@angular/core' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { BrowserAnimationsModule } from '@angular/platform-browser/animations' ; import { SharedModule } from './shared/shared.module' ; import { CoreModule } from './core/core.module' ; import { ModelsModule } from './models/models.module' ; import { ServicesModule } from './services/services.module' ; import { ViewsModule } from './views/views.module' ; @NgModule ({ declarations : [ AppComponent ], imports : [ BrowserModule , AppRoutingModule , SharedModule , CoreModule , ModelsModule , ServicesModule , ViewsModule , BrowserAnimationsModule , ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { } Y despu\u00e9s crearemos el componente header, dentro del m\u00f3dulo core. Para eso ejecutaremos el comando: ng generate component core/header C\u00f3digo de la pantalla Esto nos crear\u00e1 una carpeta con los ficheros del componente, donde tendremos que copiar el siguiente contenido: header.component.html < mat-toolbar > < mat-toolbar-row > < div class = \"header_container\" > < div class = \"header_title\" > < mat-icon > storefront </ mat-icon > Ludoteca Tan </ div > < div class = \"header_separator\" > | </ div > < div class = \"header_menu\" > < div class = \"header_button\" > < a routerLink = \"/games\" routerLinkActive = \"active\" > Cat\u00e1logo </ a > </ div > < div class = \"header_button\" > < a routerLink = \"/categories\" routerLinkActive = \"active\" > Categor\u00edas </ a > </ div > < div class = \"header_button\" > < a routerLink = \"/authors\" routerLinkActive = \"active\" > Autores </ a > </ div > </ div > < div class = \"header_login\" > < mat-icon > account_circle </ mat-icon > Sign in </ div > </ div > </ mat-toolbar-row > </ mat-toolbar > header.component.scss . mat-toolbar { background-color : blue ; color : white ; } . header_container { display : flex ; width : 100 % ; .header_title { .mat-icon { vertical-align : sub ; } } . header_separator { margin-left : 30 px ; margin-right : 30 px ; } . header_menu { flex-grow : 4 ; display : flex ; flex-direction : row ; .header_button { margin-left : 1 em ; margin-right : 1 em ; font-size : 16 px ; a { font-weight : lighter ; text-decoration : none ; cursor : pointer ; color : white ; } a : hover { color : grey ; } a . active { font-weight : normal ; text-decoration : underline ; color : lightyellow ; } } } . header_login { font-size : 16 px ; cursor : pointer ; .mat-icon { vertical-align : sub ; } } } Al utilizar etiquetas de material como mat-toolbar o mat-icon y routerLink necesitaremos importar las dependencias. Esto lo podemos hacer directamente en el m\u00f3dulo del que depende, es decir en el fichero core.module.ts core.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { MatIconModule } from '@angular/material/icon' ; import { MatToolbarModule } from '@angular/material/toolbar' ; import { HeaderComponent } from './header/header.component' ; import { RouterModule } from '@angular/router' ; @NgModule ({ declarations : [ HeaderComponent ], imports : [ CommonModule , RouterModule , MatIconModule , MatToolbarModule , ], exports : [ HeaderComponent ] }) export class CoreModule { } Adem\u00e1s de a\u00f1adir las dependencias, diremos que este m\u00f3dulo va a exportar el componente HeaderComponent para poder utilizarlo desde otras p\u00e1ginas. Ya por \u00faltimo solo nos queda modificar la p\u00e1gina general de la aplicaci\u00f3n app.component.html para a\u00f1adirle el componente HeaderComponent . app.component.html < div > < app-header ></ app-header > < div > < router-outlet ></ router-outlet > </ div > </ div > Vamos al navegador y refrescamos la p\u00e1gina, deber\u00eda aparecer una barra superior (Header) con las opciones de men\u00fa. Algo similar a esto: Recuerda Cuando se a\u00f1aden componentes a los ficheros html , siempre se deben utilizar los selectores definidos para el componente. En el caso anterior hemos a\u00f1adido app-header que es el mismo nombre selector que tiene el componente en el fichero header.component.ts . Adem\u00e1s, recuerda que para poder utilizar componentes de otros m\u00f3dulos, los debes exportar ya que de lo contrario tan solo podr\u00e1n utilizarse dentro del m\u00f3dulo donde se declaran. Creando un listado b\u00e1sico Crear componente Ya tenemos la estructura principal, ahora vamos a crear nuestra primera pantalla. Vamos a empezar por la de Categor\u00edas que es la m\u00e1s sencilla, ya que se trata de un listado, que muestra datos sin filtrar ni paginar. Las pantallas deber\u00edan ir todas dentro del m\u00f3dulo views as\u00ed que vamos a ejecutar el siguiente comando para crear la pantalla dentro de dicho m\u00f3dulo: ng generate component views/categories Por \u00faltimo vamos a a\u00f1adir la nueva ruta del componente dentro del routing, para ello modificamos el fichero app-routing.module.ts app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { CategoriesComponent } from './views/categories/categories.component' ; const routes : Routes = [ { path : 'categories' , component : CategoriesComponent }, ]; @NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } Si abrimos el navegador y accedemos a http://localhost:4200/ podremos navegar mediante el men\u00fa Categor\u00edas el cual abrir\u00e1 el componente que acabamos de crear. C\u00f3digo de la pantalla Ahora vamos a construir la pantalla. Para manejar la informaci\u00f3n del listado, necesitamos almacenar los datos en un objeto de tipo model . Para ello crearemos un fichero en models\\categories\\Category.ts donde implementaremos la clase necesaria. Esta clase ser\u00e1 la que utilizaremos en el c\u00f3digo html y ts de nuestro componente. categories.component.html < div class = \"container\" > < h1 > Listado de Categor\u00edas </ h1 > < mat-table [ dataSource ]=\" dataSource \" > < ng-container matColumnDef = \"id\" > < mat-header-cell * matHeaderCellDef > Identificador </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.id}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"name\" > < mat-header-cell * matHeaderCellDef > Nombre categor\u00eda </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.name}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" >< mat-icon > edit </ mat-icon ></ button > < button mat-icon-button color = \"accent\" >< mat-icon > clear </ mat-icon ></ button > </ mat-cell > </ ng-container > < mat-header-row * matHeaderRowDef = \"displayedColumns; sticky: true\" ></ mat-header-row > < mat-row * matRowDef = \"let row; columns: displayedColumns;\" ></ mat-row > </ mat-table > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" > Nueva categor\u00eda </ button > </ div > </ div > categories.component.scss . container { margin : 20 px ; mat-table { margin-top : 10 px ; margin-bottom : 20 px ; .mat-header-row { background-color : #f5f5f5 ; .mat-header-cell { text-transform : uppercase ; font-weight : bold ; color : #838383 ; } } . mat-column-id { flex : 0 0 20 % ; justify-content : center ; } . mat-column-action { flex : 0 0 10 % ; justify-content : center ; } } . buttons { text-align : right ; } } Category.ts export class Category { id : number ; name : string ; } categories.component.ts import { Component , OnInit } from '@angular/core' ; import { Category } from 'src/app/models/categories/Category' ; import { MatTableDataSource } from '@angular/material/table' ; @Component ({ selector : 'app-categories' , templateUrl : './categories.component.html' , styleUrls : [ './categories.component.scss' ] }) export class CategoriesComponent implements OnInit { dataSource = new MatTableDataSource < Category > (); displayedColumns : string [] = [ 'id' , 'name' , 'action' ]; constructor () { } ngOnInit () : void { } } El c\u00f3digo HTML es f\u00e1cil de seguir pero por si acaso: L\u00ednea 4: Creamos la tabla con la variable dataSource definida en el fichero .ts L\u00ednea 5: Definici\u00f3n de la primera columna, su cabecera y el dato que va a contener L\u00ednea 10: Definici\u00f3n de la segunda columna, su cabecera y el dato que va a contener L\u00ednea 15: Definici\u00f3n de la tercera columna, su cabecera vac\u00eda y los dos botones de acci\u00f3n L\u00ednea 23 y 24: Construcci\u00f3n de la cabecera y las filas Y ya por \u00faltimo, a\u00f1adimos los componentes que se han utilizado de Angular Material a las dependencias del m\u00f3dulo donde est\u00e1 definido el componente en este caso views\\views.module.ts : views.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { MatTableModule } from '@angular/material/table' ; import { MatIconModule } from '@angular/material/icon' ; import { MatButtonModule } from '@angular/material/button' ; import { CategoriesComponent } from './categories/categories.component' ; @NgModule ({ declarations : [ CategoriesComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule ], }) export class ViewsModule { } Si abrimos el navegador y accedemos a http://localhost:4200/ y pulsamos en el men\u00fa de Categor\u00edas obtendremos una pantalla con un listado vac\u00edo (solo con cabeceras) y un bot\u00f3n de crear Nueva Categor\u00eda. A\u00f1adiendo datos En este punto y para ver como responde el listado, vamos a a\u00f1adir datos. Si tuvieramos el backend implementado podr\u00edamos consultar los datos directamente de una operaci\u00f3n de negocio de backend, pero ahora mismo no lo tenemos implementado as\u00ed que para no bloquear el desarrollo vamos a mockear los datos. Creando un servicio En angular, cualquier acceso a datos debe pasar por un service , as\u00ed que vamos a crearnos uno para categor\u00edas. Vamos a la consola y ejecutamos: ng generate service services/categories/category Esto nos crear\u00e1 un servicio y lo a\u00f1adir\u00e1 al m\u00f3dulo de services.module.ts . Adem\u00e1s, este servicio es inyectable por defecto as\u00ed que podemos utilizarlo inyect\u00e1ndolo en cualquier componente que lo necesite. Implementando un servicio Vamos a implementar una operaci\u00f3n de negocio que recupere el listado de categor\u00edas y lo vamos a hacer de forma reactiva (as\u00edncrona) para simular una petici\u00f3n a backend. Modificamos los siguientes ficheros: category.service.ts import { Injectable } from '@angular/core' ; import { Category } from 'src/app/models/categories/Category' ; import { Observable } from 'rxjs' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor () { } getCategories () : Observable < Category [] > { return new Observable (); } } categories.component.ts import { Component , OnInit } from '@angular/core' ; import { Category } from 'src/app/models/categories/Category' ; import { MatTableDataSource } from '@angular/material/table' ; import { CategoryService } from 'src/app/services/categories/category.service' ; @Component ({ selector : 'app-categories' , templateUrl : './categories.component.html' , styleUrls : [ './categories.component.scss' ] }) export class CategoriesComponent implements OnInit { dataSource = new MatTableDataSource < Category > (); displayedColumns : string [] = [ 'id' , 'name' , 'action' ]; constructor ( private categoryService : CategoryService , ) { } ngOnInit () : void { this . categoryService . getCategories (). subscribe ( categories => this . dataSource . data = categories ); } } Mockeando datos Como hemos comentado anteriormente, el backend todav\u00eda no est\u00e1 implementado as\u00ed que vamos a mockear datos. Nos crearemos un fichero mock-categories.ts con datos ficticios y modificaremos el servicio para que devuelva esos datos. De esta forma, cuando tengamos implementada la operaci\u00f3n de negocio en backend, tan solo tenemos que sustuir el c\u00f3digo que devuelve datos est\u00e1ticos por una llamada http. mock-categories.ts import { Category } from 'src/app/models/categories/Category' ; export const CATEGORY_DATA : Category [] = [ { id : 1 , name : 'Dados' }, { id : 2 , name : 'Fichas' }, { id : 3 , name : 'Cartas' }, { id : 4 , name : 'Rol' }, { id : 5 , name : 'Tableros' }, { id : 6 , name : 'Tem\u00e1ticos' }, { id : 7 , name : 'Europeos' }, { id : 8 , name : 'Guerra' }, { id : 9 , name : 'Abstractos' }, ] category.service.ts import { Injectable } from '@angular/core' ; import { CATEGORY_DATA } from './mock-categories' ; import { Category } from 'src/app/models/categories/Category' ; import { Observable , of } from 'rxjs' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor () { } getCategories () : Observable < Category [] > { return of ( CATEGORY_DATA ); } } Si ahora refrescamos la p\u00e1gina web, veremos que el listado ya tiene datos con los que vamos a interactuar. Simulando las otras peticiones Para terminar, vamos a simular las otras dos peticiones, la de editar y la de borrar para cuando tengamos que utilizarlas. El servicio debe quedar m\u00e1s o menos as\u00ed: category.service.ts import { Injectable } from '@angular/core' ; import { CATEGORY_DATA } from './mock-categories' ; import { Category } from 'src/app/models/categories/Category' ; import { Observable , of } from 'rxjs' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor () { } getCategories () : Observable < Category [] > { return of ( CATEGORY_DATA ); } saveCategory ( category : Category ) : Observable < Category > { return of ( null ); } deleteCategory ( idCategory : number ) : Observable < any > { return of ( null ); } } A\u00f1adiendo acciones al listado Crear componente Ahora nos queda a\u00f1adir las acciones al listado: crear, editar y eliminar. Empezaremos primero por las acciones de crear y editar, que ambas deber\u00edan abrir una ventana modal con un formulario para poder modificar datos de la entidad Categor\u00eda . Como siempre, para crear un componente usamos el asistente de Angular, esta vez al tratarse de una pantalla que solo vamos a utilizar dentro del listado de categor\u00edas, tiene sentido que lo creemos dentro de ese directorio: ng generate component views/categories/category-dialog Ahora vamos a hacer que se abra al pulsar el bot\u00f3n Nueva categor\u00eda . Para eso, vamos al fichero views\\categories\\categories.component.ts y a\u00f1adimos un nuevo m\u00e9todo: categories.component.ts ... import { MatDialog } from '@angular/material/dialog' ; ... constructor ( private categoryService : CategoryService , public dialog : MatDialog , ) { } ... createCategory() { const dialogRef = this . dialog . open ( CategoryDialogComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } ... Para poder abrir un componente dentro de un dialogo necesitamos obtener en el constructor un MatDialog. De ah\u00ed que hayamos tenido que a\u00f1adirlo como import y en el constructor. Dentro del m\u00e9todo createCategory lo que hacemos es crear un dialogo con el componente CategoryDialogComponent en su interior, pasarle unos datos de creaci\u00f3n, donde podemos poner estilos del dialog y un objeto data donde pondremos los datos que queremos pasar entre los componentes. Por \u00faltimo, nos suscribimos al evento afterClosed para ejecutar las acciones que creamos oportunas, en nuestro caso volveremos a cargar el listado inicial. Como hemos utilizado un MatDialog en el componente, necesitamos a\u00f1adirlo tambi\u00e9n al m\u00f3dulo, as\u00ed que abrimos el fichero views.module.ts y a\u00f1adimos: views.module.ts ... import { MAT_DIALOG_DATA , MatDialogModule } from '@angular/material/dialog' ; @NgModule ({ declarations : [ CategoriesComponent , CategoryDialogComponent ], imports : [ ... MatDialogModule ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class ViewsModule { } Y ya por \u00faltimo enlazamos el click en el bot\u00f3n con el m\u00e9todo que acabamos de crear para abrir el dialogo. Modificamos el fichero views\\categories\\categories.component.html y a\u00f1adimos el evento click: categories.component.html ... < div class = \"buttons\" > < button mat - flat - button color = \"primary\" ( click ) = \"createCategory()\" > Nueva categor\u00eda < /button> < /div> < /div> Si refrescamos el navegador y pulsamos el bot\u00f3n Nueva categor\u00eda veremos como se abre una ventana modal de tipo Dialog con el componente nuevo que hemos creado. C\u00f3digo del dialogo Ahora vamos a darle forma al formulario de editar y crear. Para ello vamos al html, ts y css del componente y pegamos el siguiente contenido: category-dialog.component.html < div class = \"container\" > < h1 > Crear categor\u00eda </ h1 > < form > < mat-form-field > < mat-label > Identificador </ mat-label > < input type = \"number\" matInput placeholder = \"Identificador\" [( ngModel )]=\" category . id \" name = \"id\" disabled > </ mat-form-field > < mat-form-field > < mat-label > Nombre </ mat-label > < input type = \"text\" matInput placeholder = \"Nombre de categor\u00eda\" [( ngModel )]=\" category . name \" name = \"name\" required > < mat-error > El nombre no puede estar vac\u00edo </ mat-error > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onClose ()\" > Cerrar </ button > < button mat-flat-button color = \"primary\" ( click )=\" onSave () > Guardar </ button > </ div > </ div > category-dialog.component.scss . container { min-width : 350 px ; max-width : 500 px ; width : 100 % ; form { display : flex ; flex-direction : column ; margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } category-dialog.component.ts import { Component , OnInit , Inject } from '@angular/core' ; import { Category } from 'src/app/models/categories/Category' ; import { MatDialogRef } from '@angular/material/dialog' ; import { CategoryService } from 'src/app/services/categories/category.service' ; @Component ({ selector : 'app-category-dialog' , templateUrl : './category-dialog.component.html' , styleUrls : [ './category-dialog.component.scss' ] }) export class CategoryDialogComponent implements OnInit { category : Category ; constructor ( public dialogRef : MatDialogRef < CategoryDialogComponent > , private categoryService : CategoryService ) { } ngOnInit () : void { this . category = new Category (); } onSave() { this . categoryService . saveCategory ( this . category ). subscribe ( result => { this . dialogRef . close (); }); } onClose() { this . dialogRef . close (); } } Si te fijas en el c\u00f3digo TypeScript, hemos a\u00f1adido en el m\u00e9todo onSave una llamada al servicio de Category que aunque no realice ninguna operaci\u00f3n, por lo menos lo dejamos preparado para conectar con el servidor. Adem\u00e1s, como siempre, al utilizar componentes matInput , matForm , matError hay que a\u00f1adirlos como dependencias en el m\u00f3dulo views.module.ts : views.module.ts ... import { MAT_DIALOG_DATA , MatDialogModule } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatInputModule } from '@angular/material/input' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; @NgModule ({ declarations : [ CategoriesComponent , CategoryDialogComponent ], imports : [ ... MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class ViewsModule { } Ahora podemos navegar y abrir el cuadro de dialogo mediante el bot\u00f3n Nueva categor\u00eda para ver como queda nuestro formulario. Utilizar el dialogo para editar El mismo componente que hemos utilizado para crear una nueva categor\u00eda, nos sirve tambi\u00e9n para editar una categor\u00eda existente. Tan solo tenemos que utilizar la funcionalidad que Angular nos proporciona y pasarle los datos a editar en la llamada de apertura del Dialog. Vamos a implementar funcionalidad sobre el icono editar , tendremos que modificar unos cuantos ficheros: categories.component.html < div class = \"container\" > < h1 > Listado de Categor\u00edas </ h1 > < mat-table [ dataSource ]=\" dataSource \" > < ng-container matColumnDef = \"id\" > < mat-header-cell * matHeaderCellDef > Identificador </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.id}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"name\" > < mat-header-cell * matHeaderCellDef > Nombre categor\u00eda </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.name}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" > < mat-icon ( click )=\" editCategory ( element )\" > edit </ mat-icon > </ button > < button mat-icon-button color = \"accent\" >< mat-icon > clear </ mat-icon ></ button > </ mat-cell > </ ng-container > < mat-header-row * matHeaderRowDef = \"displayedColumns; sticky: true\" ></ mat-header-row > < mat-row * matRowDef = \"let row; columns: displayedColumns;\" ></ mat-row > </ mat-table > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createCategory ()\" > Nueva categor\u00eda </ button > </ div > </ div > categories.component.ts export class CategoriesComponent implements OnInit { dataSource = new MatTableDataSource < Category > (); displayedColumns : string [] = [ 'id' , 'name' , 'action' ]; constructor ( private categoryService : CategoryService , public dialog : MatDialog , ) { } ngOnInit () : void { this . categoryService . getCategories (). subscribe ( categories => this . dataSource . data = categories ); } createCategory() { const dialogRef = this . dialog . open ( CategoryDialogComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } editCategory ( category : Category ) { const dialogRef = this . dialog . open ( CategoryDialogComponent , { data : { category : category } }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } } Y los Dialog: category-dialog.component.html < div class = \"container\" > < h1 * ngIf = \"category.id == null\" > Crear categor\u00eda < /h1> < h1 * ngIf = \"category.id != null\" > Modificar categor\u00eda < /h1> < form > < mat - form - field > ... category-dialog.component.ts import { Component , OnInit , Inject } from '@angular/core' ; import { Category } from 'src/app/models/categories/Category' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { CategoryService } from 'src/app/services/categories/category.service' ; @Component ({ selector : 'app-category-dialog' , templateUrl : './category-dialog.component.html' , styleUrls : [ './category-dialog.component.scss' ] }) export class CategoryDialogComponent implements OnInit { category : Category ; constructor ( public dialogRef : MatDialogRef < CategoryDialogComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any , private categoryService : CategoryService ) { } ngOnInit () : void { if ( this . data . category != null ) { this . category = this . data . category ; } else { this . category = new Category (); } } onSave() { this . categoryService . saveCategory ( this . category ). subscribe ( result => { this . dialogRef . close (); }); } onClose() { this . dialogRef . close (); } } Navegando ahora por la p\u00e1gina y pulsando en el icono de editar, se deber\u00eda abrir una ventana con los datos que hemos seleccionado, similar a esta imagen: Si te fijas, al modificar los datos dentro de la ventana de di\u00e1logo se modifica tambi\u00e9n en el listado. Esto es porque estamos pasando el mismo objeto desde el listado a la ventana dialogo y al ser el listado y el formulario reactivos los dos, cualquier cambio sobre los datos se refresca directamente en la pantalla. Hay veces en la que este comportamiento nos interesa, pero en este caso no queremos que se modifique el listado. Para solucionarlo debemos hacer una copia del objeto, para que ambos modelos (formulario y listado) utilicen objetos diferentes. Es tan sencillo como modificar category-dialog.component.ts y a\u00f1adirle una copia del dato category-dialog.component.ts ... ngOnInit () : void { if ( this . data . category != null ) { this . category = Object . assign ({}, this . data . category ); } else { this . category = new Category (); } } ... Cuidado Hay que tener mucho cuidado con el binding de los objetos. Hay veces que al modificar un objeto NO queremos que se modifique en todas sus instancias y tenemos que poner especial cuidado en esos aspectos. Acci\u00f3n de borrado Por norma general, toda acci\u00f3n de borrado de un dato de pantalla requiere una confirmaci\u00f3n previa por parte del usuario. Es decir, para evitar que el dato se borre accidentalmente el usuario tendr\u00e1 que confirmar su acci\u00f3n. Por tanto vamos a crear un componente que nos permita pedir una confirmaci\u00f3n al usuario. Como esta pantalla de confirmaci\u00f3n va a ser algo com\u00fan a muchas acciones de borrado de nuestra aplicaci\u00f3n, vamos a crearla dentro del m\u00f3dulo shared . Como siempre, ejecutamos el comando en consola: ng generate component shared/dialog-confirmation/dialog-confirmation E implementamos el c\u00f3digo que queremos que tenga el componente. Al ser un componente gen\u00e9rico vamos a aprovechar y leeremos las variables que le pasemos en data . dialog-confirmation.component.html < div class = \"container\" > < h1 > {{title}} </ h1 > < div [ innerHTML ]=\" description \" class = \"description\" ></ div > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onNo ()\" > No </ button > < button mat-flat-button color = \"primary\" ( click )=\" onYes ()\" > S\u00ed </ button > </ div > </ div > dialog-confirmation.component.scss . container { min-width : 350 px ; max-width : 500 px ; width : 100 % ; .description { margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } dialog-confirmation.component.ts import { Component , OnInit , Inject } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; @Component ({ selector : 'app-dialog-confirmation' , templateUrl : './dialog-confirmation.component.html' , styleUrls : [ './dialog-confirmation.component.scss' ] }) export class DialogConfirmationComponent implements OnInit { title : string ; description : string ; constructor ( public dialogRef : MatDialogRef < DialogConfirmationComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any ) { } ngOnInit () : void { this . title = this . data . title ; this . description = this . data . description ; } onYes() { this . dialogRef . close ( true ); } onNo() { this . dialogRef . close ( false ); } } Recuerda Recuerda que los componentes utilizados en el di\u00e1logo de confirmaci\u00f3n se deben a\u00f1adir al m\u00f3dulo padre al que pertenecen, en este caso a shared.module.ts imports: [ CommonModule, MatDialogModule, MatIconModule, MatButtonModule, ], providers: [ { provide: MAT_DIALOG_DATA, useValue: {}, }, ] Ya por \u00faltimo, una vez tenemos el componente gen\u00e9rico de dialogo, vamos a utilizarlo en nuestro listado al pulsar el bot\u00f3n eliminar: categories.component.html ... < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" > < mat-icon ( click )=\" editCategory ( element )\" > edit </ mat-icon > </ button > < button mat-icon-button color = \"accent\" > < mat-icon ( click )=\" deleteCategory ( element )\" > clear </ mat-icon > </ button > </ mat-cell > </ ng-container > ... categories.component.ts ... deleteCategory ( category : Category ) { const dialogRef = this . dialog . open ( DialogConfirmationComponent , { data : { title : \"Eliminar categor\u00eda\" , description : \"Atenci\u00f3n si borra la categor\u00eda se perder\u00e1n sus datos.<br> \u00bfDesea eliminar la categor\u00eda?\" } }); dialogRef . afterClosed (). subscribe ( result => { if ( result ) { this . categoryService . deleteCategory ( category . id ). subscribe ( result => { this . ngOnInit (); }); } }); } } Aqu\u00ed tambi\u00e9n hemos realizado la llamada a categoryService , aunque no se realice ninguna acci\u00f3n, pero as\u00ed lo dejamos listo para enlazarlo. Llegados a este punto, ya solo nos queda enlazar las acciones de la pantalla con las operaciones de negocio del backend. Pero eso lo dejaremos para m\u00e1s adelante, primero hay que implementar las operaciones, en la siguiente secci\u00f3n.","title":"Code: Desarrollo con Angular"},{"location":"develop/step1/#desarrollo-con-angular","text":"Ahora que ya tenemos listo tanto el proyecto back de SpringBoot (en el puerto 8080) como el proyecto front de Angular (en el puerto 4200), ya podemos empezar a codificar la soluci\u00f3n. Durante todo el tutorial vamos a intentar separar completamente la implementaci\u00f3n de front de la implementaci\u00f3n de back, para que quede claro como se debe realizar en cada una de las tecnolog\u00edas.","title":"Desarrollo con Angular"},{"location":"develop/step1/#primeros-pasos","text":"Antes de empezar Antes de empezar esta parte te recomendamos encarecidamente que hagas el tutorial que viene en la propia p\u00e1gina de Angular, donde explican algunos de los conceptos b\u00e1sicos y generales de las aplicaciones. Te servir\u00e1 mucho para conocer algunos de los aspectos y componentes que utilizamos durante este tutorial. Lo puedes visitar desde su web Tour of Heroes Si abrimos el proyecto con el IDE que tengamos (Visual Studio Code en el caso del tutorial) podemos ver que en la carpeta src/app existen unos ficheros ya creados por defecto. Estos ficheros son: app.component.ts \u2192 contiene el c\u00f3digo inicial del proyecto escrito en TypeScript. app.component.html \u2192 contiene la plantilla inicial del proyecto escrita en HTML. app.component.scss \u2192 contiene los estilos CSS privados de la plantilla inicial. Vamos a modificar este c\u00f3digo inicial para ver como funciona. Abrimos el fichero app.component.ts y modificamos la l\u00ednea donde se asigna un valor a la variable title . app.component.ts ... title = 'Tutorial de Angular + Springboot' ; ... Ahora abrimos el fichero app.component.html , borramos todo el c\u00f3digo de la plantilla y a\u00f1adimos el siguiente c\u00f3digo: app.component.html < h1 > {{title}} </ h1 > Las llaves dobles permiten hacen un binding entre el c\u00f3digo del componente y la plantilla. Es decir, en este caso ir\u00e1 al c\u00f3digo TypeScript y buscar\u00e1 el valor de la variable title . Consejo El binding tambi\u00e9n nos sirve para ejecutar los m\u00e9todos de TypeScript desde el c\u00f3digo HTML. Adem\u00e1s si el valor que contiene la variable se modificara durante la ejecuci\u00f3n de alg\u00fan m\u00e9todo, autom\u00e1ticamente el c\u00f3digo HTML refrescar\u00eda el nuevo valor de la variable title Si abrimos el navegador y accedemos a http://localhost:4200/ podremos ver el resultado del c\u00f3digo.","title":"Primeros pasos"},{"location":"develop/step1/#layout-general","text":"","title":"Layout general"},{"location":"develop/step1/#crear-componente","text":"Lo primero que vamos a hacer es escoger un tema y una paleta de componentes para trabajar. Lo m\u00e1s c\u00f3modo es trabajar con Material que ya viene perfectamente integrado en Angular. Ejecutamos el comando y elegimos la paleta de colores que m\u00e1s nos guste o bien creamos una custom: ng add @angular/material Recuerda Al a\u00f1adir una nueva librer\u00eda tenemos que parar el servidor y volver a arrancarlo para que compile y precargue las nuevas dependencias. Una vez a\u00f1adida la dependencia, lo que queremos es crear una primera estructura inicial a la p\u00e1gina. Si te acuerdas cual era la estructura (y si no te acuerdas, vuelve a la secci\u00f3n Contexto de la aplicaci\u00f3n y lo revisas), ten\u00edamos una cabecera superior con un logo y t\u00edtulo y unas opciones de men\u00fa. Pues vamos a ello, crearemos esa estructura com\u00fan para toda la aplicaci\u00f3n. Este componente al ser algo core para toda la aplicaci\u00f3n deber\u00edamos crearlo dentro del m\u00f3dulo core como ya vimos anteriormente. Pero antes de todo, vamos a crear los m\u00f3dulos generales de la aplicaci\u00f3n, as\u00ed que ejecutamos en consola el comando que nos permite crear un m\u00f3dulo nuevo: ng generate module shared ng generate module core ng generate module models ng generate module services ng generate module views Y a\u00f1adimos esos m\u00f3dulos al m\u00f3dulo padre de la aplicaci\u00f3n: app.module.ts import { BrowserModule } from '@angular/platform-browser' ; import { NgModule } from '@angular/core' ; import { AppRoutingModule } from './app-routing.module' ; import { AppComponent } from './app.component' ; import { BrowserAnimationsModule } from '@angular/platform-browser/animations' ; import { SharedModule } from './shared/shared.module' ; import { CoreModule } from './core/core.module' ; import { ModelsModule } from './models/models.module' ; import { ServicesModule } from './services/services.module' ; import { ViewsModule } from './views/views.module' ; @NgModule ({ declarations : [ AppComponent ], imports : [ BrowserModule , AppRoutingModule , SharedModule , CoreModule , ModelsModule , ServicesModule , ViewsModule , BrowserAnimationsModule , ], providers : [], bootstrap : [ AppComponent ] }) export class AppModule { } Y despu\u00e9s crearemos el componente header, dentro del m\u00f3dulo core. Para eso ejecutaremos el comando: ng generate component core/header","title":"Crear componente"},{"location":"develop/step1/#codigo-de-la-pantalla","text":"Esto nos crear\u00e1 una carpeta con los ficheros del componente, donde tendremos que copiar el siguiente contenido: header.component.html < mat-toolbar > < mat-toolbar-row > < div class = \"header_container\" > < div class = \"header_title\" > < mat-icon > storefront </ mat-icon > Ludoteca Tan </ div > < div class = \"header_separator\" > | </ div > < div class = \"header_menu\" > < div class = \"header_button\" > < a routerLink = \"/games\" routerLinkActive = \"active\" > Cat\u00e1logo </ a > </ div > < div class = \"header_button\" > < a routerLink = \"/categories\" routerLinkActive = \"active\" > Categor\u00edas </ a > </ div > < div class = \"header_button\" > < a routerLink = \"/authors\" routerLinkActive = \"active\" > Autores </ a > </ div > </ div > < div class = \"header_login\" > < mat-icon > account_circle </ mat-icon > Sign in </ div > </ div > </ mat-toolbar-row > </ mat-toolbar > header.component.scss . mat-toolbar { background-color : blue ; color : white ; } . header_container { display : flex ; width : 100 % ; .header_title { .mat-icon { vertical-align : sub ; } } . header_separator { margin-left : 30 px ; margin-right : 30 px ; } . header_menu { flex-grow : 4 ; display : flex ; flex-direction : row ; .header_button { margin-left : 1 em ; margin-right : 1 em ; font-size : 16 px ; a { font-weight : lighter ; text-decoration : none ; cursor : pointer ; color : white ; } a : hover { color : grey ; } a . active { font-weight : normal ; text-decoration : underline ; color : lightyellow ; } } } . header_login { font-size : 16 px ; cursor : pointer ; .mat-icon { vertical-align : sub ; } } } Al utilizar etiquetas de material como mat-toolbar o mat-icon y routerLink necesitaremos importar las dependencias. Esto lo podemos hacer directamente en el m\u00f3dulo del que depende, es decir en el fichero core.module.ts core.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { MatIconModule } from '@angular/material/icon' ; import { MatToolbarModule } from '@angular/material/toolbar' ; import { HeaderComponent } from './header/header.component' ; import { RouterModule } from '@angular/router' ; @NgModule ({ declarations : [ HeaderComponent ], imports : [ CommonModule , RouterModule , MatIconModule , MatToolbarModule , ], exports : [ HeaderComponent ] }) export class CoreModule { } Adem\u00e1s de a\u00f1adir las dependencias, diremos que este m\u00f3dulo va a exportar el componente HeaderComponent para poder utilizarlo desde otras p\u00e1ginas. Ya por \u00faltimo solo nos queda modificar la p\u00e1gina general de la aplicaci\u00f3n app.component.html para a\u00f1adirle el componente HeaderComponent . app.component.html < div > < app-header ></ app-header > < div > < router-outlet ></ router-outlet > </ div > </ div > Vamos al navegador y refrescamos la p\u00e1gina, deber\u00eda aparecer una barra superior (Header) con las opciones de men\u00fa. Algo similar a esto: Recuerda Cuando se a\u00f1aden componentes a los ficheros html , siempre se deben utilizar los selectores definidos para el componente. En el caso anterior hemos a\u00f1adido app-header que es el mismo nombre selector que tiene el componente en el fichero header.component.ts . Adem\u00e1s, recuerda que para poder utilizar componentes de otros m\u00f3dulos, los debes exportar ya que de lo contrario tan solo podr\u00e1n utilizarse dentro del m\u00f3dulo donde se declaran.","title":"C\u00f3digo de la pantalla"},{"location":"develop/step1/#creando-un-listado-basico","text":"","title":"Creando un listado b\u00e1sico"},{"location":"develop/step1/#crear-componente_1","text":"Ya tenemos la estructura principal, ahora vamos a crear nuestra primera pantalla. Vamos a empezar por la de Categor\u00edas que es la m\u00e1s sencilla, ya que se trata de un listado, que muestra datos sin filtrar ni paginar. Las pantallas deber\u00edan ir todas dentro del m\u00f3dulo views as\u00ed que vamos a ejecutar el siguiente comando para crear la pantalla dentro de dicho m\u00f3dulo: ng generate component views/categories Por \u00faltimo vamos a a\u00f1adir la nueva ruta del componente dentro del routing, para ello modificamos el fichero app-routing.module.ts app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { CategoriesComponent } from './views/categories/categories.component' ; const routes : Routes = [ { path : 'categories' , component : CategoriesComponent }, ]; @NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } Si abrimos el navegador y accedemos a http://localhost:4200/ podremos navegar mediante el men\u00fa Categor\u00edas el cual abrir\u00e1 el componente que acabamos de crear.","title":"Crear componente"},{"location":"develop/step1/#codigo-de-la-pantalla_1","text":"Ahora vamos a construir la pantalla. Para manejar la informaci\u00f3n del listado, necesitamos almacenar los datos en un objeto de tipo model . Para ello crearemos un fichero en models\\categories\\Category.ts donde implementaremos la clase necesaria. Esta clase ser\u00e1 la que utilizaremos en el c\u00f3digo html y ts de nuestro componente. categories.component.html < div class = \"container\" > < h1 > Listado de Categor\u00edas </ h1 > < mat-table [ dataSource ]=\" dataSource \" > < ng-container matColumnDef = \"id\" > < mat-header-cell * matHeaderCellDef > Identificador </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.id}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"name\" > < mat-header-cell * matHeaderCellDef > Nombre categor\u00eda </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.name}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" >< mat-icon > edit </ mat-icon ></ button > < button mat-icon-button color = \"accent\" >< mat-icon > clear </ mat-icon ></ button > </ mat-cell > </ ng-container > < mat-header-row * matHeaderRowDef = \"displayedColumns; sticky: true\" ></ mat-header-row > < mat-row * matRowDef = \"let row; columns: displayedColumns;\" ></ mat-row > </ mat-table > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" > Nueva categor\u00eda </ button > </ div > </ div > categories.component.scss . container { margin : 20 px ; mat-table { margin-top : 10 px ; margin-bottom : 20 px ; .mat-header-row { background-color : #f5f5f5 ; .mat-header-cell { text-transform : uppercase ; font-weight : bold ; color : #838383 ; } } . mat-column-id { flex : 0 0 20 % ; justify-content : center ; } . mat-column-action { flex : 0 0 10 % ; justify-content : center ; } } . buttons { text-align : right ; } } Category.ts export class Category { id : number ; name : string ; } categories.component.ts import { Component , OnInit } from '@angular/core' ; import { Category } from 'src/app/models/categories/Category' ; import { MatTableDataSource } from '@angular/material/table' ; @Component ({ selector : 'app-categories' , templateUrl : './categories.component.html' , styleUrls : [ './categories.component.scss' ] }) export class CategoriesComponent implements OnInit { dataSource = new MatTableDataSource < Category > (); displayedColumns : string [] = [ 'id' , 'name' , 'action' ]; constructor () { } ngOnInit () : void { } } El c\u00f3digo HTML es f\u00e1cil de seguir pero por si acaso: L\u00ednea 4: Creamos la tabla con la variable dataSource definida en el fichero .ts L\u00ednea 5: Definici\u00f3n de la primera columna, su cabecera y el dato que va a contener L\u00ednea 10: Definici\u00f3n de la segunda columna, su cabecera y el dato que va a contener L\u00ednea 15: Definici\u00f3n de la tercera columna, su cabecera vac\u00eda y los dos botones de acci\u00f3n L\u00ednea 23 y 24: Construcci\u00f3n de la cabecera y las filas Y ya por \u00faltimo, a\u00f1adimos los componentes que se han utilizado de Angular Material a las dependencias del m\u00f3dulo donde est\u00e1 definido el componente en este caso views\\views.module.ts : views.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { MatTableModule } from '@angular/material/table' ; import { MatIconModule } from '@angular/material/icon' ; import { MatButtonModule } from '@angular/material/button' ; import { CategoriesComponent } from './categories/categories.component' ; @NgModule ({ declarations : [ CategoriesComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule ], }) export class ViewsModule { } Si abrimos el navegador y accedemos a http://localhost:4200/ y pulsamos en el men\u00fa de Categor\u00edas obtendremos una pantalla con un listado vac\u00edo (solo con cabeceras) y un bot\u00f3n de crear Nueva Categor\u00eda.","title":"C\u00f3digo de la pantalla"},{"location":"develop/step1/#anadiendo-datos","text":"En este punto y para ver como responde el listado, vamos a a\u00f1adir datos. Si tuvieramos el backend implementado podr\u00edamos consultar los datos directamente de una operaci\u00f3n de negocio de backend, pero ahora mismo no lo tenemos implementado as\u00ed que para no bloquear el desarrollo vamos a mockear los datos.","title":"A\u00f1adiendo datos"},{"location":"develop/step1/#creando-un-servicio","text":"En angular, cualquier acceso a datos debe pasar por un service , as\u00ed que vamos a crearnos uno para categor\u00edas. Vamos a la consola y ejecutamos: ng generate service services/categories/category Esto nos crear\u00e1 un servicio y lo a\u00f1adir\u00e1 al m\u00f3dulo de services.module.ts . Adem\u00e1s, este servicio es inyectable por defecto as\u00ed que podemos utilizarlo inyect\u00e1ndolo en cualquier componente que lo necesite.","title":"Creando un servicio"},{"location":"develop/step1/#implementando-un-servicio","text":"Vamos a implementar una operaci\u00f3n de negocio que recupere el listado de categor\u00edas y lo vamos a hacer de forma reactiva (as\u00edncrona) para simular una petici\u00f3n a backend. Modificamos los siguientes ficheros: category.service.ts import { Injectable } from '@angular/core' ; import { Category } from 'src/app/models/categories/Category' ; import { Observable } from 'rxjs' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor () { } getCategories () : Observable < Category [] > { return new Observable (); } } categories.component.ts import { Component , OnInit } from '@angular/core' ; import { Category } from 'src/app/models/categories/Category' ; import { MatTableDataSource } from '@angular/material/table' ; import { CategoryService } from 'src/app/services/categories/category.service' ; @Component ({ selector : 'app-categories' , templateUrl : './categories.component.html' , styleUrls : [ './categories.component.scss' ] }) export class CategoriesComponent implements OnInit { dataSource = new MatTableDataSource < Category > (); displayedColumns : string [] = [ 'id' , 'name' , 'action' ]; constructor ( private categoryService : CategoryService , ) { } ngOnInit () : void { this . categoryService . getCategories (). subscribe ( categories => this . dataSource . data = categories ); } }","title":"Implementando un servicio"},{"location":"develop/step1/#mockeando-datos","text":"Como hemos comentado anteriormente, el backend todav\u00eda no est\u00e1 implementado as\u00ed que vamos a mockear datos. Nos crearemos un fichero mock-categories.ts con datos ficticios y modificaremos el servicio para que devuelva esos datos. De esta forma, cuando tengamos implementada la operaci\u00f3n de negocio en backend, tan solo tenemos que sustuir el c\u00f3digo que devuelve datos est\u00e1ticos por una llamada http. mock-categories.ts import { Category } from 'src/app/models/categories/Category' ; export const CATEGORY_DATA : Category [] = [ { id : 1 , name : 'Dados' }, { id : 2 , name : 'Fichas' }, { id : 3 , name : 'Cartas' }, { id : 4 , name : 'Rol' }, { id : 5 , name : 'Tableros' }, { id : 6 , name : 'Tem\u00e1ticos' }, { id : 7 , name : 'Europeos' }, { id : 8 , name : 'Guerra' }, { id : 9 , name : 'Abstractos' }, ] category.service.ts import { Injectable } from '@angular/core' ; import { CATEGORY_DATA } from './mock-categories' ; import { Category } from 'src/app/models/categories/Category' ; import { Observable , of } from 'rxjs' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor () { } getCategories () : Observable < Category [] > { return of ( CATEGORY_DATA ); } } Si ahora refrescamos la p\u00e1gina web, veremos que el listado ya tiene datos con los que vamos a interactuar.","title":"Mockeando datos"},{"location":"develop/step1/#simulando-las-otras-peticiones","text":"Para terminar, vamos a simular las otras dos peticiones, la de editar y la de borrar para cuando tengamos que utilizarlas. El servicio debe quedar m\u00e1s o menos as\u00ed: category.service.ts import { Injectable } from '@angular/core' ; import { CATEGORY_DATA } from './mock-categories' ; import { Category } from 'src/app/models/categories/Category' ; import { Observable , of } from 'rxjs' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor () { } getCategories () : Observable < Category [] > { return of ( CATEGORY_DATA ); } saveCategory ( category : Category ) : Observable < Category > { return of ( null ); } deleteCategory ( idCategory : number ) : Observable < any > { return of ( null ); } }","title":"Simulando las otras peticiones"},{"location":"develop/step1/#anadiendo-acciones-al-listado","text":"","title":"A\u00f1adiendo acciones al listado"},{"location":"develop/step1/#crear-componente_2","text":"Ahora nos queda a\u00f1adir las acciones al listado: crear, editar y eliminar. Empezaremos primero por las acciones de crear y editar, que ambas deber\u00edan abrir una ventana modal con un formulario para poder modificar datos de la entidad Categor\u00eda . Como siempre, para crear un componente usamos el asistente de Angular, esta vez al tratarse de una pantalla que solo vamos a utilizar dentro del listado de categor\u00edas, tiene sentido que lo creemos dentro de ese directorio: ng generate component views/categories/category-dialog Ahora vamos a hacer que se abra al pulsar el bot\u00f3n Nueva categor\u00eda . Para eso, vamos al fichero views\\categories\\categories.component.ts y a\u00f1adimos un nuevo m\u00e9todo: categories.component.ts ... import { MatDialog } from '@angular/material/dialog' ; ... constructor ( private categoryService : CategoryService , public dialog : MatDialog , ) { } ... createCategory() { const dialogRef = this . dialog . open ( CategoryDialogComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } ... Para poder abrir un componente dentro de un dialogo necesitamos obtener en el constructor un MatDialog. De ah\u00ed que hayamos tenido que a\u00f1adirlo como import y en el constructor. Dentro del m\u00e9todo createCategory lo que hacemos es crear un dialogo con el componente CategoryDialogComponent en su interior, pasarle unos datos de creaci\u00f3n, donde podemos poner estilos del dialog y un objeto data donde pondremos los datos que queremos pasar entre los componentes. Por \u00faltimo, nos suscribimos al evento afterClosed para ejecutar las acciones que creamos oportunas, en nuestro caso volveremos a cargar el listado inicial. Como hemos utilizado un MatDialog en el componente, necesitamos a\u00f1adirlo tambi\u00e9n al m\u00f3dulo, as\u00ed que abrimos el fichero views.module.ts y a\u00f1adimos: views.module.ts ... import { MAT_DIALOG_DATA , MatDialogModule } from '@angular/material/dialog' ; @NgModule ({ declarations : [ CategoriesComponent , CategoryDialogComponent ], imports : [ ... MatDialogModule ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class ViewsModule { } Y ya por \u00faltimo enlazamos el click en el bot\u00f3n con el m\u00e9todo que acabamos de crear para abrir el dialogo. Modificamos el fichero views\\categories\\categories.component.html y a\u00f1adimos el evento click: categories.component.html ... < div class = \"buttons\" > < button mat - flat - button color = \"primary\" ( click ) = \"createCategory()\" > Nueva categor\u00eda < /button> < /div> < /div> Si refrescamos el navegador y pulsamos el bot\u00f3n Nueva categor\u00eda veremos como se abre una ventana modal de tipo Dialog con el componente nuevo que hemos creado.","title":"Crear componente"},{"location":"develop/step1/#codigo-del-dialogo","text":"Ahora vamos a darle forma al formulario de editar y crear. Para ello vamos al html, ts y css del componente y pegamos el siguiente contenido: category-dialog.component.html < div class = \"container\" > < h1 > Crear categor\u00eda </ h1 > < form > < mat-form-field > < mat-label > Identificador </ mat-label > < input type = \"number\" matInput placeholder = \"Identificador\" [( ngModel )]=\" category . id \" name = \"id\" disabled > </ mat-form-field > < mat-form-field > < mat-label > Nombre </ mat-label > < input type = \"text\" matInput placeholder = \"Nombre de categor\u00eda\" [( ngModel )]=\" category . name \" name = \"name\" required > < mat-error > El nombre no puede estar vac\u00edo </ mat-error > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onClose ()\" > Cerrar </ button > < button mat-flat-button color = \"primary\" ( click )=\" onSave () > Guardar </ button > </ div > </ div > category-dialog.component.scss . container { min-width : 350 px ; max-width : 500 px ; width : 100 % ; form { display : flex ; flex-direction : column ; margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } category-dialog.component.ts import { Component , OnInit , Inject } from '@angular/core' ; import { Category } from 'src/app/models/categories/Category' ; import { MatDialogRef } from '@angular/material/dialog' ; import { CategoryService } from 'src/app/services/categories/category.service' ; @Component ({ selector : 'app-category-dialog' , templateUrl : './category-dialog.component.html' , styleUrls : [ './category-dialog.component.scss' ] }) export class CategoryDialogComponent implements OnInit { category : Category ; constructor ( public dialogRef : MatDialogRef < CategoryDialogComponent > , private categoryService : CategoryService ) { } ngOnInit () : void { this . category = new Category (); } onSave() { this . categoryService . saveCategory ( this . category ). subscribe ( result => { this . dialogRef . close (); }); } onClose() { this . dialogRef . close (); } } Si te fijas en el c\u00f3digo TypeScript, hemos a\u00f1adido en el m\u00e9todo onSave una llamada al servicio de Category que aunque no realice ninguna operaci\u00f3n, por lo menos lo dejamos preparado para conectar con el servidor. Adem\u00e1s, como siempre, al utilizar componentes matInput , matForm , matError hay que a\u00f1adirlos como dependencias en el m\u00f3dulo views.module.ts : views.module.ts ... import { MAT_DIALOG_DATA , MatDialogModule } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatInputModule } from '@angular/material/input' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; @NgModule ({ declarations : [ CategoriesComponent , CategoryDialogComponent ], imports : [ ... MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class ViewsModule { } Ahora podemos navegar y abrir el cuadro de dialogo mediante el bot\u00f3n Nueva categor\u00eda para ver como queda nuestro formulario.","title":"C\u00f3digo del dialogo"},{"location":"develop/step1/#utilizar-el-dialogo-para-editar","text":"El mismo componente que hemos utilizado para crear una nueva categor\u00eda, nos sirve tambi\u00e9n para editar una categor\u00eda existente. Tan solo tenemos que utilizar la funcionalidad que Angular nos proporciona y pasarle los datos a editar en la llamada de apertura del Dialog. Vamos a implementar funcionalidad sobre el icono editar , tendremos que modificar unos cuantos ficheros: categories.component.html < div class = \"container\" > < h1 > Listado de Categor\u00edas </ h1 > < mat-table [ dataSource ]=\" dataSource \" > < ng-container matColumnDef = \"id\" > < mat-header-cell * matHeaderCellDef > Identificador </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.id}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"name\" > < mat-header-cell * matHeaderCellDef > Nombre categor\u00eda </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.name}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" > < mat-icon ( click )=\" editCategory ( element )\" > edit </ mat-icon > </ button > < button mat-icon-button color = \"accent\" >< mat-icon > clear </ mat-icon ></ button > </ mat-cell > </ ng-container > < mat-header-row * matHeaderRowDef = \"displayedColumns; sticky: true\" ></ mat-header-row > < mat-row * matRowDef = \"let row; columns: displayedColumns;\" ></ mat-row > </ mat-table > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createCategory ()\" > Nueva categor\u00eda </ button > </ div > </ div > categories.component.ts export class CategoriesComponent implements OnInit { dataSource = new MatTableDataSource < Category > (); displayedColumns : string [] = [ 'id' , 'name' , 'action' ]; constructor ( private categoryService : CategoryService , public dialog : MatDialog , ) { } ngOnInit () : void { this . categoryService . getCategories (). subscribe ( categories => this . dataSource . data = categories ); } createCategory() { const dialogRef = this . dialog . open ( CategoryDialogComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } editCategory ( category : Category ) { const dialogRef = this . dialog . open ( CategoryDialogComponent , { data : { category : category } }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } } Y los Dialog: category-dialog.component.html < div class = \"container\" > < h1 * ngIf = \"category.id == null\" > Crear categor\u00eda < /h1> < h1 * ngIf = \"category.id != null\" > Modificar categor\u00eda < /h1> < form > < mat - form - field > ... category-dialog.component.ts import { Component , OnInit , Inject } from '@angular/core' ; import { Category } from 'src/app/models/categories/Category' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { CategoryService } from 'src/app/services/categories/category.service' ; @Component ({ selector : 'app-category-dialog' , templateUrl : './category-dialog.component.html' , styleUrls : [ './category-dialog.component.scss' ] }) export class CategoryDialogComponent implements OnInit { category : Category ; constructor ( public dialogRef : MatDialogRef < CategoryDialogComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any , private categoryService : CategoryService ) { } ngOnInit () : void { if ( this . data . category != null ) { this . category = this . data . category ; } else { this . category = new Category (); } } onSave() { this . categoryService . saveCategory ( this . category ). subscribe ( result => { this . dialogRef . close (); }); } onClose() { this . dialogRef . close (); } } Navegando ahora por la p\u00e1gina y pulsando en el icono de editar, se deber\u00eda abrir una ventana con los datos que hemos seleccionado, similar a esta imagen: Si te fijas, al modificar los datos dentro de la ventana de di\u00e1logo se modifica tambi\u00e9n en el listado. Esto es porque estamos pasando el mismo objeto desde el listado a la ventana dialogo y al ser el listado y el formulario reactivos los dos, cualquier cambio sobre los datos se refresca directamente en la pantalla. Hay veces en la que este comportamiento nos interesa, pero en este caso no queremos que se modifique el listado. Para solucionarlo debemos hacer una copia del objeto, para que ambos modelos (formulario y listado) utilicen objetos diferentes. Es tan sencillo como modificar category-dialog.component.ts y a\u00f1adirle una copia del dato category-dialog.component.ts ... ngOnInit () : void { if ( this . data . category != null ) { this . category = Object . assign ({}, this . data . category ); } else { this . category = new Category (); } } ... Cuidado Hay que tener mucho cuidado con el binding de los objetos. Hay veces que al modificar un objeto NO queremos que se modifique en todas sus instancias y tenemos que poner especial cuidado en esos aspectos.","title":"Utilizar el dialogo para editar"},{"location":"develop/step1/#accion-de-borrado","text":"Por norma general, toda acci\u00f3n de borrado de un dato de pantalla requiere una confirmaci\u00f3n previa por parte del usuario. Es decir, para evitar que el dato se borre accidentalmente el usuario tendr\u00e1 que confirmar su acci\u00f3n. Por tanto vamos a crear un componente que nos permita pedir una confirmaci\u00f3n al usuario. Como esta pantalla de confirmaci\u00f3n va a ser algo com\u00fan a muchas acciones de borrado de nuestra aplicaci\u00f3n, vamos a crearla dentro del m\u00f3dulo shared . Como siempre, ejecutamos el comando en consola: ng generate component shared/dialog-confirmation/dialog-confirmation E implementamos el c\u00f3digo que queremos que tenga el componente. Al ser un componente gen\u00e9rico vamos a aprovechar y leeremos las variables que le pasemos en data . dialog-confirmation.component.html < div class = \"container\" > < h1 > {{title}} </ h1 > < div [ innerHTML ]=\" description \" class = \"description\" ></ div > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onNo ()\" > No </ button > < button mat-flat-button color = \"primary\" ( click )=\" onYes ()\" > S\u00ed </ button > </ div > </ div > dialog-confirmation.component.scss . container { min-width : 350 px ; max-width : 500 px ; width : 100 % ; .description { margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } dialog-confirmation.component.ts import { Component , OnInit , Inject } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; @Component ({ selector : 'app-dialog-confirmation' , templateUrl : './dialog-confirmation.component.html' , styleUrls : [ './dialog-confirmation.component.scss' ] }) export class DialogConfirmationComponent implements OnInit { title : string ; description : string ; constructor ( public dialogRef : MatDialogRef < DialogConfirmationComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any ) { } ngOnInit () : void { this . title = this . data . title ; this . description = this . data . description ; } onYes() { this . dialogRef . close ( true ); } onNo() { this . dialogRef . close ( false ); } } Recuerda Recuerda que los componentes utilizados en el di\u00e1logo de confirmaci\u00f3n se deben a\u00f1adir al m\u00f3dulo padre al que pertenecen, en este caso a shared.module.ts imports: [ CommonModule, MatDialogModule, MatIconModule, MatButtonModule, ], providers: [ { provide: MAT_DIALOG_DATA, useValue: {}, }, ] Ya por \u00faltimo, una vez tenemos el componente gen\u00e9rico de dialogo, vamos a utilizarlo en nuestro listado al pulsar el bot\u00f3n eliminar: categories.component.html ... < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" > < mat-icon ( click )=\" editCategory ( element )\" > edit </ mat-icon > </ button > < button mat-icon-button color = \"accent\" > < mat-icon ( click )=\" deleteCategory ( element )\" > clear </ mat-icon > </ button > </ mat-cell > </ ng-container > ... categories.component.ts ... deleteCategory ( category : Category ) { const dialogRef = this . dialog . open ( DialogConfirmationComponent , { data : { title : \"Eliminar categor\u00eda\" , description : \"Atenci\u00f3n si borra la categor\u00eda se perder\u00e1n sus datos.<br> \u00bfDesea eliminar la categor\u00eda?\" } }); dialogRef . afterClosed (). subscribe ( result => { if ( result ) { this . categoryService . deleteCategory ( category . id ). subscribe ( result => { this . ngOnInit (); }); } }); } } Aqu\u00ed tambi\u00e9n hemos realizado la llamada a categoryService , aunque no se realice ninguna acci\u00f3n, pero as\u00ed lo dejamos listo para enlazarlo. Llegados a este punto, ya solo nos queda enlazar las acciones de la pantalla con las operaciones de negocio del backend. Pero eso lo dejaremos para m\u00e1s adelante, primero hay que implementar las operaciones, en la siguiente secci\u00f3n.","title":"Acci\u00f3n de borrado"},{"location":"develop/step2/","text":"Desarrollo con Springboot Ahora que ya tenemos listo tanto el proyecto back de SpringBoot (en el puerto 8080) como el proyecto front de Angular (en el puerto 4200), ya podemos empezar a codificar la soluci\u00f3n. Durante todo el tutorial vamos a intentar separar completamente la implementaci\u00f3n de front de la implementaci\u00f3n de back, para que quede claro como se debe realizar en cada una de las tecnolog\u00edas. Primeros pasos Antes de empezar Quiero hacer hincapi\u00e9 en Springboot tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. Tanto la propia web de Spring como en el portal de tutoriales de Baeldung puedes buscar casi cualquier ejemplo que necesites. Si has seguido el tutorial, en la creaci\u00f3n del proyecto ten\u00edas la posibilidad de crear un proyecto Devonfw o crear un proyecto Springboot simple. Hay ciertas herramientas y configuraciones que provee Devonfw que son muy \u00fatiles a la hora de desarrollar aplicaciones y por tanto si hemos creado una aplicaci\u00f3n Springboot deber\u00edamos a\u00f1adirlas. A\u00f1adir utilidades Devonfw Lo primero que vamos a hacer es a\u00f1adir las dependencias a librer\u00edas de devonfw. Abriremos el fichero pom.xml que nos ha generado el Spring Initilizr y a\u00f1adiremos las siguientes l\u00edneas: pom.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <parent> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-parent </artifactId> <version> 2.3.0.RELEASE </version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId> com.capgemini.coedevon </groupId> <artifactId> tutorial </artifactId> <version> 0.0.1-SNAPSHOT </version> <name> tutorial </name> <description> Demo project for Spring Boot </description> <properties> <java.version> 1.8 </java.version> <devon4j.version> 2020.04.001 </devon4j.version> </properties> <dependencyManagement> <dependencies> <!-- BOM of devon4j --> <dependency> <groupId> com.devonfw.java.boms </groupId> <artifactId> devon4j-bom </artifactId> <version> ${devon4j.version} </version> <type> pom </type> <scope> import </scope> </dependency> </dependencies> </dependencyManagement> <dependencies> <!-- Bean-Mapping for conversion from TO to Entity and vice versa --> <dependency> <groupId> com.devonfw.java.modules </groupId> <artifactId> devon4j-beanmapping-orika </artifactId> </dependency> <!-- Rest Mappers --> <dependency> <groupId> com.devonfw.java.modules </groupId> <artifactId> devon4j-rest </artifactId> </dependency> <!-- JPA --> <dependency> <groupId> com.devonfw.java.starters </groupId> <artifactId> devon4j-starter-spring-data-jpa </artifactId> </dependency> <!-- <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-jpa</artifactId> </dependency> --> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-web </artifactId> </dependency> <dependency> <groupId> org.flywaydb </groupId> <artifactId> flyway-core </artifactId> </dependency> <dependency> <groupId> com.h2database </groupId> <artifactId> h2 </artifactId> <scope> runtime </scope> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-test </artifactId> <scope> test </scope> <exclusions> <exclusion> <groupId> org.junit.vintage </groupId> <artifactId> junit-vintage-engine </artifactId> </exclusion> </exclusions> </dependency> </dependencies> <build> <plugins> <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> </plugin> </plugins> </build> </project> Ojo, que hemos sustituido la dependencia de Spring-JPA por la dependencia de Devonfw-JPA ya que nos permite utilizar m\u00e1s funcionalidades extendidas sobre repositorios JPA. Adem\u00e1s de esa dependencia, hemos a\u00f1adido una utilidad para hacer mapeos entre objetos y para configurar los servicios Rest. Configurar utilidades Devonfw El siguiente punto es crear las clases de configuraci\u00f3n para las librer\u00edas que hemos a\u00f1adido. Para ello vamos a crear un package de configuraci\u00f3n general de la aplicaci\u00f3n com.capgemini.coedevon.tutorial.config donde crearemos tres clases (dos de ellas dentro del subpaquete mapper ). BeansOrikaConfig.java package com.capgemini.coedevon.tutorial.config ; import org.springframework.context.annotation.Bean ; import org.springframework.context.annotation.Configuration ; import com.capgemini.coedevon.tutorial.config.mapper.BeanMapper ; import com.capgemini.coedevon.tutorial.config.mapper.BeanMapperImpl ; import com.devonfw.module.beanmapping.common.base.BaseOrikaConfig ; import com.devonfw.module.json.common.base.ObjectMapperFactory ; import com.fasterxml.jackson.databind.Module ; import ma.glasnost.orika.MapperFactory ; /** * Java bean configuration for Orika. The method {@link #configureCustomMapping(MapperFactory)} from * {@link BaseOrikaConfig} can be overridden as per requirements. */ @Configuration public class BeansOrikaConfig extends BaseOrikaConfig { /** * @return the {@link BeanMapper} implementation. */ @Override @Bean public BeanMapper getBeanMapper () { return new BeanMapperImpl (); } @Bean public Module configureObjectMapper () { ObjectMapperFactory objectMapper = new ObjectMapperFactory (); return objectMapper . getExtensionModule (); } } mapper/BeanMapper.java package com.capgemini.coedevon.tutorial.config.mapper ; import org.springframework.data.domain.Page ; /** * @author coedevon */ public interface BeanMapper extends com . devonfw . module . beanmapping . common . api . BeanMapper { /** * Mapea el gen\u00e9rico de un Page en otro tipo de gen\u00e9rico * @param <T> * @param source * @param targetClass * @return */ < T > Page < T > mapPage ( Page source , Class < T > targetClass ); } mapper/BeanMapperImpl.java package com.capgemini.coedevon.tutorial.config.mapper ; import java.util.List ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.PageImpl ; import com.devonfw.module.beanmapping.common.impl.orika.BeanMapperImplOrika ; /** * @author coedevon */ public class BeanMapperImpl extends BeanMapperImplOrika implements BeanMapper { /** * {@inheritDoc} */ public < T > Page < T > mapPage ( Page source , Class < T > targetClass ) { if ( source == null ) { return null ; } List list = mapList ( source . getContent (), targetClass ); return new PageImpl <> ( list , source . getPageable (), source . getTotalElements ()); } } Listo, ya podemos empezar a desarrollar nuestros servicios. Estructurar el c\u00f3digo Vamos a hacer un breve refresco de la estructura del c\u00f3digo que ya se ha visto en puntos anteriores. Las clases deben estar agrupadas por \u00e1mbito funcional, en nuestro caso como vamos a hacer la funcionalidad de Categor\u00edas pues deber\u00eda estar todo dentro de un package del tipo com.capgemini.coedevon.tutorial.category . Adem\u00e1s, deber\u00edamos aplicar la separaci\u00f3n por capas como ya se vi\u00f3 en el esquema: La primera capa, la de Controlador , se encargar\u00e1 de procesar las peticiones y transformar datos. Esta capa llamar\u00e1 a la capa de L\u00f3gica de negocio que ejecutar\u00e1 las operaciones, ayud\u00e1ndose de otros objetos de esa misma capa de L\u00f3gica o bien de llamadas a datos a trav\u00e9s de la capa de Acceso a Datos Ahora s\u00ed, vamos a programar!. Capa de operaciones: Controller En esta capa es donde se definen las operaciones que pueden ser consumidas por los clientes. Se caracterizan por estar anotadas con las anotaciones @Controller o @RestController y por las anotaciones @RequestMapping que nos permiten definir las rutas de acceso. Controller de ejemplo Vamos a crear una clase CategoryController.java dentro del package com.capgemini.coedevon.tutorial.category para definir las rutas de las operaciones. CategoryController.java package com.capgemini.coedevon.tutorial.category ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; /** * @author coedevon */ @RequestMapping ( value = \"/category/v1\" ) @RestController public class CategoryController { /** * M\u00e9todo para recuperar todas las Category * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . GET ) public String prueba () { return \"Probando el Controller\" ; } } Si abrimos el Postman y creamos una petici\u00f3n GET a la url http://localhost:8080/category/v1/ nos responder\u00e1 con el mensaje que hemos puesto. Implementar operaciones Ahora que ya tenemos un controlador y una operacion de negocio ficticia, vamos a borrarla y a\u00f1adir las operaciones reales que consumir\u00e1 nuestra pantalla. Deberemos a\u00f1adir una operaci\u00f3n para listar, una para actualizar, una para guardar y una para borrar. Aunque para hacerlo m\u00e1s c\u00f3modo, utilizaremos la misma operaci\u00f3n para guardar y para actualizar. Adem\u00e1s, no estar trabajando con tipos simples, vamos a utilizar un objeto para recibir informaci\u00f3n y para enviar informaci\u00f3n. Estos objetos t\u00edpicamente se denominan DTO (Data Transfer Object) y nos sirven justamente para encapsular informaci\u00f3n que queremos transportar. En realidad no son m\u00e1s que clases pojo sencilla con propiedades y getters y setters. Para nuestro ejemplo crearemos una clase CategoryDto dentro del package com.capgemini.coedevon.tutorial.category.model con el siguiente contenido: CategoryDto.java package com.capgemini.coedevon.tutorial.category.model ; /** * @author coedevon */ public class CategoryDto { private Long id ; private String name ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } } A continuaci\u00f3n utilizaremos esta clase en nuestro Controller para implementar las tres operaciones de negocio. CategoryController.java package com.capgemini.coedevon.tutorial.category ; import java.util.ArrayList ; import java.util.HashMap ; import java.util.List ; import java.util.Map ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; /** * @author coedevon */ @RequestMapping ( value = \"/category/v1\" ) @RestController public class CategoryController { private long SEQUENCE = 1 ; private Map < Long , CategoryDto > categories = new HashMap < Long , CategoryDto > (); /** * M\u00e9todo para recuperar todas las Category * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { return new ArrayList ( this . categories . values ()); } /** * M\u00e9todo para crear o actualizar una Category * @param dto * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . PUT ) public CategoryDto save ( @RequestBody CategoryDto dto ) { CategoryDto category = this . categories . get ( dto . getId ()); if ( category == null ) { category = new CategoryDto (); category . setId ( this . SEQUENCE ++ ); this . categories . put ( category . getId (), category ); } category . setName ( dto . getName ()); return category ; } /** * M\u00e9todo para borrar una Category * @param id */ @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . categories . remove ( id ); } } Como todav\u00eda no tenemos acceso a BD, hemos creado una variable tipo HashMap y una variable Long, que simular\u00e1n una BD y una secuencia. Tambi\u00e9n hemos implementado tres operaciones GET, PUT y DELETE que realizan las acciones necesarias por nuestra pantalla. Ahora podr\u00edamos probarlo desde el Postman con cuatro ejemplo sencillos. Atenci\u00f3n Los datos que se reciben pueden venir informados como un par\u00e1metro en la URL Get, como una variable en el propio path o dentro del body de la petici\u00f3n. Cada uno de ellos se recupera con una anotaci\u00f3n especial: @RequestParam , @PathVariable y @RequestBody respectivamente. GET nos devuelve un listado de Categor\u00edas PUT nos sirve para insertar Categor\u00edas nuevas (si no tienen el id informado) o para actualizar Categor\u00edas (si tienen el id informado). F\u00edjate que los datos que se reciben est\u00e1n en el body. DELETE nos sirve eliminar Categor\u00edas . F\u00edjate que el dato del ID est\u00e1 en el path. Aspectos importantes Los aspectos importantes de la capa Controller son: La clase debe estar anotada con @Controller o @RestController . Mejor usar la \u00faltima anotaci\u00f3n ya que est\u00e1s diciendo que las operaciones son de tipo Rest y no har\u00e1 falta configurar nada La ruta general al controlador se define con el @RequestMapping global de la clase, aunque tambi\u00e9n se puede obviar esta anotaci\u00f3n y a\u00f1adir a cada una de las operaciones la ruta ra\u00edz. Importante, a modo de consejo, anadir en la ruta la versi\u00f3n de la API (en nuestro ejemplo v1). Esto nos ayudar\u00e1 a ampliarla y cambiar la funcionalidad a futuro: Cualquier modificaci\u00f3n del algoritmo que no afecte al contrato o cualquier operaci\u00f3n nueva, puede ir en la misma versi\u00f3n Eliminaciones y modificaciones de contrato, deber\u00edan ir en un Controller nuevo anotado con otra versi\u00f3n ( category/v2/ por ejemplo) Los m\u00e9todos que queramos exponer como operaciones deben ir anotados tambi\u00e9n con @RequestMapping con la info: path \u2192 Que nos permite definir un path para la operaci\u00f3n, siempre sum\u00e1ndole el path de la clase (si es que tuviera) method \u2192 Que nos permite definir el verbo de http que vamos a atender. Podemos tener el mismo path con diferente method, sin problema. Por lo general utilizaremos: GET \u2192 Generalmente se usa para recuperar informaci\u00f3n POST \u2192 Se utiliza para hacer update y filtrados complejos de informaci\u00f3n PUT \u2192 Se utiliza para hacer save de informaci\u00f3n DELETE \u2192 Se utiliza para hacer borrados de informaci\u00f3n Capa de Servicio: Service Pero en realidad la cosa no funciona as\u00ed. Hemos implementado parte de la l\u00f3gica de negocio (las operaciones/acciones de guardado, borrado y listado) dentro de lo que ser\u00eda la capa de operaciones o servicios al cliente. Esta capa no debe ejecutar l\u00f3gica de negocio, tan solo debe hacer transformaciones de datos y enrutar peticiones, toda la l\u00f3gica deber\u00eda ir en la capa de servicio. Implementar servicios Pues vamos a arreglarlo. Vamos a crear un servicio y vamos a mover la l\u00f3gica de negocio al servicio. CategoryService.java package com.capgemini.coedevon.tutorial.category ; import java.util.List ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; /** * @author coedevon * */ public interface CategoryService { /** * M\u00e9todo para recuperar todas las Category * @return */ List < CategoryDto > findAll (); /** * M\u00e9todo para crear o actualizar una Category * @param dto * @return */ CategoryDto save ( CategoryDto dto ); /** * M\u00e9todo para borrar una Category * @param id */ void delete ( Long id ); } CategoryServiceImpl.java package com.capgemini.coedevon.tutorial.category ; import java.util.ArrayList ; import java.util.HashMap ; import java.util.List ; import java.util.Map ; import org.springframework.stereotype.Service ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; /** * @author coedevon * */ @Service public class CategoryServiceImpl implements CategoryService { private long ID = 1 ; private Map < Long , CategoryDto > categories = new HashMap < Long , CategoryDto > (); /** * M\u00e9todo para recuperar todas las Category * @return */ public List < CategoryDto > findAll () { return new ArrayList ( this . categories . values ()); } /** * M\u00e9todo para crear o actualizar una Category * @param dto * @return */ public CategoryDto save ( CategoryDto dto ) { CategoryDto category = this . categories . get ( dto . getId ()); if ( category == null ) { category = new CategoryDto (); category . setId ( this . ID ++ ); this . categories . put ( category . getId (), category ); } category . setName ( dto . getName ()); return category ; } /** * M\u00e9todo para borrar una Category * @param id */ public void delete ( Long id ) { this . categories . remove ( id ); } } CategoryController.java package com.capgemini.coedevon.tutorial.category ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; /** * @author coedevon */ @RequestMapping ( value = \"/category/v1\" ) @RestController public class CategoryController { @Autowired private CategoryService categoryService ; /** * M\u00e9todo para recuperar todas las Category * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { return this . categoryService . findAll (); } /** * M\u00e9todo para crear o actualizar una Category * @param dto * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . PUT ) public CategoryDto save ( @RequestBody CategoryDto dto ) { return this . categoryService . save ( dto ); } /** * M\u00e9todo para borrar una Category * @param id */ @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . categoryService . delete ( id ); } } Ahora ya tenemos bien estructurado nuestro proyecto. Ya tenemos las dos capas necesarias Controladores y Servicios y cada uno se encarga de llevar a cabo su cometido de forma correcta. Aspectos importantes Los aspectos importantes de la capa Service son: Toda la l\u00f3gica de negocio, operaciones y dem\u00e1s debe estar implementada en los servicios. Los controladores simplemente invocan servicios y transforman ciertos datos. Es buena pr\u00e1ctica que la capa de servicios se implemente usando el patr\u00f3n fachada, esto quiere decir que necesitamos tener una Interface y al menos una implementaci\u00f3n de esa Interface. Y siempre siempre debemos interactuar con la Interface. Esto nos permitir\u00e1 a futuro poder sustituir la implementaci\u00f3n por otra diferente sin que el resto del c\u00f3digo se vea afectado. Especialmente \u00fatil cuando queremos mockear comportamientos en tests. La capa de servicio puede invocar a otros servicios en sus operaciones, pero nunca debe invocar a un controlador. Para crear un servicio se debe anotar mediante @Service y adem\u00e1s debe implementar la Interface del servicio. Un error muy com\u00fan al arrancar un proyecto y ver que no funcionan las llamadas, es porqu\u00e9 no existe la anotaci\u00f3n @Service o porqu\u00e9 no se ha implementado la Interface. La forma de inyectar y utilizar componentes manejados por Springboot es mediante la anotaci\u00f3n @Autowired . NO intentes crear un objeto de CategoryServiceImpl, ni hacer un new , ya que no estar\u00e1 manejado por Springboot y dar\u00e1 fallos de NullPointer. Lo mejor es dejar que Springboot lo gestione y utilizar las inyecciones de dependencias. Capa de Datos: Repository Pero no siempre vamos a acceder a los datos mediante un HasMap en memoria. En algunas ocasiones queremos que nuestro proyecto acceda a un servicio de datos como puede ser una BBDD, un servicio externo, un acceso a disco, etc. Estos accesos se deben hacer desde la capa de acceso a datos, y en concreto para nuestro ejemplo, lo haremos a trav\u00e9s de un Repository para que acceda a una BBDD. Creaci\u00f3n de BBDD Para el tutorial no necesitamos configurar una BBDD externa ni complicarnos demasiado. Vamos a utilizar una librer\u00eda muy \u00fatil llamada H2 que nos permite levantar una BBDD en memoria persistiendo los datos en memoria o en disco y vamos a utilizar las librer\u00edas de flyway para crear nuestro esquema de BBDD en el arranque de la aplicaci\u00f3n. Para esto, si te acuerdas de cuando creamos la aplicaci\u00f3n, existen unos ficheros que se encuentran dentro de la carpeta src/main/resources/db/migration/ y que nos permiten ir depositando scripts versionados para que se ejecuten en orden una vez se levante la aplicaci\u00f3n. Vamos a crear los nuestros: V0001__Create_Schema.sql CREATE SEQUENCE HIBERNATE_SEQUENCE START WITH 1000000 ; DROP TABLE IF EXISTS CATEGORY ; CREATE TABLE CATEGORY ( id BIGINT AUTO_INCREMENT PRIMARY KEY , name VARCHAR ( 250 ) NOT NULL ); V0002__Create_Data.sql INSERT INTO CATEGORY ( id , name ) VALUES ( 1 , 'Eurogames' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 2 , 'Ameritrash' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 3 , 'Familiar' ); La creaci\u00f3n de la secuencia de hibernate es necesaria para que H2 pueda trabajar con ID auto incrementales. De lo contrario al arrancar la aplicaci\u00f3n se quejar\u00e1. Implementar Entity Una vez creada la BBDD el siguiente paso es crear la entidad con la que vamos a persistir y recuperar informaci\u00f3n. Las entidades igual que los DTOs deber\u00edan estar agrupados dentro del package model de cada funcionalidad, as\u00ed que vamos a crear una nueva clase java. Category.java package com.capgemini.coedevon.tutorial.category.model ; import javax.persistence.Column ; import javax.persistence.Entity ; import javax.persistence.GeneratedValue ; import javax.persistence.GenerationType ; import javax.persistence.Id ; import javax.persistence.Table ; /** * @author coedevon */ @Entity @Table ( name = \"Category\" ) public class Category { @Id @GeneratedValue ( strategy = GenerationType . AUTO ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"name\" , nullable = false ) private String name ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } } Si te fijas, la Entity suele ser muy similar a un DTO, tiene unas propiedades y sus getters y setters. Pero a diferencia de los DTOs, esta clase tiene una serie de anotaciones que permiten a JPA hacer su magia y generar consultas SQL a la BBDD. En este ejemplo vemos 4 anotaciones importantes: @Entity \u2192 Le indica a Springboot que se trata de una clase que implementa una Entidad de BBDD. Sin esta anotaci\u00f3n no es posible hacer queries. @Table \u2192 Le indica a JPA el nombre y el schema de la tabla que representa esta clase. Por claridad se deber\u00eda poner siempre, aunque si el nombre de la tabla es igual al nombre de la clase no es necesaria la anotaci\u00f3n. @Id y @GeneratedValue \u2192 Le indica a JPA que esta propiedad es la que mapea una Primary Key y adem\u00e1s que esta PK se genera con la estrategia que se le indique en la anotaci\u00f3n @GeneratedValue , que puede ser: Generaci\u00f3n de PK por Secuence , la que utiliza Oracle, en este caso habr\u00e1 que indicarle un nombre de secuencia. Generaci\u00f3n de PK por Indentity , la que utiliza MySql o SQLServer, el auto-incremental. Generaci\u00f3n de PK por Table , en algunas BBDD se permite tener una tabla donde se almacenan como registros todas las secuencias. Generaci\u00f3n de PK Auto , elige la mejor estrategia en funci\u00f3n de la BBDD que hemos seleccionado. @Column \u2192 Le indica a JPA que esta propiedad mapea una columna de la tabla y le especifica el nombre de la columna. Al igual que la anotaci\u00f3nd de Table , esta anotaci\u00f3n no es necesaria aunque si es muy recomendable. Por claridad se deber\u00eda poner siempre, aunque si el nombre de la columna es igual al nombre de la propiedad no es necesaria la anotaci\u00f3n. Hay muchas otras anotaciones, pero estas son las b\u00e1sicas, ya ir\u00e1s aprendiendo otras. Consejo Para definir las PK de las tablas, intenta evitar una PK compuesta de m\u00e1s de una columna. La programaci\u00f3n se hace muy compleja y las magias que hace JPA en la oscuridad se complican mucho. Mi recomendaci\u00f3n es que siempre utilices una PK n\u00famerica, en la medida de lo posible, y si es necesario, crees \u00edndices compuestos de b\u00fasqueda o checks compuestos para evitar duplicidades. Implementar Repository Ahora que ya tenemos la entidad implementada, vamos a utilizarla para acceder a BBDD, y esto lo haremos con un Repository . Existen varias formas de utilizar los repositories, desde el todo autom\u00e1tico y magia de JPA hasta el repositorio manual en el que hay que codificar todo. En el tutorial voy a explicar varias formas de implementarlo para este CRUD y los siguientes CRUDs. Como ya se dijo en puntos anteriores, el acceso a datos se debe hacer siempre a trav\u00e9s de un Repository , as\u00ed que vamos a implementar uno. En esta capa, al igual que pasaba con los services, es recomendable utilizar el patr\u00f3n fachada, para poder sustituir implementaciones sin afectar al c\u00f3digo. CategoryRepository.java package com.capgemini.coedevon.tutorial.category ; import org.springframework.data.repository.CrudRepository ; import com.capgemini.coedevon.tutorial.category.model.Category ; /** * @author coedevon */ public interface CategoryRepository extends CrudRepository < Category , Long > { } \u00bfQue te parece?, sencillo, \u00bfno?. Spring ya tiene una implementaci\u00f3n por defecto de un CrudRepository, tan solo tenemos que crear una interface que extienda de la interface CrudRepository pasandole como tipos la Entity y el tipo de la Primary Key. Con eso Spring construye el resto y nos provee de los m\u00e9todos t\u00edpicos y necesarios para un CRUD. Ahora vamos a utilizarla en el Service , pero hay un problema. El Repository devuelve un objeto tipo Category y el Service y Controller devuelven un objeto tipo CategoryDto . Esto es porque en cada capa se debe con un \u00e1mbito de modelos diferente. Podr\u00edamos hacer que todo el back trabajara con Category que son entidades de persistencia, pero no es lo correcto y nos podr\u00eda llevar a cometer errores, o modificar el objeto y que sin que nosotros lo orden\u00e1semos se persistiera ese cambio en BBDD. El \u00e1mbito de trabajo de las capas con el que solemos trabajar y est\u00e1 m\u00e1s extendido es el siguiente: Los datos que vienen y van al cliente, deber\u00edan ser en la mayor\u00eda de los casos datos en formato json Al entrar en un Controller esos datos json se transforman en un DTO. Al salir del Controller hacia el cliente, esos DTOs se transforman en formato json. Estas conversiones son autom\u00e1ticas, las hace Springboot (en realidad las hace la librer\u00eda de jackson codehaus). Cuando un Controller ejecuta una llamada a un Service , generalmente le pasa sus datos en DTO, y el Service se encarga de transformar esto a una Entity . A la inversa, cuando un Service responde a un Controller , \u00e9l responde con una Entity y el Controller ya se encargar\u00e1 de transformarlo a DTO. Por \u00faltimo, para los Repository , siempre se trabaja de entrada y salida con objetos tipo Entity Parece un lio, pero ya ver\u00e1s como es muy sencillo ahora que veremos el ejemplo. Una \u00faltima cosa, para hacer esas transformaciones, las podemos hacer a mano usando getters y setters o bien utilizar el objeto BeanMapper que hemos configurado al principio como utilidad de Devonfw. El c\u00f3digo deber\u00eda quedar as\u00ed: CategoryServiceImpl.java package com.capgemini.coedevon.tutorial.category ; import java.util.List ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import com.capgemini.coedevon.tutorial.category.model.Category ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; /** * @author coedevon * */ @Service public class CategoryServiceImpl implements CategoryService { @Autowired CategoryRepository categoryRepository ; /** * {@inheritDoc} */ @Override public List < Category > findAll () { return ( List < Category > ) this . categoryRepository . findAll (); } /** * {@inheritDoc} */ @Override public Category save ( CategoryDto dto ) { Category categoria = null ; if ( dto . getId () != null ) categoria = this . categoryRepository . findById ( dto . getId ()). orElse ( null ); else categoria = new Category (); BeanUtils . copyProperties ( dto , categoria ); return this . categoryRepository . save ( categoria ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) { this . categoryRepository . deleteById ( id ); } } CategoryService.java package com.capgemini.coedevon.tutorial.category ; import java.util.List ; import com.capgemini.coedevon.tutorial.category.model.Category ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; /** * @author coedevon * */ public interface CategoryService { /** * M\u00e9todo para recuperar todas las {@link com.capgemini.coedevon.tutorial.category.model.Category} * @return */ List < Category > findAll (); /** * M\u00e9todo para crear o actualizar una {@link com.capgemini.coedevon.tutorial.category.model.Category} * @param dto * @return */ Category save ( CategoryDto dto ); /** * M\u00e9todo para borrar una {@link com.capgemini.coedevon.tutorial.category.model.Category} * @param id */ void delete ( Long id ); } CategoryController.java package com.capgemini.coedevon.tutorial.category ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; import com.devonfw.module.beanmapping.common.api.BeanMapper ; /** * @author coedevon */ @RequestMapping ( value = \"/category/v1\" ) @RestController public class CategoryController { @Autowired CategoryService categoryService ; @Autowired BeanMapper beanMapper ; /** * M\u00e9todo para recuperar todas las {@link com.capgemini.coedevon.tutorial.category.model.Category} * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { return this . beanMapper . mapList ( this . categoryService . findAll (), CategoryDto . class ); } /** * M\u00e9todo para crear o actualizar una {@link com.capgemini.coedevon.tutorial.category.model.Category} * @param dto * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . PUT ) public CategoryDto save ( @RequestBody CategoryDto dto ) { return this . beanMapper . map ( this . categoryService . save ( dto ), CategoryDto . class ); } /** * M\u00e9todo para borrar una {@link com.capgemini.coedevon.tutorial.category.model.Category} * @param id */ @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . categoryService . delete ( id ); } } El Service no tiene nada raro, simplemente accede al Repository (siempre anotado como @Autowired ) y recupera datos o los guarda. F\u00edjate en el caso especial del save que la \u00fanica diferencia es que en un caso tendr\u00e1 id != null y por tanto internamente har\u00e1 un update, y en otro caso tendr\u00e1 id == null y por tanto internamente har\u00e1 un save. En cuanto a la interface, lo \u00fanico que cambiamos fue los objetos de respuesta, que ahora pasan a ser de tipo Category . Los de entrada se mantienen como CategoryDto . Por \u00faltimo, en el Controller se puede ver como se utiliza el conversor de BeanMapper (siempre anotado como @Autowired ), que permite traducir una lista a un tipo concreto, o un objeto \u00fanico a un tipo concreto. La forma de hacer estas conversiones siempre es por nombre de propiedad. Las propiedades del objeto destino se deben llamar igual que las propiedades del objeto origen. En caso contrario se quedar\u00e1n a null. Aspectos importantes Los aspectos importantes de la capa Repository son: Al igual que los Service , se debe utilizar el patr\u00f3n fachada, por lo que tendremos una Interface y posiblemente una implementaci\u00f3n. A menudo la implementaci\u00f3n la hace internamente Springboot, pero hay veces que podemos hacer una implementaci\u00f3n manual. Lo veremos en siguientes puntos. Los Repository trabajan siempre con Entity que no son m\u00e1s que mapeos de una tabla o de una vista que existe en BBDD. Los Repository no contienen l\u00f3gica de negocio, ni transformaciones, simplemente acceder a datos, persisten o devuelven informaci\u00f3n. Los Repository JAM\u00c1S deben llamar a otros Repository ni Service . Intenta que tus clases Entity sean lo m\u00e1s sencillas posible, sobre todo en cuanto a Primary Keys, se simplificar\u00e1 mucho el desarrollo. \u00bfQue hemos aprendido? Resumiendo un poco los pasos que hemos seguido: Hay que definir y agrupar por \u00e1mbito funcional, hemos creado el package com.capgemini.coedevon.tutorial.category para aglutinar todas las clases La implementaci\u00f3n se deber\u00eda separar por capas: Controller \u2192 Maneja las peticiones de entrada del cliente y realiza transformaciones. No ejecuta directamente l\u00f3gica de negocio, para eso utiliza llamadas a la siguiente capa. Service \u2192 Ejecuta la l\u00f3gica de negocio en sus m\u00e9todos o llamando a otros objetos de la misma capa. No ejecuta directamente accesos a datos, para eso utiliza la siguiente capa. Repository \u2192 Realiza los accesos a datos de lectura y escritura. NUNCA debe llamar a otros objetos de la misma capa ni de capas anteriores. Hay que tener en cuenta los objetos modelo que se mueven en cada capa. Generalmente son: Json \u2192 Los datos que vienen y van del cliente al Controller . DTO \u2192 Los datos se mueven dentro del Controller y sirven para invocar llamadas. Tambi\u00e9n son los datos que devuelve un Controller . Entity \u2192 Los datos que sirven para persistir y leer datos de una BBDD y que NUNCA deber\u00edan ir m\u00e1s all\u00e1 del Controller .","title":"Code: Desarrollo con Springboot"},{"location":"develop/step2/#desarrollo-con-springboot","text":"Ahora que ya tenemos listo tanto el proyecto back de SpringBoot (en el puerto 8080) como el proyecto front de Angular (en el puerto 4200), ya podemos empezar a codificar la soluci\u00f3n. Durante todo el tutorial vamos a intentar separar completamente la implementaci\u00f3n de front de la implementaci\u00f3n de back, para que quede claro como se debe realizar en cada una de las tecnolog\u00edas.","title":"Desarrollo con Springboot"},{"location":"develop/step2/#primeros-pasos","text":"Antes de empezar Quiero hacer hincapi\u00e9 en Springboot tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. Tanto la propia web de Spring como en el portal de tutoriales de Baeldung puedes buscar casi cualquier ejemplo que necesites. Si has seguido el tutorial, en la creaci\u00f3n del proyecto ten\u00edas la posibilidad de crear un proyecto Devonfw o crear un proyecto Springboot simple. Hay ciertas herramientas y configuraciones que provee Devonfw que son muy \u00fatiles a la hora de desarrollar aplicaciones y por tanto si hemos creado una aplicaci\u00f3n Springboot deber\u00edamos a\u00f1adirlas.","title":"Primeros pasos"},{"location":"develop/step2/#anadir-utilidades-devonfw","text":"Lo primero que vamos a hacer es a\u00f1adir las dependencias a librer\u00edas de devonfw. Abriremos el fichero pom.xml que nos ha generado el Spring Initilizr y a\u00f1adiremos las siguientes l\u00edneas: pom.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <parent> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-parent </artifactId> <version> 2.3.0.RELEASE </version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId> com.capgemini.coedevon </groupId> <artifactId> tutorial </artifactId> <version> 0.0.1-SNAPSHOT </version> <name> tutorial </name> <description> Demo project for Spring Boot </description> <properties> <java.version> 1.8 </java.version> <devon4j.version> 2020.04.001 </devon4j.version> </properties> <dependencyManagement> <dependencies> <!-- BOM of devon4j --> <dependency> <groupId> com.devonfw.java.boms </groupId> <artifactId> devon4j-bom </artifactId> <version> ${devon4j.version} </version> <type> pom </type> <scope> import </scope> </dependency> </dependencies> </dependencyManagement> <dependencies> <!-- Bean-Mapping for conversion from TO to Entity and vice versa --> <dependency> <groupId> com.devonfw.java.modules </groupId> <artifactId> devon4j-beanmapping-orika </artifactId> </dependency> <!-- Rest Mappers --> <dependency> <groupId> com.devonfw.java.modules </groupId> <artifactId> devon4j-rest </artifactId> </dependency> <!-- JPA --> <dependency> <groupId> com.devonfw.java.starters </groupId> <artifactId> devon4j-starter-spring-data-jpa </artifactId> </dependency> <!-- <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-jpa</artifactId> </dependency> --> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-web </artifactId> </dependency> <dependency> <groupId> org.flywaydb </groupId> <artifactId> flyway-core </artifactId> </dependency> <dependency> <groupId> com.h2database </groupId> <artifactId> h2 </artifactId> <scope> runtime </scope> </dependency> <dependency> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-starter-test </artifactId> <scope> test </scope> <exclusions> <exclusion> <groupId> org.junit.vintage </groupId> <artifactId> junit-vintage-engine </artifactId> </exclusion> </exclusions> </dependency> </dependencies> <build> <plugins> <plugin> <groupId> org.springframework.boot </groupId> <artifactId> spring-boot-maven-plugin </artifactId> </plugin> </plugins> </build> </project> Ojo, que hemos sustituido la dependencia de Spring-JPA por la dependencia de Devonfw-JPA ya que nos permite utilizar m\u00e1s funcionalidades extendidas sobre repositorios JPA. Adem\u00e1s de esa dependencia, hemos a\u00f1adido una utilidad para hacer mapeos entre objetos y para configurar los servicios Rest.","title":"A\u00f1adir utilidades Devonfw"},{"location":"develop/step2/#configurar-utilidades-devonfw","text":"El siguiente punto es crear las clases de configuraci\u00f3n para las librer\u00edas que hemos a\u00f1adido. Para ello vamos a crear un package de configuraci\u00f3n general de la aplicaci\u00f3n com.capgemini.coedevon.tutorial.config donde crearemos tres clases (dos de ellas dentro del subpaquete mapper ). BeansOrikaConfig.java package com.capgemini.coedevon.tutorial.config ; import org.springframework.context.annotation.Bean ; import org.springframework.context.annotation.Configuration ; import com.capgemini.coedevon.tutorial.config.mapper.BeanMapper ; import com.capgemini.coedevon.tutorial.config.mapper.BeanMapperImpl ; import com.devonfw.module.beanmapping.common.base.BaseOrikaConfig ; import com.devonfw.module.json.common.base.ObjectMapperFactory ; import com.fasterxml.jackson.databind.Module ; import ma.glasnost.orika.MapperFactory ; /** * Java bean configuration for Orika. The method {@link #configureCustomMapping(MapperFactory)} from * {@link BaseOrikaConfig} can be overridden as per requirements. */ @Configuration public class BeansOrikaConfig extends BaseOrikaConfig { /** * @return the {@link BeanMapper} implementation. */ @Override @Bean public BeanMapper getBeanMapper () { return new BeanMapperImpl (); } @Bean public Module configureObjectMapper () { ObjectMapperFactory objectMapper = new ObjectMapperFactory (); return objectMapper . getExtensionModule (); } } mapper/BeanMapper.java package com.capgemini.coedevon.tutorial.config.mapper ; import org.springframework.data.domain.Page ; /** * @author coedevon */ public interface BeanMapper extends com . devonfw . module . beanmapping . common . api . BeanMapper { /** * Mapea el gen\u00e9rico de un Page en otro tipo de gen\u00e9rico * @param <T> * @param source * @param targetClass * @return */ < T > Page < T > mapPage ( Page source , Class < T > targetClass ); } mapper/BeanMapperImpl.java package com.capgemini.coedevon.tutorial.config.mapper ; import java.util.List ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.PageImpl ; import com.devonfw.module.beanmapping.common.impl.orika.BeanMapperImplOrika ; /** * @author coedevon */ public class BeanMapperImpl extends BeanMapperImplOrika implements BeanMapper { /** * {@inheritDoc} */ public < T > Page < T > mapPage ( Page source , Class < T > targetClass ) { if ( source == null ) { return null ; } List list = mapList ( source . getContent (), targetClass ); return new PageImpl <> ( list , source . getPageable (), source . getTotalElements ()); } } Listo, ya podemos empezar a desarrollar nuestros servicios.","title":"Configurar utilidades Devonfw"},{"location":"develop/step2/#estructurar-el-codigo","text":"Vamos a hacer un breve refresco de la estructura del c\u00f3digo que ya se ha visto en puntos anteriores. Las clases deben estar agrupadas por \u00e1mbito funcional, en nuestro caso como vamos a hacer la funcionalidad de Categor\u00edas pues deber\u00eda estar todo dentro de un package del tipo com.capgemini.coedevon.tutorial.category . Adem\u00e1s, deber\u00edamos aplicar la separaci\u00f3n por capas como ya se vi\u00f3 en el esquema: La primera capa, la de Controlador , se encargar\u00e1 de procesar las peticiones y transformar datos. Esta capa llamar\u00e1 a la capa de L\u00f3gica de negocio que ejecutar\u00e1 las operaciones, ayud\u00e1ndose de otros objetos de esa misma capa de L\u00f3gica o bien de llamadas a datos a trav\u00e9s de la capa de Acceso a Datos Ahora s\u00ed, vamos a programar!.","title":"Estructurar el c\u00f3digo"},{"location":"develop/step2/#capa-de-operaciones-controller","text":"En esta capa es donde se definen las operaciones que pueden ser consumidas por los clientes. Se caracterizan por estar anotadas con las anotaciones @Controller o @RestController y por las anotaciones @RequestMapping que nos permiten definir las rutas de acceso.","title":"Capa de operaciones: Controller"},{"location":"develop/step2/#controller-de-ejemplo","text":"Vamos a crear una clase CategoryController.java dentro del package com.capgemini.coedevon.tutorial.category para definir las rutas de las operaciones. CategoryController.java package com.capgemini.coedevon.tutorial.category ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; /** * @author coedevon */ @RequestMapping ( value = \"/category/v1\" ) @RestController public class CategoryController { /** * M\u00e9todo para recuperar todas las Category * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . GET ) public String prueba () { return \"Probando el Controller\" ; } } Si abrimos el Postman y creamos una petici\u00f3n GET a la url http://localhost:8080/category/v1/ nos responder\u00e1 con el mensaje que hemos puesto.","title":"Controller de ejemplo"},{"location":"develop/step2/#implementar-operaciones","text":"Ahora que ya tenemos un controlador y una operacion de negocio ficticia, vamos a borrarla y a\u00f1adir las operaciones reales que consumir\u00e1 nuestra pantalla. Deberemos a\u00f1adir una operaci\u00f3n para listar, una para actualizar, una para guardar y una para borrar. Aunque para hacerlo m\u00e1s c\u00f3modo, utilizaremos la misma operaci\u00f3n para guardar y para actualizar. Adem\u00e1s, no estar trabajando con tipos simples, vamos a utilizar un objeto para recibir informaci\u00f3n y para enviar informaci\u00f3n. Estos objetos t\u00edpicamente se denominan DTO (Data Transfer Object) y nos sirven justamente para encapsular informaci\u00f3n que queremos transportar. En realidad no son m\u00e1s que clases pojo sencilla con propiedades y getters y setters. Para nuestro ejemplo crearemos una clase CategoryDto dentro del package com.capgemini.coedevon.tutorial.category.model con el siguiente contenido: CategoryDto.java package com.capgemini.coedevon.tutorial.category.model ; /** * @author coedevon */ public class CategoryDto { private Long id ; private String name ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } } A continuaci\u00f3n utilizaremos esta clase en nuestro Controller para implementar las tres operaciones de negocio. CategoryController.java package com.capgemini.coedevon.tutorial.category ; import java.util.ArrayList ; import java.util.HashMap ; import java.util.List ; import java.util.Map ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; /** * @author coedevon */ @RequestMapping ( value = \"/category/v1\" ) @RestController public class CategoryController { private long SEQUENCE = 1 ; private Map < Long , CategoryDto > categories = new HashMap < Long , CategoryDto > (); /** * M\u00e9todo para recuperar todas las Category * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { return new ArrayList ( this . categories . values ()); } /** * M\u00e9todo para crear o actualizar una Category * @param dto * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . PUT ) public CategoryDto save ( @RequestBody CategoryDto dto ) { CategoryDto category = this . categories . get ( dto . getId ()); if ( category == null ) { category = new CategoryDto (); category . setId ( this . SEQUENCE ++ ); this . categories . put ( category . getId (), category ); } category . setName ( dto . getName ()); return category ; } /** * M\u00e9todo para borrar una Category * @param id */ @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . categories . remove ( id ); } } Como todav\u00eda no tenemos acceso a BD, hemos creado una variable tipo HashMap y una variable Long, que simular\u00e1n una BD y una secuencia. Tambi\u00e9n hemos implementado tres operaciones GET, PUT y DELETE que realizan las acciones necesarias por nuestra pantalla. Ahora podr\u00edamos probarlo desde el Postman con cuatro ejemplo sencillos. Atenci\u00f3n Los datos que se reciben pueden venir informados como un par\u00e1metro en la URL Get, como una variable en el propio path o dentro del body de la petici\u00f3n. Cada uno de ellos se recupera con una anotaci\u00f3n especial: @RequestParam , @PathVariable y @RequestBody respectivamente. GET nos devuelve un listado de Categor\u00edas PUT nos sirve para insertar Categor\u00edas nuevas (si no tienen el id informado) o para actualizar Categor\u00edas (si tienen el id informado). F\u00edjate que los datos que se reciben est\u00e1n en el body. DELETE nos sirve eliminar Categor\u00edas . F\u00edjate que el dato del ID est\u00e1 en el path.","title":"Implementar operaciones"},{"location":"develop/step2/#aspectos-importantes","text":"Los aspectos importantes de la capa Controller son: La clase debe estar anotada con @Controller o @RestController . Mejor usar la \u00faltima anotaci\u00f3n ya que est\u00e1s diciendo que las operaciones son de tipo Rest y no har\u00e1 falta configurar nada La ruta general al controlador se define con el @RequestMapping global de la clase, aunque tambi\u00e9n se puede obviar esta anotaci\u00f3n y a\u00f1adir a cada una de las operaciones la ruta ra\u00edz. Importante, a modo de consejo, anadir en la ruta la versi\u00f3n de la API (en nuestro ejemplo v1). Esto nos ayudar\u00e1 a ampliarla y cambiar la funcionalidad a futuro: Cualquier modificaci\u00f3n del algoritmo que no afecte al contrato o cualquier operaci\u00f3n nueva, puede ir en la misma versi\u00f3n Eliminaciones y modificaciones de contrato, deber\u00edan ir en un Controller nuevo anotado con otra versi\u00f3n ( category/v2/ por ejemplo) Los m\u00e9todos que queramos exponer como operaciones deben ir anotados tambi\u00e9n con @RequestMapping con la info: path \u2192 Que nos permite definir un path para la operaci\u00f3n, siempre sum\u00e1ndole el path de la clase (si es que tuviera) method \u2192 Que nos permite definir el verbo de http que vamos a atender. Podemos tener el mismo path con diferente method, sin problema. Por lo general utilizaremos: GET \u2192 Generalmente se usa para recuperar informaci\u00f3n POST \u2192 Se utiliza para hacer update y filtrados complejos de informaci\u00f3n PUT \u2192 Se utiliza para hacer save de informaci\u00f3n DELETE \u2192 Se utiliza para hacer borrados de informaci\u00f3n","title":"Aspectos importantes"},{"location":"develop/step2/#capa-de-servicio-service","text":"Pero en realidad la cosa no funciona as\u00ed. Hemos implementado parte de la l\u00f3gica de negocio (las operaciones/acciones de guardado, borrado y listado) dentro de lo que ser\u00eda la capa de operaciones o servicios al cliente. Esta capa no debe ejecutar l\u00f3gica de negocio, tan solo debe hacer transformaciones de datos y enrutar peticiones, toda la l\u00f3gica deber\u00eda ir en la capa de servicio.","title":"Capa de Servicio: Service"},{"location":"develop/step2/#implementar-servicios","text":"Pues vamos a arreglarlo. Vamos a crear un servicio y vamos a mover la l\u00f3gica de negocio al servicio. CategoryService.java package com.capgemini.coedevon.tutorial.category ; import java.util.List ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; /** * @author coedevon * */ public interface CategoryService { /** * M\u00e9todo para recuperar todas las Category * @return */ List < CategoryDto > findAll (); /** * M\u00e9todo para crear o actualizar una Category * @param dto * @return */ CategoryDto save ( CategoryDto dto ); /** * M\u00e9todo para borrar una Category * @param id */ void delete ( Long id ); } CategoryServiceImpl.java package com.capgemini.coedevon.tutorial.category ; import java.util.ArrayList ; import java.util.HashMap ; import java.util.List ; import java.util.Map ; import org.springframework.stereotype.Service ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; /** * @author coedevon * */ @Service public class CategoryServiceImpl implements CategoryService { private long ID = 1 ; private Map < Long , CategoryDto > categories = new HashMap < Long , CategoryDto > (); /** * M\u00e9todo para recuperar todas las Category * @return */ public List < CategoryDto > findAll () { return new ArrayList ( this . categories . values ()); } /** * M\u00e9todo para crear o actualizar una Category * @param dto * @return */ public CategoryDto save ( CategoryDto dto ) { CategoryDto category = this . categories . get ( dto . getId ()); if ( category == null ) { category = new CategoryDto (); category . setId ( this . ID ++ ); this . categories . put ( category . getId (), category ); } category . setName ( dto . getName ()); return category ; } /** * M\u00e9todo para borrar una Category * @param id */ public void delete ( Long id ) { this . categories . remove ( id ); } } CategoryController.java package com.capgemini.coedevon.tutorial.category ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; /** * @author coedevon */ @RequestMapping ( value = \"/category/v1\" ) @RestController public class CategoryController { @Autowired private CategoryService categoryService ; /** * M\u00e9todo para recuperar todas las Category * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { return this . categoryService . findAll (); } /** * M\u00e9todo para crear o actualizar una Category * @param dto * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . PUT ) public CategoryDto save ( @RequestBody CategoryDto dto ) { return this . categoryService . save ( dto ); } /** * M\u00e9todo para borrar una Category * @param id */ @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . categoryService . delete ( id ); } } Ahora ya tenemos bien estructurado nuestro proyecto. Ya tenemos las dos capas necesarias Controladores y Servicios y cada uno se encarga de llevar a cabo su cometido de forma correcta.","title":"Implementar servicios"},{"location":"develop/step2/#aspectos-importantes_1","text":"Los aspectos importantes de la capa Service son: Toda la l\u00f3gica de negocio, operaciones y dem\u00e1s debe estar implementada en los servicios. Los controladores simplemente invocan servicios y transforman ciertos datos. Es buena pr\u00e1ctica que la capa de servicios se implemente usando el patr\u00f3n fachada, esto quiere decir que necesitamos tener una Interface y al menos una implementaci\u00f3n de esa Interface. Y siempre siempre debemos interactuar con la Interface. Esto nos permitir\u00e1 a futuro poder sustituir la implementaci\u00f3n por otra diferente sin que el resto del c\u00f3digo se vea afectado. Especialmente \u00fatil cuando queremos mockear comportamientos en tests. La capa de servicio puede invocar a otros servicios en sus operaciones, pero nunca debe invocar a un controlador. Para crear un servicio se debe anotar mediante @Service y adem\u00e1s debe implementar la Interface del servicio. Un error muy com\u00fan al arrancar un proyecto y ver que no funcionan las llamadas, es porqu\u00e9 no existe la anotaci\u00f3n @Service o porqu\u00e9 no se ha implementado la Interface. La forma de inyectar y utilizar componentes manejados por Springboot es mediante la anotaci\u00f3n @Autowired . NO intentes crear un objeto de CategoryServiceImpl, ni hacer un new , ya que no estar\u00e1 manejado por Springboot y dar\u00e1 fallos de NullPointer. Lo mejor es dejar que Springboot lo gestione y utilizar las inyecciones de dependencias.","title":"Aspectos importantes"},{"location":"develop/step2/#capa-de-datos-repository","text":"Pero no siempre vamos a acceder a los datos mediante un HasMap en memoria. En algunas ocasiones queremos que nuestro proyecto acceda a un servicio de datos como puede ser una BBDD, un servicio externo, un acceso a disco, etc. Estos accesos se deben hacer desde la capa de acceso a datos, y en concreto para nuestro ejemplo, lo haremos a trav\u00e9s de un Repository para que acceda a una BBDD.","title":"Capa de Datos: Repository"},{"location":"develop/step2/#creacion-de-bbdd","text":"Para el tutorial no necesitamos configurar una BBDD externa ni complicarnos demasiado. Vamos a utilizar una librer\u00eda muy \u00fatil llamada H2 que nos permite levantar una BBDD en memoria persistiendo los datos en memoria o en disco y vamos a utilizar las librer\u00edas de flyway para crear nuestro esquema de BBDD en el arranque de la aplicaci\u00f3n. Para esto, si te acuerdas de cuando creamos la aplicaci\u00f3n, existen unos ficheros que se encuentran dentro de la carpeta src/main/resources/db/migration/ y que nos permiten ir depositando scripts versionados para que se ejecuten en orden una vez se levante la aplicaci\u00f3n. Vamos a crear los nuestros: V0001__Create_Schema.sql CREATE SEQUENCE HIBERNATE_SEQUENCE START WITH 1000000 ; DROP TABLE IF EXISTS CATEGORY ; CREATE TABLE CATEGORY ( id BIGINT AUTO_INCREMENT PRIMARY KEY , name VARCHAR ( 250 ) NOT NULL ); V0002__Create_Data.sql INSERT INTO CATEGORY ( id , name ) VALUES ( 1 , 'Eurogames' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 2 , 'Ameritrash' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 3 , 'Familiar' ); La creaci\u00f3n de la secuencia de hibernate es necesaria para que H2 pueda trabajar con ID auto incrementales. De lo contrario al arrancar la aplicaci\u00f3n se quejar\u00e1.","title":"Creaci\u00f3n de BBDD"},{"location":"develop/step2/#implementar-entity","text":"Una vez creada la BBDD el siguiente paso es crear la entidad con la que vamos a persistir y recuperar informaci\u00f3n. Las entidades igual que los DTOs deber\u00edan estar agrupados dentro del package model de cada funcionalidad, as\u00ed que vamos a crear una nueva clase java. Category.java package com.capgemini.coedevon.tutorial.category.model ; import javax.persistence.Column ; import javax.persistence.Entity ; import javax.persistence.GeneratedValue ; import javax.persistence.GenerationType ; import javax.persistence.Id ; import javax.persistence.Table ; /** * @author coedevon */ @Entity @Table ( name = \"Category\" ) public class Category { @Id @GeneratedValue ( strategy = GenerationType . AUTO ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"name\" , nullable = false ) private String name ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getName}. */ public void setName ( String name ) { this . name = name ; } } Si te fijas, la Entity suele ser muy similar a un DTO, tiene unas propiedades y sus getters y setters. Pero a diferencia de los DTOs, esta clase tiene una serie de anotaciones que permiten a JPA hacer su magia y generar consultas SQL a la BBDD. En este ejemplo vemos 4 anotaciones importantes: @Entity \u2192 Le indica a Springboot que se trata de una clase que implementa una Entidad de BBDD. Sin esta anotaci\u00f3n no es posible hacer queries. @Table \u2192 Le indica a JPA el nombre y el schema de la tabla que representa esta clase. Por claridad se deber\u00eda poner siempre, aunque si el nombre de la tabla es igual al nombre de la clase no es necesaria la anotaci\u00f3n. @Id y @GeneratedValue \u2192 Le indica a JPA que esta propiedad es la que mapea una Primary Key y adem\u00e1s que esta PK se genera con la estrategia que se le indique en la anotaci\u00f3n @GeneratedValue , que puede ser: Generaci\u00f3n de PK por Secuence , la que utiliza Oracle, en este caso habr\u00e1 que indicarle un nombre de secuencia. Generaci\u00f3n de PK por Indentity , la que utiliza MySql o SQLServer, el auto-incremental. Generaci\u00f3n de PK por Table , en algunas BBDD se permite tener una tabla donde se almacenan como registros todas las secuencias. Generaci\u00f3n de PK Auto , elige la mejor estrategia en funci\u00f3n de la BBDD que hemos seleccionado. @Column \u2192 Le indica a JPA que esta propiedad mapea una columna de la tabla y le especifica el nombre de la columna. Al igual que la anotaci\u00f3nd de Table , esta anotaci\u00f3n no es necesaria aunque si es muy recomendable. Por claridad se deber\u00eda poner siempre, aunque si el nombre de la columna es igual al nombre de la propiedad no es necesaria la anotaci\u00f3n. Hay muchas otras anotaciones, pero estas son las b\u00e1sicas, ya ir\u00e1s aprendiendo otras. Consejo Para definir las PK de las tablas, intenta evitar una PK compuesta de m\u00e1s de una columna. La programaci\u00f3n se hace muy compleja y las magias que hace JPA en la oscuridad se complican mucho. Mi recomendaci\u00f3n es que siempre utilices una PK n\u00famerica, en la medida de lo posible, y si es necesario, crees \u00edndices compuestos de b\u00fasqueda o checks compuestos para evitar duplicidades.","title":"Implementar Entity"},{"location":"develop/step2/#implementar-repository","text":"Ahora que ya tenemos la entidad implementada, vamos a utilizarla para acceder a BBDD, y esto lo haremos con un Repository . Existen varias formas de utilizar los repositories, desde el todo autom\u00e1tico y magia de JPA hasta el repositorio manual en el que hay que codificar todo. En el tutorial voy a explicar varias formas de implementarlo para este CRUD y los siguientes CRUDs. Como ya se dijo en puntos anteriores, el acceso a datos se debe hacer siempre a trav\u00e9s de un Repository , as\u00ed que vamos a implementar uno. En esta capa, al igual que pasaba con los services, es recomendable utilizar el patr\u00f3n fachada, para poder sustituir implementaciones sin afectar al c\u00f3digo. CategoryRepository.java package com.capgemini.coedevon.tutorial.category ; import org.springframework.data.repository.CrudRepository ; import com.capgemini.coedevon.tutorial.category.model.Category ; /** * @author coedevon */ public interface CategoryRepository extends CrudRepository < Category , Long > { } \u00bfQue te parece?, sencillo, \u00bfno?. Spring ya tiene una implementaci\u00f3n por defecto de un CrudRepository, tan solo tenemos que crear una interface que extienda de la interface CrudRepository pasandole como tipos la Entity y el tipo de la Primary Key. Con eso Spring construye el resto y nos provee de los m\u00e9todos t\u00edpicos y necesarios para un CRUD. Ahora vamos a utilizarla en el Service , pero hay un problema. El Repository devuelve un objeto tipo Category y el Service y Controller devuelven un objeto tipo CategoryDto . Esto es porque en cada capa se debe con un \u00e1mbito de modelos diferente. Podr\u00edamos hacer que todo el back trabajara con Category que son entidades de persistencia, pero no es lo correcto y nos podr\u00eda llevar a cometer errores, o modificar el objeto y que sin que nosotros lo orden\u00e1semos se persistiera ese cambio en BBDD. El \u00e1mbito de trabajo de las capas con el que solemos trabajar y est\u00e1 m\u00e1s extendido es el siguiente: Los datos que vienen y van al cliente, deber\u00edan ser en la mayor\u00eda de los casos datos en formato json Al entrar en un Controller esos datos json se transforman en un DTO. Al salir del Controller hacia el cliente, esos DTOs se transforman en formato json. Estas conversiones son autom\u00e1ticas, las hace Springboot (en realidad las hace la librer\u00eda de jackson codehaus). Cuando un Controller ejecuta una llamada a un Service , generalmente le pasa sus datos en DTO, y el Service se encarga de transformar esto a una Entity . A la inversa, cuando un Service responde a un Controller , \u00e9l responde con una Entity y el Controller ya se encargar\u00e1 de transformarlo a DTO. Por \u00faltimo, para los Repository , siempre se trabaja de entrada y salida con objetos tipo Entity Parece un lio, pero ya ver\u00e1s como es muy sencillo ahora que veremos el ejemplo. Una \u00faltima cosa, para hacer esas transformaciones, las podemos hacer a mano usando getters y setters o bien utilizar el objeto BeanMapper que hemos configurado al principio como utilidad de Devonfw. El c\u00f3digo deber\u00eda quedar as\u00ed: CategoryServiceImpl.java package com.capgemini.coedevon.tutorial.category ; import java.util.List ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import com.capgemini.coedevon.tutorial.category.model.Category ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; /** * @author coedevon * */ @Service public class CategoryServiceImpl implements CategoryService { @Autowired CategoryRepository categoryRepository ; /** * {@inheritDoc} */ @Override public List < Category > findAll () { return ( List < Category > ) this . categoryRepository . findAll (); } /** * {@inheritDoc} */ @Override public Category save ( CategoryDto dto ) { Category categoria = null ; if ( dto . getId () != null ) categoria = this . categoryRepository . findById ( dto . getId ()). orElse ( null ); else categoria = new Category (); BeanUtils . copyProperties ( dto , categoria ); return this . categoryRepository . save ( categoria ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) { this . categoryRepository . deleteById ( id ); } } CategoryService.java package com.capgemini.coedevon.tutorial.category ; import java.util.List ; import com.capgemini.coedevon.tutorial.category.model.Category ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; /** * @author coedevon * */ public interface CategoryService { /** * M\u00e9todo para recuperar todas las {@link com.capgemini.coedevon.tutorial.category.model.Category} * @return */ List < Category > findAll (); /** * M\u00e9todo para crear o actualizar una {@link com.capgemini.coedevon.tutorial.category.model.Category} * @param dto * @return */ Category save ( CategoryDto dto ); /** * M\u00e9todo para borrar una {@link com.capgemini.coedevon.tutorial.category.model.Category} * @param id */ void delete ( Long id ); } CategoryController.java package com.capgemini.coedevon.tutorial.category ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; import com.devonfw.module.beanmapping.common.api.BeanMapper ; /** * @author coedevon */ @RequestMapping ( value = \"/category/v1\" ) @RestController public class CategoryController { @Autowired CategoryService categoryService ; @Autowired BeanMapper beanMapper ; /** * M\u00e9todo para recuperar todas las {@link com.capgemini.coedevon.tutorial.category.model.Category} * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . GET ) public List < CategoryDto > findAll () { return this . beanMapper . mapList ( this . categoryService . findAll (), CategoryDto . class ); } /** * M\u00e9todo para crear o actualizar una {@link com.capgemini.coedevon.tutorial.category.model.Category} * @param dto * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . PUT ) public CategoryDto save ( @RequestBody CategoryDto dto ) { return this . beanMapper . map ( this . categoryService . save ( dto ), CategoryDto . class ); } /** * M\u00e9todo para borrar una {@link com.capgemini.coedevon.tutorial.category.model.Category} * @param id */ @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . categoryService . delete ( id ); } } El Service no tiene nada raro, simplemente accede al Repository (siempre anotado como @Autowired ) y recupera datos o los guarda. F\u00edjate en el caso especial del save que la \u00fanica diferencia es que en un caso tendr\u00e1 id != null y por tanto internamente har\u00e1 un update, y en otro caso tendr\u00e1 id == null y por tanto internamente har\u00e1 un save. En cuanto a la interface, lo \u00fanico que cambiamos fue los objetos de respuesta, que ahora pasan a ser de tipo Category . Los de entrada se mantienen como CategoryDto . Por \u00faltimo, en el Controller se puede ver como se utiliza el conversor de BeanMapper (siempre anotado como @Autowired ), que permite traducir una lista a un tipo concreto, o un objeto \u00fanico a un tipo concreto. La forma de hacer estas conversiones siempre es por nombre de propiedad. Las propiedades del objeto destino se deben llamar igual que las propiedades del objeto origen. En caso contrario se quedar\u00e1n a null.","title":"Implementar Repository"},{"location":"develop/step2/#aspectos-importantes_2","text":"Los aspectos importantes de la capa Repository son: Al igual que los Service , se debe utilizar el patr\u00f3n fachada, por lo que tendremos una Interface y posiblemente una implementaci\u00f3n. A menudo la implementaci\u00f3n la hace internamente Springboot, pero hay veces que podemos hacer una implementaci\u00f3n manual. Lo veremos en siguientes puntos. Los Repository trabajan siempre con Entity que no son m\u00e1s que mapeos de una tabla o de una vista que existe en BBDD. Los Repository no contienen l\u00f3gica de negocio, ni transformaciones, simplemente acceder a datos, persisten o devuelven informaci\u00f3n. Los Repository JAM\u00c1S deben llamar a otros Repository ni Service . Intenta que tus clases Entity sean lo m\u00e1s sencillas posible, sobre todo en cuanto a Primary Keys, se simplificar\u00e1 mucho el desarrollo.","title":"Aspectos importantes"},{"location":"develop/step2/#que-hemos-aprendido","text":"Resumiendo un poco los pasos que hemos seguido: Hay que definir y agrupar por \u00e1mbito funcional, hemos creado el package com.capgemini.coedevon.tutorial.category para aglutinar todas las clases La implementaci\u00f3n se deber\u00eda separar por capas: Controller \u2192 Maneja las peticiones de entrada del cliente y realiza transformaciones. No ejecuta directamente l\u00f3gica de negocio, para eso utiliza llamadas a la siguiente capa. Service \u2192 Ejecuta la l\u00f3gica de negocio en sus m\u00e9todos o llamando a otros objetos de la misma capa. No ejecuta directamente accesos a datos, para eso utiliza la siguiente capa. Repository \u2192 Realiza los accesos a datos de lectura y escritura. NUNCA debe llamar a otros objetos de la misma capa ni de capas anteriores. Hay que tener en cuenta los objetos modelo que se mueven en cada capa. Generalmente son: Json \u2192 Los datos que vienen y van del cliente al Controller . DTO \u2192 Los datos se mueven dentro del Controller y sirven para invocar llamadas. Tambi\u00e9n son los datos que devuelve un Controller . Entity \u2192 Los datos que sirven para persistir y leer datos de una BBDD y que NUNCA deber\u00edan ir m\u00e1s all\u00e1 del Controller .","title":"\u00bfQue hemos aprendido?"},{"location":"develop/step3/","text":"Conectar Angular con las operaciones de Springboot Ya casi lo tenemos listo! Por un lado tenemos la aplicaci\u00f3n Angular funcionando con datos mockeados en local, y por otro lado tenemos el servidor Springboot con las operaciones funcionando. El siguiente paso, como es obvio ser\u00e1 hacer que Angular llame directamente al servidor Springboot para leer y escribir datos y eliminar los datos mockeados en Angular. Manos a la obra! Llamada del listado La idea es que el m\u00e9todo getCategories() de category.service.ts en lugar de devolver datos est\u00e1ticos, realice una llamada al servidor a la ruta http://localhost:8080/category/v1/ . Abrimos el fichero y susituimos la l\u00ednea que antes devolv\u00eda los datos est\u00e1ticos por esto: category.service.ts import { Injectable } from '@angular/core' ; import { Category } from 'src/app/models/categories/Category' ; import { Observable } from 'rxjs' ; import { HttpClient } from '@angular/common/http' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor ( private http : HttpClient ) { } getCategories () : Observable < Category [] > { return this . http . get < Category [] > ( 'http://localhost:8080/category/v1/' ); } saveCategory ( category : Category ) : Observable < Category > { return of ( null ); } deleteCategory ( idCategory : number ) : Observable < any > { return of ( null ); } } Como hemos a\u00f1adido un componente nuevo HttpClient tenemos que a\u00f1adir la dependencial al m\u00f3dulo padre. services.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { HttpClientModule } from '@angular/common/http' ; @NgModule ({ declarations : [], imports : [ CommonModule , HttpClientModule ], }) export class ServicesModule { } Si ahora refrescas el navegador (recuerda tener arrancado tambi\u00e9n el servidor) y accedes a la pantalla de Categor\u00edas no saldr\u00e1 ning\u00fan resultado, pero si miras la consola ver\u00e1s un mensaje similar a este: Access to XMLHttpRequest at 'http://localhost:8080/category/v1/' from origin 'http://localhost:4200' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. Esto es debido a la pol\u00edtica de CORS, que impide que desde un dominio+puerto se tenga acceso indiscriminado a otro dominio+puerto diferente, y as\u00ed evita posibles ataques. Access Control Policy El error de CORS es muy habitual cuando se est\u00e1 trabajando en local y se tienen varios servidores levantados. Hay que tener mucho ojo con este filtro. Para m\u00e1s ver m\u00e1s informaci\u00f3n de como funciona y su casu\u00edstica visita Control de acceso HTTP . Para solucionarlo hay varias formas, pero la m\u00e1s c\u00f3moda en desarrollo es habilitar el permiso de CORS para cualquier origen en el servidor. Para ello vamos al c\u00f3digo de servidor y a\u00f1adimos una nueva anotaci\u00f3n: CategoryController.java package com.capgemini.coedevon.tutorial.category ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; import com.devonfw.module.beanmapping.common.api.BeanMapper ; /** * @author coedevon */ @RequestMapping ( value = \"/category/v1\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class CategoryController { @Autowired CategoryService categoryService ; @Autowired BeanMapper beanMapper ; ... Ahora s\u00ed, si refrescamos ya deber\u00eda aparecer el listado con los datos que vienen del servidor. Llamada de guardado / edici\u00f3n Para la llamada de guardado har\u00edamos lo mismo, pero invocando la operaci\u00f3n de negocio put . category.service.ts import { Injectable } from '@angular/core' ; import { Category } from 'src/app/models/categories/Category' ; import { Observable , of } from 'rxjs' ; import { HttpClient } from '@angular/common/http' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor ( private http : HttpClient ) { } getCategories () : Observable < Category [] > { return this . http . get < Category [] > ( 'http://localhost:8080/category/v1/' ); } saveCategory ( category : Category ) : Observable < Category > { return this . http . put < Category > ( 'http://localhost:8080/category/v1/' , category ); } deleteCategory ( idCategory : number ) : Observable < any > { return of ( null ); } } Ahora podemos probar a modificar o a\u00f1adir una nueva categor\u00eda desde la pantalla y deber\u00eda aparecer los nuevos datos en el listado. Llamada de borrado Y ya por \u00faltimo, la llamada de borrado, deber\u00edamos cambiarla e invocar a la operaci\u00f3n de negocio delete . category.service.ts import { Injectable } from '@angular/core' ; import { Category } from 'src/app/models/categories/Category' ; import { Observable } from 'rxjs' ; import { HttpClient } from '@angular/common/http' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor ( private http : HttpClient ) { } getCategories () : Observable < Category [] > { return this . http . get < Category [] > ( 'http://localhost:8080/category/v1/' ); } saveCategory ( category : Category ) : Observable < Category > { return this . http . put < Category > ( 'http://localhost:8080/category/v1/' , category ); } deleteCategory ( idCategory : number ) : Observable < any > { return this . http . delete ( 'http://localhost:8080/category/v1/' + idCategory ); } } Ahora podemos probar a modificar o a\u00f1adir una nueva categor\u00eda desde la pantalla y deber\u00eda aparecer los nuevos datos en el listado.","title":"Code: Conectar front con back"},{"location":"develop/step3/#conectar-angular-con-las-operaciones-de-springboot","text":"Ya casi lo tenemos listo! Por un lado tenemos la aplicaci\u00f3n Angular funcionando con datos mockeados en local, y por otro lado tenemos el servidor Springboot con las operaciones funcionando. El siguiente paso, como es obvio ser\u00e1 hacer que Angular llame directamente al servidor Springboot para leer y escribir datos y eliminar los datos mockeados en Angular. Manos a la obra!","title":"Conectar Angular con las operaciones de Springboot"},{"location":"develop/step3/#llamada-del-listado","text":"La idea es que el m\u00e9todo getCategories() de category.service.ts en lugar de devolver datos est\u00e1ticos, realice una llamada al servidor a la ruta http://localhost:8080/category/v1/ . Abrimos el fichero y susituimos la l\u00ednea que antes devolv\u00eda los datos est\u00e1ticos por esto: category.service.ts import { Injectable } from '@angular/core' ; import { Category } from 'src/app/models/categories/Category' ; import { Observable } from 'rxjs' ; import { HttpClient } from '@angular/common/http' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor ( private http : HttpClient ) { } getCategories () : Observable < Category [] > { return this . http . get < Category [] > ( 'http://localhost:8080/category/v1/' ); } saveCategory ( category : Category ) : Observable < Category > { return of ( null ); } deleteCategory ( idCategory : number ) : Observable < any > { return of ( null ); } } Como hemos a\u00f1adido un componente nuevo HttpClient tenemos que a\u00f1adir la dependencial al m\u00f3dulo padre. services.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { HttpClientModule } from '@angular/common/http' ; @NgModule ({ declarations : [], imports : [ CommonModule , HttpClientModule ], }) export class ServicesModule { } Si ahora refrescas el navegador (recuerda tener arrancado tambi\u00e9n el servidor) y accedes a la pantalla de Categor\u00edas no saldr\u00e1 ning\u00fan resultado, pero si miras la consola ver\u00e1s un mensaje similar a este: Access to XMLHttpRequest at 'http://localhost:8080/category/v1/' from origin 'http://localhost:4200' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. Esto es debido a la pol\u00edtica de CORS, que impide que desde un dominio+puerto se tenga acceso indiscriminado a otro dominio+puerto diferente, y as\u00ed evita posibles ataques. Access Control Policy El error de CORS es muy habitual cuando se est\u00e1 trabajando en local y se tienen varios servidores levantados. Hay que tener mucho ojo con este filtro. Para m\u00e1s ver m\u00e1s informaci\u00f3n de como funciona y su casu\u00edstica visita Control de acceso HTTP . Para solucionarlo hay varias formas, pero la m\u00e1s c\u00f3moda en desarrollo es habilitar el permiso de CORS para cualquier origen en el servidor. Para ello vamos al c\u00f3digo de servidor y a\u00f1adimos una nueva anotaci\u00f3n: CategoryController.java package com.capgemini.coedevon.tutorial.category ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; import com.devonfw.module.beanmapping.common.api.BeanMapper ; /** * @author coedevon */ @RequestMapping ( value = \"/category/v1\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class CategoryController { @Autowired CategoryService categoryService ; @Autowired BeanMapper beanMapper ; ... Ahora s\u00ed, si refrescamos ya deber\u00eda aparecer el listado con los datos que vienen del servidor.","title":"Llamada del listado"},{"location":"develop/step3/#llamada-de-guardado-edicion","text":"Para la llamada de guardado har\u00edamos lo mismo, pero invocando la operaci\u00f3n de negocio put . category.service.ts import { Injectable } from '@angular/core' ; import { Category } from 'src/app/models/categories/Category' ; import { Observable , of } from 'rxjs' ; import { HttpClient } from '@angular/common/http' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor ( private http : HttpClient ) { } getCategories () : Observable < Category [] > { return this . http . get < Category [] > ( 'http://localhost:8080/category/v1/' ); } saveCategory ( category : Category ) : Observable < Category > { return this . http . put < Category > ( 'http://localhost:8080/category/v1/' , category ); } deleteCategory ( idCategory : number ) : Observable < any > { return of ( null ); } } Ahora podemos probar a modificar o a\u00f1adir una nueva categor\u00eda desde la pantalla y deber\u00eda aparecer los nuevos datos en el listado.","title":"Llamada de guardado / edici\u00f3n"},{"location":"develop/step3/#llamada-de-borrado","text":"Y ya por \u00faltimo, la llamada de borrado, deber\u00edamos cambiarla e invocar a la operaci\u00f3n de negocio delete . category.service.ts import { Injectable } from '@angular/core' ; import { Category } from 'src/app/models/categories/Category' ; import { Observable } from 'rxjs' ; import { HttpClient } from '@angular/common/http' ; @Injectable ({ providedIn : 'root' }) export class CategoryService { constructor ( private http : HttpClient ) { } getCategories () : Observable < Category [] > { return this . http . get < Category [] > ( 'http://localhost:8080/category/v1/' ); } saveCategory ( category : Category ) : Observable < Category > { return this . http . put < Category > ( 'http://localhost:8080/category/v1/' , category ); } deleteCategory ( idCategory : number ) : Observable < any > { return this . http . delete ( 'http://localhost:8080/category/v1/' + idCategory ); } } Ahora podemos probar a modificar o a\u00f1adir una nueva categor\u00eda desde la pantalla y deber\u00eda aparecer los nuevos datos en el listado.","title":"Llamada de borrado"},{"location":"develop/step4/","text":"Desarrollo de un listado paginado Ya tienes tu primer listado desarrollado, tanto en front como en back. \u00bfHa sido sencillo, verdad?. Ahora vamos a implementar un listado un poco m\u00e1s complejo, este tiene datos paginados en servidor, esto quiere decir que no nos sirve un array de datos como en el anterior ejemplo. Un listado paginado en servidor, debe enviar en cada petici\u00f3n que p\u00e1gina est\u00e1 mostrando y cual es el tama\u00f1o de la p\u00e1gina, para que el servidor devuelva un subconjunto de datos. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades. Desarrollo Angular Crear componentes Vamos a desarrollar el listado de Autores as\u00ed que, debemos crear los componentes: ng generate component views/authors ng generate component views/authors/author-dialog ng generate service services/authors/author Crear el modelo Creamos el modelo en models/authors/Author.ts con las propiedades necesarias para trabajar con la informaci\u00f3n de un autor: Author.ts export class Author { id : number ; name : string ; nationality : string ; } A\u00f1adir el punto de entrada A\u00f1adimos la ruta al men\u00fa para que podamos acceder a la pantalla: app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { CategoriesComponent } from './views/categories/categories.component' ; import { AuthorsComponent } from './views/authors/authors.component' ; const routes : Routes = [ { path : 'categories' , component : CategoriesComponent }, { path : 'authors' , component : AuthorsComponent }, ]; @NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } Implementar servicio Y realizamos las diferentes implementaciones. Empezaremos por el servicio. En este caso, hay un cambio sustancial con el anterior ejemplo. Al tratarse de un listado paginado, la operaci\u00f3n getAuthors necesita informaci\u00f3n extra acerca de que p\u00e1gina de datos debe mostrar, adem\u00e1s de que el resultado ya no ser\u00e1 un listado sino una p\u00e1gina. Por defecto el esquema de datos de Spring para la paginaci\u00f3n es como el siguiente: Esquema de datos de paginaci\u00f3n { \"content\" : [ ... <listado con los resultados paginados> ... ], \"pageable\" : { \"pageNumber\" : <n\u00famero de p\u00e1gina empezando por 0 > , \"pageSize\" : <tama\u00f1o de p\u00e1gina> , \"sort\" : [ { \"property\" : <nombre de la propiedad a ordenar> , \"direction\" : <direcci\u00f3n de la ordenaci\u00f3n ASC / DESC> } ] }, \"totalElements\" : <numero total de elementos en la tabla> } As\u00ed que necesitamos poder enviar y recuperar esa informaci\u00f3n desde Angular, nos hace falta crear esos objetos. Los objetos de paginaci\u00f3n los crear\u00e9 en models/page , mientras que la paginaci\u00f3n de Author la crear\u00e9 en models/authors . SortPage.ts export class SortPage { property : String ; direction : String ; } Pageable.ts import { SortPage } from './SortPage' ; export class Pageable { pageNumber : number ; pageSize : number ; sort : SortPage []; } AuthorPage.ts import { Author } from './Author' ; import { Pageable } from '../page/Pageable' ; export class AuthorPage { content : Author []; pageable : Pageable ; } Con estos objetos creados ya podemos implementar el servicio y sus datos mockeados. mock-authors.ts import { AuthorPage } from 'src/app/models/authors/AuthorPage' ; export const AUTHOR_DATA : AuthorPage = { content : [ { id : 1 , name : 'Klaus Teuber' , nationality : 'Alemania' }, { id : 2 , name : 'Matt Leacock' , nationality : 'Estados Unidos' }, { id : 3 , name : 'Keng Leong Yeo' , nationality : 'Singapur' }, { id : 4 , name : 'Gil Hova' , nationality : 'Estados Unidos' }, { id : 5 , name : 'Kelly Adams' , nationality : 'Estados Unidos' }, { id : 6 , name : 'J. Alex Kavern' , nationality : 'Estados Unidos' }, { id : 7 , name : 'Corey Young' , nationality : 'Estados Unidos' }, ], pageable : { pageSize : 7 , pageNumber : 0 , sort : [ { property : \"id\" , direction : \"ASC\" } ] } } author.service.ts import { Injectable } from '@angular/core' ; import { Pageable } from 'src/app/models/page/Pageable' ; import { AuthorPage } from 'src/app/models/authors/AuthorPage' ; import { Observable , of } from 'rxjs' ; import { Author } from 'src/app/models/authors/Author' ; import { AUTHOR_DATA } from './mock-authors' ; @Injectable ({ povidedIn : 'root' }) export class AuthorService { constructor () { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return of ( AUTHOR_DATA ); } saveAuthor ( author : Author ) : Observable < Author > { return of ( null ); } deleteAuthor ( idAuthor : number ) : Observable < any > { return of ( null ); } } Implementar listado Ya tenemos el servicio con los datos, ahora vamos a por el listado paginado. authors.component.html < div class = \"container\" > < h1 > Listado de Autores </ h1 > < mat-table [ dataSource ]=\" dataSource \" > < ng-container matColumnDef = \"id\" > < mat-header-cell * matHeaderCellDef > Identificador </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.id}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"name\" > < mat-header-cell * matHeaderCellDef > Nombre autor </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.name}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"nationality\" > < mat-header-cell * matHeaderCellDef > Nacionalidad </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.nationality}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" > < mat-icon ( click )=\" editAuthor ( element )\" > edit </ mat-icon > </ button > < button mat-icon-button color = \"accent\" > < mat-icon ( click )=\" deleteAuthor ( element )\" > clear </ mat-icon > </ button > </ mat-cell > </ ng-container > < mat-header-row * matHeaderRowDef = \"displayedColumns; sticky: true\" ></ mat-header-row > < mat-row * matRowDef = \"let row; columns: displayedColumns;\" ></ mat-row > </ mat-table > < mat-paginator ( page )=\" loadPage ($ event )\" [ pageSizeOptions ]=\"[ 5 , 10 , 20 ]\" [ pageIndex ]=\" pageNumber \" [ pageSize ]=\" pageSize \" [ length ]=\" totalElements \" showFirstLastButtons ></ mat-paginator > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createAuthor ()\" > Nuevo autor </ button > </ div > </ div > authors.component.scss . container { margin : 20 px ; mat-table { margin-top : 10 px ; margin-bottom : 20 px ; .mat-header-row { background-color : #f5f5f5 ; .mat-header-cell { text-transform : uppercase ; font-weight : bold ; color : #838383 ; } } . mat-column-id { flex : 0 0 20 % ; justify-content : center ; } . mat-column-action { flex : 0 0 10 % ; justify-content : center ; } } . buttons { text-align : right ; } } authors.component.ts import { Component , OnInit } from '@angular/core' ; import { MatTableDataSource } from '@angular/material/table' ; import { Author } from 'src/app/models/authors/Author' ; import { MatDialog } from '@angular/material/dialog' ; import { AuthorPage } from 'src/app/models/authors/AuthorPage' ; import { Pageable } from 'src/app/models/page/Pageable' ; import { DialogConfirmationComponent } from 'src/app/shared/dialog-confirmation/dialog-confirmation/dialog-confirmation.component' ; import { AuthorDialogComponent } from './author-dialog/author-dialog.component' ; @Component ({ selector : 'app-authors' , templateUrl : './authors.component.html' , styleUrls : [ './authors.component.scss' ] }) export class AuthorsComponent implements OnInit { pageNumber : number = 0 ; pageSize : number = 5 ; totalElements : number = 0 ; dataSource = new MatTableDataSource < Author > (); displayedColumns : string [] = [ 'id' , 'name' , 'nationality' , 'action' ]; constructor ( private authorService : AuthorService , public dialog : MatDialog , ) { } ngOnInit () : void { this . loadPage (); } loadPage ( event? : PageEvent ) { let pageable : Pageable = { pageNumber : this.pageSize , pageSize : this.pageSize , sort : [{ property : 'id' , direction : 'ASC' }] } if ( event != null ) { pageable . pageSize = event . pageSize pageable . pageNumber = event . pageIndex ; } this . authorService . getAuthors ( pageable ). subscribe ( data => { this . dataSource . data = data . content ; this . pageNumber = data . pageable . pageNumber ; this . pageSize = data . pageable . pageSize ; this . totalElements = data . totalElements ; } ); } createAuthor() { const dialogRef = this . dialog . open ( AuthorDialogComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } editAuthor ( author : Author ) { const dialogRef = this . dialog . open ( AuthorDialogComponent , { data : { author : author } }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } deleteAuthor ( author : Author ) { const dialogRef = this . dialog . open ( DialogConfirmationComponent , { data : { title : \"Eliminar autor\" , description : \"Atenci\u00f3n si borra el autor se perder\u00e1n sus datos.<br> \u00bfDesea eliminar el autor?\" } }); dialogRef . afterClosed (). subscribe ( result => { if ( result ) { this . authorService . deleteAuthor ( author . id ). subscribe ( result => { this . ngOnInit (); }); } }); } } F\u00edjate como hemos a\u00f1adido la paginaci\u00f3n. Al HTML le hemos a\u00f1adido un componente nuevo mat-paginator , lo que nos va a obligar a a\u00f1adirlo al m\u00f3dulo tambi\u00e9n como dependencia. Ese componente le hemos definido un m\u00e9todo page que se ejecuta cada vez que la p\u00e1gina cambia, y unas propiedades con las que calcular\u00e1 la p\u00e1gina, el tama\u00f1o y el n\u00famero total de p\u00e1ginas. Al Typescript le hemos tenido que a\u00f1adir esas variables y hemos creado un m\u00e9todo para cargar datos que lo que hace es construir un objeto pageable con los valores actuales del componente paginador y lanza la petici\u00f3n con esos datos en el body. Obviamente al ser un mock no funcionar\u00e1 el cambio de p\u00e1gina y dem\u00e1s. Como hemos comentado, a\u00f1adimos la dependencia al m\u00f3dulo para que todo funcione. views.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { MatTableModule } from '@angular/material/table' ; import { MatIconModule } from '@angular/material/icon' ; import { MatButtonModule } from '@angular/material/button' ; import { CategoriesComponent } from './categories/categories.component' ; import { CategoryDialogComponent } from './categories/category-dialog/category-dialog.component' ; import { MAT_DIALOG_DATA , MatDialogModule } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatInputModule } from '@angular/material/input' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; import { AuthorsComponent } from './authors/authors.component' ; import { AuthorDialogComponent } from './authors/author-dialog/author-dialog.component' ; import { MatPaginatorModule } from '@angular/material/paginator' ; @NgModule ({ declarations : [ CategoriesComponent , CategoryDialogComponent , AuthorsComponent , AuthorDialogComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule , MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , MatPaginatorModule , ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class ViewsModule { } Deber\u00eda verse algo similar a esto: Implementar dialogo edici\u00f3n El \u00faltimo paso, es definir la pantalla de dialogo que realizar\u00e1 el alta y modificado de los datos de un Autor . author-dialog.component.html < div class = \"container\" > < h1 * ngIf = \"author.id == null\" > Crear autor </ h1 > < h1 * ngIf = \"author.id != null\" > Modificar autor </ h1 > < form > < mat-form-field > < mat-label > Identificador </ mat-label > < input type = \"number\" matInput placeholder = \"Identificador\" [( ngModel )]=\" author . id \" name = \"id\" disabled > </ mat-form-field > < mat-form-field > < mat-label > Nombre </ mat-label > < input type = \"text\" matInput placeholder = \"Nombre del autor\" [( ngModel )]=\" author . name \" name = \"name\" required > < mat-error > El nombre no puede estar vac\u00edo </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Nacionalidad </ mat-label > < input type = \"text\" matInput placeholder = \"Nacionalidad del autor\" [( ngModel )]=\" author . nationality \" name = \"nationality\" required > < mat-error > La nacionalidad no puede estar vac\u00eda </ mat-error > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onClose ()\" > Cerrar </ button > < button mat-flat-button color = \"primary\" ( click )=\" onSave ()\" > Guardar </ button > </ div > </ div > author-dialog.component.scss . container { min-width : 350 px ; max-width : 500 px ; width : 100 % ; form { display : flex ; flex-direction : column ; margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } author-dialog.component.ts import { Component , OnInit , Inject } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { Author } from 'src/app/models/authors/Author' ; import { AuthorService } from 'src/app/services/authors/author.service' ; @Component ({ selector : 'app-author-dialog' , templateUrl : './author-dialog.component.html' , styleUrls : [ './author-dialog.component.scss' ] }) export class AuthorDialogComponent implements OnInit { author : Author ; constructor ( public dialogRef : MatDialogRef < AuthorDialogComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any , private authorService : AuthorService ) { } ngOnInit () : void { if ( this . data . author != null ) { this . author = Object . assign ({}, this . data . author ); } else { this . author = new Author (); } } onSave() { this . authorService . saveAuthor ( this . author ). subscribe ( result => { this . dialogRef . close (); }); } onClose() { this . dialogRef . close (); } } Que deber\u00eda quedar algo as\u00ed: Desarrollo Springboot Modelos Lo primero que vamos a hacer es crear los modelos para trabajar con BBDD y con peticiones hacia el front. Adem\u00e1s, tambi\u00e9n tenemos que a\u00f1adir datos al script de inicializaci\u00f3n de BBDD. V0001__Create_Schema.sql CREATE SEQUENCE HIBERNATE_SEQUENCE START WITH 1000000 ; DROP TABLE IF EXISTS CATEGORY ; CREATE TABLE CATEGORY ( id BIGINT AUTO_INCREMENT PRIMARY KEY , name VARCHAR ( 250 ) NOT NULL ); DROP TABLE IF EXISTS AUTHOR ; CREATE TABLE AUTHOR ( id BIGINT AUTO_INCREMENT PRIMARY KEY , name VARCHAR ( 400 ) NOT NULL , nationality VARCHAR ( 250 ) NOT NULL ); V0002__Create_Data.sql INSERT INTO CATEGORY ( id , name ) VALUES ( 1 , 'Eurogames' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 2 , 'Ameritrash' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 3 , 'Familiar' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 1 , 'Alan R. Moon' , 'US' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 2 , 'Vital Lacerda' , 'PT' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 3 , 'Simone Luciani' , 'IT' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 4 , 'Perepau Llistosella' , 'ES' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 5 , 'Michael Kiesling' , 'DE' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 6 , 'Phil Walker-Harding' , 'US' ); Author.java package com.capgemini.coedevon.tutorial.author.model ; import javax.persistence.Column ; import javax.persistence.Entity ; import javax.persistence.GeneratedValue ; import javax.persistence.GenerationType ; import javax.persistence.Id ; import javax.persistence.Table ; /** * @author coedevon */ @Entity @Table ( name = \"Author\" ) public class Author { @Id @GeneratedValue ( strategy = GenerationType . AUTO ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"name\" , nullable = false ) private String name ; @Column ( name = \"nationality\" ) private String nationality ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getid}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getname}. */ public void setName ( String name ) { this . name = name ; } /** * @return nationality */ public String getNationality () { return this . nationality ; } /** * @param nationality new value of {@link #getnationality}. */ public void setNationality ( String nationality ) { this . nationality = nationality ; } } AuthorDto.java package com.capgemini.coedevon.tutorial.author.model ; /** * @author coedevon */ public class AuthorDto { private Long id ; private String name ; private String nationality ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getid}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getname}. */ public void setName ( String name ) { this . name = name ; } /** * @return nationality */ public String getNationality () { return this . nationality ; } /** * @param nationality new value of {@link #getnationality}. */ public void setNationality ( String nationality ) { this . nationality = nationality ; } } Repository Para desarrollar todas las operaciones, esta vez vamos a ir de m\u00e1s bajo a m\u00e1s alto nivel. Empezaremos por el acceso a datos, crearemos el Repository. AuthorRepository.java package com.capgemini.coedevon.tutorial.author ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.Pageable ; import org.springframework.data.repository.CrudRepository ; import com.capgemini.coedevon.tutorial.author.model.Author ; /** * @author coedevon */ public interface AuthorRepository extends CrudRepository < Author , Long > { /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param page * @return */ Page < Author > findAll ( Pageable page ); } Si te fijas, este Repository ya no est\u00e1 vac\u00edo como el anterior, no nos sirve con las operaciones b\u00e1sicas del CrudRepository en este caso tenemos que a\u00f1adir un m\u00e9todo nuevo al que pasandole un objeto de tipo Pageable nos devuelva una Page . El objeto Pageable no es m\u00e1s que una interface que le permite a Spring JPA saber que p\u00e1gina se quiere buscar, cual es el tama\u00f1o de p\u00e1gina y cuales son las propiedades de ordenaci\u00f3n que se debe lanzar en la consulta. El objeto Page no es m\u00e1s que un contenedor que engloba la informaci\u00f3n b\u00e1sica de la p\u00e1gina que se est\u00e1 consultando (n\u00famero de p\u00e1gina, tama\u00f1o de p\u00e1gina, n\u00famero total de resultados) y el conjunto de datos de la BBDD que contiene esa p\u00e1gina una vez han sido buscados y ordenados. Adem\u00e1s, la m\u00e1gina de Spring JPA har\u00e1 su trabajo y nosotros no necesitamos implementar ninguna query, Spring ya entiende que un findAll significa que debe recuperar todos los datos de la tabla Author y adem\u00e1s deben estar paginados. Nos ahorra tener que buscar una p\u00e1gina concreta de datos y hacer un count de la tabla para obtener el total de resultados. Para ver otros ejemplos y m\u00e1s informaci\u00f3n, visita la p\u00e1gina de QueryMethods . Service La siguiente capa que vamos a implementar es justamente la capa que hace uso del Repository , es decir el Service . AuthorService.java package com.capgemini.coedevon.tutorial.author ; import org.springframework.data.domain.Page ; import com.capgemini.coedevon.tutorial.author.model.Author ; import com.capgemini.coedevon.tutorial.author.model.AuthorDto ; import com.capgemini.coedevon.tutorial.author.model.AuthorSearchDto ; /** * @author coedevon * */ public interface AuthorService { /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param dto * @return */ Page < Author > findPage ( AuthorSearchDto dto ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param data * @return */ Author save ( AuthorDto data ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param id */ void delete ( Long id ); } AuthorServiceImpl.java package com.capgemini.coedevon.tutorial.author ; import javax.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.stereotype.Service ; import com.capgemini.coedevon.tutorial.author.model.Author ; import com.capgemini.coedevon.tutorial.author.model.AuthorDto ; import com.capgemini.coedevon.tutorial.author.model.AuthorSearchDto ; /** * @author coedevon */ @Service @Transactional public class AuthorServiceImpl implements AuthorService { @Autowired AuthorRepository authorRepository ; /** * {@inheritDoc} */ @Override public Page < Author > findPage ( AuthorSearchDto dto ) { return this . authorRepository . findAll ( dto . getPageable ()); } /** * {@inheritDoc} */ @Override public Author save ( AuthorDto data ) { Author categoria = null ; if ( data . getId () != null ) categoria = this . authorRepository . findById ( data . getId ()). orElse ( null ); else categoria = new Author (); BeanUtils . copyProperties ( data , categoria ); return this . authorRepository . save ( categoria ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) { this . authorRepository . deleteById ( id ); } } AuthorSearchDto.java package com.capgemini.coedevon.tutorial.author.model ; import org.springframework.data.domain.Pageable ; /** * @author coedevon */ public class AuthorSearchDto { private Pageable pageable ; /** * @return pageable */ public Pageable getPageable () { return this . pageable ; } /** * @param pageable new value of {@link #getPageable}. */ public void setPageable ( Pageable pageable ) { this . pageable = pageable ; } } En esta capa, si te fijas, ya no devolvemos un List<Author> , sino que ahora devolvemos un Page<Author> que es el m\u00e9todo que hemos a\u00f1adido al Repository . Adem\u00e1s, hemos creado un objeto nuevo AuthorSearchDto , ya que es necesario para realizar la peticion con el objeto Pageable . \u00bfDemasiados de DTOs? No tengas miedo en crear muchos DTOs, de hecho la implementaci\u00f3n \u00f3ptima deber\u00eda tener un DTO de entrada y de otro de salida para cada uno de los m\u00e9todos del Controller . No llegaremos hasta ese extremo y reutilizaremos todo el c\u00f3digo que podamos, pero no pasa nada si creas 3, 4 o incluso 10 DTOs si realmente los necesitas. Controller Para terminar, vamos a implementar el Controller para que ataque a la capa de Service , con los endpoints de las operaciones que vamos a publicar. AuthorController.java package com.capgemini.coedevon.tutorial.author ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.coedevon.tutorial.author.model.AuthorDto ; import com.capgemini.coedevon.tutorial.author.model.AuthorSearchDto ; import com.capgemini.coedevon.tutorial.config.mapper.BeanMapper ; /** * @author coedevon */ @RequestMapping ( value = \"/author/v1\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class AuthorController { @Autowired AuthorService authorService ; @Autowired BeanMapper beanMapper ; /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param dto * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . POST ) public Page < AuthorDto > findPage ( @RequestBody AuthorSearchDto dto ) { return this . beanMapper . mapPage ( this . authorService . findPage ( dto ), AuthorDto . class ); } /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param data datos de la entidad * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . PUT ) public AuthorDto save ( @RequestBody AuthorDto data ) { return this . beanMapper . map ( this . authorService . save ( data ), AuthorDto . class ); } /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param id PK de la entidad */ @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . authorService . delete ( id ); } } En esta capa hemos hecho la conversi\u00f3n de un Page<Author> (modelo entidad) a un Page<AuthorDto> (modelo DTO) con la ayuda del beanMapper de devonfw. Recuerda que al cliente no le deben llegar modelos entidades sino DTOs. Adem\u00e1s, el m\u00e9todo de carga findPage ya no es un m\u00e9todo de tipo GET , ahora es de tipo POST porque le tenemos que enviar los datos de la paginaci\u00f3n para que Spring JPA pueda hacer su magia. Prueba de las operaciones Si ahora levantamos la aplicaci\u00f3n y probamos con el postman, podemos ver los resultados que nos ofrece el back. POST nos devuelve un listado paginado de Autores , f\u00edjate bien en la petici\u00f3n Pageable y la respuesta tipo Page . PUT nos sirve para insertar Autores nuevas (si no tienen el id informado) o para actualizar Autores (si tienen el id informado). F\u00edjate que los datos que se reciben est\u00e1n en el body. DELETE nos sirve eliminar Autores . F\u00edjate que el dato del ID est\u00e1 en el path. Conectar front con back Una vez implementado front y back, lo que nos queda es modificar el servicio del front para que conecte directamente con las operaciones ofrecidas por el back. author.service.ts import { Injectable } from '@angular/core' ; import { Pageable } from 'src/app/models/page/Pageable' ; import { AuthorPage } from 'src/app/models/authors/AuthorPage' ; import { Observable , of } from 'rxjs' ; import { Author } from 'src/app/models/authors/Author' ; import { HttpClient } from '@angular/common/http' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor ( private http : HttpClient ) { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return this . http . post < AuthorPage > ( 'http://localhost:8080/author/v1/' , { pageable : pageable }); } saveAuthor ( author : Author ) : Observable < Author > { return this . http . put < Author > ( 'http://localhost:8080/author/v1/' , author ); } deleteAuthor ( idAuthor : number ) : Observable < any > { return this . http . delete ( 'http://localhost:8080/author/v1/' + idAuthor ); } }","title":"Code: Listado paginado"},{"location":"develop/step4/#desarrollo-de-un-listado-paginado","text":"Ya tienes tu primer listado desarrollado, tanto en front como en back. \u00bfHa sido sencillo, verdad?. Ahora vamos a implementar un listado un poco m\u00e1s complejo, este tiene datos paginados en servidor, esto quiere decir que no nos sirve un array de datos como en el anterior ejemplo. Un listado paginado en servidor, debe enviar en cada petici\u00f3n que p\u00e1gina est\u00e1 mostrando y cual es el tama\u00f1o de la p\u00e1gina, para que el servidor devuelva un subconjunto de datos. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.","title":"Desarrollo de un listado paginado"},{"location":"develop/step4/#desarrollo-angular","text":"","title":"Desarrollo Angular"},{"location":"develop/step4/#crear-componentes","text":"Vamos a desarrollar el listado de Autores as\u00ed que, debemos crear los componentes: ng generate component views/authors ng generate component views/authors/author-dialog ng generate service services/authors/author","title":"Crear componentes"},{"location":"develop/step4/#crear-el-modelo","text":"Creamos el modelo en models/authors/Author.ts con las propiedades necesarias para trabajar con la informaci\u00f3n de un autor: Author.ts export class Author { id : number ; name : string ; nationality : string ; }","title":"Crear el modelo"},{"location":"develop/step4/#anadir-el-punto-de-entrada","text":"A\u00f1adimos la ruta al men\u00fa para que podamos acceder a la pantalla: app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { CategoriesComponent } from './views/categories/categories.component' ; import { AuthorsComponent } from './views/authors/authors.component' ; const routes : Routes = [ { path : 'categories' , component : CategoriesComponent }, { path : 'authors' , component : AuthorsComponent }, ]; @NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { }","title":"A\u00f1adir el punto de entrada"},{"location":"develop/step4/#implementar-servicio","text":"Y realizamos las diferentes implementaciones. Empezaremos por el servicio. En este caso, hay un cambio sustancial con el anterior ejemplo. Al tratarse de un listado paginado, la operaci\u00f3n getAuthors necesita informaci\u00f3n extra acerca de que p\u00e1gina de datos debe mostrar, adem\u00e1s de que el resultado ya no ser\u00e1 un listado sino una p\u00e1gina. Por defecto el esquema de datos de Spring para la paginaci\u00f3n es como el siguiente: Esquema de datos de paginaci\u00f3n { \"content\" : [ ... <listado con los resultados paginados> ... ], \"pageable\" : { \"pageNumber\" : <n\u00famero de p\u00e1gina empezando por 0 > , \"pageSize\" : <tama\u00f1o de p\u00e1gina> , \"sort\" : [ { \"property\" : <nombre de la propiedad a ordenar> , \"direction\" : <direcci\u00f3n de la ordenaci\u00f3n ASC / DESC> } ] }, \"totalElements\" : <numero total de elementos en la tabla> } As\u00ed que necesitamos poder enviar y recuperar esa informaci\u00f3n desde Angular, nos hace falta crear esos objetos. Los objetos de paginaci\u00f3n los crear\u00e9 en models/page , mientras que la paginaci\u00f3n de Author la crear\u00e9 en models/authors . SortPage.ts export class SortPage { property : String ; direction : String ; } Pageable.ts import { SortPage } from './SortPage' ; export class Pageable { pageNumber : number ; pageSize : number ; sort : SortPage []; } AuthorPage.ts import { Author } from './Author' ; import { Pageable } from '../page/Pageable' ; export class AuthorPage { content : Author []; pageable : Pageable ; } Con estos objetos creados ya podemos implementar el servicio y sus datos mockeados. mock-authors.ts import { AuthorPage } from 'src/app/models/authors/AuthorPage' ; export const AUTHOR_DATA : AuthorPage = { content : [ { id : 1 , name : 'Klaus Teuber' , nationality : 'Alemania' }, { id : 2 , name : 'Matt Leacock' , nationality : 'Estados Unidos' }, { id : 3 , name : 'Keng Leong Yeo' , nationality : 'Singapur' }, { id : 4 , name : 'Gil Hova' , nationality : 'Estados Unidos' }, { id : 5 , name : 'Kelly Adams' , nationality : 'Estados Unidos' }, { id : 6 , name : 'J. Alex Kavern' , nationality : 'Estados Unidos' }, { id : 7 , name : 'Corey Young' , nationality : 'Estados Unidos' }, ], pageable : { pageSize : 7 , pageNumber : 0 , sort : [ { property : \"id\" , direction : \"ASC\" } ] } } author.service.ts import { Injectable } from '@angular/core' ; import { Pageable } from 'src/app/models/page/Pageable' ; import { AuthorPage } from 'src/app/models/authors/AuthorPage' ; import { Observable , of } from 'rxjs' ; import { Author } from 'src/app/models/authors/Author' ; import { AUTHOR_DATA } from './mock-authors' ; @Injectable ({ povidedIn : 'root' }) export class AuthorService { constructor () { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return of ( AUTHOR_DATA ); } saveAuthor ( author : Author ) : Observable < Author > { return of ( null ); } deleteAuthor ( idAuthor : number ) : Observable < any > { return of ( null ); } }","title":"Implementar servicio"},{"location":"develop/step4/#implementar-listado","text":"Ya tenemos el servicio con los datos, ahora vamos a por el listado paginado. authors.component.html < div class = \"container\" > < h1 > Listado de Autores </ h1 > < mat-table [ dataSource ]=\" dataSource \" > < ng-container matColumnDef = \"id\" > < mat-header-cell * matHeaderCellDef > Identificador </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.id}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"name\" > < mat-header-cell * matHeaderCellDef > Nombre autor </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.name}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"nationality\" > < mat-header-cell * matHeaderCellDef > Nacionalidad </ mat-header-cell > < mat-cell * matCellDef = \"let element\" > {{element.nationality}} </ mat-cell > </ ng-container > < ng-container matColumnDef = \"action\" > < mat-header-cell * matHeaderCellDef ></ mat-header-cell > < mat-cell * matCellDef = \"let element\" > < button mat-icon-button color = \"primary\" > < mat-icon ( click )=\" editAuthor ( element )\" > edit </ mat-icon > </ button > < button mat-icon-button color = \"accent\" > < mat-icon ( click )=\" deleteAuthor ( element )\" > clear </ mat-icon > </ button > </ mat-cell > </ ng-container > < mat-header-row * matHeaderRowDef = \"displayedColumns; sticky: true\" ></ mat-header-row > < mat-row * matRowDef = \"let row; columns: displayedColumns;\" ></ mat-row > </ mat-table > < mat-paginator ( page )=\" loadPage ($ event )\" [ pageSizeOptions ]=\"[ 5 , 10 , 20 ]\" [ pageIndex ]=\" pageNumber \" [ pageSize ]=\" pageSize \" [ length ]=\" totalElements \" showFirstLastButtons ></ mat-paginator > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createAuthor ()\" > Nuevo autor </ button > </ div > </ div > authors.component.scss . container { margin : 20 px ; mat-table { margin-top : 10 px ; margin-bottom : 20 px ; .mat-header-row { background-color : #f5f5f5 ; .mat-header-cell { text-transform : uppercase ; font-weight : bold ; color : #838383 ; } } . mat-column-id { flex : 0 0 20 % ; justify-content : center ; } . mat-column-action { flex : 0 0 10 % ; justify-content : center ; } } . buttons { text-align : right ; } } authors.component.ts import { Component , OnInit } from '@angular/core' ; import { MatTableDataSource } from '@angular/material/table' ; import { Author } from 'src/app/models/authors/Author' ; import { MatDialog } from '@angular/material/dialog' ; import { AuthorPage } from 'src/app/models/authors/AuthorPage' ; import { Pageable } from 'src/app/models/page/Pageable' ; import { DialogConfirmationComponent } from 'src/app/shared/dialog-confirmation/dialog-confirmation/dialog-confirmation.component' ; import { AuthorDialogComponent } from './author-dialog/author-dialog.component' ; @Component ({ selector : 'app-authors' , templateUrl : './authors.component.html' , styleUrls : [ './authors.component.scss' ] }) export class AuthorsComponent implements OnInit { pageNumber : number = 0 ; pageSize : number = 5 ; totalElements : number = 0 ; dataSource = new MatTableDataSource < Author > (); displayedColumns : string [] = [ 'id' , 'name' , 'nationality' , 'action' ]; constructor ( private authorService : AuthorService , public dialog : MatDialog , ) { } ngOnInit () : void { this . loadPage (); } loadPage ( event? : PageEvent ) { let pageable : Pageable = { pageNumber : this.pageSize , pageSize : this.pageSize , sort : [{ property : 'id' , direction : 'ASC' }] } if ( event != null ) { pageable . pageSize = event . pageSize pageable . pageNumber = event . pageIndex ; } this . authorService . getAuthors ( pageable ). subscribe ( data => { this . dataSource . data = data . content ; this . pageNumber = data . pageable . pageNumber ; this . pageSize = data . pageable . pageSize ; this . totalElements = data . totalElements ; } ); } createAuthor() { const dialogRef = this . dialog . open ( AuthorDialogComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } editAuthor ( author : Author ) { const dialogRef = this . dialog . open ( AuthorDialogComponent , { data : { author : author } }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } deleteAuthor ( author : Author ) { const dialogRef = this . dialog . open ( DialogConfirmationComponent , { data : { title : \"Eliminar autor\" , description : \"Atenci\u00f3n si borra el autor se perder\u00e1n sus datos.<br> \u00bfDesea eliminar el autor?\" } }); dialogRef . afterClosed (). subscribe ( result => { if ( result ) { this . authorService . deleteAuthor ( author . id ). subscribe ( result => { this . ngOnInit (); }); } }); } } F\u00edjate como hemos a\u00f1adido la paginaci\u00f3n. Al HTML le hemos a\u00f1adido un componente nuevo mat-paginator , lo que nos va a obligar a a\u00f1adirlo al m\u00f3dulo tambi\u00e9n como dependencia. Ese componente le hemos definido un m\u00e9todo page que se ejecuta cada vez que la p\u00e1gina cambia, y unas propiedades con las que calcular\u00e1 la p\u00e1gina, el tama\u00f1o y el n\u00famero total de p\u00e1ginas. Al Typescript le hemos tenido que a\u00f1adir esas variables y hemos creado un m\u00e9todo para cargar datos que lo que hace es construir un objeto pageable con los valores actuales del componente paginador y lanza la petici\u00f3n con esos datos en el body. Obviamente al ser un mock no funcionar\u00e1 el cambio de p\u00e1gina y dem\u00e1s. Como hemos comentado, a\u00f1adimos la dependencia al m\u00f3dulo para que todo funcione. views.module.ts import { NgModule } from '@angular/core' ; import { CommonModule } from '@angular/common' ; import { MatTableModule } from '@angular/material/table' ; import { MatIconModule } from '@angular/material/icon' ; import { MatButtonModule } from '@angular/material/button' ; import { CategoriesComponent } from './categories/categories.component' ; import { CategoryDialogComponent } from './categories/category-dialog/category-dialog.component' ; import { MAT_DIALOG_DATA , MatDialogModule } from '@angular/material/dialog' ; import { MatFormFieldModule } from '@angular/material/form-field' ; import { MatInputModule } from '@angular/material/input' ; import { FormsModule , ReactiveFormsModule } from '@angular/forms' ; import { AuthorsComponent } from './authors/authors.component' ; import { AuthorDialogComponent } from './authors/author-dialog/author-dialog.component' ; import { MatPaginatorModule } from '@angular/material/paginator' ; @NgModule ({ declarations : [ CategoriesComponent , CategoryDialogComponent , AuthorsComponent , AuthorDialogComponent ], imports : [ CommonModule , MatTableModule , MatIconModule , MatButtonModule , MatDialogModule , MatFormFieldModule , MatInputModule , FormsModule , ReactiveFormsModule , MatPaginatorModule , ], providers : [ { provide : MAT_DIALOG_DATA , useValue : {}, }, ] }) export class ViewsModule { } Deber\u00eda verse algo similar a esto:","title":"Implementar listado"},{"location":"develop/step4/#implementar-dialogo-edicion","text":"El \u00faltimo paso, es definir la pantalla de dialogo que realizar\u00e1 el alta y modificado de los datos de un Autor . author-dialog.component.html < div class = \"container\" > < h1 * ngIf = \"author.id == null\" > Crear autor </ h1 > < h1 * ngIf = \"author.id != null\" > Modificar autor </ h1 > < form > < mat-form-field > < mat-label > Identificador </ mat-label > < input type = \"number\" matInput placeholder = \"Identificador\" [( ngModel )]=\" author . id \" name = \"id\" disabled > </ mat-form-field > < mat-form-field > < mat-label > Nombre </ mat-label > < input type = \"text\" matInput placeholder = \"Nombre del autor\" [( ngModel )]=\" author . name \" name = \"name\" required > < mat-error > El nombre no puede estar vac\u00edo </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Nacionalidad </ mat-label > < input type = \"text\" matInput placeholder = \"Nacionalidad del autor\" [( ngModel )]=\" author . nationality \" name = \"nationality\" required > < mat-error > La nacionalidad no puede estar vac\u00eda </ mat-error > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onClose ()\" > Cerrar </ button > < button mat-flat-button color = \"primary\" ( click )=\" onSave ()\" > Guardar </ button > </ div > </ div > author-dialog.component.scss . container { min-width : 350 px ; max-width : 500 px ; width : 100 % ; form { display : flex ; flex-direction : column ; margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } author-dialog.component.ts import { Component , OnInit , Inject } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { Author } from 'src/app/models/authors/Author' ; import { AuthorService } from 'src/app/services/authors/author.service' ; @Component ({ selector : 'app-author-dialog' , templateUrl : './author-dialog.component.html' , styleUrls : [ './author-dialog.component.scss' ] }) export class AuthorDialogComponent implements OnInit { author : Author ; constructor ( public dialogRef : MatDialogRef < AuthorDialogComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any , private authorService : AuthorService ) { } ngOnInit () : void { if ( this . data . author != null ) { this . author = Object . assign ({}, this . data . author ); } else { this . author = new Author (); } } onSave() { this . authorService . saveAuthor ( this . author ). subscribe ( result => { this . dialogRef . close (); }); } onClose() { this . dialogRef . close (); } } Que deber\u00eda quedar algo as\u00ed:","title":"Implementar dialogo edici\u00f3n"},{"location":"develop/step4/#desarrollo-springboot","text":"","title":"Desarrollo Springboot"},{"location":"develop/step4/#modelos","text":"Lo primero que vamos a hacer es crear los modelos para trabajar con BBDD y con peticiones hacia el front. Adem\u00e1s, tambi\u00e9n tenemos que a\u00f1adir datos al script de inicializaci\u00f3n de BBDD. V0001__Create_Schema.sql CREATE SEQUENCE HIBERNATE_SEQUENCE START WITH 1000000 ; DROP TABLE IF EXISTS CATEGORY ; CREATE TABLE CATEGORY ( id BIGINT AUTO_INCREMENT PRIMARY KEY , name VARCHAR ( 250 ) NOT NULL ); DROP TABLE IF EXISTS AUTHOR ; CREATE TABLE AUTHOR ( id BIGINT AUTO_INCREMENT PRIMARY KEY , name VARCHAR ( 400 ) NOT NULL , nationality VARCHAR ( 250 ) NOT NULL ); V0002__Create_Data.sql INSERT INTO CATEGORY ( id , name ) VALUES ( 1 , 'Eurogames' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 2 , 'Ameritrash' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 3 , 'Familiar' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 1 , 'Alan R. Moon' , 'US' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 2 , 'Vital Lacerda' , 'PT' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 3 , 'Simone Luciani' , 'IT' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 4 , 'Perepau Llistosella' , 'ES' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 5 , 'Michael Kiesling' , 'DE' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 6 , 'Phil Walker-Harding' , 'US' ); Author.java package com.capgemini.coedevon.tutorial.author.model ; import javax.persistence.Column ; import javax.persistence.Entity ; import javax.persistence.GeneratedValue ; import javax.persistence.GenerationType ; import javax.persistence.Id ; import javax.persistence.Table ; /** * @author coedevon */ @Entity @Table ( name = \"Author\" ) public class Author { @Id @GeneratedValue ( strategy = GenerationType . AUTO ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"name\" , nullable = false ) private String name ; @Column ( name = \"nationality\" ) private String nationality ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getid}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getname}. */ public void setName ( String name ) { this . name = name ; } /** * @return nationality */ public String getNationality () { return this . nationality ; } /** * @param nationality new value of {@link #getnationality}. */ public void setNationality ( String nationality ) { this . nationality = nationality ; } } AuthorDto.java package com.capgemini.coedevon.tutorial.author.model ; /** * @author coedevon */ public class AuthorDto { private Long id ; private String name ; private String nationality ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getid}. */ public void setId ( Long id ) { this . id = id ; } /** * @return name */ public String getName () { return this . name ; } /** * @param name new value of {@link #getname}. */ public void setName ( String name ) { this . name = name ; } /** * @return nationality */ public String getNationality () { return this . nationality ; } /** * @param nationality new value of {@link #getnationality}. */ public void setNationality ( String nationality ) { this . nationality = nationality ; } }","title":"Modelos"},{"location":"develop/step4/#repository","text":"Para desarrollar todas las operaciones, esta vez vamos a ir de m\u00e1s bajo a m\u00e1s alto nivel. Empezaremos por el acceso a datos, crearemos el Repository. AuthorRepository.java package com.capgemini.coedevon.tutorial.author ; import org.springframework.data.domain.Page ; import org.springframework.data.domain.Pageable ; import org.springframework.data.repository.CrudRepository ; import com.capgemini.coedevon.tutorial.author.model.Author ; /** * @author coedevon */ public interface AuthorRepository extends CrudRepository < Author , Long > { /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param page * @return */ Page < Author > findAll ( Pageable page ); } Si te fijas, este Repository ya no est\u00e1 vac\u00edo como el anterior, no nos sirve con las operaciones b\u00e1sicas del CrudRepository en este caso tenemos que a\u00f1adir un m\u00e9todo nuevo al que pasandole un objeto de tipo Pageable nos devuelva una Page . El objeto Pageable no es m\u00e1s que una interface que le permite a Spring JPA saber que p\u00e1gina se quiere buscar, cual es el tama\u00f1o de p\u00e1gina y cuales son las propiedades de ordenaci\u00f3n que se debe lanzar en la consulta. El objeto Page no es m\u00e1s que un contenedor que engloba la informaci\u00f3n b\u00e1sica de la p\u00e1gina que se est\u00e1 consultando (n\u00famero de p\u00e1gina, tama\u00f1o de p\u00e1gina, n\u00famero total de resultados) y el conjunto de datos de la BBDD que contiene esa p\u00e1gina una vez han sido buscados y ordenados. Adem\u00e1s, la m\u00e1gina de Spring JPA har\u00e1 su trabajo y nosotros no necesitamos implementar ninguna query, Spring ya entiende que un findAll significa que debe recuperar todos los datos de la tabla Author y adem\u00e1s deben estar paginados. Nos ahorra tener que buscar una p\u00e1gina concreta de datos y hacer un count de la tabla para obtener el total de resultados. Para ver otros ejemplos y m\u00e1s informaci\u00f3n, visita la p\u00e1gina de QueryMethods .","title":"Repository"},{"location":"develop/step4/#service","text":"La siguiente capa que vamos a implementar es justamente la capa que hace uso del Repository , es decir el Service . AuthorService.java package com.capgemini.coedevon.tutorial.author ; import org.springframework.data.domain.Page ; import com.capgemini.coedevon.tutorial.author.model.Author ; import com.capgemini.coedevon.tutorial.author.model.AuthorDto ; import com.capgemini.coedevon.tutorial.author.model.AuthorSearchDto ; /** * @author coedevon * */ public interface AuthorService { /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param dto * @return */ Page < Author > findPage ( AuthorSearchDto dto ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param data * @return */ Author save ( AuthorDto data ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param id */ void delete ( Long id ); } AuthorServiceImpl.java package com.capgemini.coedevon.tutorial.author ; import javax.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.stereotype.Service ; import com.capgemini.coedevon.tutorial.author.model.Author ; import com.capgemini.coedevon.tutorial.author.model.AuthorDto ; import com.capgemini.coedevon.tutorial.author.model.AuthorSearchDto ; /** * @author coedevon */ @Service @Transactional public class AuthorServiceImpl implements AuthorService { @Autowired AuthorRepository authorRepository ; /** * {@inheritDoc} */ @Override public Page < Author > findPage ( AuthorSearchDto dto ) { return this . authorRepository . findAll ( dto . getPageable ()); } /** * {@inheritDoc} */ @Override public Author save ( AuthorDto data ) { Author categoria = null ; if ( data . getId () != null ) categoria = this . authorRepository . findById ( data . getId ()). orElse ( null ); else categoria = new Author (); BeanUtils . copyProperties ( data , categoria ); return this . authorRepository . save ( categoria ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) { this . authorRepository . deleteById ( id ); } } AuthorSearchDto.java package com.capgemini.coedevon.tutorial.author.model ; import org.springframework.data.domain.Pageable ; /** * @author coedevon */ public class AuthorSearchDto { private Pageable pageable ; /** * @return pageable */ public Pageable getPageable () { return this . pageable ; } /** * @param pageable new value of {@link #getPageable}. */ public void setPageable ( Pageable pageable ) { this . pageable = pageable ; } } En esta capa, si te fijas, ya no devolvemos un List<Author> , sino que ahora devolvemos un Page<Author> que es el m\u00e9todo que hemos a\u00f1adido al Repository . Adem\u00e1s, hemos creado un objeto nuevo AuthorSearchDto , ya que es necesario para realizar la peticion con el objeto Pageable . \u00bfDemasiados de DTOs? No tengas miedo en crear muchos DTOs, de hecho la implementaci\u00f3n \u00f3ptima deber\u00eda tener un DTO de entrada y de otro de salida para cada uno de los m\u00e9todos del Controller . No llegaremos hasta ese extremo y reutilizaremos todo el c\u00f3digo que podamos, pero no pasa nada si creas 3, 4 o incluso 10 DTOs si realmente los necesitas.","title":"Service"},{"location":"develop/step4/#controller","text":"Para terminar, vamos a implementar el Controller para que ataque a la capa de Service , con los endpoints de las operaciones que vamos a publicar. AuthorController.java package com.capgemini.coedevon.tutorial.author ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.coedevon.tutorial.author.model.AuthorDto ; import com.capgemini.coedevon.tutorial.author.model.AuthorSearchDto ; import com.capgemini.coedevon.tutorial.config.mapper.BeanMapper ; /** * @author coedevon */ @RequestMapping ( value = \"/author/v1\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class AuthorController { @Autowired AuthorService authorService ; @Autowired BeanMapper beanMapper ; /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param dto * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . POST ) public Page < AuthorDto > findPage ( @RequestBody AuthorSearchDto dto ) { return this . beanMapper . mapPage ( this . authorService . findPage ( dto ), AuthorDto . class ); } /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param data datos de la entidad * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . PUT ) public AuthorDto save ( @RequestBody AuthorDto data ) { return this . beanMapper . map ( this . authorService . save ( data ), AuthorDto . class ); } /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param id PK de la entidad */ @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . authorService . delete ( id ); } } En esta capa hemos hecho la conversi\u00f3n de un Page<Author> (modelo entidad) a un Page<AuthorDto> (modelo DTO) con la ayuda del beanMapper de devonfw. Recuerda que al cliente no le deben llegar modelos entidades sino DTOs. Adem\u00e1s, el m\u00e9todo de carga findPage ya no es un m\u00e9todo de tipo GET , ahora es de tipo POST porque le tenemos que enviar los datos de la paginaci\u00f3n para que Spring JPA pueda hacer su magia.","title":"Controller"},{"location":"develop/step4/#prueba-de-las-operaciones","text":"Si ahora levantamos la aplicaci\u00f3n y probamos con el postman, podemos ver los resultados que nos ofrece el back. POST nos devuelve un listado paginado de Autores , f\u00edjate bien en la petici\u00f3n Pageable y la respuesta tipo Page . PUT nos sirve para insertar Autores nuevas (si no tienen el id informado) o para actualizar Autores (si tienen el id informado). F\u00edjate que los datos que se reciben est\u00e1n en el body. DELETE nos sirve eliminar Autores . F\u00edjate que el dato del ID est\u00e1 en el path.","title":"Prueba de las operaciones"},{"location":"develop/step4/#conectar-front-con-back","text":"Una vez implementado front y back, lo que nos queda es modificar el servicio del front para que conecte directamente con las operaciones ofrecidas por el back. author.service.ts import { Injectable } from '@angular/core' ; import { Pageable } from 'src/app/models/page/Pageable' ; import { AuthorPage } from 'src/app/models/authors/AuthorPage' ; import { Observable , of } from 'rxjs' ; import { Author } from 'src/app/models/authors/Author' ; import { HttpClient } from '@angular/common/http' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor ( private http : HttpClient ) { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return this . http . post < AuthorPage > ( 'http://localhost:8080/author/v1/' , { pageable : pageable }); } saveAuthor ( author : Author ) : Observable < Author > { return this . http . put < Author > ( 'http://localhost:8080/author/v1/' , author ); } deleteAuthor ( idAuthor : number ) : Observable < any > { return this . http . delete ( 'http://localhost:8080/author/v1/' + idAuthor ); } }","title":"Conectar front con back"},{"location":"develop/step5/","text":"Desarrollo de un listado filtrado En este punto ya tenemos dos listados, uno b\u00e1sico y otro paginado. Ahora vamos a implementar un listado un poco diferente, con filtros y con una presentaci\u00f3n un tanto distinta. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades. Desarrollo Angular Crear componentes Vamos a desarrollar el listado de Juegos . Este listado es un tanto peculiar, porque no tiene una tabla como tal, sino que tiene una tabla con \"tiles\" para cada uno de los juegos. Necesitaremos un componente para el listado y otro componente para el detalle del juego. Tambi\u00e9n necesitaremos otro componente para el dialogo de edici\u00f3n / alta. Manos a la obra: ng generate component views/games ng generate component views/games/game-detail ng generate component views/games/game-dialog ng generate service services/games/game Crear el modelo Lo primero que vamos a hacer es crear el modelo en models/games/Game.ts con todas las propiedades necesarias para trabajar con un juego: Game.ts import { Category } from '../categories/Category' ; import { Author } from '../authors/Author' ; export class Game { id : number ; title : string ; age : number ; category : Category ; author : Author ; } Como ves, el juego tiene dos objetos para mapear categor\u00eda y autor. A\u00f1adir el punto de entrada A\u00f1adimos la ruta al men\u00fa para que podamos navegar a esta pantalla: app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { CategoriesComponent } from './views/categories/categories.component' ; import { AuthorsComponent } from './views/authors/authors.component' ; import { GamesComponent } from './views/games/games.component' ; const routes : Routes = [ { path : '' , redirectTo : '/games' , pathMatch : 'full' }, { path : 'categories' , component : CategoriesComponent }, { path : 'authors' , component : AuthorsComponent }, { path : 'games' , component : GamesComponent }, ]; @NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } Adem\u00e1s, hemos a\u00f1adido una regla adicional para que cuando se cargue la p\u00e1gina inicial (sin ruta) por defecto redirija al cat\u00e1logo de juegos. Implementar servicio A continuaci\u00f3n implementamos el servicio y mockeamos datos de ejemplo: mock-games.ts import { Game } from \"src/app/models/games/Game\" ; export const GAME_DATA : Game [] = [ { id : 1 , title : 'Juego 1' , age : 6 , category : { id : 1 , name : 'Categor\u00eda 1' }, author : { id : 1 , name : 'Autor 1' , nationality : 'Nacionalidad 1' } }, { id : 2 , title : 'Juego 2' , age : 8 , category : { id : 1 , name : 'Categor\u00eda 1' }, author : { id : 2 , name : 'Autor 2' , nationality : 'Nacionalidad 2' } }, { id : 3 , title : 'Juego 3' , age : 4 , category : { id : 1 , name : 'Categor\u00eda 1' }, author : { id : 3 , name : 'Autor 3' , nationality : 'Nacionalidad 3' } }, { id : 4 , title : 'Juego 4' , age : 10 , category : { id : 2 , name : 'Categor\u00eda 2' }, author : { id : 1 , name : 'Autor 1' , nationality : 'Nacionalidad 1' } }, { id : 5 , title : 'Juego 5' , age : 16 , category : { id : 2 , name : 'Categor\u00eda 2' }, author : { id : 2 , name : 'Autor 2' , nationality : 'Nacionalidad 2' } }, { id : 6 , title : 'Juego 6' , age : 16 , category : { id : 2 , name : 'Categor\u00eda 2' }, author : { id : 3 , name : 'Autor 3' , nationality : 'Nacionalidad 3' } }, { id : 7 , title : 'Juego 7' , age : 12 , category : { id : 3 , name : 'Categor\u00eda 3' }, author : { id : 1 , name : 'Autor 1' , nationality : 'Nacionalidad 1' } }, { id : 8 , title : 'Juego 8' , age : 14 , category : { id : 3 , name : 'Categor\u00eda 3' }, author : { id : 2 , name : 'Autor 2' , nationality : 'Nacionalidad 2' } }, ] game.service.ts import { Injectable } from '@angular/core' ; import { Game } from 'src/app/models/games/Game' ; import { Observable , of } from 'rxjs' ; import { GAME_DATA } from './mock-games' ; @Injectable ({ providedIn : 'root' }) export class GameService { constructor () { } getGames ( title? : String , categoryId? : number ) : Observable < Game [] > { return of ( GAME_DATA ); } saveGame ( game : Game ) : Observable < Game > { return of ( null ); } } Implementar listado Ya tenemos las operaciones del servicio con datoos, as\u00ed que ahora vamos a por el listado filtrado. games.component.html < div class = \"container\" > < h1 > Cat\u00e1logo de juegos </ h1 > < div class = \"filters\" > < form > < mat-form-field > < mat-label > T\u00edtulo del juego </ mat-label > < input type = \"text\" matInput placeholder = \"T\u00edtulo del juego\" [( ngModel )]=\" filterTitle \" name = \"title\" > </ mat-form-field > < mat-form-field > < mat-label > Categor\u00eda del juego </ mat-label > < mat-select disableRipple [( ngModel )]=\" filterCategory \" name = \"category\" > < mat-option * ngFor = \"let category of categories\" [ value ]=\" category \" > {{category.name}} </ mat-option > </ mat-select > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onCleanFilter ()\" > Limpiar </ button > < button mat-stroked-button ( click )=\" onSearch ()\" > Filtrar </ button > </ div > </ div > < div class = \"game-list\" > < app-game-detail * ngFor = \"let game of games; let i = index;\" ( click )=\" editGame ( game )\" > </ app-game-detail > </ div > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createGame () > Nuevo juego </ button > </ div > </ div > games.component.scss . container { margin : 20 px ; .filters { display : flex ; mat-form-field { width : 300 px ; margin-right : 20 px ; } . buttons { flex : auto ; align-self : center ; button { margin-left : 15 px ; } } } . game-list { margin-top : 20 px ; margin-bottom : 20 px ; display : flex ; flex-flow : wrap ; overflow : auto ; } . buttons { text-align : right ; } } button { width : 125 px ; } games.component.ts import { Component , OnInit } from '@angular/core' ; import { Category } from 'src/app/models/categories/Category' ; import { Game } from 'src/app/models/games/Game' ; import { GameService } from 'src/app/services/games/game.service' ; import { CategoryService } from 'src/app/services/categories/category.service' ; import { GameDialogComponent } from './game-dialog/game-dialog.component' ; import { MatDialog } from '@angular/material/dialog' ; @Component ({ selector : 'app-games' , templateUrl : './games.component.html' , styleUrls : [ './games.component.scss' ] }) export class GamesComponent implements OnInit { categories : Category []; games : Game []; filterCategory : Category ; filterTitle : string ; constructor ( private gameService : GameService , private categoryService : CategoryService , public dialog : MatDialog , ) { } ngOnInit () : void { this . gameService . getGames (). subscribe ( games => this . games = games ); this . categoryService . getCategories (). subscribe ( categories => this . categories = categories ); } onCleanFilter () : void { this . filterTitle = null ; this . filterCategory = null ; this . onSearch (); } onSearch () : void { let title = this . filterTitle ; let categoryId = this . filterCategory != null ? this . filterCategory.id : null ; this . gameService . getGames ( title , categoryId ). subscribe ( games => this . games = games ); } createGame() { const dialogRef = this . dialog . open ( GameDialogComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } editGame ( game : Game ) { const dialogRef = this . dialog . open ( GameDialogComponent , { data : { game : game } }); dialogRef . afterClosed (). subscribe ( result => { this . onSearch (); }); } } Debe quedar algo similar a esto: Tenemos una pantalla con una secci\u00f3n de filtros en la parte superior, donde podemos introducir un texto o seleccionar una categor\u00eda de un dropdown, un listado que de momento tiene todos los componentes b\u00e1sicos en una fila uno detr\u00e1s del otro, y un bot\u00f3n para crear juegos nuevos. Implementar detalle del item Ahora vamos a implementar el detalle de cada uno de los items que forman el listado. Para ello lo primero que haremos ser\u00e1 pasarle la informaci\u00f3n del juego a cada componente como un dato de entrada Input . games.component.html < div class = \"container\" > < h1 > Cat\u00e1logo de juegos </ h1 > < div class = \"filters\" > < form > < mat-form-field > < mat-label > T\u00edtulo del juego </ mat-label > < input type = \"text\" matInput placeholder = \"T\u00edtulo del juego\" [( ngModel )]=\" filterName \" name = \"title\" > </ mat-form-field > < mat-form-field > < mat-label > Categor\u00eda del juego </ mat-label > < mat-select disableRipple [( ngModel )]=\" filterCategory \" name = \"category\" > < mat-option * ngFor = \"let category of categories\" [ value ]=\" category \" > {{category.name}} </ mat-option > </ mat-select > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onCleanFilter ()\" > Limpiar </ button > < button mat-stroked-button ( click )=\" onSearch ()\" > Filtrar </ button > </ div > </ div > < div class = \"game-list\" > < app-game-detail * ngFor = \"let game of games; let i = index;\" ( click )=\" editGame ( game )\" [ game ]=\" game \" > </ app-game-detail > </ div > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createGame ()\" > Nuevo juego </ button > </ div > </ div > Tambi\u00e9n vamos a necesitar una foto de ejemplo para poder en el detalle de los juegos. Vamos a utilizar esta imagen: Y ya para terminar, implementamos el componente de detalle: game-detail.component.html < div class = \"container\" > < mat-card > < div class = \"photo\" > < img src = \"./assets/foto.png\" > </ div > < div class = \"detail\" > < div class = \"title\" > {{game.title}} </ div > < div class = \"properties\" > < div >< i > Edad recomendada: </ i > +{{game.age}} </ div > < div >< i > Categor\u00eda: </ i > {{game.category.name}} </ div > < div >< i > Autor: </ i > {{game.author.name}} </ div > < div >< i > Nacionalidad: </ i > {{game.author.nationality}} </ div > </ div > </ div > </ mat-card > </ div > game-detail.component.scss . container { display : flex ; width : 325 px ; mat-card { width : 100 % ; margin : 10 px ; display : flex ; .photo { margin-right : 10 px ; img { width : 80 px ; height : 80 px ; } } . detail { .title { font-size : 14 px ; font-weight : bold ; } . properties { font-size : 11 px ; div { height : 15 px ; } } } } } game-detail.component.ts import { Component , OnInit , Input } from '@angular/core' ; import { Game } from 'src/app/models/games/Game' ; @Component ({ selector : 'app-game-detail' , templateUrl : './game-detail.component.html' , styleUrls : [ './game-detail.component.scss' ] }) export class GameDetailComponent implements OnInit { @Input () game : Game ; constructor () { } ngOnInit () : void { } } Ahora si que deber\u00eda quedar algo similar a esta pantalla: Implementar dialogo de edici\u00f3n Ya solo nos falta el \u00faltimo paso, implementar el cuadro de edici\u00f3n / alta de un nuevo juego. Pero tenemos un peque\u00f1o problema, y es que al crear o editar un juego debemos seleccionar una Categor\u00eda y un Autor . Para la Categor\u00eda no tenemos ning\u00fan problema, pero para el Autor no tenemos un servicio que nos devuelva todos los autores, solo tenemos un servicio que nos devuelve una Page de autores. As\u00ed que lo primero que haremos ser\u00e1 implementar una operaci\u00f3n getAllAuthors para poder recuperar una lista. mock-authors-list.ts import { Author } from 'src/app/models/authors/Author' ; export const AUTHOR_DATA_LIST : Author [] = [ { id : 1 , name : 'Klaus Teuber' , nationality : 'Alemania' }, { id : 2 , name : 'Matt Leacock' , nationality : 'Estados Unidos' }, { id : 3 , name : 'Keng Leong Yeo' , nationality : 'Singapur' }, { id : 4 , name : 'Gil Hova' , nationality : 'Estados Unidos' }, { id : 5 , name : 'Kelly Adams' , nationality : 'Estados Unidos' }, ] mock-authors.ts import { AuthorPage } from 'src/app/models/authors/AuthorPage' ; import { AUTHOR_DATA_LIST } from './mock-authors-list' ; export const AUTHOR_DATA : AuthorPage = { content : AUTHOR_DATA_LIST , pageable : { pageSize : 5 , pageNumber : 0 , sort : [ { property : \"id\" , direction : \"ASC\" } ] }, totalElements : 7 } author.service.ts import { Injectable } from '@angular/core' ; import { Pageable } from 'src/app/models/page/Pageable' ; import { AuthorPage } from 'src/app/models/authors/AuthorPage' ; import { Observable , of } from 'rxjs' ; import { Author } from 'src/app/models/authors/Author' ; import { HttpClient } from '@angular/common/http' ; import { AUTHOR_DATA_LIST } from './mock-authors-list' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor ( private http : HttpClient ) { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return this . http . post < AuthorPage > ( 'http://localhost:8080/author/v1/' , { pageable : pageable }); } saveAuthor ( author : Author ) : Observable < Author > { return this . http . put < Author > ( 'http://localhost:8080/author/v1/' , author ); } deleteAuthor ( idAuthor : number ) : Observable < any > { return this . http . delete ( 'http://localhost:8080/author/v1/' + idAuthor ); } getAllAuthors () : Observable < Author [] > { return of ( AUTHOR_DATA_LIST ); } } Clean Code Acuerdate de lo que hemos comentado antes, siempre debes tener presente el Clean Code . \u00a1No dupliques c\u00f3digo!, es muy importante de cara al futuro mantenimiento. En este caso, en tanto en mock-authors como en mock-authors-list ten\u00edamos un listado de autores. Lo mejor es que no dupliquemos el c\u00f3digo y uno de ellos haga uso del otro. Ahora s\u00ed que tenemos todo listo para implementar el cuadro de dialogo para dar de alta o editar juegos. game-dialog.component.html < div class = \"container\" > < h1 * ngIf = \"game.id == null\" > Crear juego </ h1 > < h1 * ngIf = \"game.id != null\" > Modificar juego </ h1 > < form > < mat-form-field > < mat-label > Identificador </ mat-label > < input type = \"number\" matInput placeholder = \"Identificador\" [( ngModel )]=\" game . id \" name = \"id\" disabled > </ mat-form-field > < mat-form-field > < mat-label > T\u00edtulo </ mat-label > < input type = \"text\" matInput placeholder = \"T\u00edtulo del juego\" [( ngModel )]=\" game . title \" name = \"title\" required > < mat-error > El t\u00edtulo no puede estar vac\u00edo </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Edad recomendada </ mat-label > < input type = \"number\" matInput placeholder = \"Edad recomendada\" [( ngModel )]=\" game . age \" name = \"age\" required > < mat-error > La edad no puede estar vac\u00eda </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Categor\u00eda </ mat-label > < mat-select disableRipple [( ngModel )]=\" game . category \" name = \"category\" required > < mat-option * ngFor = \"let category of categories\" [ value ]=\" category \" > {{category.name}} </ mat-option > </ mat-select > < mat-error > La categor\u00eda no puede estar vac\u00eda </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Autor </ mat-label > < mat-select disableRipple [( ngModel )]=\" game . author \" name = \"author\" required > < mat-option * ngFor = \"let author of authors\" [ value ]=\" author \" > {{author.name}} </ mat-option > </ mat-select > < mat-error > El autor no puede estar vac\u00edo </ mat-error > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onClose ()\" > Cerrar </ button > < button mat-flat-button color = \"primary\" ( click )=\" onSave ()\" > Guardar </ button > </ div > </ div > game-dialog.component.scss . container { min-width : 350 px ; max-width : 500 px ; width : 100 % ; form { display : flex ; flex-direction : column ; margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } game-dialog.component.ts import { Component , OnInit , Inject } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { Game } from 'src/app/models/games/Game' ; import { GameService } from 'src/app/services/games/game.service' ; import { Author } from 'src/app/models/authors/Author' ; import { Category } from 'src/app/models/categories/Category' ; import { AuthorService } from 'src/app/services/authors/author.service' ; import { CategoryService } from 'src/app/services/categories/category.service' ; @Component ({ selector : 'app-game-dialog' , templateUrl : './game-dialog.component.html' , styleUrls : [ './game-dialog.component.scss' ] }) export class GameDialogComponent implements OnInit { game : Game ; authors : Author []; categories : Category []; constructor ( public dialogRef : MatDialogRef < GameDialogComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any , private gameService : GameService , private categoryService : CategoryService , private authorService : AuthorService , ) { } ngOnInit () : void { if ( this . data . game != null ) { this . game = Object . assign ({}, this . data . game ); } else { this . game = new Game (); } this . categoryService . getCategories (). subscribe ( categories => { this . categories = categories ; if ( this . data . game . category != null ) { let categoryFilter : Category [] = categories . filter ( category => category . id == this . data . game . category . id ); if ( categoryFilter != null ) { this . game . category = categoryFilter [ 0 ]; } } } ); this . authorService . getAllAuthors (). subscribe ( authors => { this . authors = authors if ( this . data . game . author != null ) { let authorFilter : Author [] = authors . filter ( author => author . id == this . data . game . author . id ); if ( authorFilter != null ) { this . game . author = authorFilter [ 0 ]; } } } ); } onSave() { this . gameService . saveGame ( this . game ). subscribe ( result => { this . dialogRef . close (); }); } onClose() { this . dialogRef . close (); } } Como puedes ver, para rellenar los componentes seleccionables de dropdown, hemos realizado una consulta al servicio para recuperar todos los autores y categorias, y en la respuesta de cada uno de ellos, hemos buscado en los resultados cual es el que coincide con el ID enviado desde el listado, y ese es el que hemos fijado en el objeto Game . De esta forma, no estamos cogiendo directamente los datos del listado, sino que no estamos asegurando que los datos de autor y de categor\u00eda son los que vienen del servicio, siempre filtrando por su ID. Desarrollo Springboot Modelos Lo primero que vamos a hacer es crear los modelos para trabajar con BBDD y con peticiones hacia el front. Adem\u00e1s, tambi\u00e9n tenemos que a\u00f1adir datos al script de inicializaci\u00f3n de BBDD. V0001__Create_Schema.sql CREATE SEQUENCE HIBERNATE_SEQUENCE START WITH 1000000 ; DROP TABLE IF EXISTS CATEGORY ; CREATE TABLE CATEGORY ( id BIGINT AUTO_INCREMENT PRIMARY KEY , name VARCHAR ( 250 ) NOT NULL ); DROP TABLE IF EXISTS AUTHOR ; CREATE TABLE AUTHOR ( id BIGINT AUTO_INCREMENT PRIMARY KEY , name VARCHAR ( 400 ) NOT NULL , nationality VARCHAR ( 250 ) NOT NULL ); DROP TABLE IF EXISTS GAME ; CREATE TABLE GAME ( id BIGINT AUTO_INCREMENT PRIMARY KEY , title VARCHAR ( 250 ) NOT NULL , age VARCHAR ( 3 ) NOT NULL , category_id BIGINT DEFAULT NULL , author_id BIGINT DEFAULT NULL ); ALTER TABLE GAME ADD FOREIGN KEY ( category_id ) REFERENCES CATEGORY ( id ); ALTER TABLE GAME ADD FOREIGN KEY ( author_id ) REFERENCES AUTHOR ( id ); V0002__Create_Data.sql INSERT INTO CATEGORY ( id , name ) VALUES ( 1 , 'Eurogames' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 2 , 'Ameritrash' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 3 , 'Familiar' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 1 , 'Alan R. Moon' , 'US' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 2 , 'Vital Lacerda' , 'PT' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 3 , 'Simone Luciani' , 'IT' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 4 , 'Perepau Llistosella' , 'ES' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 5 , 'Michael Kiesling' , 'DE' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 6 , 'Phil Walker-Harding' , 'US' ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 1 , 'On Mars' , '14' , 1 , 2 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 2 , 'Aventureros al tren' , '8' , 3 , 1 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 3 , '1920: Wall Street' , '12' , 1 , 4 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 4 , 'Barrage' , '14' , 1 , 3 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 5 , 'Los viajes de Marco Polo' , '12' , 1 , 3 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 6 , 'Azul' , '8' , 3 , 5 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 7 , 'Osopark' , '8' , 3 , 6 ); Game.java package com.capgemini.coedevon.tutorial.game.model ; import javax.persistence.Column ; import javax.persistence.Entity ; import javax.persistence.GeneratedValue ; import javax.persistence.GenerationType ; import javax.persistence.Id ; import javax.persistence.JoinColumn ; import javax.persistence.ManyToOne ; import javax.persistence.Table ; import com.capgemini.coedevon.tutorial.author.model.Author ; import com.capgemini.coedevon.tutorial.category.model.Category ; /** * @author coedevon */ @Entity @Table ( name = \"Game\" ) public class Game { @Id @GeneratedValue ( strategy = GenerationType . AUTO ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"title\" , nullable = false ) private String title ; @Column ( name = \"age\" , nullable = false ) private String age ; @ManyToOne @JoinColumn ( name = \"category_id\" , nullable = false ) private Category category ; @ManyToOne @JoinColumn ( name = \"author_id\" , nullable = false ) private Author author ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return age */ public String getAge () { return this . age ; } /** * @param age new value of {@link #getAge}. */ public void setAge ( String age ) { this . age = age ; } /** * @return category */ public Category getCategory () { return this . category ; } /** * @param category new value of {@link #getCategory}. */ public void setCategory ( Category category ) { this . category = category ; } /** * @return author */ public Author getAuthor () { return this . author ; } /** * @param author new value of {@link #getAuthor}. */ public void setAuthor ( Author author ) { this . author = author ; } } GameDto.java package com.capgemini.coedevon.tutorial.game.model ; import com.capgemini.coedevon.tutorial.author.model.AuthorDto ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; /** * @author coedevon */ public class GameDto { private Long id ; private String title ; private String age ; private CategoryDto category ; private AuthorDto author ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return age */ public String getAge () { return this . age ; } /** * @param age new value of {@link #getAge}. */ public void setAge ( String age ) { this . age = age ; } /** * @return category */ public CategoryDto getCategory () { return this . category ; } /** * @param category new value of {@link #getCategory}. */ public void setCategory ( CategoryDto category ) { this . category = category ; } /** * @return author */ public AuthorDto getAuthor () { return this . author ; } /** * @param author new value of {@link #getAuthor}. */ public void setAuthor ( AuthorDto author ) { this . author = author ; } } Repository Para esta ocasi\u00f3n, vamos a necesitar un listado filtrado por t\u00edtulo o por categor\u00eda, as\u00ed que necesitaremos pasarle esos datos y filtrar la query. Para el t\u00edtulo vamos a buscar por una cadena contenida, as\u00ed que el par\u00e1metro ser\u00e1 de tipo String , mientras que para la categor\u00eda vamos a buscar por su primary key, as\u00ed que el par\u00e1metro ser\u00e1 de tipo Long . B\u00fasquedas en BBDD Siempre deber\u00edamos buscar a los hijos por primary keys, nunca hay que hacerlo por una descripci\u00f3n libre ya que el usuario podr\u00eda teclear el mismo nombre de diferentes formas y no habr\u00eda manera de buscar correctamente el resultado. As\u00ed que siempre que haya un dropdown, se debe filtrar por su ID. Podr\u00edamos utilizar los QueryMethods para que Spring JPA haga su magia, pero en esta ocasi\u00f3n vamos a hacer una implementaci\u00f3n concreta de este m\u00e9todo de filtrado. Esta implementaci\u00f3n la haremos en un Repository normal, y el resto de m\u00e9todos nos vendr\u00e1n dados por un CrudRepository como hemos hecho hasta ahora. GameRepository.java package com.capgemini.coedevon.tutorial.game ; import org.springframework.data.repository.CrudRepository ; import com.capgemini.coedevon.tutorial.game.model.Game ; /** * @author coedevon */ public interface GameRepository extends CrudRepository < Game , Long > , GameCustomRepository { } GameCustomRepository.java package com.capgemini.coedevon.tutorial.game ; import java.util.List ; import com.capgemini.coedevon.tutorial.game.model.Game ; /** * @author coedevon * */ public interface GameCustomRepository { /** * M\u00e9todo para recuperar todas las {@link com.capgemini.coedevon.tutorial.game.model.Game} filtradas * @param title * @param category * @return */ List < Game > findByFilter ( String title , Long category ); } GameCustomRepositoryImpl.java package com.capgemini.coedevon.tutorial.game ; import java.util.List ; import javax.persistence.EntityManager ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.util.StringUtils ; import com.capgemini.coedevon.tutorial.game.model.Game ; import com.devonfw.module.basic.common.api.query.LikePatternSyntax ; import com.devonfw.module.jpa.dataaccess.api.QueryUtil ; import com.querydsl.core.alias.Alias ; import com.querydsl.jpa.impl.JPAQuery ; /** * @author coedevon * */ public class GameCustomRepositoryImpl implements GameCustomRepository { @Autowired private EntityManager entityManager ; /** * {@inheritDoc} */ public List < Game > findByFilter ( String title , Long category ) { Game alias = Alias . alias ( Game . class ); JPAQuery < Game > query = new JPAQuery < Game > ( this . entityManager ). from ( Alias . $ ( alias )); if ( StringUtils . hasText ( title )) { QueryUtil . get (). whereLike ( query , Alias . $ ( alias . getTitle ()), title , LikePatternSyntax . SQL , true , true ); } if ( category != null ) { query . where ( Alias . $ ( alias . getCategory (). getId ()). eq ( category )); } return query . fetch (); } } No se puede implementar un CrudRepository ya que es una interface que tiene su propia implementaci\u00f3n en Spring JPA. El truco que podemos hacer es crear una interface y una implementaci\u00f3n custom con los m\u00e9todos que necesitemos y en nuestro CrudRepository extender la interface custom. De esta forma \u00fanicamente utilizamos un objeto Repository , pero realmente Spring JPA provee los m\u00e9todos de Crud y nosotros proveemos los m\u00e9todos custom. La implementaci\u00f3n de las queries que hagamos dentro del custom repository ya es cosa nuestra y podemos utilizar lo que necesitemos. En este caso hemos optado por utilizar Criteria para hacer la Query ayud\u00e1ndonos de unas clases de utilidad que provee Devonfw, muy recomendables para hacer queries paginadas. Service Siguiente paso, la capa de l\u00f3gica, es decir el Service . GameService.java package com.capgemini.coedevon.tutorial.game ; import java.util.List ; import com.capgemini.coedevon.tutorial.game.model.Game ; import com.capgemini.coedevon.tutorial.game.model.GameDto ; /** * @author coedevon */ public interface GameService { /** * M\u00e9todo para recuperar todas las {@link com.capgemini.coedevon.tutorial.game.model.Game} filtradas * @param title * @param category * @return */ List < Game > findByFilter ( String title , Long category ); /** * M\u00e9todo para crear o actualizar una {@link com.capgemini.coedevon.tutorial.game.model.Game} * @param dto * @return */ public Game save ( GameDto dto ); } AuthorServiceImpl.java package com.capgemini.coedevon.tutorial.game ; import java.util.List ; import javax.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import com.capgemini.coedevon.tutorial.game.model.Game ; import com.capgemini.coedevon.tutorial.game.model.GameDto ; /** * @author coedevon */ @Service @Transactional public class GameServiceImpl implements GameService { @Autowired GameRepository gameRepository ; /** * {@inheritDoc} */ @Override public List < Game > findByFilter ( String title , Long category ) { return this . gameRepository . findByFilter ( title , category ); } /** * {@inheritDoc} */ @Override public Game save ( GameDto dto ) { Game game = null ; if ( dto . getId () != null ) game = this . gameRepository . findById ( dto . getId ()). orElse ( null ); else game = new Game (); BeanUtils . copyProperties ( dto , game , \"author\" , \"category\" ); //TODO: Setear categoria y autor return this . gameRepository . save ( game ); } } En este Service volvemos a utilizar el List en lugar del Page, y hemos eliminado el m\u00e9todo delete ya que no se pueden borrar juegos. Pero, la novedad est\u00e1 en el save . Si recuerdas, un Game tiene una relaci\u00f3n con Author y otra relaci\u00f3n con Category . Estas relaciones se hacen a nivel de Entity , sin embargo en nuestro dto de entrada al m\u00e9todo GameDto estamos tratando con CategoryDto y AuthorDto . Una soluci\u00f3n podr\u00eda ser convertir esos DTOs a Entity , pero esto podr\u00eda llevar a duplicidades en la cache interna de JPA, as\u00ed que mejor no utilizar esta soluci\u00f3n. Lo correcto es realizar consultas a la BBDD y traernos esas entities. Pero si recuerdas las reglas b\u00e1sicas, un Repository debe pertenecer a un solo Service , por lo que en lugar de llamar a m\u00e9todos de los AuthorRepository y CategoryRepository desde nuestro GameService , debemos llamar a m\u00e9todos expuestos en AuthorService y CategoryService . Para ello necesitaremos crear esos m\u00e9todos get en los otros Services . Quedar\u00eda algo as\u00ed: AuthorService.java package com.capgemini.coedevon.tutorial.author ; import org.springframework.data.domain.Page ; import com.capgemini.coedevon.tutorial.author.model.Author ; import com.capgemini.coedevon.tutorial.author.model.AuthorDto ; import com.capgemini.coedevon.tutorial.author.model.AuthorSearchDto ; /** * @author coedevon * */ public interface AuthorService { /** * Recupera un {@link com.capgemini.coedevon.tutorial.author.model.Author} a trav\u00e9s de su ID * @param id * @return */ Author get ( Long id ); /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param dto * @return */ Page < Author > findPage ( AuthorSearchDto dto ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param data * @return */ Author save ( AuthorDto data ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param id */ void delete ( Long id ); } AuthorServiceImpl.java package com.capgemini.coedevon.tutorial.author ; import javax.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.stereotype.Service ; import com.capgemini.coedevon.tutorial.author.model.Author ; import com.capgemini.coedevon.tutorial.author.model.AuthorDto ; import com.capgemini.coedevon.tutorial.author.model.AuthorSearchDto ; /** * @author coedevon */ @Service @Transactional public class AuthorServiceImpl implements AuthorService { @Autowired AuthorRepository authorRepository ; /** * {@inheritDoc} */ @Override public Author get ( Long id ) { return this . authorRepository . findById ( id ). orElse ( null ); } /** * {@inheritDoc} */ @Override public Page < Author > findPage ( AuthorSearchDto dto ) { return this . authorRepository . findAll ( dto . getPageable ()); } /** * {@inheritDoc} */ @Override public Author save ( AuthorDto data ) { Author categoria = null ; if ( data . getId () != null ) categoria = get ( data . getId ()); else categoria = new Author (); BeanUtils . copyProperties ( data , categoria ); return this . authorRepository . save ( categoria ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) { this . authorRepository . deleteById ( id ); } } CategoryService.java package com.capgemini.coedevon.tutorial.category ; import java.util.List ; import com.capgemini.coedevon.tutorial.category.model.Category ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; /** * @author coedevon * */ public interface CategoryService { /** * Recupera una {@link com.capgemini.coedevon.tutorial.category.model.Category} a partir de su ID * @param id * @return */ Category get ( Long id ); /** * M\u00e9todo para recuperar todas las {@link com.capgemini.coedevon.tutorial.category.model.Category} * @return */ List < Category > findAll (); /** * M\u00e9todo para crear o actualizar una {@link com.capgemini.coedevon.tutorial.category.model.Category} * @param dto * @return */ Category save ( CategoryDto dto ); /** * M\u00e9todo para borrar una {@link com.capgemini.coedevon.tutorial.category.model.Category} * @param id */ void delete ( Long id ); } CategoryServiceImpl.java package com.capgemini.coedevon.tutorial.category ; import java.util.List ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import com.capgemini.coedevon.tutorial.category.model.Category ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; /** * @author coedevon * */ @Service public class CategoryServiceImpl implements CategoryService { @Autowired CategoryRepository categoryRepository ; /** * {@inheritDoc} */ @Override public Category get ( Long id ) { return this . categoryRepository . findById ( id ). orElse ( null ); } /** * {@inheritDoc} */ @Override public List < Category > findAll () { return ( List < Category > ) this . categoryRepository . findAll (); } /** * {@inheritDoc} */ @Override public Category save ( CategoryDto dto ) { Category categoria = null ; if ( dto . getId () != null ) categoria = get ( dto . getId ()); else categoria = new Category (); BeanUtils . copyProperties ( dto , categoria ); return this . categoryRepository . save ( categoria ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) { this . categoryRepository . deleteById ( id ); } } Clean Code A la hora de implementar m\u00e9todos nuevos, ten siempre presente el Clean Code . \u00a1No dupliques c\u00f3digo!, es muy importante de cara al futuro mantenimiento. Si en nuestro m\u00e9todo save hac\u00edamos uso de una operaci\u00f3n findById y ahora hemos creado una nueva operaci\u00f3n get , hagamos uso de esta nueva operaci\u00f3n y no repitamos el c\u00f3digo. Y ahora ya podemos implementar correctamente nuestro Service . GameServiceImpl.java package com.capgemini.coedevon.tutorial.game ; import java.util.List ; import javax.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import com.capgemini.coedevon.tutorial.author.AuthorService ; import com.capgemini.coedevon.tutorial.author.model.Author ; import com.capgemini.coedevon.tutorial.category.CategoryService ; import com.capgemini.coedevon.tutorial.category.model.Category ; import com.capgemini.coedevon.tutorial.game.model.Game ; import com.capgemini.coedevon.tutorial.game.model.GameDto ; /** * @author coedevon */ @Service @Transactional public class GameServiceImpl implements GameService { @Autowired GameRepository gameRepository ; @Autowired AuthorService authorService ; @Autowired CategoryService categoryService ; /** * {@inheritDoc} */ @Override public List < Game > findByFilter ( String title , Long category ) { return this . gameRepository . findByFilter ( title , category ); } /** * {@inheritDoc} */ @Override public Game save ( GameDto dto ) { Game game = null ; if ( dto . getId () != null ) game = this . gameRepository . findById ( dto . getId ()). orElse ( null ); else game = new Game (); BeanUtils . copyProperties ( dto , game , \"author\" , \"category\" ); Author author = this . authorService . get ( dto . getAuthor (). getId ()); game . setAuthor ( author ); Category category = this . categoryService . get ( dto . getCategory (). getId ()); game . setCategory ( category ); return this . gameRepository . save ( game ); } } Controller Despu\u00e9s de todo este mareo, ya podemos terminar ocn la \u00faltima capa. Vamos a implementar el Controller para que ataque a la capa de Service , con los endpoints de las operaciones que vamos a publicar. Adem\u00e1s, para realizar la b\u00fasqueda necesitaremos un nuevo DTO como ya vimos en el ejemplo del listado paginado. GameController.java package com.capgemini.coedevon.tutorial.game ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.coedevon.tutorial.config.mapper.BeanMapper ; import com.capgemini.coedevon.tutorial.game.model.GameDto ; import com.capgemini.coedevon.tutorial.game.model.GameSearchDto ; /** * @author coedevon */ @RequestMapping ( value = \"/game/v1\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class GameController { @Autowired GameService gameService ; @Autowired BeanMapper beanMapper ; /* * M\u00e9todo para recuperar todos los {@link com.capgemini.coedevon.tutorial.game.model.Game} filtrados * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . POST ) public List < GameDto > findByFilter ( @RequestBody GameSearchDto dto ) { return this . beanMapper . mapList ( this . gameService . findByFilter ( dto . getTitle (), dto . getCategoryId ()), GameDto . class ); } /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.game.model.Game} * @param dto * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . PUT ) public GameDto save ( @RequestBody GameDto dto ) { return this . beanMapper . map ( this . gameService . save ( dto ), GameDto . class ); } } GameSearchDto.java package com.capgemini.coedevon.tutorial.game.model ; /** * @author coedevon */ public class GameSearchDto { private String title ; private Long categoryId ; /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return categoryId */ public Long getCategoryId () { return this . categoryId ; } /** * @param categoryId new value of {@link #getcategoryId}. */ public void setCategoryId ( Long categoryId ) { this . categoryId = categoryId ; } } Pues con esto ya tendr\u00edamos todas las consultas de Game implementadas. Ahora solo falta probarlas. Prueba de las operaciones Si ahora levantamos la aplicaci\u00f3n y probamos con el postman, podemos ver los resultados que nos ofrece el back. POST nos devuelve un listado paginado de Juegos , f\u00edjate bien en la petici\u00f3n donde env\u00edamos los filtros y la respuesta que tiene los objetos Categoria y Autor inclu\u00eddos. PUT nos sirve para insertar Juegos nuevos (si no tienen el id informado) o para actualizar Juegos (si tienen el id informado). F\u00edjate que para enlazar Categoria y Autor tan solo hace falta el id de cada no de ellos, ya que en el m\u00e9todo save se hace una consulta get para recuperarlos por su id. Adem\u00e1s que no tendr\u00eda sentido enviar toda la informaci\u00f3n de esas entidades ya que no est\u00e1s dando de alta una Categoria ni un Autor . Implementar listado Autores Como hemos visto anteriormente en la parte de frontend, para la edici\u00f3n de un Juego nos hace falta un m\u00e9todo que devuelva un listado de Autores , ya que ahora mismo la operaci\u00f3n que tenemos implementada devuelve un objeto Page . As\u00ed que antes de finalizar la implementaci\u00f3n de backend, vamos a desarrollar esta nueva operaci\u00f3n. Por supuesto, respetaremos las operaciones previas que ya exist\u00edan. AuthorController.java package com.capgemini.coedevon.tutorial.author ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.coedevon.tutorial.author.model.AuthorDto ; import com.capgemini.coedevon.tutorial.author.model.AuthorSearchDto ; import com.capgemini.coedevon.tutorial.config.mapper.BeanMapper ; /** * @author coedevon */ @RequestMapping ( value = \"/author/v1\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class AuthorController { @Autowired AuthorService authorService ; @Autowired BeanMapper beanMapper ; /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param dto * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . GET ) public List < AuthorDto > list () { return this . beanMapper . mapList ( this . authorService . list (), AuthorDto . class ); } /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param dto * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . POST ) public Page < AuthorDto > findPage ( @RequestBody AuthorSearchDto dto ) { return this . beanMapper . mapPage ( this . authorService . findPage ( dto ), AuthorDto . class ); } /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param data datos de la entidad * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . PUT ) public AuthorDto save ( @RequestBody AuthorDto data ) { return this . beanMapper . map ( this . authorService . save ( data ), AuthorDto . class ); } /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param id PK de la entidad */ @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . authorService . delete ( id ); } } AuthorService.java package com.capgemini.coedevon.tutorial.author ; import java.util.List ; import org.springframework.data.domain.Page ; import com.capgemini.coedevon.tutorial.author.model.Author ; import com.capgemini.coedevon.tutorial.author.model.AuthorDto ; import com.capgemini.coedevon.tutorial.author.model.AuthorSearchDto ; /** * @author coedevon * */ public interface AuthorService { /** * Recupera un {@link com.capgemini.coedevon.tutorial.author.model.Author} a trav\u00e9s de su ID * @param id * @return */ Author get ( Long id ); /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param dto * @return */ Page < Author > findPage ( AuthorSearchDto dto ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param data * @return */ Author save ( AuthorDto data ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param id */ void delete ( Long id ); /** * M\u00e9todo para recuperar un listado completo de {@link com.capgemini.coedevon.tutorial.author.model.Author} * @return */ List < Author > list (); } AuthorServiceImpl.java package com.capgemini.coedevon.tutorial.author ; import java.util.List ; import javax.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.stereotype.Service ; import com.capgemini.coedevon.tutorial.author.model.Author ; import com.capgemini.coedevon.tutorial.author.model.AuthorDto ; import com.capgemini.coedevon.tutorial.author.model.AuthorSearchDto ; /** * @author coedevon */ @Service @Transactional public class AuthorServiceImpl implements AuthorService { @Autowired AuthorRepository authorRepository ; /** * {@inheritDoc} */ @Override public Author get ( Long id ) { return this . authorRepository . findById ( id ). orElse ( null ); } /** * {@inheritDoc} */ @Override public Page < Author > findPage ( AuthorSearchDto dto ) { return this . authorRepository . findAll ( dto . getPageable ()); } /** * {@inheritDoc} */ @Override public Author save ( AuthorDto data ) { Author categoria = null ; if ( data . getId () != null ) categoria = get ( data . getId ()); else categoria = new Author (); BeanUtils . copyProperties ( data , categoria ); return this . authorRepository . save ( categoria ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) { this . authorRepository . deleteById ( id ); } /** * {@inheritDoc} */ @Override public List < Author > list () { return ( List < Author > ) this . authorRepository . findAll (); } } Ahora s\u00ed, todo listo para seguir al siguiente punto. Conectar front con back Una vez implementado front y back, lo que nos queda es modificar el servicio del front para que conecte directamente con las operaciones ofrecidas por el back. author-service.ts import { Injectable } from '@angular/core' ; import { Pageable } from 'src/app/models/page/Pageable' ; import { AuthorPage } from 'src/app/models/authors/AuthorPage' ; import { Observable , of } from 'rxjs' ; import { Author } from 'src/app/models/authors/Author' ; import { HttpClient } from '@angular/common/http' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor ( private http : HttpClient ) { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return this . http . post < AuthorPage > ( 'http://localhost:8080/author/v1/' , { pageable : pageable }); } saveAuthor ( author : Author ) : Observable < Author > { return this . http . put < Author > ( 'http://localhost:8080/author/v1/' , author ); } deleteAuthor ( idAuthor : number ) : Observable < any > { return this . http . delete ( 'http://localhost:8080/author/v1/' + idAuthor ); } getAllAuthors () : Observable < Author [] > { return this . http . get < Author [] > ( 'http://localhost:8080/author/v1/' ); } } game-service.ts import { Injectable } from '@angular/core' ; import { Game } from 'src/app/models/games/Game' ; import { Observable , of } from 'rxjs' ; import { HttpClient } from '@angular/common/http' ; @Injectable ({ providedIn : 'root' }) export class GameService { constructor ( private http : HttpClient ) { } getGames ( title? : String , categoryId? : number ) : Observable < Game [] > { let data = { title : title != null ? title : null , categoryId : categoryId != null ? categoryId : null }; return this . http . post < Game [] > ( 'http://localhost:8080/game/v1/' , data ); } saveGame ( game : Game ) : Observable < Game > { return this . http . put < Game > ( 'http://localhost:8080/game/v1/' , game ); } }","title":"Code: Listado filtrado"},{"location":"develop/step5/#desarrollo-de-un-listado-filtrado","text":"En este punto ya tenemos dos listados, uno b\u00e1sico y otro paginado. Ahora vamos a implementar un listado un poco diferente, con filtros y con una presentaci\u00f3n un tanto distinta. Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.","title":"Desarrollo de un listado filtrado"},{"location":"develop/step5/#desarrollo-angular","text":"","title":"Desarrollo Angular"},{"location":"develop/step5/#crear-componentes","text":"Vamos a desarrollar el listado de Juegos . Este listado es un tanto peculiar, porque no tiene una tabla como tal, sino que tiene una tabla con \"tiles\" para cada uno de los juegos. Necesitaremos un componente para el listado y otro componente para el detalle del juego. Tambi\u00e9n necesitaremos otro componente para el dialogo de edici\u00f3n / alta. Manos a la obra: ng generate component views/games ng generate component views/games/game-detail ng generate component views/games/game-dialog ng generate service services/games/game","title":"Crear componentes"},{"location":"develop/step5/#crear-el-modelo","text":"Lo primero que vamos a hacer es crear el modelo en models/games/Game.ts con todas las propiedades necesarias para trabajar con un juego: Game.ts import { Category } from '../categories/Category' ; import { Author } from '../authors/Author' ; export class Game { id : number ; title : string ; age : number ; category : Category ; author : Author ; } Como ves, el juego tiene dos objetos para mapear categor\u00eda y autor.","title":"Crear el modelo"},{"location":"develop/step5/#anadir-el-punto-de-entrada","text":"A\u00f1adimos la ruta al men\u00fa para que podamos navegar a esta pantalla: app-routing.module.ts import { NgModule } from '@angular/core' ; import { Routes , RouterModule } from '@angular/router' ; import { CategoriesComponent } from './views/categories/categories.component' ; import { AuthorsComponent } from './views/authors/authors.component' ; import { GamesComponent } from './views/games/games.component' ; const routes : Routes = [ { path : '' , redirectTo : '/games' , pathMatch : 'full' }, { path : 'categories' , component : CategoriesComponent }, { path : 'authors' , component : AuthorsComponent }, { path : 'games' , component : GamesComponent }, ]; @NgModule ({ imports : [ RouterModule . forRoot ( routes )], exports : [ RouterModule ] }) export class AppRoutingModule { } Adem\u00e1s, hemos a\u00f1adido una regla adicional para que cuando se cargue la p\u00e1gina inicial (sin ruta) por defecto redirija al cat\u00e1logo de juegos.","title":"A\u00f1adir el punto de entrada"},{"location":"develop/step5/#implementar-servicio","text":"A continuaci\u00f3n implementamos el servicio y mockeamos datos de ejemplo: mock-games.ts import { Game } from \"src/app/models/games/Game\" ; export const GAME_DATA : Game [] = [ { id : 1 , title : 'Juego 1' , age : 6 , category : { id : 1 , name : 'Categor\u00eda 1' }, author : { id : 1 , name : 'Autor 1' , nationality : 'Nacionalidad 1' } }, { id : 2 , title : 'Juego 2' , age : 8 , category : { id : 1 , name : 'Categor\u00eda 1' }, author : { id : 2 , name : 'Autor 2' , nationality : 'Nacionalidad 2' } }, { id : 3 , title : 'Juego 3' , age : 4 , category : { id : 1 , name : 'Categor\u00eda 1' }, author : { id : 3 , name : 'Autor 3' , nationality : 'Nacionalidad 3' } }, { id : 4 , title : 'Juego 4' , age : 10 , category : { id : 2 , name : 'Categor\u00eda 2' }, author : { id : 1 , name : 'Autor 1' , nationality : 'Nacionalidad 1' } }, { id : 5 , title : 'Juego 5' , age : 16 , category : { id : 2 , name : 'Categor\u00eda 2' }, author : { id : 2 , name : 'Autor 2' , nationality : 'Nacionalidad 2' } }, { id : 6 , title : 'Juego 6' , age : 16 , category : { id : 2 , name : 'Categor\u00eda 2' }, author : { id : 3 , name : 'Autor 3' , nationality : 'Nacionalidad 3' } }, { id : 7 , title : 'Juego 7' , age : 12 , category : { id : 3 , name : 'Categor\u00eda 3' }, author : { id : 1 , name : 'Autor 1' , nationality : 'Nacionalidad 1' } }, { id : 8 , title : 'Juego 8' , age : 14 , category : { id : 3 , name : 'Categor\u00eda 3' }, author : { id : 2 , name : 'Autor 2' , nationality : 'Nacionalidad 2' } }, ] game.service.ts import { Injectable } from '@angular/core' ; import { Game } from 'src/app/models/games/Game' ; import { Observable , of } from 'rxjs' ; import { GAME_DATA } from './mock-games' ; @Injectable ({ providedIn : 'root' }) export class GameService { constructor () { } getGames ( title? : String , categoryId? : number ) : Observable < Game [] > { return of ( GAME_DATA ); } saveGame ( game : Game ) : Observable < Game > { return of ( null ); } }","title":"Implementar servicio"},{"location":"develop/step5/#implementar-listado","text":"Ya tenemos las operaciones del servicio con datoos, as\u00ed que ahora vamos a por el listado filtrado. games.component.html < div class = \"container\" > < h1 > Cat\u00e1logo de juegos </ h1 > < div class = \"filters\" > < form > < mat-form-field > < mat-label > T\u00edtulo del juego </ mat-label > < input type = \"text\" matInput placeholder = \"T\u00edtulo del juego\" [( ngModel )]=\" filterTitle \" name = \"title\" > </ mat-form-field > < mat-form-field > < mat-label > Categor\u00eda del juego </ mat-label > < mat-select disableRipple [( ngModel )]=\" filterCategory \" name = \"category\" > < mat-option * ngFor = \"let category of categories\" [ value ]=\" category \" > {{category.name}} </ mat-option > </ mat-select > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onCleanFilter ()\" > Limpiar </ button > < button mat-stroked-button ( click )=\" onSearch ()\" > Filtrar </ button > </ div > </ div > < div class = \"game-list\" > < app-game-detail * ngFor = \"let game of games; let i = index;\" ( click )=\" editGame ( game )\" > </ app-game-detail > </ div > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createGame () > Nuevo juego </ button > </ div > </ div > games.component.scss . container { margin : 20 px ; .filters { display : flex ; mat-form-field { width : 300 px ; margin-right : 20 px ; } . buttons { flex : auto ; align-self : center ; button { margin-left : 15 px ; } } } . game-list { margin-top : 20 px ; margin-bottom : 20 px ; display : flex ; flex-flow : wrap ; overflow : auto ; } . buttons { text-align : right ; } } button { width : 125 px ; } games.component.ts import { Component , OnInit } from '@angular/core' ; import { Category } from 'src/app/models/categories/Category' ; import { Game } from 'src/app/models/games/Game' ; import { GameService } from 'src/app/services/games/game.service' ; import { CategoryService } from 'src/app/services/categories/category.service' ; import { GameDialogComponent } from './game-dialog/game-dialog.component' ; import { MatDialog } from '@angular/material/dialog' ; @Component ({ selector : 'app-games' , templateUrl : './games.component.html' , styleUrls : [ './games.component.scss' ] }) export class GamesComponent implements OnInit { categories : Category []; games : Game []; filterCategory : Category ; filterTitle : string ; constructor ( private gameService : GameService , private categoryService : CategoryService , public dialog : MatDialog , ) { } ngOnInit () : void { this . gameService . getGames (). subscribe ( games => this . games = games ); this . categoryService . getCategories (). subscribe ( categories => this . categories = categories ); } onCleanFilter () : void { this . filterTitle = null ; this . filterCategory = null ; this . onSearch (); } onSearch () : void { let title = this . filterTitle ; let categoryId = this . filterCategory != null ? this . filterCategory.id : null ; this . gameService . getGames ( title , categoryId ). subscribe ( games => this . games = games ); } createGame() { const dialogRef = this . dialog . open ( GameDialogComponent , { data : {} }); dialogRef . afterClosed (). subscribe ( result => { this . ngOnInit (); }); } editGame ( game : Game ) { const dialogRef = this . dialog . open ( GameDialogComponent , { data : { game : game } }); dialogRef . afterClosed (). subscribe ( result => { this . onSearch (); }); } } Debe quedar algo similar a esto: Tenemos una pantalla con una secci\u00f3n de filtros en la parte superior, donde podemos introducir un texto o seleccionar una categor\u00eda de un dropdown, un listado que de momento tiene todos los componentes b\u00e1sicos en una fila uno detr\u00e1s del otro, y un bot\u00f3n para crear juegos nuevos.","title":"Implementar listado"},{"location":"develop/step5/#implementar-detalle-del-item","text":"Ahora vamos a implementar el detalle de cada uno de los items que forman el listado. Para ello lo primero que haremos ser\u00e1 pasarle la informaci\u00f3n del juego a cada componente como un dato de entrada Input . games.component.html < div class = \"container\" > < h1 > Cat\u00e1logo de juegos </ h1 > < div class = \"filters\" > < form > < mat-form-field > < mat-label > T\u00edtulo del juego </ mat-label > < input type = \"text\" matInput placeholder = \"T\u00edtulo del juego\" [( ngModel )]=\" filterName \" name = \"title\" > </ mat-form-field > < mat-form-field > < mat-label > Categor\u00eda del juego </ mat-label > < mat-select disableRipple [( ngModel )]=\" filterCategory \" name = \"category\" > < mat-option * ngFor = \"let category of categories\" [ value ]=\" category \" > {{category.name}} </ mat-option > </ mat-select > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onCleanFilter ()\" > Limpiar </ button > < button mat-stroked-button ( click )=\" onSearch ()\" > Filtrar </ button > </ div > </ div > < div class = \"game-list\" > < app-game-detail * ngFor = \"let game of games; let i = index;\" ( click )=\" editGame ( game )\" [ game ]=\" game \" > </ app-game-detail > </ div > < div class = \"buttons\" > < button mat-flat-button color = \"primary\" ( click )=\" createGame ()\" > Nuevo juego </ button > </ div > </ div > Tambi\u00e9n vamos a necesitar una foto de ejemplo para poder en el detalle de los juegos. Vamos a utilizar esta imagen: Y ya para terminar, implementamos el componente de detalle: game-detail.component.html < div class = \"container\" > < mat-card > < div class = \"photo\" > < img src = \"./assets/foto.png\" > </ div > < div class = \"detail\" > < div class = \"title\" > {{game.title}} </ div > < div class = \"properties\" > < div >< i > Edad recomendada: </ i > +{{game.age}} </ div > < div >< i > Categor\u00eda: </ i > {{game.category.name}} </ div > < div >< i > Autor: </ i > {{game.author.name}} </ div > < div >< i > Nacionalidad: </ i > {{game.author.nationality}} </ div > </ div > </ div > </ mat-card > </ div > game-detail.component.scss . container { display : flex ; width : 325 px ; mat-card { width : 100 % ; margin : 10 px ; display : flex ; .photo { margin-right : 10 px ; img { width : 80 px ; height : 80 px ; } } . detail { .title { font-size : 14 px ; font-weight : bold ; } . properties { font-size : 11 px ; div { height : 15 px ; } } } } } game-detail.component.ts import { Component , OnInit , Input } from '@angular/core' ; import { Game } from 'src/app/models/games/Game' ; @Component ({ selector : 'app-game-detail' , templateUrl : './game-detail.component.html' , styleUrls : [ './game-detail.component.scss' ] }) export class GameDetailComponent implements OnInit { @Input () game : Game ; constructor () { } ngOnInit () : void { } } Ahora si que deber\u00eda quedar algo similar a esta pantalla:","title":"Implementar detalle del item"},{"location":"develop/step5/#implementar-dialogo-de-edicion","text":"Ya solo nos falta el \u00faltimo paso, implementar el cuadro de edici\u00f3n / alta de un nuevo juego. Pero tenemos un peque\u00f1o problema, y es que al crear o editar un juego debemos seleccionar una Categor\u00eda y un Autor . Para la Categor\u00eda no tenemos ning\u00fan problema, pero para el Autor no tenemos un servicio que nos devuelva todos los autores, solo tenemos un servicio que nos devuelve una Page de autores. As\u00ed que lo primero que haremos ser\u00e1 implementar una operaci\u00f3n getAllAuthors para poder recuperar una lista. mock-authors-list.ts import { Author } from 'src/app/models/authors/Author' ; export const AUTHOR_DATA_LIST : Author [] = [ { id : 1 , name : 'Klaus Teuber' , nationality : 'Alemania' }, { id : 2 , name : 'Matt Leacock' , nationality : 'Estados Unidos' }, { id : 3 , name : 'Keng Leong Yeo' , nationality : 'Singapur' }, { id : 4 , name : 'Gil Hova' , nationality : 'Estados Unidos' }, { id : 5 , name : 'Kelly Adams' , nationality : 'Estados Unidos' }, ] mock-authors.ts import { AuthorPage } from 'src/app/models/authors/AuthorPage' ; import { AUTHOR_DATA_LIST } from './mock-authors-list' ; export const AUTHOR_DATA : AuthorPage = { content : AUTHOR_DATA_LIST , pageable : { pageSize : 5 , pageNumber : 0 , sort : [ { property : \"id\" , direction : \"ASC\" } ] }, totalElements : 7 } author.service.ts import { Injectable } from '@angular/core' ; import { Pageable } from 'src/app/models/page/Pageable' ; import { AuthorPage } from 'src/app/models/authors/AuthorPage' ; import { Observable , of } from 'rxjs' ; import { Author } from 'src/app/models/authors/Author' ; import { HttpClient } from '@angular/common/http' ; import { AUTHOR_DATA_LIST } from './mock-authors-list' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor ( private http : HttpClient ) { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return this . http . post < AuthorPage > ( 'http://localhost:8080/author/v1/' , { pageable : pageable }); } saveAuthor ( author : Author ) : Observable < Author > { return this . http . put < Author > ( 'http://localhost:8080/author/v1/' , author ); } deleteAuthor ( idAuthor : number ) : Observable < any > { return this . http . delete ( 'http://localhost:8080/author/v1/' + idAuthor ); } getAllAuthors () : Observable < Author [] > { return of ( AUTHOR_DATA_LIST ); } } Clean Code Acuerdate de lo que hemos comentado antes, siempre debes tener presente el Clean Code . \u00a1No dupliques c\u00f3digo!, es muy importante de cara al futuro mantenimiento. En este caso, en tanto en mock-authors como en mock-authors-list ten\u00edamos un listado de autores. Lo mejor es que no dupliquemos el c\u00f3digo y uno de ellos haga uso del otro. Ahora s\u00ed que tenemos todo listo para implementar el cuadro de dialogo para dar de alta o editar juegos. game-dialog.component.html < div class = \"container\" > < h1 * ngIf = \"game.id == null\" > Crear juego </ h1 > < h1 * ngIf = \"game.id != null\" > Modificar juego </ h1 > < form > < mat-form-field > < mat-label > Identificador </ mat-label > < input type = \"number\" matInput placeholder = \"Identificador\" [( ngModel )]=\" game . id \" name = \"id\" disabled > </ mat-form-field > < mat-form-field > < mat-label > T\u00edtulo </ mat-label > < input type = \"text\" matInput placeholder = \"T\u00edtulo del juego\" [( ngModel )]=\" game . title \" name = \"title\" required > < mat-error > El t\u00edtulo no puede estar vac\u00edo </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Edad recomendada </ mat-label > < input type = \"number\" matInput placeholder = \"Edad recomendada\" [( ngModel )]=\" game . age \" name = \"age\" required > < mat-error > La edad no puede estar vac\u00eda </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Categor\u00eda </ mat-label > < mat-select disableRipple [( ngModel )]=\" game . category \" name = \"category\" required > < mat-option * ngFor = \"let category of categories\" [ value ]=\" category \" > {{category.name}} </ mat-option > </ mat-select > < mat-error > La categor\u00eda no puede estar vac\u00eda </ mat-error > </ mat-form-field > < mat-form-field > < mat-label > Autor </ mat-label > < mat-select disableRipple [( ngModel )]=\" game . author \" name = \"author\" required > < mat-option * ngFor = \"let author of authors\" [ value ]=\" author \" > {{author.name}} </ mat-option > </ mat-select > < mat-error > El autor no puede estar vac\u00edo </ mat-error > </ mat-form-field > </ form > < div class = \"buttons\" > < button mat-stroked-button ( click )=\" onClose ()\" > Cerrar </ button > < button mat-flat-button color = \"primary\" ( click )=\" onSave ()\" > Guardar </ button > </ div > </ div > game-dialog.component.scss . container { min-width : 350 px ; max-width : 500 px ; width : 100 % ; form { display : flex ; flex-direction : column ; margin-bottom : 20 px ; } . buttons { text-align : right ; button { margin-left : 10 px ; } } } game-dialog.component.ts import { Component , OnInit , Inject } from '@angular/core' ; import { MatDialogRef , MAT_DIALOG_DATA } from '@angular/material/dialog' ; import { Game } from 'src/app/models/games/Game' ; import { GameService } from 'src/app/services/games/game.service' ; import { Author } from 'src/app/models/authors/Author' ; import { Category } from 'src/app/models/categories/Category' ; import { AuthorService } from 'src/app/services/authors/author.service' ; import { CategoryService } from 'src/app/services/categories/category.service' ; @Component ({ selector : 'app-game-dialog' , templateUrl : './game-dialog.component.html' , styleUrls : [ './game-dialog.component.scss' ] }) export class GameDialogComponent implements OnInit { game : Game ; authors : Author []; categories : Category []; constructor ( public dialogRef : MatDialogRef < GameDialogComponent > , @Inject ( MAT_DIALOG_DATA ) public data : any , private gameService : GameService , private categoryService : CategoryService , private authorService : AuthorService , ) { } ngOnInit () : void { if ( this . data . game != null ) { this . game = Object . assign ({}, this . data . game ); } else { this . game = new Game (); } this . categoryService . getCategories (). subscribe ( categories => { this . categories = categories ; if ( this . data . game . category != null ) { let categoryFilter : Category [] = categories . filter ( category => category . id == this . data . game . category . id ); if ( categoryFilter != null ) { this . game . category = categoryFilter [ 0 ]; } } } ); this . authorService . getAllAuthors (). subscribe ( authors => { this . authors = authors if ( this . data . game . author != null ) { let authorFilter : Author [] = authors . filter ( author => author . id == this . data . game . author . id ); if ( authorFilter != null ) { this . game . author = authorFilter [ 0 ]; } } } ); } onSave() { this . gameService . saveGame ( this . game ). subscribe ( result => { this . dialogRef . close (); }); } onClose() { this . dialogRef . close (); } } Como puedes ver, para rellenar los componentes seleccionables de dropdown, hemos realizado una consulta al servicio para recuperar todos los autores y categorias, y en la respuesta de cada uno de ellos, hemos buscado en los resultados cual es el que coincide con el ID enviado desde el listado, y ese es el que hemos fijado en el objeto Game . De esta forma, no estamos cogiendo directamente los datos del listado, sino que no estamos asegurando que los datos de autor y de categor\u00eda son los que vienen del servicio, siempre filtrando por su ID.","title":"Implementar dialogo de edici\u00f3n"},{"location":"develop/step5/#desarrollo-springboot","text":"","title":"Desarrollo Springboot"},{"location":"develop/step5/#modelos","text":"Lo primero que vamos a hacer es crear los modelos para trabajar con BBDD y con peticiones hacia el front. Adem\u00e1s, tambi\u00e9n tenemos que a\u00f1adir datos al script de inicializaci\u00f3n de BBDD. V0001__Create_Schema.sql CREATE SEQUENCE HIBERNATE_SEQUENCE START WITH 1000000 ; DROP TABLE IF EXISTS CATEGORY ; CREATE TABLE CATEGORY ( id BIGINT AUTO_INCREMENT PRIMARY KEY , name VARCHAR ( 250 ) NOT NULL ); DROP TABLE IF EXISTS AUTHOR ; CREATE TABLE AUTHOR ( id BIGINT AUTO_INCREMENT PRIMARY KEY , name VARCHAR ( 400 ) NOT NULL , nationality VARCHAR ( 250 ) NOT NULL ); DROP TABLE IF EXISTS GAME ; CREATE TABLE GAME ( id BIGINT AUTO_INCREMENT PRIMARY KEY , title VARCHAR ( 250 ) NOT NULL , age VARCHAR ( 3 ) NOT NULL , category_id BIGINT DEFAULT NULL , author_id BIGINT DEFAULT NULL ); ALTER TABLE GAME ADD FOREIGN KEY ( category_id ) REFERENCES CATEGORY ( id ); ALTER TABLE GAME ADD FOREIGN KEY ( author_id ) REFERENCES AUTHOR ( id ); V0002__Create_Data.sql INSERT INTO CATEGORY ( id , name ) VALUES ( 1 , 'Eurogames' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 2 , 'Ameritrash' ); INSERT INTO CATEGORY ( id , name ) VALUES ( 3 , 'Familiar' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 1 , 'Alan R. Moon' , 'US' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 2 , 'Vital Lacerda' , 'PT' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 3 , 'Simone Luciani' , 'IT' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 4 , 'Perepau Llistosella' , 'ES' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 5 , 'Michael Kiesling' , 'DE' ); INSERT INTO AUTHOR ( id , name , nationality ) VALUES ( 6 , 'Phil Walker-Harding' , 'US' ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 1 , 'On Mars' , '14' , 1 , 2 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 2 , 'Aventureros al tren' , '8' , 3 , 1 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 3 , '1920: Wall Street' , '12' , 1 , 4 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 4 , 'Barrage' , '14' , 1 , 3 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 5 , 'Los viajes de Marco Polo' , '12' , 1 , 3 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 6 , 'Azul' , '8' , 3 , 5 ); INSERT INTO GAME ( id , title , age , category_id , author_id ) VALUES ( 7 , 'Osopark' , '8' , 3 , 6 ); Game.java package com.capgemini.coedevon.tutorial.game.model ; import javax.persistence.Column ; import javax.persistence.Entity ; import javax.persistence.GeneratedValue ; import javax.persistence.GenerationType ; import javax.persistence.Id ; import javax.persistence.JoinColumn ; import javax.persistence.ManyToOne ; import javax.persistence.Table ; import com.capgemini.coedevon.tutorial.author.model.Author ; import com.capgemini.coedevon.tutorial.category.model.Category ; /** * @author coedevon */ @Entity @Table ( name = \"Game\" ) public class Game { @Id @GeneratedValue ( strategy = GenerationType . AUTO ) @Column ( name = \"id\" , nullable = false ) private Long id ; @Column ( name = \"title\" , nullable = false ) private String title ; @Column ( name = \"age\" , nullable = false ) private String age ; @ManyToOne @JoinColumn ( name = \"category_id\" , nullable = false ) private Category category ; @ManyToOne @JoinColumn ( name = \"author_id\" , nullable = false ) private Author author ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return age */ public String getAge () { return this . age ; } /** * @param age new value of {@link #getAge}. */ public void setAge ( String age ) { this . age = age ; } /** * @return category */ public Category getCategory () { return this . category ; } /** * @param category new value of {@link #getCategory}. */ public void setCategory ( Category category ) { this . category = category ; } /** * @return author */ public Author getAuthor () { return this . author ; } /** * @param author new value of {@link #getAuthor}. */ public void setAuthor ( Author author ) { this . author = author ; } } GameDto.java package com.capgemini.coedevon.tutorial.game.model ; import com.capgemini.coedevon.tutorial.author.model.AuthorDto ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; /** * @author coedevon */ public class GameDto { private Long id ; private String title ; private String age ; private CategoryDto category ; private AuthorDto author ; /** * @return id */ public Long getId () { return this . id ; } /** * @param id new value of {@link #getId}. */ public void setId ( Long id ) { this . id = id ; } /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return age */ public String getAge () { return this . age ; } /** * @param age new value of {@link #getAge}. */ public void setAge ( String age ) { this . age = age ; } /** * @return category */ public CategoryDto getCategory () { return this . category ; } /** * @param category new value of {@link #getCategory}. */ public void setCategory ( CategoryDto category ) { this . category = category ; } /** * @return author */ public AuthorDto getAuthor () { return this . author ; } /** * @param author new value of {@link #getAuthor}. */ public void setAuthor ( AuthorDto author ) { this . author = author ; } }","title":"Modelos"},{"location":"develop/step5/#repository","text":"Para esta ocasi\u00f3n, vamos a necesitar un listado filtrado por t\u00edtulo o por categor\u00eda, as\u00ed que necesitaremos pasarle esos datos y filtrar la query. Para el t\u00edtulo vamos a buscar por una cadena contenida, as\u00ed que el par\u00e1metro ser\u00e1 de tipo String , mientras que para la categor\u00eda vamos a buscar por su primary key, as\u00ed que el par\u00e1metro ser\u00e1 de tipo Long . B\u00fasquedas en BBDD Siempre deber\u00edamos buscar a los hijos por primary keys, nunca hay que hacerlo por una descripci\u00f3n libre ya que el usuario podr\u00eda teclear el mismo nombre de diferentes formas y no habr\u00eda manera de buscar correctamente el resultado. As\u00ed que siempre que haya un dropdown, se debe filtrar por su ID. Podr\u00edamos utilizar los QueryMethods para que Spring JPA haga su magia, pero en esta ocasi\u00f3n vamos a hacer una implementaci\u00f3n concreta de este m\u00e9todo de filtrado. Esta implementaci\u00f3n la haremos en un Repository normal, y el resto de m\u00e9todos nos vendr\u00e1n dados por un CrudRepository como hemos hecho hasta ahora. GameRepository.java package com.capgemini.coedevon.tutorial.game ; import org.springframework.data.repository.CrudRepository ; import com.capgemini.coedevon.tutorial.game.model.Game ; /** * @author coedevon */ public interface GameRepository extends CrudRepository < Game , Long > , GameCustomRepository { } GameCustomRepository.java package com.capgemini.coedevon.tutorial.game ; import java.util.List ; import com.capgemini.coedevon.tutorial.game.model.Game ; /** * @author coedevon * */ public interface GameCustomRepository { /** * M\u00e9todo para recuperar todas las {@link com.capgemini.coedevon.tutorial.game.model.Game} filtradas * @param title * @param category * @return */ List < Game > findByFilter ( String title , Long category ); } GameCustomRepositoryImpl.java package com.capgemini.coedevon.tutorial.game ; import java.util.List ; import javax.persistence.EntityManager ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.util.StringUtils ; import com.capgemini.coedevon.tutorial.game.model.Game ; import com.devonfw.module.basic.common.api.query.LikePatternSyntax ; import com.devonfw.module.jpa.dataaccess.api.QueryUtil ; import com.querydsl.core.alias.Alias ; import com.querydsl.jpa.impl.JPAQuery ; /** * @author coedevon * */ public class GameCustomRepositoryImpl implements GameCustomRepository { @Autowired private EntityManager entityManager ; /** * {@inheritDoc} */ public List < Game > findByFilter ( String title , Long category ) { Game alias = Alias . alias ( Game . class ); JPAQuery < Game > query = new JPAQuery < Game > ( this . entityManager ). from ( Alias . $ ( alias )); if ( StringUtils . hasText ( title )) { QueryUtil . get (). whereLike ( query , Alias . $ ( alias . getTitle ()), title , LikePatternSyntax . SQL , true , true ); } if ( category != null ) { query . where ( Alias . $ ( alias . getCategory (). getId ()). eq ( category )); } return query . fetch (); } } No se puede implementar un CrudRepository ya que es una interface que tiene su propia implementaci\u00f3n en Spring JPA. El truco que podemos hacer es crear una interface y una implementaci\u00f3n custom con los m\u00e9todos que necesitemos y en nuestro CrudRepository extender la interface custom. De esta forma \u00fanicamente utilizamos un objeto Repository , pero realmente Spring JPA provee los m\u00e9todos de Crud y nosotros proveemos los m\u00e9todos custom. La implementaci\u00f3n de las queries que hagamos dentro del custom repository ya es cosa nuestra y podemos utilizar lo que necesitemos. En este caso hemos optado por utilizar Criteria para hacer la Query ayud\u00e1ndonos de unas clases de utilidad que provee Devonfw, muy recomendables para hacer queries paginadas.","title":"Repository"},{"location":"develop/step5/#service","text":"Siguiente paso, la capa de l\u00f3gica, es decir el Service . GameService.java package com.capgemini.coedevon.tutorial.game ; import java.util.List ; import com.capgemini.coedevon.tutorial.game.model.Game ; import com.capgemini.coedevon.tutorial.game.model.GameDto ; /** * @author coedevon */ public interface GameService { /** * M\u00e9todo para recuperar todas las {@link com.capgemini.coedevon.tutorial.game.model.Game} filtradas * @param title * @param category * @return */ List < Game > findByFilter ( String title , Long category ); /** * M\u00e9todo para crear o actualizar una {@link com.capgemini.coedevon.tutorial.game.model.Game} * @param dto * @return */ public Game save ( GameDto dto ); } AuthorServiceImpl.java package com.capgemini.coedevon.tutorial.game ; import java.util.List ; import javax.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import com.capgemini.coedevon.tutorial.game.model.Game ; import com.capgemini.coedevon.tutorial.game.model.GameDto ; /** * @author coedevon */ @Service @Transactional public class GameServiceImpl implements GameService { @Autowired GameRepository gameRepository ; /** * {@inheritDoc} */ @Override public List < Game > findByFilter ( String title , Long category ) { return this . gameRepository . findByFilter ( title , category ); } /** * {@inheritDoc} */ @Override public Game save ( GameDto dto ) { Game game = null ; if ( dto . getId () != null ) game = this . gameRepository . findById ( dto . getId ()). orElse ( null ); else game = new Game (); BeanUtils . copyProperties ( dto , game , \"author\" , \"category\" ); //TODO: Setear categoria y autor return this . gameRepository . save ( game ); } } En este Service volvemos a utilizar el List en lugar del Page, y hemos eliminado el m\u00e9todo delete ya que no se pueden borrar juegos. Pero, la novedad est\u00e1 en el save . Si recuerdas, un Game tiene una relaci\u00f3n con Author y otra relaci\u00f3n con Category . Estas relaciones se hacen a nivel de Entity , sin embargo en nuestro dto de entrada al m\u00e9todo GameDto estamos tratando con CategoryDto y AuthorDto . Una soluci\u00f3n podr\u00eda ser convertir esos DTOs a Entity , pero esto podr\u00eda llevar a duplicidades en la cache interna de JPA, as\u00ed que mejor no utilizar esta soluci\u00f3n. Lo correcto es realizar consultas a la BBDD y traernos esas entities. Pero si recuerdas las reglas b\u00e1sicas, un Repository debe pertenecer a un solo Service , por lo que en lugar de llamar a m\u00e9todos de los AuthorRepository y CategoryRepository desde nuestro GameService , debemos llamar a m\u00e9todos expuestos en AuthorService y CategoryService . Para ello necesitaremos crear esos m\u00e9todos get en los otros Services . Quedar\u00eda algo as\u00ed: AuthorService.java package com.capgemini.coedevon.tutorial.author ; import org.springframework.data.domain.Page ; import com.capgemini.coedevon.tutorial.author.model.Author ; import com.capgemini.coedevon.tutorial.author.model.AuthorDto ; import com.capgemini.coedevon.tutorial.author.model.AuthorSearchDto ; /** * @author coedevon * */ public interface AuthorService { /** * Recupera un {@link com.capgemini.coedevon.tutorial.author.model.Author} a trav\u00e9s de su ID * @param id * @return */ Author get ( Long id ); /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param dto * @return */ Page < Author > findPage ( AuthorSearchDto dto ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param data * @return */ Author save ( AuthorDto data ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param id */ void delete ( Long id ); } AuthorServiceImpl.java package com.capgemini.coedevon.tutorial.author ; import javax.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.stereotype.Service ; import com.capgemini.coedevon.tutorial.author.model.Author ; import com.capgemini.coedevon.tutorial.author.model.AuthorDto ; import com.capgemini.coedevon.tutorial.author.model.AuthorSearchDto ; /** * @author coedevon */ @Service @Transactional public class AuthorServiceImpl implements AuthorService { @Autowired AuthorRepository authorRepository ; /** * {@inheritDoc} */ @Override public Author get ( Long id ) { return this . authorRepository . findById ( id ). orElse ( null ); } /** * {@inheritDoc} */ @Override public Page < Author > findPage ( AuthorSearchDto dto ) { return this . authorRepository . findAll ( dto . getPageable ()); } /** * {@inheritDoc} */ @Override public Author save ( AuthorDto data ) { Author categoria = null ; if ( data . getId () != null ) categoria = get ( data . getId ()); else categoria = new Author (); BeanUtils . copyProperties ( data , categoria ); return this . authorRepository . save ( categoria ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) { this . authorRepository . deleteById ( id ); } } CategoryService.java package com.capgemini.coedevon.tutorial.category ; import java.util.List ; import com.capgemini.coedevon.tutorial.category.model.Category ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; /** * @author coedevon * */ public interface CategoryService { /** * Recupera una {@link com.capgemini.coedevon.tutorial.category.model.Category} a partir de su ID * @param id * @return */ Category get ( Long id ); /** * M\u00e9todo para recuperar todas las {@link com.capgemini.coedevon.tutorial.category.model.Category} * @return */ List < Category > findAll (); /** * M\u00e9todo para crear o actualizar una {@link com.capgemini.coedevon.tutorial.category.model.Category} * @param dto * @return */ Category save ( CategoryDto dto ); /** * M\u00e9todo para borrar una {@link com.capgemini.coedevon.tutorial.category.model.Category} * @param id */ void delete ( Long id ); } CategoryServiceImpl.java package com.capgemini.coedevon.tutorial.category ; import java.util.List ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import com.capgemini.coedevon.tutorial.category.model.Category ; import com.capgemini.coedevon.tutorial.category.model.CategoryDto ; /** * @author coedevon * */ @Service public class CategoryServiceImpl implements CategoryService { @Autowired CategoryRepository categoryRepository ; /** * {@inheritDoc} */ @Override public Category get ( Long id ) { return this . categoryRepository . findById ( id ). orElse ( null ); } /** * {@inheritDoc} */ @Override public List < Category > findAll () { return ( List < Category > ) this . categoryRepository . findAll (); } /** * {@inheritDoc} */ @Override public Category save ( CategoryDto dto ) { Category categoria = null ; if ( dto . getId () != null ) categoria = get ( dto . getId ()); else categoria = new Category (); BeanUtils . copyProperties ( dto , categoria ); return this . categoryRepository . save ( categoria ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) { this . categoryRepository . deleteById ( id ); } } Clean Code A la hora de implementar m\u00e9todos nuevos, ten siempre presente el Clean Code . \u00a1No dupliques c\u00f3digo!, es muy importante de cara al futuro mantenimiento. Si en nuestro m\u00e9todo save hac\u00edamos uso de una operaci\u00f3n findById y ahora hemos creado una nueva operaci\u00f3n get , hagamos uso de esta nueva operaci\u00f3n y no repitamos el c\u00f3digo. Y ahora ya podemos implementar correctamente nuestro Service . GameServiceImpl.java package com.capgemini.coedevon.tutorial.game ; import java.util.List ; import javax.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Service ; import com.capgemini.coedevon.tutorial.author.AuthorService ; import com.capgemini.coedevon.tutorial.author.model.Author ; import com.capgemini.coedevon.tutorial.category.CategoryService ; import com.capgemini.coedevon.tutorial.category.model.Category ; import com.capgemini.coedevon.tutorial.game.model.Game ; import com.capgemini.coedevon.tutorial.game.model.GameDto ; /** * @author coedevon */ @Service @Transactional public class GameServiceImpl implements GameService { @Autowired GameRepository gameRepository ; @Autowired AuthorService authorService ; @Autowired CategoryService categoryService ; /** * {@inheritDoc} */ @Override public List < Game > findByFilter ( String title , Long category ) { return this . gameRepository . findByFilter ( title , category ); } /** * {@inheritDoc} */ @Override public Game save ( GameDto dto ) { Game game = null ; if ( dto . getId () != null ) game = this . gameRepository . findById ( dto . getId ()). orElse ( null ); else game = new Game (); BeanUtils . copyProperties ( dto , game , \"author\" , \"category\" ); Author author = this . authorService . get ( dto . getAuthor (). getId ()); game . setAuthor ( author ); Category category = this . categoryService . get ( dto . getCategory (). getId ()); game . setCategory ( category ); return this . gameRepository . save ( game ); } }","title":"Service"},{"location":"develop/step5/#controller","text":"Despu\u00e9s de todo este mareo, ya podemos terminar ocn la \u00faltima capa. Vamos a implementar el Controller para que ataque a la capa de Service , con los endpoints de las operaciones que vamos a publicar. Adem\u00e1s, para realizar la b\u00fasqueda necesitaremos un nuevo DTO como ya vimos en el ejemplo del listado paginado. GameController.java package com.capgemini.coedevon.tutorial.game ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.coedevon.tutorial.config.mapper.BeanMapper ; import com.capgemini.coedevon.tutorial.game.model.GameDto ; import com.capgemini.coedevon.tutorial.game.model.GameSearchDto ; /** * @author coedevon */ @RequestMapping ( value = \"/game/v1\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class GameController { @Autowired GameService gameService ; @Autowired BeanMapper beanMapper ; /* * M\u00e9todo para recuperar todos los {@link com.capgemini.coedevon.tutorial.game.model.Game} filtrados * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . POST ) public List < GameDto > findByFilter ( @RequestBody GameSearchDto dto ) { return this . beanMapper . mapList ( this . gameService . findByFilter ( dto . getTitle (), dto . getCategoryId ()), GameDto . class ); } /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.game.model.Game} * @param dto * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . PUT ) public GameDto save ( @RequestBody GameDto dto ) { return this . beanMapper . map ( this . gameService . save ( dto ), GameDto . class ); } } GameSearchDto.java package com.capgemini.coedevon.tutorial.game.model ; /** * @author coedevon */ public class GameSearchDto { private String title ; private Long categoryId ; /** * @return title */ public String getTitle () { return this . title ; } /** * @param title new value of {@link #getTitle}. */ public void setTitle ( String title ) { this . title = title ; } /** * @return categoryId */ public Long getCategoryId () { return this . categoryId ; } /** * @param categoryId new value of {@link #getcategoryId}. */ public void setCategoryId ( Long categoryId ) { this . categoryId = categoryId ; } } Pues con esto ya tendr\u00edamos todas las consultas de Game implementadas. Ahora solo falta probarlas.","title":"Controller"},{"location":"develop/step5/#prueba-de-las-operaciones","text":"Si ahora levantamos la aplicaci\u00f3n y probamos con el postman, podemos ver los resultados que nos ofrece el back. POST nos devuelve un listado paginado de Juegos , f\u00edjate bien en la petici\u00f3n donde env\u00edamos los filtros y la respuesta que tiene los objetos Categoria y Autor inclu\u00eddos. PUT nos sirve para insertar Juegos nuevos (si no tienen el id informado) o para actualizar Juegos (si tienen el id informado). F\u00edjate que para enlazar Categoria y Autor tan solo hace falta el id de cada no de ellos, ya que en el m\u00e9todo save se hace una consulta get para recuperarlos por su id. Adem\u00e1s que no tendr\u00eda sentido enviar toda la informaci\u00f3n de esas entidades ya que no est\u00e1s dando de alta una Categoria ni un Autor .","title":"Prueba de las operaciones"},{"location":"develop/step5/#implementar-listado-autores","text":"Como hemos visto anteriormente en la parte de frontend, para la edici\u00f3n de un Juego nos hace falta un m\u00e9todo que devuelva un listado de Autores , ya que ahora mismo la operaci\u00f3n que tenemos implementada devuelve un objeto Page . As\u00ed que antes de finalizar la implementaci\u00f3n de backend, vamos a desarrollar esta nueva operaci\u00f3n. Por supuesto, respetaremos las operaciones previas que ya exist\u00edan. AuthorController.java package com.capgemini.coedevon.tutorial.author ; import java.util.List ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.web.bind.annotation.CrossOrigin ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestBody ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.RequestMethod ; import org.springframework.web.bind.annotation.RestController ; import com.capgemini.coedevon.tutorial.author.model.AuthorDto ; import com.capgemini.coedevon.tutorial.author.model.AuthorSearchDto ; import com.capgemini.coedevon.tutorial.config.mapper.BeanMapper ; /** * @author coedevon */ @RequestMapping ( value = \"/author/v1\" ) @RestController @CrossOrigin ( origins = \"*\" ) public class AuthorController { @Autowired AuthorService authorService ; @Autowired BeanMapper beanMapper ; /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param dto * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . GET ) public List < AuthorDto > list () { return this . beanMapper . mapList ( this . authorService . list (), AuthorDto . class ); } /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param dto * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . POST ) public Page < AuthorDto > findPage ( @RequestBody AuthorSearchDto dto ) { return this . beanMapper . mapPage ( this . authorService . findPage ( dto ), AuthorDto . class ); } /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param data datos de la entidad * @return */ @RequestMapping ( path = \"/\" , method = RequestMethod . PUT ) public AuthorDto save ( @RequestBody AuthorDto data ) { return this . beanMapper . map ( this . authorService . save ( data ), AuthorDto . class ); } /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param id PK de la entidad */ @RequestMapping ( path = \"/{id}\" , method = RequestMethod . DELETE ) public void delete ( @PathVariable ( \"id\" ) Long id ) { this . authorService . delete ( id ); } } AuthorService.java package com.capgemini.coedevon.tutorial.author ; import java.util.List ; import org.springframework.data.domain.Page ; import com.capgemini.coedevon.tutorial.author.model.Author ; import com.capgemini.coedevon.tutorial.author.model.AuthorDto ; import com.capgemini.coedevon.tutorial.author.model.AuthorSearchDto ; /** * @author coedevon * */ public interface AuthorService { /** * Recupera un {@link com.capgemini.coedevon.tutorial.author.model.Author} a trav\u00e9s de su ID * @param id * @return */ Author get ( Long id ); /** * M\u00e9todo para recuperar un listado paginado de {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param dto * @return */ Page < Author > findPage ( AuthorSearchDto dto ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param data * @return */ Author save ( AuthorDto data ); /** * M\u00e9todo para crear o actualizar un {@link com.capgemini.coedevon.tutorial.author.model.Author} * @param id */ void delete ( Long id ); /** * M\u00e9todo para recuperar un listado completo de {@link com.capgemini.coedevon.tutorial.author.model.Author} * @return */ List < Author > list (); } AuthorServiceImpl.java package com.capgemini.coedevon.tutorial.author ; import java.util.List ; import javax.transaction.Transactional ; import org.springframework.beans.BeanUtils ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.data.domain.Page ; import org.springframework.stereotype.Service ; import com.capgemini.coedevon.tutorial.author.model.Author ; import com.capgemini.coedevon.tutorial.author.model.AuthorDto ; import com.capgemini.coedevon.tutorial.author.model.AuthorSearchDto ; /** * @author coedevon */ @Service @Transactional public class AuthorServiceImpl implements AuthorService { @Autowired AuthorRepository authorRepository ; /** * {@inheritDoc} */ @Override public Author get ( Long id ) { return this . authorRepository . findById ( id ). orElse ( null ); } /** * {@inheritDoc} */ @Override public Page < Author > findPage ( AuthorSearchDto dto ) { return this . authorRepository . findAll ( dto . getPageable ()); } /** * {@inheritDoc} */ @Override public Author save ( AuthorDto data ) { Author categoria = null ; if ( data . getId () != null ) categoria = get ( data . getId ()); else categoria = new Author (); BeanUtils . copyProperties ( data , categoria ); return this . authorRepository . save ( categoria ); } /** * {@inheritDoc} */ @Override public void delete ( Long id ) { this . authorRepository . deleteById ( id ); } /** * {@inheritDoc} */ @Override public List < Author > list () { return ( List < Author > ) this . authorRepository . findAll (); } } Ahora s\u00ed, todo listo para seguir al siguiente punto.","title":"Implementar listado Autores"},{"location":"develop/step5/#conectar-front-con-back","text":"Una vez implementado front y back, lo que nos queda es modificar el servicio del front para que conecte directamente con las operaciones ofrecidas por el back. author-service.ts import { Injectable } from '@angular/core' ; import { Pageable } from 'src/app/models/page/Pageable' ; import { AuthorPage } from 'src/app/models/authors/AuthorPage' ; import { Observable , of } from 'rxjs' ; import { Author } from 'src/app/models/authors/Author' ; import { HttpClient } from '@angular/common/http' ; @Injectable ({ providedIn : 'root' }) export class AuthorService { constructor ( private http : HttpClient ) { } getAuthors ( pageable : Pageable ) : Observable < AuthorPage > { return this . http . post < AuthorPage > ( 'http://localhost:8080/author/v1/' , { pageable : pageable }); } saveAuthor ( author : Author ) : Observable < Author > { return this . http . put < Author > ( 'http://localhost:8080/author/v1/' , author ); } deleteAuthor ( idAuthor : number ) : Observable < any > { return this . http . delete ( 'http://localhost:8080/author/v1/' + idAuthor ); } getAllAuthors () : Observable < Author [] > { return this . http . get < Author [] > ( 'http://localhost:8080/author/v1/' ); } } game-service.ts import { Injectable } from '@angular/core' ; import { Game } from 'src/app/models/games/Game' ; import { Observable , of } from 'rxjs' ; import { HttpClient } from '@angular/common/http' ; @Injectable ({ providedIn : 'root' }) export class GameService { constructor ( private http : HttpClient ) { } getGames ( title? : String , categoryId? : number ) : Observable < Game [] > { let data = { title : title != null ? title : null , categoryId : categoryId != null ? categoryId : null }; return this . http . post < Game [] > ( 'http://localhost:8080/game/v1/' , data ); } saveGame ( game : Game ) : Observable < Game > { return this . http . put < Game > ( 'http://localhost:8080/game/v1/' , game ); } }","title":"Conectar front con back"},{"location":"develop/step6/","text":"Validaciones Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n. Validaciones en Angular Validaciones en Springboot","title":"Code: Validaciones"},{"location":"develop/step6/#validaciones","text":"Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n.","title":"Validaciones"},{"location":"develop/step6/#validaciones-en-angular","text":"","title":"Validaciones en Angular"},{"location":"develop/step6/#validaciones-en-springboot","text":"","title":"Validaciones en Springboot"},{"location":"develop/step7/","text":"Seguridad Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n.","title":"Code: Crear Login"},{"location":"develop/step7/#seguridad","text":"Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n.","title":"Seguridad"},{"location":"develop/step8/","text":"Tests Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n.","title":"Code: Testing"},{"location":"develop/step8/#tests","text":"Atenci\u00f3n Esta secci\u00f3n est\u00e1 incompleta y todav\u00eda en desarrollo. Puedes leerla pero seguramente cambiar\u00e1 o ampliar\u00e1 su informaci\u00f3n.","title":"Tests"}]}