{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenido!","text":"<p>Si est\u00e1s leyendo esto es porque tienes mucha fuerza de voluntad y unas enormes ganas de aprender a desarrollar con el stack tecnol\u00f3gico de CCA (Java Spring Boot, Nodejs, Angular) o porque te han mandando hacer este tutorial en tu etapa de formaci\u00f3n. En cualquier caso, te agradecemos el esfuerzo que est\u00e1s haciendo y te deseamos suerte .</p> <p>Por favor, si detectas que hay algo incorrecto en el tutorial, que no funciona o que est\u00e1 mal escrito, contacta con nosotros para que podamos solventarlo para futuras lecturas. Escr\u00edbenos un issue aqu\u00ed.</p>"},{"location":"#que-vamos-a-hacer","title":"\u00bfQue vamos a hacer?","text":"<p>Durante este tutorial, vamos a crear una aplicaci\u00f3n web paso a paso con Spring Boot o Nodejs para la parte servidora y con Angular para la parte frontal. Intentar\u00e9 comentar todo lo m\u00e1s detallado posible, pero si echas en falta alguna explicaci\u00f3n por favor, escr\u00edbenos un issue aqu\u00ed para que podamos a\u00f1adirla.</p>"},{"location":"#como-lo-vamos-a-hacer","title":"\u00bfComo lo vamos a hacer?","text":"<p>En primer lugar te comentar\u00e9 brevemente las herramientas que usaremos en el tutorial y la forma de instalarlas (altamente recomendado). Luego veremos un vistazo general de lo que vamos a construir para que tengas un contexto general de la aplicaci\u00f3n. Y por \u00faltimo desarrollaremos paso a paso el backend y el frontend de la aplicaci\u00f3n.</p> <p>Durante todo el tutorial intentar\u00e9 dar unas pautas y consejos de buenas pr\u00e1cticas que todos deber\u00edamos adoptar, en la medida de lo posible, para homogeneizar el desarrollo de todos los proyectos.</p> <p>Adem\u00e1s para cada uno de los cap\u00edtulos que lo requieran, voy a desdoblar el tutorial por cada una de las tecnolog\u00edas disponibles para que vayas construyendo con la que m\u00e1s c\u00f3modo te sientas. </p> <p>As\u00ed que antes de empezar debes elegir bien con que tecnolog\u00edas vas a comenzar de las que tengo disponibles. Puedes volver a este tutorial m\u00e1s adelante por si he ido a\u00f1adiendo nuevas tecnolog\u00edas. </p>"},{"location":"#hay-pre-requisitos","title":"\u00bfHay pre-requisitos?","text":"<p>No es obligado tener ning\u00fan conocimiento previo, pero es altamente recomendable que al menos conozcas lo b\u00e1sico de las tecnolog\u00edas que vamos a ver en el tutorial. Te sugiero que visites los itinerarios formativos de aquellas tecnolog\u00edas que quieras aprender y al menos hacer los cursos de nivel \"Esencial\". De momento tengo estas:</p> <ul> <li>\ud83d\udd35 Frontend - Angular</li> <li>\ud83d\udfe2 Backend - Springboot</li> <li>\ud83d\udfe2 Backend - Nodejs</li> </ul> <p>Una vez hayas hecho los cursos esenciales, ya puedes volver y continuar con este tutorial. Repito que no es obligado, si ya tienes conocimientos previos de las tecnolog\u00edas no es necesario que hagas los cursos.</p>"},{"location":"#y-luego-que","title":"\u00bfY luego qu\u00e9?","text":"<p>Pues al final del tutorial, expondremos unos ejercicios pr\u00e1cticos para que los resuelvas tu mismo, aplicando los conocimientos adquiridos en el tutorial. Para ver si has comprendido correctamente todo lo aqu\u00ed descrito.</p> <p>No te preocupes, no es un examen </p>"},{"location":"#recomendaciones","title":"Recomendaciones","text":"<p>Te recomiendo que leas todo el tutorial, que no te saltes ning\u00fan punto y si se hace referencia a los anexos, que los visites y los leas tambi\u00e9n. Si tan solo copias y pegas, no ser\u00e1s capaz de hacer el \u00faltimo ejercicio por ti mismo. Debes leer y comprender lo que se est\u00e1 haciendo.</p> <p>Adem\u00e1s, los anexos est\u00e1n ah\u00ed por algo, sirven para completar informaci\u00f3n y para que conozcas los motivos por los que estamos programando as\u00ed el tutorial. Por favor, \u00e9chales un ojo tambi\u00e9n cuando te lo indique.</p>"},{"location":"#por-ultimo-no-te-olvides","title":"Por \u00faltimo, \u00a1no te olvides!","text":"<p>Cuando lo tengas todo listo, por favor no te olvides de subir los proyectos a alg\u00fan repositorio Github propio y av\u00edsanos para que podamos echarle un ojo y darte sugerencias y feedback .</p>"},{"location":"exercise/","title":"Ahora hazlo tu!","text":"<p>Ahora vamos a ver si has comprendido bien el tutorial. Voy a poner dos ejercicios uno m\u00e1s sencillo que el otro para ver si eres capaz de llevarlos a cabo. \u00a1Vamos alla, mucha suerte!</p> <p>Nuestro amigo Ernesto Esvida ya tiene disponible su web para gestionar su cat\u00e1logo de juegos, autores y categor\u00edas, pero todav\u00eda le falta un poco m\u00e1s para poder hacer buen uso de su ludoteca. As\u00ed que nos ha pedido dos funcionalidades extra.</p>"},{"location":"exercise/#gestion-de-clientes","title":"Gesti\u00f3n de clientes","text":""},{"location":"exercise/#requisitos","title":"Requisitos","text":"<p>Por un lado necesita poder tener una base de datos de sus clientes. Para ello nos ha pedido que si podemos crearle una pantalla de CRUD sencilla, al igual que hicimos con las categor\u00edas donde \u00e9l pueda dar de alta a sus clientes.</p> <p>Nos ha pasado un esquema muy sencillo de lo que quiere, tan solo quiere guardar un listado de los nombres de sus clientes para tenerlos fichados, y nos ha hecho un par de pantallas sencillas muy similares a Categor\u00edas.</p> <p></p> <p></p> <p>Un listado sin filtros de ning\u00fan tipo ni paginaci\u00f3n.</p> <p>Un formulario de edici\u00f3n / alta, cuyo \u00fanico dato editable sea el nombre. Adem\u00e1s, la \u00fanica restricci\u00f3n que nos ha pedido es que NO podamos dar de alta a un cliente con el mismo nombre que otro existente. As\u00ed que deberemos comprobar el nombre, antes de guardar el cliente.</p>"},{"location":"exercise/#consejos","title":"Consejos","text":"<p>Para empezar te dar\u00e9 unos consejos:</p> <ul> <li>Recuerda crear la tabla de la BBDD y sus datos</li> <li>Intenta primero hacer el listado completo, en el orden que m\u00e1s te guste: frontend o backend.</li> <li>Completa el listado conectando ambas capas.</li> <li>Termina el caso de uso haciendo las funcionalidades de edici\u00f3n, nuevo y borrado. Presta atenci\u00f3n a la validaci\u00f3n a la hora de guardar un cliente, NO se puede guardar si el nombre ya existe.</li> </ul>"},{"location":"exercise/#gestion-de-prestamos","title":"Gesti\u00f3n de pr\u00e9stamos","text":""},{"location":"exercise/#requisitos_1","title":"Requisitos","text":"<p>Por otro lado, quiere hacer uso de su cat\u00e1logo de juegos y de sus clientes, y quiere saber que juegos ha prestado a cada cliente. Para ello nos ha pedido una p\u00e1gina bastante compleja donde se podr\u00e1 consultar diferente informaci\u00f3n y se permitir\u00e1 realizar el pr\u00e9stamo de los juegos.</p> <p>Nos ha pasado el siguiente boceto y requisitos:</p> <p></p> <p>La pantalla tendr\u00e1 dos zonas:</p> <ul> <li>Una zona de filtrado donde se permitir\u00e1 filtrar por:<ul> <li>T\u00edtulo del juego, que deber\u00e1 ser un combo seleccionable con los juegos del cat\u00e1logo de la Ludoteca.</li> <li>Cliente, que deber\u00e1 ser un combo seleccionable con los clientes dados de alta en la aplicaci\u00f3n.</li> <li>Fecha, que deber\u00e1 ser de tipo Datepicker y que permitir\u00e1 elegir una fecha de b\u00fasqueda. Al elegir un d\u00eda nos deber\u00e1 mostrar que juegos est\u00e1n prestados para dicho d\u00eda. OJO que los pr\u00e9stamos son con fecha de inicio y de fin, si elijo un d\u00eda intermedio deber\u00eda aparecer el elemento en la tabla.</li> </ul> </li> <li>Una zona de listado paginado que deber\u00e1 mostrar<ul> <li>El identificador del pr\u00e9stamo</li> <li>El nombre del juego prestado</li> <li>El nombre del cliente que lo solicit\u00f3</li> <li>La fecha de inicio del pr\u00e9stamo</li> <li>La fecha de fin del pr\u00e9stamo</li> <li>Un bot\u00f3n que permite eliminar el pr\u00e9stamo</li> </ul> </li> </ul> <p></p> <p>Al pulsar el bot\u00f3n de <code>Nuevo pr\u00e9stamo</code> se abrir\u00e1 una pantalla donde se podr\u00e1 ingresar la siguiente informaci\u00f3n, toda ella obligatoria:</p> <ul> <li>Identificador, inicialmente vac\u00edo y en modo lectura</li> <li>Nombre del cliente, mediante un combo seleccionable</li> <li>Nombre del juego, mediante un combo seleccionable</li> <li>Fechas del pr\u00e9stamo, donde se podr\u00e1 introducir dos fechas, de inicio y fin del pr\u00e9stamo.</li> </ul> <p>Las validaciones son sencillas aunque laboriosas:</p> <ul> <li>La fecha de fin NO podr\u00e1 ser anterior a la fecha de inicio</li> <li>El periodo de pr\u00e9stamo m\u00e1ximo solo podr\u00e1 ser de 14 d\u00edas. Si el usuario quiere un pr\u00e9stamo para m\u00e1s de 14 d\u00edas la aplicaci\u00f3n no debe permitirlo mostrando una alerta al intentar guardar.</li> <li>El mismo juego no puede estar prestado a dos clientes distintos en un mismo d\u00eda. OJO que los pr\u00e9stamos tienen fecha de inicio y fecha fin, el juego no puede estar prestado a m\u00e1s de un cliente para ninguno de los d\u00edas que contemplan las fechas actuales del rango.</li> <li>Un mismo cliente no puede tener prestados m\u00e1s de 2 juegos en un mismo d\u00eda. OJO que los pr\u00e9stamos tienen fecha de inicio y fecha fin, el cliente no puede tener m\u00e1s de dos pr\u00e9stamos para ninguno de los d\u00edas que contemplan las fechas actuales del rango.</li> </ul>"},{"location":"exercise/#consejos_1","title":"Consejos","text":"<p>Para empezar te dar\u00e9 unos consejos:</p> <ul> <li>Recuerda crear la tabla de la BBDD y sus datos</li> <li>Intenta primero hacer el listado paginado sin filtros, en el orden que m\u00e1s te guste: frontend o backend. Recuerda que se trata de un listado paginado, as\u00ed que deber\u00e1s utilizar el obtejo <code>Page</code>.</li> <li>Completa el listado conectando ambas capas.</li> <li>Ahora implementa los filtros, presta atenci\u00f3n al filtro de fecha, es el m\u00e1s complejo.</li> <li>Para la paginaci\u00f3n filtrada solo tienes que mezclar los conceptos que hemos visto en los puntos del tutorial anteriores. <ul> <li>Si hiciste el backend en Springboot recuerda revisar Baeldung por si tienes dudas sobre las queries y recuerda que las <code>Specifications</code> son muy \u00fatiles, pero en este caso deber\u00e1s implementar otro tipo de operaciones, no te sirve solo con la operaci\u00f3n de igualdad <code>:</code>, que ya vimos en el tutorial.</li> </ul> </li> <li>Implementa la pantalla de alta de pr\u00e9stamo, sin ninguna validaci\u00f3n.</li> <li>Cuando ya te funcione, intenta ir a\u00f1adiendo una a una las validaciones. Algunas de ellas pueden hacerse en frontend, mientras que otras deber\u00e1n validarse en backend</li> </ul>"},{"location":"exercise/#ya-has-terminado","title":"\u00bfYa has terminado?","text":"<p>Si has llegado a este punto es porque ya tienes terminado el tutorial. Por favor no te olvides de subir los proyectos a alg\u00fan repositorio Github propio (puedes revisar el anexo Tutorial b\u00e1sico de Git) y av\u00edsarnos para que podamos echarle un ojo y darte sugerencias y feedback .</p>"},{"location":"thanks/","title":"Agradecimientos!","text":"<p>Antes de empezar quer\u00edamos dar las gracias a todos los que hab\u00e9is participado de manera directa o indirecta en la elaboraci\u00f3n de este tutorial, y a todos aquellos que lo hab\u00e9is sufrido haciendolo. </p> <p>De verdad</p> <pre><code>                                G R A C I A S\n</code></pre>"},{"location":"thanks/#colaboradores","title":"Colaboradores","text":"<p>Menci\u00f3n especial a las personas que han participado en el tutorial ya sea como testers, como promotores o como desarrolladores, por orden temporal de colaboraci\u00f3n:</p> <ul> <li>Felipe Garcia (@fgarciafer)</li> <li>Armen Mirzoyan (@armirzoya)</li> <li>Carlos Aguilar (@caaguila)</li> <li>Jhonatan Core (@corevill)</li> <li>Carlos Navarro (@DarkWarlord)</li> <li>Cesar Cardona (@Cazs03)</li> <li>Marina Valls (@mvalemany)</li> <li>Jaume Segarra (@jaumesegarra)</li> <li>Laura Medina (@larulirea)</li> <li>Yolanda Ubeda</li> <li>Pablo Jimenez (@pajimene)</li> </ul>"},{"location":"usecases/","title":"Contexto de la aplicaci\u00f3n","text":""},{"location":"usecases/#introduccion","title":"Introducci\u00f3n","text":"<p>Nuestro amigo Ernesto Esvida es muy aficionado a los juegos de mesa y desde muy peque\u00f1o ha ido coleccionando muchos juegos. Hasta tal punto que ha decidido regentar una Ludoteca.</p> <p>Como la colecci\u00f3n de juegos era suya personal, toda la informaci\u00f3n del cat\u00e1logo de juegos la ten\u00eda perfectamente clasificado en fichas de cart\u00f3n. Pero ahora que va abrir su propio negocio, necesita digitalizar esa informaci\u00f3n y hacerla m\u00e1s accesible.</p> <p>Como es un buen amigo de la infancia, hemos decidido ayudar a Ernesto y colaborar haciendo una peque\u00f1a aplicaci\u00f3n web que le sirva de cat\u00e1logo de juegos. Es m\u00e1s o menos el mismo sistema que estaba utilizando, pero esta vez en digital.</p> <p>Por cierto, la Ludoteca al final se va a llamar Ludoteca T\u00e1n.</p> <p>Info</p> <p>Las im\u00e1genes que aparecen a continuaci\u00f3n son mockups o dise\u00f1os de alambre de las pantallas que vamos a desarrollar durante el tutorial. No quiere decir que el estilo final de las pantallas deba ser as\u00ed, ni mucho menos. Es simplemente una forma sencilla de ejemplificar como debe quedar m\u00e1s o menos una pantalla.</p>"},{"location":"usecases/#estructura-de-un-proyecto-web","title":"Estructura de un proyecto Web","text":"<p>En todas las aplicaciones web modernas y los proyectos en los que trabajamos se pueden diferenciar, de forma general, tres grandes bloques funcionales, como se muestra en la imagen inferior.</p> <p></p> <p>El funcionamiento es muy sencillo y difiere de las aplicaciones instalables que se ejecuta todo en una misma m\u00e1quina o servidor.</p> <ul> <li>Con esta estructura, el usuario accede a la aplicaci\u00f3n mediante un navegador web instalado en su m\u00e1quina local.</li> <li>Este navegador solicita informaci\u00f3n mediante una URL a un servidor de recursos est\u00e1ticos. Esto es lo que denominaremos un servidor frontend. Para programar servidores frontend se pueden usar muchas tecnolog\u00edas, en este tutorial lo desarrollaremos en Angular. Este c\u00f3digo frontend se descarga y se ejecuta dentro del navegador, y contiene la representaci\u00f3n visual de las pantallas y ciertos comportamientos y navegaci\u00f3n entre componentes. Sin embargo, por lo general, no tiene datos ni ejecuta l\u00f3gica de negocio.</li> <li>Para estas labores de obtener datos o ejecutar l\u00f3gica de negocio, el c\u00f3digo frontend necesita invocar endpoints de la segunda capa, el backend. Al igual que antes, el backend, puede estar desarrollado en muchas tecnolog\u00edas, en este tutorial se puede elegir entre Java-Springboot o Nodejs. Lo importante de esta capa es que es necesario exponer unos endpoints que sean invocados por la capa de frontend. T\u00edpicamente estos endpoints son operaciones API Rest que veremos m\u00e1s adelante.</li> <li>Por \u00faltimo, el servidor backend / capa backend, necesitar\u00e1 leer y guardar datos de alg\u00fan sitio. Esto se hace utilizando la tercera capa, la capa de datos. Normalmente esta capa de datos ser\u00e1 una BBDD instalada en alg\u00fan servidor externo, aunque a veces como es el caso del tutorial de Springboot, podemos embeber el servidor en memoria de backend. Pero por norma general, esta capa es externa.</li> </ul> <p>As\u00ed pues el flujo normal de una aplicaci\u00f3n ser\u00eda el siguiente:</p> <ul> <li>El usuario abre el navegador y solicita una web mediante una URL</li> <li>El servidor frontend, le sirve los recursos (p\u00e1ginas web, javascript, im\u00e1genes, ...) y se cargan en el navegador</li> <li>El navegador renderiza las p\u00e1ginas web, ejecuta los procesos javascript y realiza las navegaciones</li> <li>Si en alg\u00fan momento se requiere invocar una operaci\u00f3n, el navegador lanzar\u00e1 una petici\u00f3n contra una URL del backend</li> <li>El backend estar\u00e1 escuchando las peticiones y las ejecutar\u00e1 en el momento que le invoquen devulviendo un resultado al navegador</li> <li>Si hiciera falta leer o guardar datos, el backend lo realizar\u00e1 lanzando consultas SQL contra la BBDD</li> </ul> <p>Dicho esto, por lo general necesitaremos un m\u00ednimo de dos proyectos para desarrollar una aplicaci\u00f3n: </p> <ul> <li> <p>Por un lado tendremos un proyecto Frontend que se ejecutar\u00e1 en un servidor web de ficheros est\u00e1ticos, tipo Apache. Este proyecto ser\u00e1 c\u00f3digo javascript, css y html, que se renderizar\u00e1 en el navegador Web y que realizar\u00e1 ciertas operaciones sencillas y validaciones en local y llamadas a nuestro servidor backend para ejecutar las operaciones de negocio.</p> </li> <li> <p>Por otro lado tendremos un proyecto Backend que se ejecutar\u00e1 en un servidor de aplicaciones, tipo Tomcat o Node. Este proyecto tendr\u00e1 la l\u00f3gica de negocio de las operaciones, el acceso a los datos de la BBDD y cualquier integraci\u00f3n con servicios de terceros. La forma de exponer estas operaciones de negocio ser\u00e1 mediante endpoints de acceso, en concreto llamadas tipo REST.</p> </li> </ul> <p>Pueden haber otros tipos de proyectos dentro de la aplicaci\u00f3n, sobretodo si est\u00e1n basados en microservicios o tienen componentes batch, pero estos proyectos no vamos a verlos en el tutorial.</p> <p>A partir de ahora, para que sea m\u00e1s sencillo acceder al tutorial, diferenciaremos las tecnolog\u00edas en el men\u00fa mediante los siguientes colores:</p> <ul> <li>\ud83d\udd35 Frontend</li> <li>\ud83d\udfe2 Backend</li> </ul> <p>Consejo</p> <p>Como norma cada uno de los proyectos que componen la aplicaci\u00f3n, deber\u00eda estar conectado a un repositorio de c\u00f3digo diferente para poder evolucionar y trabajar con cada uno de ellos de forma aislada sin afectar a los dem\u00e1s. As\u00ed adem\u00e1s podemos tener equipos aislados que trabajen con cada uno de los proyectos por separado.</p> <p>Info</p> <p>Durante todo el tutorial, voy a intentar separar la construcci\u00f3n del proyecto Frontend de la construcci\u00f3n del proyecto Backend. Elige una tecnolog\u00eda para cada una de las capas y utiliza siempre la misma en todos los apartados del tutorial.</p>"},{"location":"usecases/#diseno-de-bd","title":"Dise\u00f1o de BD","text":"<p>Para el proyecto que vamos a crear vamos a modelizar y gestionar 3 entidades: <code>GAME</code>, <code>CATEGORY</code> y <code>AUTHOR</code>.</p> <p>Para la entidad <code>GAME</code>, Ernesto nos ha comentado que la informaci\u00f3n que est\u00e1 guardando en sus fichas es la siguiente:</p> <ul> <li>id (este dato no estaba originalmente en las fichas pero nos ser\u00e1 muy util para indexar y realizar b\u00fasquedas)</li> <li>title</li> <li>age</li> <li>category</li> <li>author</li> </ul> <p>La entidad <code>CATEGORY</code> estar\u00e1 compuesta por los siguientes campos:</p> <ul> <li>id (lo mismo que en <code>GAME</code>)</li> <li>name</li> </ul> <p>La entidad <code>AUTHOR</code> estar\u00e1 compuesta por los siguientes campos:</p> <ul> <li>id (lo mismo que en <code>GAME</code>)</li> <li>name</li> <li>nationality</li> </ul> <p>Comenzaremos con un caso b\u00e1sico que cumpla las siguientes premisas: un juego pertenece a una categor\u00eda y ha sido creado por un \u00fanico autor. </p> <p>Modelando este contexto quedar\u00eda algo similar a esto:</p> <p></p>"},{"location":"usecases/#diseno-de-pantallas","title":"Dise\u00f1o de pantallas","text":"<p>Deber\u00edamos construir tres pantallas de mantenimiento CRUD (Create, Read, Update, Delete) y una pantalla de Login general para activar las acciones de administrador. M\u00e1s o menos las pantallas deber\u00edan quedar as\u00ed:</p>"},{"location":"usecases/#listado-de-juegos","title":"Listado de juegos","text":""},{"location":"usecases/#edicion-de-juego","title":"Edici\u00f3n de juego","text":""},{"location":"usecases/#listado-de-categorias","title":"Listado de categor\u00edas","text":""},{"location":"usecases/#edicion-de-categoria","title":"Edici\u00f3n de categor\u00eda","text":""},{"location":"usecases/#listado-de-autores","title":"Listado de autores","text":""},{"location":"usecases/#edicion-de-autor","title":"Edici\u00f3n de autor","text":""},{"location":"usecases/#pantalla-de-login","title":"Pantalla de Login","text":""},{"location":"usecases/#diseno-funcional","title":"Dise\u00f1o funcional","text":"<p>Por \u00faltimo vamos a definir un poco la funcionalidad b\u00e1sica que Ernesto necesita para iniciar su negocio.</p>"},{"location":"usecases/#aspectos-generales","title":"Aspectos generales","text":"<ul> <li>El sistema tan solo tendr\u00e1 dos roles:    <code>usuario b\u00e1sico</code> es el usuario an\u00f3nimo que accede a la web sin registrar. Solo tiene permisos para mostrar listados    <code>usuario administrador</code> es el usuario que se registra en la aplicaci\u00f3n. Puede realizar las operaciones de alta, edici\u00f3n y borrado</li> </ul> <p>Por defecto cuando entras en la aplicaci\u00f3n tendr\u00e1s los privilegios de un <code>usuario b\u00e1sico</code> hasta que el usuario haga un login correcto con el usuario / password <code>admin</code> / <code>admin</code>. En ese momento pasara a ser un <code>usuario administrador</code> y podr\u00e1 realizar operaciones de alta, baja y modificaci\u00f3n.</p> <p>La estructura general de la aplicaci\u00f3n ser\u00e1:</p> <ul> <li>Una cabecer\u00e1 superior que contendr\u00e1:</li> <li>el logo y el nombre de la tienda</li> <li>un enlace a cada uno de los CRUD del sistema</li> <li>un bot\u00f3n de <code>Sign in</code></li> <li>Zona de trabajo, donde cargaremos las pantallas que el usuario vaya abriendo</li> </ul> <p>Al pulsar sobre la funcionalidad de <code>Sign in</code> aparecer\u00e1 una ventana modal que preguntar\u00e1 usuario y password. Esto realizar\u00e1 una llamada al backend, donde se validar\u00e1 si el usuario es correcto. </p> <ul> <li>En caso de ser correcto, devolver\u00e1 un token jwt de acceso, que el cliente web deber\u00e1 guardar en <code>sessionStorage</code> para futuras peticiones</li> <li>En caso de no ser correcto, devolver\u00e1 un error de Usuario y/o password incorrectos</li> </ul> <p>Todas las operaciones del backend que permitan crear, modificar o borrar datos, deber\u00e1n estar securizadas para que no puedan ser accedidas sin haberse autenticado previamente.</p>"},{"location":"usecases/#crud-de-juegos","title":"CRUD de Juegos","text":"<p>Al acceder a esta pantalla se mostrar\u00e1 un listado de los juegos disponibles en el cat\u00e1logo de la BD. Esta tabla debe contener filtros en la parte superior, pero no debe estar paginada.</p> <p>Se debe poder filtrar por:</p> <ul> <li>nombre del juego. Donde el usuario podr\u00e1 poner cualquier texto y el filtrado ser\u00e1 todos aquellos juegos que <code>contengan</code> el texto buscado</li> <li>categor\u00eda del juego. Donde aparecer\u00e1 un desplegable que el usuario seleccionar de entre todas las categor\u00edas de juego que existan en la BD.</li> </ul> <p>Dos botones permitir\u00e1n realizar el filtrado de juegos (lanzando una nueva consulta a BD) o limpiar los filtros seleccionados (lanzando una consulta con los filtros vac\u00edos).</p> <p>En la tabla debe aparecer a modo de fichas. No hace falta que sea exactamente igual a la maqueta, no es un requisito determinar un ancho general de ficha por lo que pueden caber 2,3 o x fichas en una misma fila, depender\u00e1 del programador. Pero todas las fichas deben tener el mismo ancho:</p> <ul> <li>Un espacio destinado a una foto (de momento no pondremos nada en ese espacio)</li> <li>Una columna con la siguiente informaci\u00f3n:<ul> <li>T\u00edtulo del juego, resaltado de alguna forma</li> <li>Edad recomendada</li> <li>Categor\u00eda del juego, mostraremos su nombre</li> <li>Autor del juego, mostraremos su nombre</li> <li>Nacionalidad del juego, mostraremos la nacionalidad del autor del juego</li> </ul> </li> </ul> <p>Los juegos no se pueden eliminar, pero si se puede editar si el usuario pulsa en alguna de las fichas (solo en el caso de que el usuario tenga permisos).</p> <p>Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevos juegos (solo en el caso de que el usuario tenga permisos).</p> <p>Crear</p> <p>Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con cinco inputs:</p> <ul> <li>Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de <code>Identificador</code></li> <li>T\u00edtulo. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de <code>T\u00edtulo</code></li> <li>Edad. Este input es obligatorio, es de tipo num\u00e9rico de 0 a 99, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de <code>Edad</code></li> <li>Categor\u00eda. Este input es obligatorio, ser\u00e1 un campo seleccionable donde aparecer\u00e1n todas las categor\u00edas de la BD, aparecer\u00e1 vac\u00edo por defecto. Con el placeholder de <code>Categor\u00eda</code></li> <li>Autor. Este input es obligatorio, ser\u00e1 un campo seleccionable donde aparecer\u00e1n todos los autores de la BD, aparecer\u00e1 vac\u00edo por defecto. Con el placeholder de <code>Autor</code></li> </ul> <p>Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. </p> <p>Editar</p> <p>Al pulsar en una de las fichas con un click simple, se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de <code>Crear</code> pero con los cinco campos rellenados con los datos de BD.</p>"},{"location":"usecases/#crud-de-categorias","title":"CRUD de Categor\u00edas","text":"<p>Al acceder a esta pantalla se mostrar\u00e1 un listado de las categor\u00edas que tenemos en la BD. La tabla no tiene filtros, puesto que tiene muy pocos registros. Tampoco estar\u00e1 paginada.</p> <p>En la tabla debe aparecer:</p> <ul> <li>identificador de la categor\u00eda</li> <li>nombre de la categor\u00eda</li> <li>bot\u00f3n de editar (solo en el caso de que el usuario tenga permisos)</li> <li>bot\u00f3n de borrar (solo en el caso de que el usuario tenga permisos)</li> </ul> <p>Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevas categor\u00edas (solo en el caso de que el usuario tenga permisos).</p> <p>Crear</p> <p>Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con dos inputs:</p> <ul> <li>Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de <code>Identificador</code></li> <li>Nombre. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de <code>Nombre</code></li> </ul> <p>Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD.</p> <p>Editar</p> <p>Al pulsar el icono de editar se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de <code>Crear</code> pero con los dos campos rellenados con los datos de BD.</p> <p>Borrar</p> <p>Si el usuario pulsa el bot\u00f3n de borrar, se deber\u00e1 comprobar si esa categor\u00eda tiene alg\u00fan <code>Juego</code> asociado. En caso de tenerlo se le informar\u00e1 al usuario de que dicha categor\u00eda no se puede eliminar por tener asociado un juego. En caso de no estar asociada, se le preguntar\u00e1 al usuario mediante un mensaje de confirmaci\u00f3n si desea eliminar la categor\u00eda. Solo en caso de que la respuesta sea afirmativa, se lanzar\u00e1 el borrado f\u00edsico de la categor\u00eda en BD.</p>"},{"location":"usecases/#crud-de-autores","title":"CRUD de Autores","text":"<p>Al acceder a esta pantalla se mostrar\u00e1 un listado de los autores que tenemos en la BD. La tabla no tiene filtros pero deber\u00e1 estar paginada en servidor.</p> <p>En la tabla debe aparecer:</p> <ul> <li>identificador del autor</li> <li>nombre del autor</li> <li>nacionalidad del autor</li> <li>bot\u00f3n de editar (solo en el caso de que el usuario tenga permisos)</li> <li>bot\u00f3n de borrar (solo en el caso de que el usuario tenga permisos)</li> </ul> <p>Debajo de la tabla aparecer\u00e1 un bot\u00f3n para crear nuevos autores (solo en el caso de que el usuario tenga permisos).</p> <p>Crear</p> <p>Al pulsar el bot\u00f3n de crear se deber\u00e1 abrir una ventana modal con tres inputs:</p> <ul> <li>Identificador. Este input deber\u00e1 ser de solo lectura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de <code>Identificador</code></li> <li>Nombre. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de <code>Nombre</code></li> <li>Nacionalidad. Este input es obligatorio, ser\u00e1 de escritura y deber\u00e1 aparecer vac\u00edo, sin ning\u00fan valor. Con el placeholder de <code>Nacionalidad</code></li> </ul> <p>Todos los datos obligatorios se deber\u00e1n comprobar que son v\u00e1lidos antes de guardarlo en BD. Dos botones en la parte inferior de la ventana permitir\u00e1n al usuario cerrar la ventana o guardar los datos en la BD. </p> <p>Editar</p> <p>Al pulsar el icono de editar se deber\u00e1 abrir una ventana modal utilizando el mismo componente que la ventana de <code>Crear</code> pero con los tres campos rellenados con los datos de BD.</p> <p>Borrar</p> <p>Si el usuario pulsa el bot\u00f3n de borrar, se deber\u00e1 comprobar si ese autor tiene alg\u00fan <code>Juego</code> asociado. En caso de tenerlo se le informar\u00e1 al usuario de que dicho autor no se puede eliminar por tener asociado un juego. En caso de no estar asociado, se le preguntar\u00e1 al usuario mediante un mensaje de confirmaci\u00f3n si desea eliminar el autor. Solo en caso de que la respuesta sea afirmativa, se lanzar\u00e1 el borrado f\u00edsico de la categor\u00eda en BD.</p>"},{"location":"appendix/git/","title":"Tutorial b\u00e1sico de Git","text":"<p>Cada vez se tiende m\u00e1s a utilizar repositorios de c\u00f3digo Git y, aunque no sea objeto de este tutorial Springboot-Angular, queremos hacer un resumen muy b\u00e1sico y sencillo de como utilizar Git.</p> <p>En el mercado existen multitud de herramientas para gestionar repositorios Git, podemos utilizar cualquiera de ellas, aunque desde devonfw se recomienda utilizar Git SCM. Adem\u00e1s, existen tambi\u00e9n multitud de servidores de c\u00f3digo que implementan repositorios Git, como podr\u00edan ser GitHub, GitLab, Bitbucket, etc. Todos ellos trabajan de la misma forma, as\u00ed que este resumen servir\u00e1 para todos ellos.</p> <p>Info</p> <p>Este anexo muestra un resumen muy sencillo y b\u00e1sico de los comandos m\u00e1s comunes que se utilizan en Git. Para ver detalles m\u00e1s avanzados o un tutorial completo te recomiendo que leas la guia de Atlassian.</p>"},{"location":"appendix/git/#funcionamiento-basico","title":"Funcionamiento b\u00e1sico","text":"<p>Existen dos conceptos en Git que debes tener muy claros: las ramas y los repositorios. Vamos a ver como funciona cada uno de ellos.</p>"},{"location":"appendix/git/#ramas","title":"Ramas","text":"<p>Por un lado tenemos las <code>ramas</code> de Git. El repositorio puede tener tantas ramas como se quiera, pero por lo general debe existir una rama maestra a menudo llamada develop o master, y luego muchas ramas con cada una de las funcionalidades desarrolladas.</p> <p></p> <p>Las ramas siempre se deben crear a partir de una rama (en el ejemplo llamaremos develop), con una foto concreta y determinada de esa rama. Esta rama deber\u00e1 tener un nombre que describa lo que va a contener esa rama (en el ejemplo feature/xxx). Y por lo general, esa rama se <code>mergear\u00e1</code> con otra rama del repositorio, que puede ser la rama de origen o cualquier otra (en el ejemplo ser\u00e1 con la rama origen develop).</p> <p>As\u00ed pues, podemos tener algo as\u00ed:</p> <p></p> <p>Las acciones de crear ramas y mergear ramas est\u00e1n explicadas m\u00e1s abajo. En este punto solo es necesario que seas conocedor de:</p> <ul> <li>existen ramas maestras --&gt; que contienen el c\u00f3digo completo de la aplicaci\u00f3n</li> <li>existen ramas de desarrollo --&gt; que generalmente se crean de una rama maestra en un punto temporal concreto</li> <li>en alg\u00fan momento esas ramas de desarrollo se deben mergear en una rama maestra</li> <li>ojo cuidado, cuando hay varias personas en el equipo trabajando, habr\u00e1n varias ramas de desarrollo que nazcan de diferentes puntos temporales y que habr\u00e1 que tener en cuenta para posibles conflictos. Recuerda que no est\u00e1s solo programando, hay m\u00e1s gente modificando el c\u00f3digo.</li> </ul>"},{"location":"appendix/git/#repositorios","title":"Repositorios","text":"<p>El otro concepto que debe queda claro, es el de repositorios. Por defecto, en Git, se trabaja con el repositorio local, en el que puedes crear ramas, modificar c\u00f3digo, mergear, etc. pero todos esos cambios que se hagan, ser\u00e1n todos en local, nadie m\u00e1s tendr\u00e1 acceso.</p> <p>Tambi\u00e9n existe el repositorio remoto, tambi\u00e9n llamado <code>origin</code>. Este repositorio es el que todos los integrantes del equipo utilizan como referencia. Existen acciones de Git que permite sincronizar los repositorios.</p> <p></p> <p>En este punto solo es necesario que seas conocedor de:</p> <ul> <li>Los cambios que realices en local (en tu repositorio local) solo ser\u00e1n visibles por ti. Puedes crear ramas y borrarlas, pero solo tu las ver\u00e1s.</li> <li>Los cambios que se suban al repositorio remoto ser\u00e1n visibles para todos. Pueden haber ramas protegidas para que no se puedan modificar desde el equipo, t\u00edpicamente las ramas maestras. Estas ramas solo pueden modificarse previa validaci\u00f3n y <code>pull request</code> o <code>merge request</code> (depende de la aplicaci\u00f3n usada para Git).</li> <li>Existen acciones que permiten subir tus cambios de local a remoto. Recuerda que pueden existir ramas protegidas.</li> <li>Existen acciones que permiten actualizar tus ramas locales con los cambios remotos.</li> <li>Recuerda que no trabajas solo, es posible que tu repositorio local no est\u00e9 sincronizado, tus compa\u00f1eros han podido subir c\u00f3digo y deber\u00edas sincronizarte frecuentemente.</li> </ul>"},{"location":"appendix/git/#acciones-mas-tipicas","title":"Acciones m\u00e1s t\u00edpicas","text":"<p>En la Gu\u00eda r\u00e1pida puedes ver m\u00e1s detalle de estas acciones pero por lo general:</p> <ul> <li>Lo primero es descargarse una copia del repositorio con todas sus ramas. Se descargar\u00eda de remoto a local. A partir de este momento se trabaja en local.</li> <li>Cada nueva funcionalidad deber\u00eda tener su rama asociada, por tanto, lo l\u00f3gico es crear una rama de desarrollo (t\u00edpicamente feature/xxx) a partir de una rama maestra (t\u00edpicamente develop o master).</li> <li>Se trabajar\u00eda de forma local con esa rama. Es buena pr\u00e1ctica que si llevas mucho tiempo con la rama creada, de vez en cuando, sincronices tu repositorio local con lo que exista en el repositorio remoto. Adem\u00e1s, como es posible que la rama maestra de la que part\u00eda haya cambiado, esos cambios deber\u00edas llevarlos tambi\u00e9n a tu rama en desarrollo. Con esto consigues que tu punto temporal sea m\u00e1s moderno y tengas menos conflictos. Recuerda que no est\u00e1s solo trabajando.</li> <li>Cuando lo tengas listo y antes de subir nada, deber\u00edas realizar una \u00faltima sincronizaci\u00f3n de remoto a local. Despu\u00e9s deber\u00edas hacer un merge de tus ramas locales de desarrollo con las ramas maestras locales de las que partieron, por los posibles cambios que alguien hubiera podido subir.</li> <li>Por \u00faltimo, una vez tengas todo actualizado, ya puedes subir el c\u00f3digo al repositorio remoto (tu rama de desarrollo), y solicitar un <code>pull request</code> o <code>merge request</code> contra la rama maestra que quieras modificar.</li> <li>Alguien, diferente a ti, debe revisar esa solicitud y aprobarla antes de que se realice todo el merge correcto en remoto. Y vuelta a empezar.</li> </ul>"},{"location":"appendix/git/#funcionamiento-avanzado","title":"Funcionamiento avanzado","text":"<p>A continuaci\u00f3n vamos a describir estos mismos conceptos y acciones que hemos visto, pero m\u00e1s en profundidad para que veas como trabaja internamente Git. No es necesario que leas este punto, aunque es recomendable.</p>"},{"location":"appendix/git/#estructuras-y-flujo-de-trabajo","title":"Estructuras y flujo de trabajo","text":"<p>Lo primero que debes conocer de Git es su funcionamiento b\u00e1sico de flujo de trabajo. Tu repositorio local est\u00e1 compuesto por tres \"estructuras\" que contienen los archivos y los cambios de los ficheros del repositorio. </p> <p></p> <ul> <li>Working directory - Contiene los archivos con los que est\u00e1s trabajando localmente.</li> <li>Staging Area - Es un \u00e1rea intermedia donde vamos a\u00f1adiendo ficheros para ir agrupando modificaciones.</li> <li>Local Repository - Es el repositorio local donde tendr\u00e9mos el registro de todos los commits que hemos realizado. Por defecto apunta a HEAD que es el \u00faltimo commit registrado.</li> </ul> <p>Existen operaciones que nos permiten a\u00f1adir o borrar ficheros dentro de cada una de las estructuras desde otra estructura.</p> <p></p> <p>As\u00ed pues, los comandos b\u00e1sicos dentro de nuestro repositorio local son los siguientes.</p>"},{"location":"appendix/git/#add-y-commmit","title":"add y commmit","text":"<p>Puedes registrar los cambios realizados en tu <code>working directory</code> y a\u00f1adirlos al <code>staging area</code> usando el comando</p> <p><pre><code>git add &lt;filename&gt;\n</code></pre>     o si quieres a\u00f1adir todos los ficheros modificados <pre><code>git add .\n</code></pre></p> <p>Este es el primer paso en el flujo de trabajo b\u00e1sico. Una vez tenemos los cambios registrados en el <code>staging area</code> podemos hacer un commit y persistirlos dentro del <code>local repository</code> mediante el comando</p> <pre><code>git commit -m \"&lt;Commit message&gt;\"\n</code></pre> <p>A partir de ese momento, los ficheros modificados y a\u00f1adidos al <code>local repository</code> se han persistido y se han a\u00f1adido a tu <code>HEAD</code>, aunque todav\u00eda siguen estando el local, no lo has enviado a ning\u00fan repositorio remoto.</p>"},{"location":"appendix/git/#reset","title":"reset","text":"<p>De la misma manera que se han a\u00f1adido ficheros a <code>staging area</code> o a <code>local repository</code>, podemos retirarlos de estas estructuras y volver a recuperar los ficheros que ten\u00edamos anteriormente en el <code>working directory</code>. Por ejemplo, si nos hemos equivocado al incluir ficheros en un commit o simplemente queremos deshacer los cambios que hemos realizado bastar\u00eda con lanzar el comando</p> <p><pre><code>git reset --hard\n</code></pre>     o si queremos volver a un commit concreto <pre><code>git reset &lt;COMMIT&gt;\n</code></pre></p>"},{"location":"appendix/git/#trabajo-con-ramas","title":"Trabajo con ramas","text":"<p>Para complicarlo todo un poco m\u00e1s, el trabajo con git siempre se realiza mediante ramas. Estas ramas nos sirven para desarrollar funcionalidades aisladas unas de otras y poder hacer mezclas de c\u00f3digo de unas ramas a otras. Las ramas m\u00e1s comunes dentro de git suelen ser:</p> <ul> <li>master Esta ser\u00e1 la rama que contenga el c\u00f3digo fuente que tenemos en <code>producci\u00f3n</code>.</li> <li>release Esta ser\u00e1 la rama que contenga el c\u00f3digo fuente de cada una de las entregas parciales, no tiene porqu\u00e9 coincidir con la rama <code>master</code>.</li> <li>develop Esta ser\u00e1 la rama que contenga el c\u00f3digo fuente estable que est\u00e1 actualmente en desarrollo.</li> <li>feature/xxxx Estas ser\u00e1nn la rama que contengan el c\u00f3digo fuente de desarrollo de cada una de las funcionalidades. Generalmente estas ramas las crea cada desarrollador, las mantiene en local, hasta que las sube a remoto para realizar un <code>merge</code> a la rama <code>develop</code>.</li> </ul> <p>Siempre que trabajes con ramas debes tener en cuenta que al empezar tu desarrollo debes partir de una versi\u00f3n actualizada de la rama <code>develop</code>, y al terminar tu desarrollo debes solicitar un <code>merge</code> contra <code>develop</code>, para que tu funcionalidad est\u00e9 incorporada en la rama de desarrollo.</p> <p></p>"},{"location":"appendix/git/#crear-ramas","title":"Crear ramas","text":"<p>Crear ramas en local es tan sencillo como ejecutar este comando:</p> <pre><code>git checkout -b &lt;NOMBRE_RAMA&gt;\n</code></pre> <p>Eso nos crear\u00e1 una rama con el nombre que le hayamos dicho y mover\u00e1 el <code>Working Directory</code> a dicha rama.</p>"},{"location":"appendix/git/#cambiar-de-rama","title":"Cambiar de rama","text":"<p>Para cambiar de una rama a otra en local tan solo debemos ejecutar el comando:</p> <pre><code>git checkout &lt;NOMBRE_RAMA&gt;\n</code></pre> <p>La rama debe existir, sino se quejar\u00e1 de que no encuentra la rama. Este comando nos mover\u00e1 el <code>Working Directory</code> a la rama que le hayamos indicado. Si tenemos cambios en el <code>Staging Area</code> que no hayan sido movidos al <code>Local Repository</code> NO nos permitir\u00e1 movernos a la rama ya que perder\u00edamos los cambios. Antes de poder movernos debemos <code>resetear</code> los cambios o bien <code>commitearlos</code>.</p>"},{"location":"appendix/git/#remote-repository","title":"Remote repository","text":"<p>Hasta aqu\u00ed es todo m\u00e1s o menos sencillo, trabajamos con nuestro repositorio local, creamos ramas, commiteamos o reseteamos cambios de c\u00f3digo, pero todo esto lo hacemos en local. Ahora necesitamos que esos cambios se distribuyan y puedan leerlos el resto de integrantes de nuestro equipo.</p> <p>Aqu\u00ed es donde entra en juego los repositorios remotos.</p> <p></p> <p>Aqu\u00ed debemos tener MUY en cuenta que el c\u00f3digo que vamos a publicar en remoto SOLO es posible publicarlo desde el <code>Local Repository</code>. Es decir que para poder subir c\u00f3digo a remote antes debemos a\u00f1adirlo a <code>Staging Area</code> y hacer un commit para persistirlo en el <code>Local Repository</code>.</p>"},{"location":"appendix/git/#clone","title":"clone","text":"<p>Antes de empezar a tocar c\u00f3digo del proyecto podemos crear un <code>Local Repository</code> vac\u00edo o bien bajarnos un proyecto que ya exista en un <code>Remote Repository</code>. Esta \u00faltima opci\u00f3n es la m\u00e1s normal.</p> <p>Para bajarnos un proyecto desde remoto tan solo hay que ejecutar el comando:</p> <pre><code>git clone &lt;REMOTE_URL&gt;\n</code></pre> <p>Esto te crear\u00e1 una carpeta con el nombre del proyecto y dentro se descargar\u00e1 la estructura completa del repositorio y te mover\u00e1 al <code>Working Directory</code> todo el c\u00f3digo de la rama por defecto para ese repositorio.</p>"},{"location":"appendix/git/#envio-de-cambios","title":"env\u00edo de cambios","text":"<p>El env\u00edo de datos a un <code>Remote Repository</code> tan solo es posible realizarlo desde <code>Local Repository</code> (por lo que antes deber\u00e1s commitear cambios all\u00ed), y se debe ejecutar el comando:</p> <pre><code>git push origin\n</code></pre>"},{"location":"appendix/git/#actualizar-y-fusionar","title":"actualizar y fusionar","text":"<p>En ocasiones (bastante habitual) ser\u00e1 necesario descargarse los cambios de un <code>Remote Repository</code> para poder trabajar con la \u00faltima versi\u00f3n. Para ello debemos ejecutar el comando:</p> <pre><code>git pull\n</code></pre> <p>El propio <code>git</code> realizar\u00e1 la fusi\u00f3n local del c\u00f3digo remoto con el c\u00f3digo de tu <code>Working Directory</code>. Pero en ocasiones, si se ha modificado el mismo fichero en remoto y en local, se puede producir un Conflicto. No pasa nada, tan solo tendr\u00e1s que abrir dicho fichero en conflicto y resolverlo manualmente dejando el c\u00f3digo mezclado correcto.</p> <p>Tambi\u00e9n es posible que el c\u00f3digo que queramos actualizar est\u00e9 en otra rama, si lo que necesitamos es fusionar el c\u00f3digo de otra rama con la rama actual, nos situaremos en la rama destino y ejecutaremos el comando:</p> <pre><code>git merge &lt;RAMA_ORIGEN&gt;\n</code></pre> <p>Esto har\u00e1 lo mismo que un pull en local y fusionar\u00e1 el c\u00f3digo de una rama en otra. Tambi\u00e9n es posible que se produzcan conflictos que deber\u00e1s resolver de forma manual.</p>"},{"location":"appendix/git/#merge-request","title":"Merge Request","text":"<p>Ya por \u00faltimo, como estamos trabajando con ramas, lo \u00fanico que hacemos es subir y bajar ramas, pero en alg\u00fan momento alguien debe fusionar el contenido de una rama en la rama <code>develop</code>, <code>release</code> o <code>master</code>, que son las ramas principales.</p> <p>Se podr\u00eda directamente usar el comando merge para eso, pero en la mayor\u00eda de los repositorios no esta permitido subir el c\u00f3digo de una rama principal, por lo que no podr\u00e1s hacer un merge y subirlo. Para eso existe otra opci\u00f3n que es la de <code>Merge Request</code>.</p> <p>Esta opci\u00f3n permite a un usuario solicitar que otro usuario verifique y valide que el c\u00f3digo de su rama es correcto y lo puede fusionar en <code>Remote Repository</code> con una rama principal. Al ser una operaci\u00f3n delicada, tan solo es posible ejecutarla a trav\u00e9s de la web del repositorio git. </p> <p></p> <p>Por lo general existir\u00e1 una opci\u00f3n / bot\u00f3n que permitir\u00e1 hacer un <code>Merge Request</code> con una rama origen y una rama destino (generalmente una de las principales). A esa petici\u00f3n se le asignar\u00e1 un validador y se enviar\u00e1. El usuario validador verificar\u00e1 si es correcto o no y validar\u00e1 o rechazar\u00e1 la petici\u00f3n. En caso de validarla se fusionar\u00e1 autom\u00e1ticamente en remoto y todos los usuarios podr\u00e1n descargar los nuevos cambios desde la rama.</p> <p>\u00a1Cuidado!</p> <p>Siempre antes de solicitar un <code>Merge Request</code> debes comprobar que tienes actualizada la rama comparandola con la rama remota que queremos mergear, en nuestro ejemplo ser\u00e1 <code>develop</code>. </p> <p>Para actualizarla tu rama hay que seguir tres pasos muy sencillos:</p> <ul> <li>Cambias a la rama <code>develop</code> y descargarnos los cambios del repositorio remoto (git pull)</li> <li>Cambias a tu rama y ejecutar un merge desde <code>develop</code> hacia nuestra rama (git merge develop)</li> <li>Subes tus cambios a remoto (git add, git commit y git push) y ya puedes solcitar el <code>Merge Request</code></li> </ul>"},{"location":"appendix/git/#guia-rapida","title":"Gu\u00eda r\u00e1pida","text":"<p>Los pasos b\u00e1sicos de utilizaci\u00f3n de git son sencillos.</p> <p></p> <ul> <li>Primero nos bajamos el repositorio o lo creamos en local mediante los comandos <pre><code>git clone\n    o \ngit init\n</code></pre></li> <li>Una vez estamos trabajando con nuestro repositorio local, cada vez que vayamos a comenzar una funcionalidad nueva, debemos crear una rama nueva siempre partiendo desde una rama maestra mediante el comando: (en nuestro ejemplo la rama maestra ser\u00e1 <code>develop</code>) <pre><code>git checkout -b &lt;rama&gt;\n</code></pre></li> <li>Cuando tengamos implementados los cambios que queremos realizar, hay que subirlos al staging y luego persistirlos en nuestro repositorio local. Esto lo hacemos con el comando <pre><code>git add .\ngit commit -m \"&lt;Commit message&gt;\"\n</code></pre></li> <li>Siempre antes de subir los cambios al repositorio remoto, hay que comprobar que tenemos actualizada nuestra rama comparandola con la rama remota que queremos mergear, en nuestro ejemplo ser\u00e1 <code>develop</code>. Por tanto tenemos que cambiar a la rama <code>develop</code>, descargarnos los cambios del repositorio remoto, volver a cambiar a nuestra rama y ejecutar un merge desde <code>develop</code> hacia nuestra rama, ejecutando estos comandos <pre><code>git checkout develop\ngit pull\ngit checkout &lt;rama&gt;\ngit merge develop\n</code></pre></li> <li>Ahora que ya tenemos actualizadas las ramas, tan solo nos basta subir nuestra rama a remoto, con el comando <pre><code>git push --set-upstream origin &lt;rama&gt;\n</code></pre></li> <li>Por \u00faltimo accedemos al cliente web del repositorio y solicitamos un <code>merge request</code> contra <code>develop</code>. Para que sea validado y aprobado por otro compa\u00f1ero del equipo.</li> <li>Si en alg\u00fan momento necesitamos modificar nuestro c\u00f3digo del <code>merge request</code> antes de que haya sido aprobado, nos basta con repetir los pasos anteriores <pre><code>git add .\ngit commit -m \"&lt;Commit message&gt;\"\ngit push origin\n</code></pre></li> <li>Una vez hayamos terminado el desarrollo y vayamos a empezar una nueva funcionalidad, volveremos al punto 2 de este listado y comenzaremos de nuevo los comando. Debemos recordad que tenemos que partir siempre de la rama <code>develop</code> y adem\u00e1s debe estar actualizada <code>git pull</code>.</li> </ul>"},{"location":"appendix/jpa/","title":"Funcionamiento Spring Data","text":"<p>Este anexo no pretende explicar el funcionamiento interno de Spring Data, simplemente conocer un poco como utilizarlo y algunos peque\u00f1os tips que pueden ser interesantes.</p>"},{"location":"appendix/jpa/#funcionamiento-basico","title":"Funcionamiento b\u00e1sico","text":"<p>Lo primero que deber\u00edas tener claro, es que hagas lo que hagas, al final todo termina lanzando una query nativa sobre la BBDD. Da igual que uses cualquier tipo de acelerador (luego veremos alguno), ya que al final Spring Data termina convirtiendo lo que hayas programado en una query nativa.</p> <p>Cuanta m\u00e1s informaci\u00f3n le proporciones a Spring Data, tendr\u00e1s m\u00e1s control sobre la query final, pero m\u00e1s dificil ser\u00e1 de mantener. Lo mejor es utilizar, siempre que se pueda, todos los automatismos y automagias posibles y dejar que Spring haga su faena. Habr\u00e1 ocasiones en que esto no nos sirva, en ese momento tendremos que decidir si queremos bajar el nivel de implementaci\u00f3n o queremos utilizar otra alternativa como procesos por streams.</p>"},{"location":"appendix/jpa/#derived-query-methods","title":"Derived Query Methods","text":"<p>Para la realizaci\u00f3n de consultas a la base de datos, Spring Data nos ofrece un sencillo mecanismo que consiste en crear definiciones de m\u00e9todos con una sintaxis especifica, para luego traducirlas autom\u00e1ticamente a consultas nativas, por parte de Spring Data.</p> <p>Esto es muy \u00fatil, ya que convierte a la aplicaci\u00f3n en agn\u00f3sticos de la tecnolog\u00eda de BBDD utilizada y podemos migrar con facilidad entre las muchas soluciones disponibles en el mercado, delegando esta tarea en Spring.</p> <p>Esta es la opci\u00f3n m\u00e1s indicada en la mayor\u00eda de los casos, siempre que puedas deber\u00edas utilizar esta forma de realizar las consultas. Como parte negativa, en algunos casos en consultas m\u00e1s complejas la definici\u00f3n de los m\u00e9todos puede extenderse demasiado dificultando la lectura del c\u00f3digo.</p> <p>De esto tenemos alg\u00fan ejemplo por el tutorial, en el repositorio de GameRepository.</p> <p>Siguiendo el ejemplo del tutorial, si tuvieramos que recuperar los <code>Game</code> por el nombre del juego, se podr\u00eda crear un m\u00e9todo en el <code>GameRepository</code> de esta forma:</p> <pre><code>List&lt;Game&gt; findByName(String name);\n</code></pre> <p>Spring Data entender\u00eda que quieres recuperar un listado de <code>Game</code> que est\u00e1n filtrados por su propiedad <code>Name</code> y generar\u00eda la consulta SQL de forma autom\u00e1tica, sin tener que implementar nada.</p> <p>Se pueden contruir muchos m\u00e9todos diferentes, te recomiendo que leas un peque\u00f1o tutorial de Baeldung y profundices con la documentaci\u00f3n oficial donde podr\u00e1s ver todas las opciones.</p>"},{"location":"appendix/jpa/#anotacion-query","title":"Anotaci\u00f3n @Query","text":"<p>Otra forma de realizar consultas, esta vez menos autom\u00e1tica y m\u00e1s cercana a SQL, es la anotaci\u00f3n @Query.</p> <p>Existen dos opciones a la hora de usar la anotaci\u00f3n <code>@Query</code>. Esta anotaci\u00f3n ya la hemos usado en el tutorial, dentro del GameRepository.</p> <p>En primer lugar tenemos las consultas JPQL. Estas guardan un parecido con el lenguaje SQL pero al igual que en el caso anterior, son traducidas por Spring Data a la consulta final nativa. Su uso no est\u00e1 recomendado ya que estamos a\u00f1adiendo un nivel de concreci\u00f3n y por tanto estamos aumentando la complejidad del c\u00f3digo. Aun as\u00ed, es otra forma de generar consultas.</p> <p>Por otra parte, tambi\u00e9n es posible generar consultas nativas directamente dentro de esta anotaci\u00f3n interactuando de forma directa con la base de datos. Esta pr\u00e1ctica es altamente desaconsejable ya que crea acoplamientos con la tecnolog\u00eda de la BBDD utilizada y es una fuente de errores.</p> <p>Puedes ver m\u00e1s informaci\u00f3n de esta anotaci\u00f3n desde este peque\u00f1o tutorial de Baeldung.</p>"},{"location":"appendix/jpa/#acelerando-las-consultas","title":"Acelerando las consultas","text":"<p>En muchas ocasiones necesitamos obtener informaci\u00f3n que no est\u00e1 en una \u00fanica tabla por motivos de dise\u00f1o de la base de datos. Debemos plasmar esta casu\u00edstica con cuidado a nuestro modelo relacional para obtener resultados \u00f3ptimos en cuanto al rendimiento.</p> <p>Para ilustrar el caso vamos a recuperar los objetos utilizados en el tutorial <code>Author</code>, <code>Gategory</code> y <code>Game</code>. Si recuerdas, tenemos que un <code>Game</code> tiene asociado un <code>Author</code> y tiene asociada una <code>Gategory</code>.</p> <p>Cuando utilizamos el m\u00e9todo de filtrado <code>find</code> que construimos en el <code>GameRepository</code>, vemos que Spring Data traduce la <code>@Query</code> que hab\u00edamos dise\u00f1ado en una query SQL para recuperar los juegos.</p> <pre><code>@Query(\"select g from Game g where (:title is null or g.title like '%'||:title||'%') and (:category is null or g.category.id = :category)\")\nList&lt;Game&gt; find(@Param(\"title\") String title, @Param(\"category\") Long category);\n</code></pre> <p>Esta <code>@Query</code> es la que utiliza Spring Data para traducir las propiedades a objetos de BBDD y mapear los resultados a objetos Java. Si tenemos activada la property <code>spring.jpa.show-sql=true</code> podremos ver las queries que est\u00e1 generando Spring Data. El resultado es el siguiente.</p> <pre><code>Hibernate: select game0_.id as id1_2_, game0_.age as age2_2_, game0_.author_id as author_i4_2_, game0_.category_id as category5_2_, game0_.title as title3_2_ from game game0_ where (? is null or game0_.title like ('%'||?||'%')) and (? is null or game0_.category_id=?)\nHibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_, author0_.nationality as national3_0_0_ from author author0_ where author0_.id=?\nHibernate: select category0_.id as id1_1_0_, category0_.name as name2_1_0_ from category category0_ where category0_.id=?\nHibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_, author0_.nationality as national3_0_0_ from author author0_ where author0_.id=?\nHibernate: select category0_.id as id1_1_0_, category0_.name as name2_1_0_ from category category0_ where category0_.id=?\nHibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_, author0_.nationality as national3_0_0_ from author author0_ where author0_.id=?\nHibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_, author0_.nationality as national3_0_0_ from author author0_ where author0_.id=?\nHibernate: select author0_.id as id1_0_0_, author0_.name as name2_0_0_, author0_.nationality as national3_0_0_ from author author0_ where author0_.id=?\n</code></pre> <p>Si te fijas ha generado una query SQL para filtrar los <code>Game</code>, pero luego cuando ha intentado construir los objetos Java, ha tenido que lanzar una serie de queries para recuperar los diferentes <code>Author</code> y <code>Category</code> a trav\u00e9s de sus <code>id</code>. Obviamente Spring Data es muy lista y cachea los resultados obtenidos para no tener que recuperarlos n veces, pero aun as\u00ed, lanza unas cuantas consultas. Esto penaliza el rendimiento de nuestra operaci\u00f3n, ya que tiene que lanzar n queries a BBDD que, aunque son muy \u00f3ptimas, incrementan unos milisegundos el tiempo total.</p> <p>Para evitar esta circunstancia, disponemos de la anotaci\u00f3n denominada <code>@EnitityGraph</code> la cual proporciona directrices a Spring Data sobre la forma en la que deseamos realizar la consulta, permitiendo que realice agrupaciones y uniones de tablas en una \u00fanica query que, aun siendo mas compleja, en muchos casos el rendimiento es mucho mejor que realizar m\u00faltiples interacciones con la BBDD.</p> <p>Siguiendo el ejemplo anterior podr\u00edamos utilizar la anotaci\u00f3n de esta forma:</p> <pre><code>@Query(\"select g from Game g where (:title is null or g.title like '%'||:title||'%') and (:category is null or g.category.id = :category)\")\n@EntityGraph(attributePaths = {\"category\", \"author\"})\nList&lt;Game&gt; find(@Param(\"title\") String title, @Param(\"category\") Long category);\n</code></pre> <p>Donde le estamos diciendo a Spring Data que cuando realice la query, haga el cruce con las propiedades <code>category</code> y <code>author</code>, que a su vez son entidades y por tanto mapean dos tablas de BBDD. El resultado es el siguiente:</p> <pre><code>Hibernate: select game0_.id as id1_2_0_, category1_.id as id1_1_1_, author2_.id as id1_0_2_, game0_.age as age2_2_0_, game0_.author_id as author_i4_2_0_, game0_.category_id as category5_2_0_, game0_.title as title3_2_0_, category1_.name as name2_1_1_, author2_.name as name2_0_2_, author2_.nationality as national3_0_2_ from game game0_ left outer join category category1_ on game0_.category_id=category1_.id left outer join author author2_ on game0_.author_id=author2_.id where (? is null or game0_.title like ('%'||?||'%')) and (? is null or game0_.category_id=?)\n</code></pre> <p>Una \u00fanica query, que es m\u00e1s compleja que la anterior, ya que hace dos cruces con tablas de BBDD, pero que nos evita tener que lanzar n queries diferentes para recuperar <code>Author</code> y <code>Category</code>.</p> <p>Generalmente, el uso de <code>@EntityGraph</code> acelera mucho los resultados y es muy recomendable utilizarlo para realizar los cruces inline. Se puede utilizar tanto con <code>@Query</code> como con <code>Derived Query Methods</code>. Puedes leer m\u00e1s informaci\u00f3n en este peque\u00f1o tutorial de Baeldung.</p>"},{"location":"appendix/jpa/#alternativa-de-streams","title":"Alternativa de Streams","text":"<p>A partir de Java 8 disponemos de los Java Streams. Se trata de una herramienta que nos permite multitud de opciones relativas tratamiento y trasformaci\u00f3n de los datos manejados.</p> <p>En este apartado \u00fanicamente se menciona debido a que en muchas ocasiones cuando nos enfrentamos a consultas complejas, puede ser beneficioso evitar ofuscar las consultas y realizar las trasformaciones necesarias mediante los Streams.</p> <p>Un ejemplo de uso pr\u00e1ctico podr\u00eda ser, evitar usar la cl\u00e1usula <code>IN</code> de SQL en una determinada consulta que podr\u00eda penalizar notablemente el rendimiento de las consultas. En vez de eso se podr\u00eda utilizar el m\u00e9todo de JAVA <code>filter</code> sobre el conjunto de elementos para obtener el mismo resultado.</p> <p>Puedes leer m\u00e1s informaci\u00f3n en el tutorial de Baeldung.</p>"},{"location":"appendix/jpa/#specifications","title":"Specifications","text":"<p>En algunos casos puede ocurrir que con las herramientas descritas anteriormente no tengamos suficiente alcance, bien porque las definiciones de los m\u00e9todos se complican y alargan demasiado o debido a que la consulta es demasiado gen\u00e9rica como para realizarlo de este modo.</p> <p>Para este caso se dispone de las Specifications que nos proveen de una forma de escribir consultas reutilizables mediante una API que ofrece una forma fluida de crear y combinar consultas complejas.</p> <p>Un ejemplo de caso de uso podr\u00eda ser un CRUD de una determinada entidad que debe poder filtrar por todos los atributos de esta, donde el tipo de filtrado viene especificado en la propia consulta y no siempre es requerido. En este caso no podr\u00edamos construir una consulta basada en definir un determinado m\u00e9todo ya no conocemos de ante mano que filtros ni que atributos vamos a recibir y deberemos recurrir al uso de las Specifications.</p> <p>Puedes leer m\u00e1s informaci\u00f3n en el tutorial de Baeldung.</p>"},{"location":"appendix/rest/","title":"Breve detalle sobre REST","text":"<p>Antes de empezar vamos a hablar de operaciones REST. Estas operaciones son el punto de entrada a nuestra aplicaci\u00f3n y se pueden diferenciar dos claros elementos:</p> <ul> <li>Ruta hacia el recurso, lo que viene siendo la URL.</li> <li>Acci\u00f3n a realizar sobre el recurso, lo que viene siendo la operaci\u00f3n HTTP o el verbo.</li> </ul>"},{"location":"appendix/rest/#ruta-del-recurso","title":"Ruta del recurso","text":"<p>La ruta del recurso nos indica entre otras cosas, el endpoint y su posible jerarqu\u00eda sobre la que se va a realizar la operaci\u00f3n. Debe tener una ra\u00edz de recurso y si se requiere navegar por el recursos, la jerarqu\u00eda ir\u00e1 separada por barras. La URL nunca deber\u00eda tener verbos o acciones solamente recursos, identificadores o atributos.  Por ejemplo en nuestro caso de <code>Categor\u00edas</code>, ser\u00edan correctas las siguientes rutas:</p> <ul> <li> /category</li> <li> /category/3</li> <li> /category/?name=Dados</li> </ul> <p>Sin embargo, no ser\u00edan del todo correctas las rutas:</p> <ul> <li> /getCategory</li> <li> /findCategories</li> <li> /saveCategory</li> <li> /category/save</li> </ul> <p>A menudo, se integran datos identificadores o atributos de b\u00fasqueda dentro de la propia ruta. Podr\u00edamos definir la operaci\u00f3n <code>category/3</code> para referirse a la Categor\u00eda con ID = 3, o <code>category/?name=Dados</code> para referirse a las categor\u00edas con nombre = Dados. A veces, estos datos tambi\u00e9n pueden ir como atributos en la URL o en el cuerpo de la petici\u00f3n, aunque se recomienda que siempre que sean identificadores vayan determinados en la propia URL.</p> <p>Si el dominio categor\u00eda tuviera hijos o relaciones con alg\u00fan otro dominio se podr\u00eda a\u00f1adir esas jerarqu\u00eda a la URL. Por ejemplo podr\u00edamos tener <code>category/3/child/2</code> para referirnos al hijo de ID = 2 que tiene la Categor\u00eda de ID = 3, y as\u00ed sucesivamente.</p>"},{"location":"appendix/rest/#accion-sobre-el-recurso","title":"Acci\u00f3n sobre el recurso","text":"<p>La acci\u00f3n sobre el recurso se determina mediante la operaci\u00f3n o verbo HTTP que se utiliza en el endpoint. Los verbos m\u00e1s usados ser\u00edan:</p> <ul> <li>GET. Cuando se quiere recuperar un recursos.</li> <li>POST. Cuando se quiere crear un recurso. Aunque a menudo se utiliza para realizar otras acciones de b\u00fasqueda o validaci\u00f3n.</li> <li>PUT. Cuando se quiere actualizar o modificar un recurso. Aunque a menudo se utiliza una sola operaci\u00f3n para crear o actualizar. En ese caso se utilizar\u00eda solamente <code>POST</code>.</li> <li>DELETE. Cuando se quiere eliminar un recurso.</li> </ul> <p>De esta forma tendr\u00edamos:</p> <ul> <li><code>GET /category/3</code>. Realizar\u00eda un acceso para recuperar la categor\u00eda 3.</li> <li><code>POST o PUT /category/3</code>. Realizar\u00eda un acceso para crear o modificar la categor\u00eda 3. Los datos a modificar deber\u00edan ir en el body.</li> <li><code>DELETE /category/3</code>. Realizar\u00eda un acceso para borrar la categor\u00eda 3.</li> <li><code>GET /category/?name=Dados</code>. Realizar\u00eda un acceso para recuperar las categor\u00edas que tengan nombre = Dados.</li> </ul> <p>Excepciones a la regla</p> <p>A veces hay que ejecutar una operaci\u00f3n que no es 'estandar' en cuanto a verbos HTTP. Para ese caso, deberemos clarificar en la URL la acci\u00f3n que se debe realizar y si vamos a enviar datos deber\u00eda ser de tipo <code>POST</code> mientras que si simplemente se requiere una contestaci\u00f3n sin enviar datos ser\u00e1 de tipo <code>GET</code>. Por ejemplo <code>POST /category/3/validate</code> realizar\u00eda un acceso para ejecutar una validaci\u00f3n sobre los datos enviados en el body de la categor\u00eda 3.</p>"},{"location":"appendix/tdd/","title":"TDD (Test Driven Development)","text":"<p>Se trata de una pr\u00e1ctica de programaci\u00f3n que consiste en escribir primero las pruebas (generalmente unitarias), despu\u00e9s escribir el c\u00f3digo fuente que pase la prueba satisfactoriamente y, por \u00faltimo, refactorizar el c\u00f3digo escrito.</p> <p>Este ciclo se suele representar con la siguiente imagen:</p> <p></p> <p>Con esta pr\u00e1ctica se consigue entre otras cosas: un c\u00f3digo m\u00e1s robusto, m\u00e1s seguro, m\u00e1s mantenible y una mayor rapidez en el desarrollo.</p> <p>Los pasos que se siguen son:</p> <ol> <li> <p>Primero hay que escribir el test o los tests que cubran la funcionalidad que voy a implementar. Los test no solo deben probar los casos correctos, sino que deben probar los casos err\u00f3neos e incluso los casos en los que se provoca una excepci\u00f3n. Cuantos m\u00e1s test hagas, mejor probada y m\u00e1s robusta ser\u00e1 tu aplicaci\u00f3n.</p> <p>Adem\u00e1s, como efecto colateral, al escribir el test est\u00e1s pensando el dise\u00f1o de c\u00f3mo va a funcionar la aplicaci\u00f3n. En vez de liarte a programar como loco, te est\u00e1s forzando a pensar primero y ver cual es la mejor soluci\u00f3n. Por ejemplo para implementar una operaci\u00f3n de calculadora primero piensas en qu\u00e9 es lo que necesitar\u00e1s: una clase Calculadora con un m\u00e9todo que se llame Suma y que tenga dos par\u00e1metros.</p> </li> <li> <p>El segundo paso una vez tengo definido el test, que evidentemente fallar\u00e1 (e incluso a menudo ni siquiera compilar\u00e1), es implementar el c\u00f3digo necesario para que los tests funcionen. Aqu\u00ed muchas veces pecamos de querer implementar demasiadas cosas o pensando en que en un futuro necesitaremos modificar ciertas partes y lo dejamos ya preparado para ello. Hay que ir con mucho cuidado con las <code>optimizaciones prematuras</code>, a menudo no son necesarias y solo hacen que dificultar nuestro c\u00f3digo.</p> <p>Piensa en construir el m\u00ednimo c\u00f3digo que haga que tus tests funcionen correctamente. Adem\u00e1s, no es necesario que sea un c\u00f3digo demasiado purista y limpio.</p> </li> <li> <p>El \u00faltimo paso y a menudo el m\u00e1s olvidado es el <code>Refactor</code>. Una vez te has asegurado que tu c\u00f3digo funciona y que los tests funcionan correctamente (ojo no solo los tuyos sino todos los que ya existan en la aplicaci\u00f3n) llega el paso de sacarle brillo a tu c\u00f3digo.</p> <p>En este paso tienes que intentar mejorar tu c\u00f3digo, evitar duplicidades, evitar malos olores de programaci\u00f3n, eliminar posibles malos usos del lenguaje, etc. En definitiva que tu c\u00f3digo se lea y se entienda mejor.</p> </li> </ol> <p>Si seguimos estos pasos a la hora de programar, nuestra aplicaci\u00f3n estar\u00e1 muy bien testada. Cada vez que hagamos un cambio tendremos una certeza muy elevada, de forma r\u00e1pida y sencilla, de si la aplicaci\u00f3n sigue funcionando o hemos roto algo. Y lo mejor de todo, las implementaciones que hagamos estar\u00e1n bien pensadas y dise\u00f1adas y acotadas realmente a lo que necesitamos.</p>"},{"location":"cleancode/angular/","title":"Estructura y Buenas pr\u00e1cticas - Angular","text":"<p>Nota</p> <p>Antes de empezar y para puntualizar, Angular se considera un framework SPA Single-page application.</p> <p>En esta parte vamos a explicar los fundamentos de un proyecto en Angular y las recomendaciones existentes.</p>"},{"location":"cleancode/angular/#estructura-y-funcionamiento","title":"Estructura y funcionamiento","text":""},{"location":"cleancode/angular/#ciclo-de-vida-de-angular","title":"Ciclo de vida de Angular","text":"<p>El comportamiento de ciclo de vida de un componente Angular pasa por diferentes etapas que podemos ver en el esquema que mostramos a continuaci\u00f3n:</p> <p></p> <p>Es importante tenerlo claro para saber que m\u00e9todos podemos utilizar para realizar operaciones con el componente.</p>"},{"location":"cleancode/angular/#carpetas-creadas-por-angular","title":"Carpetas creadas por Angular","text":"<p>Al crear una aplicaci\u00f3n Angular, tendremos los siguientes directorios:</p> <ul> <li>node_modules: Todos los m\u00f3dulos de librar\u00edas usado por el proyecto.</li> <li>\\src\\app: Contiene todo el c\u00f3digo asociado al proyecto.<ul> <li>\\src\\assets: Normalmente la carpeta usada para los recursos.</li> <li>\\src\\environments: Aqu\u00ed ir\u00e1n los ficheros relacionados con los entornos de desarrollos.</li> </ul> </li> </ul> <p>Otros ficheros importantes de un proyecto de Angular</p> <p>Otros archivos que debemos tener en cuenta dentro del proyecto son:</p> <ul> <li>angular.json: Configuraci\u00f3n del propio CLI. La madre de todos los configuradores</li> <li>package.json: Dependencias de librer\u00edas y scripts</li> </ul>"},{"location":"cleancode/angular/#estructura-de-modulos","title":"Estructura de m\u00f3dulos","text":"<p>Existe m\u00faltiples consensos al respecto de como estructurar un proyecto en Angular, pero al final, depende de los requisitos del proyecto. Una sugerencia de como hacerlo es la siguiente:</p> <pre><code>- src\\app\n    - core              /* Componentes y utilidades comunes */ \n        - header        /* Estructura del header */ \n        - footer        /* Estructura del footer */ \n  - domain1       /* M\u00f3dulo con los componentes del dominio1 */\n      - services        /* Servicios con operaciones del dominio1 */ \n      - models          /* Modelos de datos del dominio1 */ \n      - component1      /* Componente1 del dominio1 */ \n      - componentX      /* ComponenteX del dominio1 */ \n  - domainX       /* As\u00ed para el resto de dominios de la aplicaci\u00f3n */\n</code></pre> <p>Recordar, que esto es una sugerencia para una estructura de carpetas y componentes. No existe un estandar.</p> <p>ATENCI\u00d3N: Componentes gen\u00e9ricos</p> <p>Debemos tener en cuenta que a la hora de programar un componente <code>core</code>, lo ideal es pensar que sea un componente plug &amp; play, es decir que si lo copias y lo llevas a otro proyecto funcione sin la necesidad de adaptarlo.</p>"},{"location":"cleancode/angular/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":"<p>A continuaci\u00f3n veremos un listado de buenas pr\u00e1cticas de Angular y de c\u00f3digo limpio que deber\u00edamos intentar seguir en nuestro desarrollo.</p>"},{"location":"cleancode/angular/#estructura-de-archivos","title":"Estructura de archivos","text":"<p>Antes de empezar con un proyecto lo ideal, es pararse y pensar en los requerimientos de una buena estructura, en un futuro lo agradecer\u00e1s.</p>"},{"location":"cleancode/angular/#nombres-claros","title":"Nombres claros","text":"<p>Utilizar la S de los principios S.O.L.I.D para los nombres de variables, m\u00e9todos y dem\u00e1s c\u00f3digo.</p> <p>El efecto que produce este principio son clases con nombres muy descriptivos y por tanto largos.</p> <p>Tambi\u00e9n se recomienta utilizar <code>kebab-case</code> para los nombres de ficheros. Ej. hero-button.component.ts</p>"},{"location":"cleancode/angular/#organiza-tu-codigo","title":"Organiza tu c\u00f3digo","text":"<p>Intenta organizar tu c\u00f3digo fuente:</p> <ul> <li>Lo m\u00e1s importante debe ir arriba.</li> <li>Primero propiedades, despu\u00e9s m\u00e9todos.</li> <li>Un Item para un archivo: cada archivo deber\u00eda contener solamente un componente, al igual que los servicios.</li> <li>Solo una responsabilidad: Cada clase o modulo deber\u00eda tener solamente una responsabilidad.</li> <li>El nombre correcto: las propiedades y m\u00e9todos deber\u00edan usar el sistema de camel case (ej: getUserByName), al contrario, las clases (componentes, servicios, etc) deben usar upper camel case (ej: UserComponent).</li> <li>Los componentes y servicios deben tener su respectivo sufijo: UserComponent, UserService.</li> <li>Imports: los archivos externos van primero.</li> </ul>"},{"location":"cleancode/angular/#usar-linters-prettier-eslint","title":"Usar linters Prettier &amp; ESLint","text":"<p>Un linter es una herramienta que nos ayuda a seguir las buenas pr\u00e1cticas o gu\u00edas de estilo de nuestro c\u00f3digo fuente. En este caso, para JavaScript, proveeremos de unos muy famosos. Una de las m\u00e1s famosas es la combinaci\u00f3n de  Angular app to ESLint with Prettier, AirBnB Styleguide Recordar que a\u00f1adir este tipo de configuraci\u00f3n es opcional, pero necesaria para tener un buen c\u00f3digo de calidad.</p>"},{"location":"cleancode/angular/#git-hooks","title":"Git Hooks","text":"<p>Los Git Hooks son scripts de shell que se ejecutan autom\u00e1ticamente antes o despu\u00e9s de que Git ejecute un comando importante como Commit o Push. Para hacer uso de el es tan sencillo como:</p> <p>npm install husky --save-dev</p> <p>Y a\u00f1adir en el fichero lo siguiente:</p> <pre><code>// package.json\n{\n\"husky\": {\n\"hooks\": {\n\"pre-commit\": \"npm test\",\n\"pre-push\": \"npm test\",\n\"...\": \"...\"\n}\n}\n}\n</code></pre> <p>Usar husky para el preformateo de c\u00f3digo antes de subirlo</p> <p>Es una buena pr\u00e1ctica que todo el equipo use el mismo est\u00e1ndar de formateo de codigo, con husky se puede solucionar.</p>"},{"location":"cleancode/angular/#utilizar-banana-in-the-box","title":"Utilizar Banana in the Box","text":"<p>Como el nombre sugiere banana in the box se debe a la forma que tiene lo siguiente: [{}] Esto es una forma muy sencilla de trabajar los cambios en la forma de Two ways binding. Es decir, el padre informa de un valor u objeto y el hijo lo manipula y actualiza el estado/valor al padre inmediatamente. La forma de implementarlo es sencillo</p> <p>Padre: HTML:</p> <p><code>&lt;my-input [(text)]=\"text\"&gt;&lt;/my-input&gt;</code></p> <p>Hijo</p> <pre><code>@Input() value: string;\n@Output() valueChange = new EventEmitter&lt;string&gt;();\nupdateValue(value){\nthis.value = value;\nthis.valueChange.emit(value);\n}\n</code></pre> <p>Prefijo Change</p> <p>Destacar que el prefijo 'Change' es necesario incluirlo en el Hijo para que funcione</p>"},{"location":"cleancode/angular/#correcto-uso-de-los-servicios","title":"Correcto uso de los servicios","text":"<p>Una buena practica es aconsejable no declarar los servicios en el provides, sino usar un decorador que forma parte de las ultimas versiones de Angular</p> <pre><code>@Injectable({\nprovidedIn: 'root',\n})\nexport class HeroService {\nconstructor() { }\n}\n</code></pre>"},{"location":"cleancode/angular/#lazy-load","title":"Lazy Load","text":"<p>Lazy Load es un patr\u00f3n de dise\u00f1o que consiste en retrasar la carga o inicializaci\u00f3n</p> <p>desde el app-routing.module.ts</p> <p>A\u00f1adiremos un codigo parecido a este <pre><code>  {\npath: 'customers',\nloadChildren: () =&gt; import('./customers/customers.module').then(m =&gt; m.CustomersModule)\n},\n</code></pre></p> <p>Con esto veremos que el m\u00f3dulo se cargar\u00e1 seg\u00fan se necesite.</p>"},{"location":"cleancode/nodejs/","title":"Estructura y Buenas pr\u00e1cticas - Nodejs","text":""},{"location":"cleancode/nodejs/#estructura-y-funcionamiento","title":"Estructura y funcionamiento","text":"<p>En los proyectos Nodejs no existe nada estandarizado y oficial que hable sobre estructura de proyectos y nomenclatura de Nodejs. Tan solo existen algunas sugerencias y buenas pr\u00e1cticas a la hora de desarrollar que te recomiendo que utilices en la medida de lo posible.</p> <p>Tip</p> <p>Piensa que el c\u00f3digo fuente que escribes hoy, es como un libro que se leer\u00e1 durante a\u00f1os. Alguien tendr\u00e1 que coger tu c\u00f3digo y leerlo en unos meses o a\u00f1os para hacer alguna modificaci\u00f3n y, como buenos desarrolladores que somos, tenemos la obligaci\u00f3n de facilitarle en todo lo posible la comprensi\u00f3n de ese c\u00f3digo fuente. Quiz\u00e1 esa persona futura podr\u00edas ser tu en unos meses y quedar\u00eda muy mal que no entendieras ni tu propio c\u00f3digo </p>"},{"location":"cleancode/nodejs/#estructura-en-capas","title":"Estructura en capas","text":"<p>Todos los proyectos para crear una Rest API con node y express est\u00e1n divididos en capas. Como m\u00ednimo estar\u00e1 la capa de rutas, controlador y modelo. En nuestro caso vamos a a\u00f1adir una capa mas de servicios para quitarle trabajo al controlador y desacoplarlo de la capa de datos. As\u00ed si en el futuro queremos cambiar nuestra base de datos no romperemos tanto \ud83d\ude0a</p> <p>Rutas</p> <p>En nuestro proyecto una ruta ser\u00e1 una secci\u00f3n de c\u00f3digo express que asociar\u00e1 un verbo http, una ruta o patr\u00f3n de url y una funci\u00f3n perteneciente al controlador para manejar esa petici\u00f3n.</p> <p>Controladores</p> <p>En nuestros controladores tendremos los m\u00e9todos que obtendr\u00e1n las solicitudes de las rutas, se comunicar\u00e1n con la capa de servicio y convertir\u00e1n estas solicitudes en respuestas http.</p> <p>Servicio</p> <p>Nuestra capa de servicio incluir\u00e1 toda la l\u00f3gica de negocio de nuestra aplicaci\u00f3n. Para realizar sus operaciones puede realizar llamadas tanto a otras clases dentro de esta capa, como a clases de la capa inferior.</p> <p>Modelo</p> <p>Como su nombre indica esta capa representa los modelos de datos de nuestra aplicaci\u00f3n. En nuestro caso, al usar un ODM, solo tendremos modelos de datos definidos seg\u00fan sus requisitos.</p>"},{"location":"cleancode/nodejs/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":""},{"location":"cleancode/nodejs/#accesos-entre-capas","title":"Accesos entre capas","text":"<p>En base a la divisi\u00f3n por capas que hemos comentado arriba, y el resto de entidades implicadas, hay una serie de reglas important\u00edsimas que debes seguir muy de cerca:</p> <ul> <li> <p>Un <code>Controlador</code></p> <ul> <li>NO debe contener l\u00f3gica en su clase. Solo est\u00e1 permitido que ejecute l\u00f3gica a trav\u00e9s de una llamada al objeto de la capa L\u00f3gica.</li> <li>NO puede ejecutar directamente operaciones de la capa Acceso a Datos, siempre debe pasar por la capa de servicios.</li> <li>Debemos seguir una coherencia entre todas las URL de las operaciones. Por ejemplo, si elegimos save para guardar, usemos esa palabra en todas las operaciones que sean de ese tipo. Evitad utilizar diferentes palabras save, guardar, persistir, actualizar para la misma acci\u00f3n.</li> </ul> </li> <li> <p>Un <code>Servicio</code></p> <ul> <li>NO puede llamar a objetos de la capa Controlador.</li> <li>NO debe llamar a Acceso a Datos que NO sean de su \u00e1mbito / competencia.</li> <li>Si es necesario puede llamar a otros Servicios para recuperar cierta informaci\u00f3n que no sea de su \u00e1mbito / competencia.</li> <li>Es un buen lugar para implementar la l\u00f3gica de negocio.</li> </ul> </li> </ul>"},{"location":"cleancode/nodejs/#usar-linters-prettier-eslint-se-recomienda-encarecidamente","title":"Usar linters Prettier &amp; ESLint (Se recomienda encarecidamente)","text":"<p>Un linter es una herramienta que nos ayuda a seguir las buenas pr\u00e1cticas o gu\u00edas de estilo de nuestro c\u00f3digo fuente. En este caso, para JavaScript, proveeremos de unos muy famosos. Una de las m\u00e1s famosas es la combinaci\u00f3n de Angular app to ESLint with Prettier, AirBnB Styleguide Recordar que a\u00f1adir este tipo de configuraci\u00f3n es opcional, pero necesaria para tener un buen c\u00f3digo de calidad.</p>"},{"location":"cleancode/springboot/","title":"Estructura y Buenas pr\u00e1cticas - Spring Boot","text":""},{"location":"cleancode/springboot/#estructura-y-funcionamiento","title":"Estructura y funcionamiento","text":"<p>En Springboot no existe nada estandarizado y oficial que hable sobre estructura de proyectos y nomenclatura. Tan solo existen algunas sugerencias y buenas pr\u00e1cticas a la hora de desarrollar que te recomiendo que utilices en la medida de lo posible.</p> <p>Tip</p> <p>Piensa que el c\u00f3digo fuente que escribes hoy, es como un libro que se leer\u00e1 durante a\u00f1os. Alguien tendr\u00e1 que coger tu c\u00f3digo y leerlo en unos meses o a\u00f1os para hacer alguna modificaci\u00f3n y, como buenos desarrolladores que somos, tenemos la obligaci\u00f3n de facilitarle en todo lo posible la comprensi\u00f3n de ese c\u00f3digo fuente. Quiz\u00e1 esa persona futura podr\u00edas ser tu en unos meses y quedar\u00eda muy mal que no entendieras ni tu propio c\u00f3digo </p>"},{"location":"cleancode/springboot/#estructura-en-capas","title":"Estructura en capas","text":"<p>Todos los proyectos web que construimos basados en Springboot se caracterizan por estar divididos en tres capas (a menos que utilicemos DDD para desarrollar que entonces existen infinitas capas ).</p> <p></p> <ul> <li>Controlador. Es la capa m\u00e1s alta, la que tiene acceso directo con el cliente. En esta capa es donde se exponen las operaciones que queremos publicar y que el cliente puede consumir. Para realizar sus operaciones lo m\u00e1s normal es que realice llamadas a las clases de la capa inmediatamente inferior.</li> <li>L\u00f3gica. Tambi\u00e9n llamada capa de <code>Servicios</code>. Es la capa intermedia que da soporte a las operaciones que est\u00e1n expuestas y ejecutan toda la l\u00f3gica de negocio de la aplicaci\u00f3n. Para realizar sus operaciones puede realizar llamadas tanto a otras clases dentro de esta capa, como a clases de la capa inferior.</li> <li>Acceso a Datos. Como su nombre indica, es la capa que accede a datos. T\u00edpicamente es la capa que ejecuta las consultas contra BBDD, pero esto no tiene por qu\u00e9 ser obligadamente as\u00ed. Tambi\u00e9n entrar\u00edan en esa capa aquellas clases que consumen datos externos, por ejemplo de un servidor externo. Las clases de esta capa deben ser nodos <code>finales</code>, no pueden llamar a ninguna otra clase para ejecutar sus operaciones, ni siquiera de su misma capa.</li> </ul>"},{"location":"cleancode/springboot/#estructura-de-proyecto","title":"Estructura de proyecto","text":"<p>En proyectos medianos o grandes, estructurar los directorios del proyecto en base a la estructura anteriormente descrita ser\u00eda muy complejo, ya que en cada uno de los niveles tendr\u00edamos muchas clases. As\u00ed que lo normal es diferenciar por \u00e1mbito funcional y dentro de cada <code>package</code> realizar la separaci\u00f3n en <code>Controlador</code>, <code>L\u00f3gica</code> y <code>Acceso a datos</code>.</p> <p>Tened en cuenta en un mismo \u00e1mbito funcional puede tener varios controladores o varios servicios de l\u00f3gica uno por cada entidad que estemos tratando. Siempre que se pueda, agruparemos entidades que intervengan dentro de una misma funcionalidad. </p> <p>En nuestro caso del tutorial, tendremos tres \u00e1mbitos funcionales <code>Categor\u00eda</code>, <code>Autor</code>, y <code>Juego</code> que diferenciaremos cada uno con su propia estructura.</p>"},{"location":"cleancode/springboot/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":""},{"location":"cleancode/springboot/#nomenclatura-de-las-clases","title":"Nomenclatura de las clases","text":"<p><code>@TODO: En construcci\u00f3n</code></p>"},{"location":"cleancode/springboot/#accesos-entre-capas","title":"Accesos entre capas","text":"<p>En base a la divisi\u00f3n por capas que hemos comentado arriba, y el resto de entidades implicadas, hay una serie de reglas important\u00edsimas que debes seguir muy de cerca:</p> <ul> <li>Un <code>Controlador</code><ul> <li>NO debe contener l\u00f3gica en su clase. Solo est\u00e1 permitido que ejecute l\u00f3gica a trav\u00e9s de una llamada al objeto de la capa <code>L\u00f3gica</code>.</li> <li>NO puede ejecutar directamente operaciones de la capa <code>Acceso a Datos</code>, siempre debe pasar por la capa <code>L\u00f3gica</code>.</li> <li>NO debe enviar ni recibir del cliente objetos de tipo <code>Entity</code>.</li> <li>Es un buen lugar para realizar las conversiones de datos entre <code>Entity</code> y <code>Dto</code>.</li> <li>En teor\u00eda cada operaci\u00f3n deber\u00eda tener su propio Dto, aunque los podemos reutilizar entre operaciones similares.</li> <li>Debemos seguir una coherencia entre todas las URL de las operaciones. Por ejemplo si elegimos <code>save</code> para guardar, usemos esa palabra en todas las operaciones que sean de ese tipo. Evitad utilizar diferentes palabras <code>save</code>, <code>guardar</code>, <code>persistir</code>, <code>actualizar</code> para la misma acci\u00f3n.</li> </ul> </li> <li>Un <code>Servicio</code><ul> <li>NO puede llamar a objetos de la la capa <code>Controlador</code>.</li> <li>NO puede ejecutar directamente queries contra la BBDD, siempre debe pasar por la capa <code>Acceso a Datos</code>.</li> <li>NO debe llamar a <code>Acceso a Datos</code> que NO sean de su \u00e1mbito / competencia.</li> <li>Si es necesario puede llamar a otros <code>Servicios</code> para recuperar cierta informaci\u00f3n que no sea de su \u00e1mbito / competencia.</li> <li>Debe trabajar en la medida de lo posible con objetos de tipo <code>Entity</code>.</li> <li>Es un buen lugar para implementar la l\u00f3gica de negocio.</li> </ul> </li> <li>Un <code>Acceso a Datos</code><ul> <li>NO puede llamar a ninguna otra capa. Ni <code>Controlador</code>, ni <code>Servicios</code>, ni <code>Acceso a Datos</code>.</li> <li>NO debe contener l\u00f3gica en su clase.</li> <li>Esta capa solo debe resolver el dato que se le ha solicitado y devolverlo a la capa de <code>Servicios</code>.</li> </ul> </li> </ul>"},{"location":"develop/basic/angular/","title":"Listado simple - Angular","text":"<p>Ahora que ya tenemos listo el proyecto frontend de Angular (en el puerto 4200), ya podemos empezar a codificar la soluci\u00f3n.</p>"},{"location":"develop/basic/angular/#primeros-pasos","title":"Primeros pasos","text":"<p>Antes de empezar</p> <p>Quiero hacer hincapi\u00e9 que Angular tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. Tanto en la propia web de documentaci\u00f3n de Angular como en la web de componentes Angular Material puedes buscar casi cualquier ejemplo que necesites.</p> <p>Si abrimos el proyecto con el IDE que tengamos (Visual Studio Code en el caso del tutorial) podemos ver que en la carpeta <code>src/app</code> existen unos ficheros ya creados por defecto. Estos ficheros son:</p> <ul> <li><code>app.component.ts</code> \u2192 contiene el c\u00f3digo inicial del proyecto escrito en TypeScript.</li> <li><code>app.component.html</code> \u2192 contiene la plantilla inicial del proyecto escrita en HTML.</li> <li><code>app.component.scss</code> \u2192 contiene los estilos CSS privados de la plantilla inicial.</li> </ul> <p>Vamos a modificar este c\u00f3digo inicial para ver como funciona. Abrimos el fichero <code>app.component.ts</code> y modificamos la l\u00ednea donde se asigna un valor a la variable <code>title</code>.</p> app.component.ts <pre><code>...\ntitle = 'Tutorial de Angular';\n...\n</code></pre> <p>Ahora abrimos el fichero <code>app.component.html</code>, borramos todo el c\u00f3digo de la plantilla y a\u00f1adimos el siguiente c\u00f3digo:</p> app.component.html <pre><code>&lt;h1&gt;{{title}}&lt;/h1&gt;\n</code></pre> <p>Las llaves dobles permiten hacen un binding entre el c\u00f3digo del componente y la plantilla. Es decir, en este caso ir\u00e1 al c\u00f3digo TypeScript y buscar\u00e1 el valor de la variable <code>title</code>.</p> <p>Consejo</p> <p>El binding tambi\u00e9n nos sirve para ejecutar los m\u00e9todos de TypeScript desde el c\u00f3digo HTML. Adem\u00e1s si el valor que contiene la variable se modificara durante la ejecuci\u00f3n de alg\u00fan m\u00e9todo, autom\u00e1ticamente el c\u00f3digo HTML refrescar\u00eda el nuevo valor de la variable <code>title</code> </p> <p>Si abrimos el navegador y accedemos a <code>http://localhost:4200/</code> podremos ver el resultado del c\u00f3digo.</p>"},{"location":"develop/basic/angular/#layout-general","title":"Layout general","text":""},{"location":"develop/basic/angular/#crear-componente","title":"Crear componente","text":"<p>Lo primero que vamos a hacer es escoger un tema y una paleta de componentes para trabajar. Lo m\u00e1s c\u00f3modo es trabajar con <code>Material</code> que ya viene perfectamente integrado en Angular. Ejecutamos el comando y elegimos la paleta de colores que m\u00e1s nos guste o bien creamos una custom:</p> <pre><code>ng add @angular/material\n</code></pre> <p>Recuerda</p> <p>Al a\u00f1adir una nueva librer\u00eda tenemos que parar el servidor y volver a arrancarlo para que compile y precargue las nuevas dependencias.</p> <p>Una vez a\u00f1adida la dependencia, lo que queremos es crear una primera estructura inicial a la p\u00e1gina. Si te acuerdas cual era la estructura (y si no te acuerdas, vuelve a la secci\u00f3n <code>Contexto de la aplicaci\u00f3n</code> y lo revisas), ten\u00edamos una cabecera superior con un logo y t\u00edtulo y unas opciones de men\u00fa.</p> <p>Pues vamos a ello, crearemos esa estructura com\u00fan para toda la aplicaci\u00f3n. Este componente al ser algo core para toda la aplicaci\u00f3n deber\u00edamos crearlo dentro del m\u00f3dulo <code>core</code> como ya vimos anteriormente.</p> <p>Pero antes de todo, vamos a crear los m\u00f3dulos generales de la aplicaci\u00f3n, as\u00ed que ejecutamos en consola el comando que nos permite crear un m\u00f3dulo nuevo:</p> <pre><code>ng generate module core\n</code></pre> <p>Y a\u00f1adimos esos m\u00f3dulos al m\u00f3dulo padre de la aplicaci\u00f3n:</p> app.module.ts <pre><code>import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { CoreModule } from './core/core.module';\n@NgModule({\ndeclarations: [\nAppComponent\n],\nimports: [\nBrowserModule,\nAppRoutingModule,\nCoreModule,\nBrowserAnimationsModule,\n],\nproviders: [],\nbootstrap: [AppComponent]\n})\nexport class AppModule { }\n</code></pre> <p>Y despu\u00e9s crearemos el componente header, dentro del m\u00f3dulo core. Para eso ejecutaremos el comando:</p> <pre><code>ng generate component core/header\n</code></pre>"},{"location":"develop/basic/angular/#codigo-de-la-pantalla","title":"C\u00f3digo de la pantalla","text":"<p>Esto nos crear\u00e1 una carpeta con los ficheros del componente, donde tendremos que copiar el siguiente contenido:</p> header.component.htmlheader.component.scss <pre><code>&lt;mat-toolbar&gt;\n    &lt;mat-toolbar-row&gt;\n        &lt;div class=\"header_container\"&gt;\n            &lt;div class=\"header_title\"&gt;              \n                &lt;mat-icon&gt;storefront&lt;/mat-icon&gt; Ludoteca Tan\n            &lt;/div&gt;\n\n            &lt;div class=\"header_separator\"&gt; | &lt;/div&gt;\n\n            &lt;div class=\"header_menu\"&gt;\n                &lt;div class=\"header_button\"&gt;\n                    &lt;a routerLink=\"/games\" routerLinkActive=\"active\"&gt;Cat\u00e1logo&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;div class=\"header_button\"&gt;\n                    &lt;a routerLink=\"/categories\" routerLinkActive=\"active\"&gt;Categor\u00edas&lt;/a&gt;\n                &lt;/div&gt;\n                &lt;div class=\"header_button\"&gt;\n                    &lt;a routerLink=\"/authors\" routerLinkActive=\"active\"&gt;Autores&lt;/a&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n\n            &lt;div class=\"header_login\"&gt;\n                &lt;mat-icon&gt;account_circle&lt;/mat-icon&gt; Sign in\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/mat-toolbar-row&gt;\n&lt;/mat-toolbar&gt;\n</code></pre> <pre><code>.mat-toolbar {\nbackground-color: blue;\ncolor: white;\n}\n\n.header_container {\ndisplay: flex;\nwidth: 100%;\n.header_title {\n.mat-icon {\nvertical-align: sub;\n}\n}\n\n.header_separator {\nmargin-left: 30px;\nmargin-right: 30px;\n}\n\n.header_menu {\nflex-grow: 4;\ndisplay: flex;\nflex-direction: row;\n\n.header_button {\nmargin-left: 1em;\nmargin-right: 1em;\nfont-size: 16px;\n\na {\nfont-weight: lighter;\ntext-decoration: none;\ncursor: pointer;\ncolor: white;\n}\n\na:hover {\ncolor: grey;\n}\n\na.active {\nfont-weight: normal;\ntext-decoration: underline;\ncolor: lightyellow;\n}\n\n}\n}\n\n.header_login {\nfont-size: 16px;\ncursor: pointer;\n.mat-icon {\nvertical-align: sub;\n}\n}\n}\n</code></pre> <p>Al utilizar etiquetas de material como <code>mat-toolbar</code> o <code>mat-icon</code> y <code>routerLink</code> necesitaremos importar las dependencias. Esto lo podemos hacer directamente en el m\u00f3dulo del que depende, es decir en el fichero <code>core.module.ts</code></p> core.module.ts <pre><code>import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatToolbarModule } from '@angular/material/toolbar';\nimport { HeaderComponent } from './header/header.component';\nimport { RouterModule } from '@angular/router';\n@NgModule({\ndeclarations: [HeaderComponent],\nimports: [\nCommonModule,\nRouterModule,\nMatIconModule, MatToolbarModule,\n],\nexports: [\nHeaderComponent\n]\n})\nexport class CoreModule { }\n</code></pre> <p>Adem\u00e1s de a\u00f1adir las dependencias, diremos que este m\u00f3dulo va a exportar el componente <code>HeaderComponent</code> para poder utilizarlo desde otras p\u00e1ginas.</p> <p>Ya por \u00faltimo solo nos queda modificar la p\u00e1gina general de la aplicaci\u00f3n <code>app.component.html</code> para a\u00f1adirle el componente <code>HeaderComponent</code>.</p> app.component.html <pre><code>&lt;div&gt;\n&lt;app-header&gt;&lt;/app-header&gt;\n&lt;div&gt;\n    &lt;router-outlet&gt;&lt;/router-outlet&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>Vamos al navegador y refrescamos la p\u00e1gina, deber\u00eda aparecer una barra superior (Header) con las opciones de men\u00fa. Algo similar a esto:</p> <p></p> <p>Recuerda</p> <p>Cuando se a\u00f1aden componentes a los ficheros <code>html</code>, siempre se deben utilizar los selectores definidos para el componente. En el caso anterior hemos a\u00f1adido <code>app-header</code> que es el mismo nombre selector que tiene el componente en el fichero <code>header.component.ts</code>. Adem\u00e1s, recuerda que para poder utilizar componentes de otros m\u00f3dulos, los debes exportar ya que de lo contrario tan solo podr\u00e1n utilizarse dentro del m\u00f3dulo donde se declaran.</p>"},{"location":"develop/basic/angular/#creando-un-listado-basico","title":"Creando un listado b\u00e1sico","text":""},{"location":"develop/basic/angular/#crear-componente_1","title":"Crear componente","text":"<p>Ya tenemos la estructura principal, ahora vamos a crear nuestra primera pantalla. Vamos a empezar por la de <code>Categor\u00edas</code> que es la m\u00e1s sencilla, ya que se trata de un listado, que muestra datos sin filtrar ni paginar.</p> <p>Como categor\u00edas es un dominio funcional de la aplicaci\u00f3n, vamos a crear un m\u00f3dulo que contenga toda la funcionalidad de ese dominio. Ejecutamos en consola:</p> <pre><code>ng generate module category\n</code></pre> <p>Y por tanto, al igual que hicimos anteriormente, hay que a\u00f1adir el m\u00f3dulo al fichero <code>app.module.ts</code></p> app.module.ts <pre><code>import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { CoreModule } from './core/core.module';\nimport { CategoryModule } from './category/category.module';\n@NgModule({\ndeclarations: [\nAppComponent\n],\nimports: [\nBrowserModule,\nAppRoutingModule,\nCoreModule,\nCategoryModule,\nBrowserAnimationsModule,\n],\nproviders: [],\nbootstrap: [AppComponent]\n})\nexport class AppModule { }\n</code></pre> <p>Ahora todas las pantallas, componentes y servicios que creemos, referidos a este dominio funcional, deber\u00e1n ir dentro del modulo <code>cagegory</code>.</p> <p>Vamos a crear un primer componente que ser\u00e1 un listado de categor\u00edas. Para ello vamos a ejecutar el siguiente comando:</p> <pre><code>ng generate component category/category-list\n</code></pre> <p>Para terminar de configurar la aplicaci\u00f3n, vamos a a\u00f1adir la ruta del componente dentro del componente routing de Angular, para poder acceder a \u00e9l, para ello modificamos el fichero <code>app-routing.module.ts</code></p> app-routing.module.ts <pre><code>import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { CategoryListComponent } from './category/category-list/category-list.component';\nconst routes: Routes = [\n{ path: 'categories', component: CategoryListComponent },\n];\n\n@NgModule({\nimports: [RouterModule.forRoot(routes)],\nexports: [RouterModule]\n})\nexport class AppRoutingModule { }\n</code></pre> <p>Si abrimos el navegador y accedemos a <code>http://localhost:4200/</code> podremos navegar mediante el men\u00fa <code>Categor\u00edas</code> el cual abrir\u00e1 el componente que acabamos de crear.</p>"},{"location":"develop/basic/angular/#codigo-de-la-pantalla_1","title":"C\u00f3digo de la pantalla","text":"<p>Ahora vamos a construir la pantalla. Para manejar la informaci\u00f3n del listado, necesitamos almacenar los datos en un objeto de tipo <code>model</code>. Para ello crearemos un fichero en <code>category\\model\\Category.ts</code> donde implementaremos la clase necesaria. Esta clase ser\u00e1 la que utilizaremos en el c\u00f3digo html y ts de nuestro componente.</p> Category.ts <pre><code>export class Category {\nid: number;\nname: string;\n}\n</code></pre> <p>Tambi\u00e9n, escribiremos el c\u00f3digo de la pantalla de listado.</p> category-list.component.htmlcategory-list.component.scsscategory-list.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1&gt;Listado de Categor\u00edas&lt;/h1&gt;\n\n&lt;mat-table [dataSource]=\"dataSource\"&gt;\n&lt;ng-container matColumnDef=\"id\"&gt;\n&lt;mat-header-cell *matHeaderCellDef&gt; Identificador &lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.id}} &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n&lt;ng-container matColumnDef=\"name\"&gt;\n&lt;mat-header-cell *matHeaderCellDef&gt; Nombre categor\u00eda  &lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.name}} &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n&lt;ng-container matColumnDef=\"action\"&gt;\n&lt;mat-header-cell *matHeaderCellDef&gt;&lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt;\n                &lt;button mat-icon-button color=\"primary\"&gt;&lt;mat-icon&gt;edit&lt;/mat-icon&gt;&lt;/button&gt;\n                &lt;button mat-icon-button color=\"accent\"&gt;&lt;mat-icon&gt;clear&lt;/mat-icon&gt;&lt;/button&gt;\n            &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n&lt;mat-header-row *matHeaderRowDef=\"displayedColumns; sticky: true\"&gt;&lt;/mat-header-row&gt;\n&lt;mat-row *matRowDef=\"let row; columns: displayedColumns;\"&gt;&lt;/mat-row&gt;\n&lt;/mat-table&gt;\n\n    &lt;div class=\"buttons\"&gt;\n        &lt;button mat-flat-button color=\"primary\"&gt;Nueva categor\u00eda&lt;/button&gt;\n    &lt;/div&gt;   \n&lt;/div&gt;\n</code></pre> <pre><code>.container {\nmargin: 20px;\n\nmat-table {\nmargin-top: 10px;\nmargin-bottom: 20px;\n\n.mat-header-row {\nbackground-color:#f5f5f5;\n\n.mat-header-cell {\ntext-transform: uppercase;\nfont-weight: bold;\ncolor: #838383;\n}      }\n\n.mat-column-id {\nflex: 0 0 20%;\njustify-content: center;\n}\n\n.mat-column-action {\nflex: 0 0 10%;\njustify-content: center;\n}\n}\n\n.buttons {\ntext-align: right;\n}\n}\n</code></pre> <pre><code>import { Component, OnInit } from '@angular/core';\nimport { MatTableDataSource } from '@angular/material/table';\nimport { Category } from '../model/Category';\n@Component({\nselector: 'app-category-list',\ntemplateUrl: './category-list.component.html',\nstyleUrls: ['./category-list.component.scss']\n})\nexport class CategoryListComponent implements OnInit {\n\ndataSource = new MatTableDataSource&lt;Category&gt;();\ndisplayedColumns: string[] = ['id', 'name', 'action'];\nconstructor() { }\n\nngOnInit(): void {\n}\n\n}\n</code></pre> <p>El c\u00f3digo HTML es f\u00e1cil de seguir pero por si acaso:</p> <ul> <li>L\u00ednea 4: Creamos la tabla con la variable <code>dataSource</code> definida en el fichero .ts</li> <li>L\u00ednea 5: Definici\u00f3n de la primera columna, su cabecera y el dato que va a contener</li> <li>L\u00ednea 10: Definici\u00f3n de la segunda columna, su cabecera y el dato que va a contener</li> <li>L\u00ednea 15: Definici\u00f3n de la tercera columna, su cabecera vac\u00eda y los dos botones de acci\u00f3n</li> <li>L\u00ednea 23 y 24: Construcci\u00f3n de la cabecera y las filas</li> </ul> <p>Y ya por \u00faltimo, a\u00f1adimos los componentes que se han utilizado de Angular Material a las dependencias del m\u00f3dulo donde est\u00e1 definido el componente en este caso <code>category\\category.module.ts</code>:</p> category.module.ts <pre><code>import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { MatTableModule } from '@angular/material/table';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatButtonModule } from '@angular/material/button';\nimport { CategoryListComponent } from './category-list/category-list.component';\n\n@NgModule({\ndeclarations: [CategoryListComponent],\nimports: [\nCommonModule,\nMatTableModule,\nMatIconModule, MatButtonModule\n],\n})\nexport class CategoryModule { }\n</code></pre> <p>Si abrimos el navegador y accedemos a <code>http://localhost:4200/</code> y pulsamos en el men\u00fa de <code>Categor\u00edas</code> obtendremos una pantalla con un listado vac\u00edo (solo con cabeceras) y un bot\u00f3n de crear Nueva Categor\u00eda que aun no hace nada.</p>"},{"location":"develop/basic/angular/#anadiendo-datos","title":"A\u00f1adiendo datos","text":"<p>En este punto y para ver como responde el listado, vamos a a\u00f1adir datos. Si tuvieramos el backend implementado podr\u00edamos consultar los datos directamente de una operaci\u00f3n de negocio de backend, pero ahora mismo no lo tenemos implementado as\u00ed que para no bloquear el desarrollo vamos a mockear los datos.</p>"},{"location":"develop/basic/angular/#creando-un-servicio","title":"Creando un servicio","text":"<p>En angular, cualquier acceso a datos debe pasar por un <code>service</code>, as\u00ed que vamos a crearnos uno para todas las operaciones de categor\u00edas. Vamos a la consola y ejecutamos:</p> <pre><code>ng generate service category/category\n</code></pre> <p>Esto nos crear\u00e1 un servicio, que adem\u00e1s podemos utilizarlo inyect\u00e1ndolo en cualquier componente que lo necesite. </p>"},{"location":"develop/basic/angular/#implementando-un-servicio","title":"Implementando un servicio","text":"<p>Vamos a implementar una operaci\u00f3n de negocio que recupere el listado de categor\u00edas y lo vamos a hacer de forma reactiva (as\u00edncrona) para simular una petici\u00f3n a backend. Modificamos los siguientes ficheros:</p> category.service.tscategory-list.component.ts <pre><code>import { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { Category } from './model/Category';\n@Injectable({\nprovidedIn: 'root'\n})\nexport class CategoryService {\n\nconstructor() { }\n\ngetCategories(): Observable&lt;Category[]&gt; {\nreturn new Observable();\n}\n}\n</code></pre> <pre><code>import { Component, OnInit } from '@angular/core';\nimport { MatTableDataSource } from '@angular/material/table';\nimport { Category } from '../model/Category';\nimport { CategoryService } from '../category.service';\n@Component({\nselector: 'app-category-list',\ntemplateUrl: './category-list.component.html',\nstyleUrls: ['./category-list.component.scss']\n})\nexport class CategoryListComponent implements OnInit {\n\ndataSource = new MatTableDataSource&lt;Category&gt;();\ndisplayedColumns: string[] = ['id', 'name', 'action'];\n\nconstructor(\nprivate categoryService: CategoryService,\n) { }\n\nngOnInit(): void {\nthis.categoryService.getCategories().subscribe(\ncategories =&gt; this.dataSource.data = categories\n);\n}\n}\n</code></pre>"},{"location":"develop/basic/angular/#mockeando-datos","title":"Mockeando datos","text":"<p>Como hemos comentado anteriormente, el backend todav\u00eda no est\u00e1 implementado as\u00ed que vamos a mockear datos. Nos crearemos un fichero <code>mock-categories.ts</code> dentro de model, con datos ficticios y modificaremos el servicio para que devuelva esos datos. De esta forma, cuando tengamos implementada la operaci\u00f3n de negocio en backend, tan solo tenemos que sustuir el c\u00f3digo que devuelve datos est\u00e1ticos por una llamada http.</p> mock-categories.tscategory.service.ts <pre><code>import { Category } from \"./Category\";\n\nexport const CATEGORY_DATA: Category[] = [\n{ id: 1, name: 'Dados' },\n{ id: 2, name: 'Fichas' },\n{ id: 3, name: 'Cartas' },\n{ id: 4, name: 'Rol' },\n{ id: 5, name: 'Tableros' },\n{ id: 6, name: 'Tem\u00e1ticos' },\n{ id: 7, name: 'Europeos' },\n{ id: 8, name: 'Guerra' },\n{ id: 9, name: 'Abstractos' },\n]    </code></pre> <pre><code>import { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Category } from './model/Category';\nimport { CATEGORY_DATA } from './model/mock-categories';\n@Injectable({\nprovidedIn: 'root'\n})\nexport class CategoryService {\n\nconstructor() { }\n\ngetCategories(): Observable&lt;Category[]&gt; {\nreturn of(CATEGORY_DATA);\n}\n}\n</code></pre> <p>Si ahora refrescamos la p\u00e1gina web, veremos que el listado ya tiene datos con los que vamos a interactuar.</p> <p></p>"},{"location":"develop/basic/angular/#simulando-las-otras-peticiones","title":"Simulando las otras peticiones","text":"<p>Para terminar, vamos a simular las otras dos peticiones, la de editar y la de borrar para cuando tengamos que utilizarlas. El servicio debe quedar m\u00e1s o menos as\u00ed:</p> category.service.ts <pre><code>import { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Category } from './model/Category';\nimport { CATEGORY_DATA } from './model/mock-categories';\n\n@Injectable({\nprovidedIn: 'root'\n})\nexport class CategoryService {\n\nconstructor() { }\n\ngetCategories(): Observable&lt;Category[]&gt; {\nreturn of(CATEGORY_DATA);\n}\n\nsaveCategory(category: Category): Observable&lt;Category&gt; {\nreturn of(null);\n}\ndeleteCategory(idCategory : number): Observable&lt;any&gt; {\nreturn of(null);\n}  }\n</code></pre>"},{"location":"develop/basic/angular/#anadiendo-acciones-al-listado","title":"A\u00f1adiendo acciones al listado","text":""},{"location":"develop/basic/angular/#crear-componente_2","title":"Crear componente","text":"<p>Ahora nos queda a\u00f1adir las acciones al listado: crear, editar y eliminar. Empezaremos primero por las acciones de crear y editar, que ambas deber\u00edan abrir una ventana modal con un formulario para poder modificar datos de la entidad <code>Categor\u00eda</code>. Como siempre, para crear un componente usamos el asistente de Angular, esta vez al tratarse de una pantalla que solo vamos a utilizar dentro del dominio de categor\u00edas, tiene sentido que lo creemos dentro de ese m\u00f3dulo:</p> <pre><code>ng generate component category/category-edit\n</code></pre> <p>Ahora vamos a hacer que se abra al pulsar el bot\u00f3n <code>Nueva categor\u00eda</code>. Para eso, vamos al fichero <code>category-list.component.ts</code> y a\u00f1adimos un nuevo m\u00e9todo:</p> category-list.component.ts <pre><code>...\nimport { MatDialog } from '@angular/material/dialog';\nimport { CategoryEditComponent } from '../category-edit/category-edit.component';\n...\nconstructor(\nprivate categoryService: CategoryService,\npublic dialog: MatDialog,\n) { }\n...\ncreateCategory() {    const dialogRef = this.dialog.open(CategoryEditComponent, {\ndata: {}\n});\ndialogRef.afterClosed().subscribe(result =&gt; {\nthis.ngOnInit();\n});    }  ...\n</code></pre> <p>Para poder abrir un componente dentro de un dialogo necesitamos obtener en el constructor un MatDialog. De ah\u00ed que hayamos tenido que a\u00f1adirlo como import y en el constructor.</p> <p>Dentro del m\u00e9todo <code>createCategory</code> lo que hacemos es crear un dialogo con el componente <code>CategoryEditComponent</code> en su interior, pasarle unos datos de creaci\u00f3n, donde podemos poner estilos del dialog y un objeto <code>data</code> donde pondremos los datos que queremos pasar entre los componentes. Por \u00faltimo, nos suscribimos al evento <code>afterClosed</code> para ejecutar las acciones que creamos oportunas, en nuestro caso volveremos a cargar el listado inicial.</p> <p>Como hemos utilizado un <code>MatDialog</code> en el componente, necesitamos a\u00f1adirlo tambi\u00e9n al m\u00f3dulo, as\u00ed que abrimos el fichero <code>category.module.ts</code> y a\u00f1adimos:</p> category.module.ts <pre><code>...\nimport { MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';\n@NgModule({\ndeclarations: [CategoryListComponent, CategoryEditComponent],\nimports: [\n...\nMatDialogModule\n],\nproviders: [\n{\nprovide: MAT_DIALOG_DATA,\nuseValue: {},\n},\n]\n})\nexport class CategoryModule { }\n</code></pre> <p>Y ya por \u00faltimo enlazamos el click en el bot\u00f3n con el m\u00e9todo que acabamos de crear para abrir el dialogo. Modificamos el fichero <code>category-list.component.html</code> y a\u00f1adimos el evento click:</p> category-list.component.html <pre><code>...\n&lt;div class=\"buttons\"&gt;\n&lt;button mat-flat-button color=\"primary\" (click)=\"createCategory()\"&gt;Nueva categor\u00eda&lt;/button&gt; \n&lt;/div&gt;   \n&lt;/div&gt;\n</code></pre> <p>Si refrescamos el navegador y pulsamos el bot\u00f3n <code>Nueva categor\u00eda</code> veremos como se abre una ventana modal de tipo Dialog con el componente nuevo que hemos creado, aunque solo se leer\u00e1 <code>category-edit works!</code> que es el contenido por defecto del componente.</p>"},{"location":"develop/basic/angular/#codigo-del-dialogo","title":"C\u00f3digo del dialogo","text":"<p>Ahora vamos a darle forma al formulario de editar y crear. Para ello vamos al html, ts y css del componente y pegamos el siguiente contenido:</p> category-edit.component.htmlcategory-edit.component.scsscategory-edit.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1&gt;Crear categor\u00eda&lt;/h1&gt;\n\n    &lt;form&gt;\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;Identificador&lt;/mat-label&gt;\n            &lt;input type=\"text\" matInput placeholder=\"Identificador\" [(ngModel)]=\"category.id\" name=\"id\" disabled&gt;\n        &lt;/mat-form-field&gt;\n\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;Nombre&lt;/mat-label&gt;\n            &lt;input type=\"text\" matInput placeholder=\"Nombre de categor\u00eda\" [(ngModel)]=\"category.name\" name=\"name\" required&gt;\n            &lt;mat-error&gt;El nombre no puede estar vac\u00edo&lt;/mat-error&gt;\n        &lt;/mat-form-field&gt;\n    &lt;/form&gt;\n\n    &lt;div class=\"buttons\"&gt;\n        &lt;button mat-stroked-button (click)=\"onClose()\"&gt;Cerrar&lt;/button&gt;\n        &lt;button mat-flat-button color=\"primary\" (click)=\"onSave()\"&gt;Guardar&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <pre><code>.container {\nmin-width: 350px;\nmax-width: 500px;\nwidth: 100%;\n\nform {\ndisplay: flex;\nflex-direction: column;\nmargin-bottom:20px;\n}\n\n.buttons {\ntext-align: right;\n\nbutton {\nmargin-left: 10px;\n}\n}\n}\n</code></pre> <pre><code>import { Component, OnInit } from '@angular/core';\nimport { MatDialogRef } from '@angular/material/dialog';\nimport { CategoryService } from '../category.service';\nimport { Category } from '../model/Category';\n\n@Component({\nselector: 'app-category-edit',\ntemplateUrl: './category-edit.component.html',\nstyleUrls: ['./category-edit.component.scss']\n})\nexport class CategoryEditComponent implements OnInit {\n\ncategory : Category;\n\nconstructor(\npublic dialogRef: MatDialogRef&lt;CategoryEditComponent&gt;,\nprivate categoryService: CategoryService\n) { }\n\nngOnInit(): void {\nthis.category = new Category();\n}\n\nonSave() {\nthis.categoryService.saveCategory(this.category).subscribe(result =&gt; {\nthis.dialogRef.close();\n});    }  onClose() {\nthis.dialogRef.close();\n}\n\n}\n</code></pre> <p>Si te fijas en el c\u00f3digo TypeScript, hemos a\u00f1adido en el m\u00e9todo <code>onSave</code> una llamada al servicio de <code>CategoryService</code> que aunque no realice ninguna operaci\u00f3n de momento, por lo menos lo dejamos preparado para conectar con el servidor.</p> <p>Adem\u00e1s, como siempre, al utilizar componentes <code>matInput</code>, <code>matForm</code>, <code>matError</code> hay que a\u00f1adirlos como dependencias en el m\u00f3dulo <code>category.module.ts</code>:</p> category.module.ts <pre><code>...\nimport { MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';\nimport { MatFormFieldModule } from '@angular/material/form-field';\nimport { MatInputModule } from '@angular/material/input';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\n@NgModule({\ndeclarations: [CategoryListComponent, CategoryEditComponent],\nimports: [\n...\nMatDialogModule,\nMatFormFieldModule,\nMatInputModule,\nFormsModule,\nReactiveFormsModule,\n],\nproviders: [\n{\nprovide: MAT_DIALOG_DATA,\nuseValue: {},\n},\n]\n})\nexport class CategoryModule { }\n</code></pre> <p>Ahora podemos navegar y abrir el cuadro de dialogo mediante el bot\u00f3n <code>Nueva categor\u00eda</code> para ver como queda nuestro formulario.</p>"},{"location":"develop/basic/angular/#utilizar-el-dialogo-para-editar","title":"Utilizar el dialogo para editar","text":"<p>El mismo componente que hemos utilizado para crear una nueva categor\u00eda, nos sirve tambi\u00e9n para editar una categor\u00eda existente. Tan solo tenemos que utilizar la funcionalidad que Angular nos proporciona y pasarle los datos a editar en la llamada de apertura del Dialog. Vamos a implementar funcionalidad sobre el icono <code>editar</code>, tendremos que modificar unos cuantos ficheros:</p> category-list.component.htmlcategory-list.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1&gt;Listado de Categor\u00edas&lt;/h1&gt;\n\n    &lt;mat-table [dataSource]=\"dataSource\"&gt; \n        &lt;ng-container matColumnDef=\"id\"&gt;\n            &lt;mat-header-cell *matHeaderCellDef&gt; Identificador &lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.id}} &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n        &lt;ng-container matColumnDef=\"name\"&gt;\n            &lt;mat-header-cell *matHeaderCellDef&gt; Nombre categor\u00eda  &lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.name}} &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n        &lt;ng-container matColumnDef=\"action\"&gt;\n            &lt;mat-header-cell *matHeaderCellDef&gt;&lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt;\n&lt;button mat-icon-button color=\"primary\" (click)=\"editCategory(element)\"&gt;\n&lt;mat-icon&gt;edit&lt;/mat-icon&gt;\n&lt;/button&gt;\n&lt;button mat-icon-button color=\"accent\"&gt;&lt;mat-icon&gt;clear&lt;/mat-icon&gt;&lt;/button&gt;\n            &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n        &lt;mat-header-row *matHeaderRowDef=\"displayedColumns; sticky: true\"&gt;&lt;/mat-header-row&gt;\n        &lt;mat-row *matRowDef=\"let row; columns: displayedColumns;\"&gt;&lt;/mat-row&gt;\n    &lt;/mat-table&gt;\n\n    &lt;div class=\"buttons\"&gt;\n        &lt;button mat-flat-button color=\"primary\" (click)=\"createCategory()\"&gt;Nueva categor\u00eda&lt;/button&gt; \n    &lt;/div&gt;   \n&lt;/div&gt;\n</code></pre> <pre><code>export class CategoryListComponent implements OnInit {\n\ndataSource = new MatTableDataSource&lt;Category&gt;();\ndisplayedColumns: string[] = ['id', 'name', 'action'];\n\nconstructor(\nprivate categoryService: CategoryService,\npublic dialog: MatDialog,\n) { }\n\nngOnInit(): void {\nthis.categoryService.getCategories().subscribe(\ncategories =&gt; this.dataSource.data = categories\n);\n}\n\ncreateCategory() {    const dialogRef = this.dialog.open(CategoryEditComponent, {\ndata: {}\n});\n\ndialogRef.afterClosed().subscribe(result =&gt; {\nthis.ngOnInit();\n});    }  editCategory(category: Category) {\nconst dialogRef = this.dialog.open(CategoryEditComponent, {\ndata: { category: category }\n});\ndialogRef.afterClosed().subscribe(result =&gt; {\nthis.ngOnInit();\n});\n}\n}\n</code></pre> <p>Y los Dialog:</p> category-edit.component.htmlcategory-edit.component.ts <pre><code>&lt;div class=\"container\"&gt;\n&lt;h1 *ngIf=\"category.id == null\"&gt;Crear categor\u00eda&lt;/h1&gt;\n&lt;h1 *ngIf=\"category.id != null\"&gt;Modificar categor\u00eda&lt;/h1&gt;\n&lt;form&gt;\n&lt;mat-form-field&gt;\n...\n</code></pre> <pre><code>import { Component, OnInit, Inject } from '@angular/core';\nimport { MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';\nimport { CategoryService } from '../category.service';\nimport { Category } from '../model/Category';\n\n@Component({\nselector: 'app-category-edit',\ntemplateUrl: './category-edit.component.html',\nstyleUrls: ['./category-edit.component.scss']\n})\nexport class CategoryEditComponent implements OnInit {\n\ncategory : Category;\n\nconstructor(\npublic dialogRef: MatDialogRef&lt;CategoryEditComponent&gt;,\n@Inject(MAT_DIALOG_DATA) public data: any,\nprivate categoryService: CategoryService\n) { }\n\nngOnInit(): void {\nif (this.data.category != null) {\nthis.category = this.data.category;\n}\nelse {\nthis.category = new Category();\n}\n}\n\nonSave() {\nthis.categoryService.saveCategory(this.category).subscribe(result =&gt; {\nthis.dialogRef.close();\n});    }  onClose() {\nthis.dialogRef.close();\n}\n\n}\n</code></pre> <p>Navegando ahora por la p\u00e1gina y pulsando en el icono de editar, se deber\u00eda abrir una ventana con los datos que hemos seleccionado, similar a esta imagen:</p> <p></p> <p>Si te fijas, al modificar los datos dentro de la ventana de di\u00e1logo se modifica tambi\u00e9n en el listado. Esto es porque estamos pasando el mismo objeto desde el listado a la ventana dialogo y al ser el listado y el formulario reactivos los dos, cualquier cambio sobre los datos se refresca directamente en la pantalla. </p> <p>Hay veces en la que este comportamiento nos interesa, pero en este caso no queremos que se modifique el listado. Para solucionarlo debemos hacer una copia del objeto, para que ambos modelos (formulario y listado) utilicen objetos diferentes. Es tan sencillo como modificar <code>category-edit.component.ts</code> y a\u00f1adirle una copia del dato</p> category-edit.component.ts <pre><code>    ...\nngOnInit(): void {\nif (this.data.category != null) {\nthis.category = Object.assign({}, this.data.category);\n}\nelse {\nthis.category = new Category();\n}\n}\n...\n</code></pre> <p>Cuidado</p> <p>Hay que tener mucho cuidado con el binding de los objetos. Hay veces que al modificar un objeto NO queremos que se modifique en todas sus instancias y tenemos que poner especial cuidado en esos aspectos.</p>"},{"location":"develop/basic/angular/#accion-de-borrado","title":"Acci\u00f3n de borrado","text":"<p>Por norma general, toda acci\u00f3n de borrado de un dato de pantalla requiere una confirmaci\u00f3n previa por parte del usuario. Es decir, para evitar que el dato se borre accidentalmente el usuario tendr\u00e1 que confirmar su acci\u00f3n. Por tanto vamos a crear un componente que nos permita pedir una confirmaci\u00f3n al usuario.</p> <p>Como esta pantalla de confirmaci\u00f3n va a ser algo com\u00fan a muchas acciones de borrado de nuestra aplicaci\u00f3n, vamos a crearla dentro del m\u00f3dulo <code>core</code>. Como siempre, ejecutamos el comando en consola:</p> <pre><code>ng generate component core/dialog-confirmation\n</code></pre> <p>E implementamos el c\u00f3digo que queremos que tenga el componente. Al ser un componente gen\u00e9rico vamos a aprovechar y leeremos las variables que le pasemos en <code>data</code>.</p> dialog-confirmation.component.htmldialog-confirmation.component.scssdialog-confirmation.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1&gt;{{title}}&lt;/h1&gt;\n    &lt;div [innerHTML]=\"description\" class=\"description\"&gt;&lt;/div&gt;\n\n    &lt;div class=\"buttons\"&gt;\n        &lt;button mat-stroked-button (click)=\"onNo()\"&gt;No&lt;/button&gt;\n        &lt;button mat-flat-button color=\"primary\" (click)=\"onYes()\"&gt;S\u00ed&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/div&gt;    \n</code></pre> <pre><code>.container {\nmin-width: 350px;\nmax-width: 500px;\nwidth: 100%;\n\n.description {\nmargin-bottom: 20px;\n}\n\n.buttons {\ntext-align: right;\n\nbutton {\nmargin-left: 10px;\n}\n}\n}    </code></pre> <pre><code>import { Component, OnInit, Inject } from '@angular/core';\nimport { MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';\n\n@Component({\nselector: 'app-dialog-confirmation',\ntemplateUrl: './dialog-confirmation.component.html',\nstyleUrls: ['./dialog-confirmation.component.scss']\n})\nexport class DialogConfirmationComponent implements OnInit {\n\ntitle : string;\ndescription : string;\n\nconstructor(\npublic dialogRef: MatDialogRef&lt;DialogConfirmationComponent&gt;,\n@Inject(MAT_DIALOG_DATA) public data: any\n) { }\n\nngOnInit(): void {\nthis.title = this.data.title;\nthis.description = this.data.description;\n}\n\nonYes() {\nthis.dialogRef.close(true);\n}\n\nonNo() {\nthis.dialogRef.close(false);\n}\n}\n</code></pre> <p>Recuerda</p> <p>Recuerda que los componentes utilizados en el di\u00e1logo de confirmaci\u00f3n se deben a\u00f1adir al m\u00f3dulo padre al que pertenecen, en este caso a <code>core.module.ts</code> <pre><code>imports: [\n  CommonModule,\n  RouterModule,\n  MatIconModule, \n  MatToolbarModule,\n  MatDialogModule,\n  MatButtonModule,\n],\nproviders: [\n  {\n    provide: MAT_DIALOG_DATA,\n    useValue: {},\n  },\n],\n</code></pre></p> <p>Ya por \u00faltimo, una vez tenemos el componente gen\u00e9rico de dialogo, vamos a utilizarlo en nuestro listado al pulsar el bot\u00f3n eliminar:</p> category-list.component.htmlcategory-list.component.ts <pre><code>    ...\n    &lt;ng-container matColumnDef=\"action\"&gt;\n        &lt;mat-header-cell *matHeaderCellDef&gt;&lt;/mat-header-cell&gt;\n        &lt;mat-cell *matCellDef=\"let element\"&gt;\n            &lt;button mat-icon-button color=\"primary\" (click)=\"editCategory(element)\"&gt;\n                &lt;mat-icon&gt;edit&lt;/mat-icon&gt;\n            &lt;/button&gt;\n            &lt;button mat-icon-button color=\"accent\" (click)=\"deleteCategory(element)\"&gt;\n&lt;mat-icon&gt;clear&lt;/mat-icon&gt;\n&lt;/button&gt;\n        &lt;/mat-cell&gt;\n    &lt;/ng-container&gt;\n    ...\n</code></pre> <pre><code>  ...\ndeleteCategory(category: Category) {    const dialogRef = this.dialog.open(DialogConfirmationComponent, {\ndata: { title: \"Eliminar categor\u00eda\", description: \"Atenci\u00f3n si borra la categor\u00eda se perder\u00e1n sus datos.&lt;br&gt; \u00bfDesea eliminar la categor\u00eda?\" }\n});\ndialogRef.afterClosed().subscribe(result =&gt; {\nif (result) {\nthis.categoryService.deleteCategory(category.id).subscribe(result =&gt; {\nthis.ngOnInit();\n}); }\n});\n}  ...    </code></pre> <p>Aqu\u00ed tambi\u00e9n hemos realizado la llamada a <code>categoryService</code>, aunque no se realice ninguna acci\u00f3n, pero as\u00ed lo dejamos listo para enlazarlo.</p> <p>Llegados a este punto, ya solo nos queda enlazar las acciones de la pantalla con las operaciones de negocio del backend.</p>"},{"location":"develop/basic/angular/#conectar-con-backend","title":"Conectar con Backend","text":"<p>Antes de seguir</p> <p>Antes de seguir con este punto, debes implementar el c\u00f3digo de backend en la tecnolog\u00eda que quieras (Springboot o Nodejs). Si has empezado este cap\u00edtulo implementando el frontend, por favor accede a la secci\u00f3n correspondiente de backend para poder continuar con el tutorial. Una vez tengas implementadas todas las operaciones para este listado, puedes volver a este punto y continuar con Angular.</p> <p>El siguiente paso, como es obvio ser\u00e1 hacer que Angular llame directamente al servidor backend para leer y escribir datos y eliminar los datos mockeados en Angular.</p> <p>Manos a la obra!</p>"},{"location":"develop/basic/angular/#llamada-del-listado","title":"Llamada del listado","text":"<p>La idea es que el m\u00e9todo <code>getCategories()</code> de <code>category.service.ts</code> en lugar de devolver datos est\u00e1ticos, realice una llamada al servidor a la ruta <code>http://localhost:8080/category</code>.</p> <p>Abrimos el fichero y susituimos la l\u00ednea que antes devolv\u00eda los datos est\u00e1ticos por esto:</p> category.service.ts <pre><code>import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Category } from './model/Category';\n\n@Injectable({\nprovidedIn: 'root'\n})\nexport class CategoryService { constructor(\nprivate http: HttpClient\n) { }\n\ngetCategories(): Observable&lt;Category[]&gt; {\nreturn this.http.get&lt;Category[]&gt;('http://localhost:8080/category');\n}\n\nsaveCategory(category: Category): Observable&lt;Category&gt; {\nreturn of(null);\n}\n\ndeleteCategory(idCategory : number): Observable&lt;any&gt; {\nreturn of(null);\n}  }\n</code></pre> <p>Como hemos a\u00f1adido un componente nuevo <code>HttpClient</code> tenemos que a\u00f1adir la dependencia al m\u00f3dulo padre.</p> category.module.ts <pre><code>import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { MatTableModule } from '@angular/material/table';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatButtonModule } from '@angular/material/button';\nimport { CategoryListComponent } from './category-list/category-list.component';\nimport { CategoryEditComponent } from './category-edit/category-edit.component';\nimport { MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';\nimport { MatFormFieldModule } from '@angular/material/form-field';\nimport { MatInputModule } from '@angular/material/input';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { HttpClientModule } from '@angular/common/http';\n@NgModule({\ndeclarations: [CategoryListComponent, CategoryEditComponent],\nimports: [\nCommonModule,\nMatTableModule,\nMatIconModule, MatButtonModule,\nMatDialogModule,\nMatFormFieldModule,\nMatInputModule,\nFormsModule,\nReactiveFormsModule,\nHttpClientModule,\n],\nproviders: [\n{\nprovide: MAT_DIALOG_DATA,\nuseValue: {},\n},\n]\n})\nexport class CategoryModule { }\n</code></pre> <p>Si ahora refrescas el navegador (recuerda tener arrancado tambi\u00e9n el servidor) y accedes a la pantalla de <code>Categor\u00edas</code> deber\u00eda aparecer el listado con los datos que vienen del servidor.</p> <p></p>"},{"location":"develop/basic/angular/#llamada-de-guardado-edicion","title":"Llamada de guardado / edici\u00f3n","text":"<p>Para la llamada de guardado har\u00edamos lo mismo, pero invocando la operaci\u00f3n de negocio <code>put</code>.</p> category.service.ts <pre><code>import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Category } from './model/Category';\n\n@Injectable({\nprovidedIn: 'root'\n})\nexport class CategoryService { constructor(\nprivate http: HttpClient\n) { }\n\ngetCategories(): Observable&lt;Category[]&gt; {\nreturn this.http.get&lt;Category[]&gt;('http://localhost:8080/category');\n}\n\nsaveCategory(category: Category): Observable&lt;Category&gt; {\n\nlet url = 'http://localhost:8080/category';\nif (category.id != null) url += '/'+category.id;\nreturn this.http.put&lt;Category&gt;(url, category);\n}\n\ndeleteCategory(idCategory : number): Observable&lt;any&gt; {\nreturn of(null);\n}  } </code></pre> <p>Ahora podemos probar a modificar o a\u00f1adir una nueva categor\u00eda desde la pantalla y deber\u00eda aparecer los nuevos datos en el listado.</p>"},{"location":"develop/basic/angular/#llamada-de-borrado","title":"Llamada de borrado","text":"<p>Y ya por \u00faltimo, la llamada de borrado, deber\u00edamos cambiarla e invocar a la operaci\u00f3n de negocio <code>delete</code>.</p> category.service.ts <pre><code>import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Category } from './model/Category';\n\n@Injectable({\nprovidedIn: 'root'\n})\nexport class CategoryService { constructor(\nprivate http: HttpClient\n) { }\n\ngetCategories(): Observable&lt;Category[]&gt; {\nreturn this.http.get&lt;Category[]&gt;('http://localhost:8080/category');\n}\n\nsaveCategory(category: Category): Observable&lt;Category&gt; {\n\nlet url = 'http://localhost:8080/category';\nif (category.id != null) url += '/'+category.id;\n\nreturn this.http.put&lt;Category&gt;(url, category);\n}\n\ndeleteCategory(idCategory : number): Observable&lt;any&gt; {\nreturn this.http.delete('http://localhost:8080/category/'+idCategory);\n}  } </code></pre> <p>Ahora podemos probar a modificar o a\u00f1adir una nueva categor\u00eda desde la pantalla y deber\u00eda aparecer los nuevos datos en el listado.</p> <p>Como ves, es bastante sencillo conectar server y client.</p>"},{"location":"develop/basic/angular/#depuracion","title":"Depuraci\u00f3n","text":"<p>Una parte muy importante del desarrollo es tener la capacidad de depurar nuestro c\u00f3digo, en este apartado vamos a explicar como se realiza <code>debug</code> en Front.</p> <p>Esta parte se puede realizar con nuestro navegador favorito, en este caso vamos a utilizar Chrome.</p> <p>El primer paso es abrir las herramientas del desarrollador del navegador presionando <code>F12</code>.</p> <p></p> <p>En esta herramienta tenemos varias partes importantes:</p> <ul> <li>Elements: Inspector de los elementos del DOM de nuestra aplicaci\u00f3n que nos ayuda identificar el c\u00f3digo generado.</li> <li>Console: Consola donde podemos ver mensajes importantes que nos ayudan a identificar posibles problemas.</li> <li>Source: El navegador de ficheros que componen nuestra aplicaci\u00f3n.</li> <li>Network: El registro de peticiones que realiza nuestra aplicaci\u00f3n.</li> </ul> <p>Identificados los elementos importantes, vamos a depurar la operaci\u00f3n de crear categor\u00eda.</p> <p>Para ello nos dirigimos a la pesta\u00f1a de <code>Source</code>, en el \u00e1rbol de carpetas nos dirigimos a la ruta donde est\u00e1 localizado el c\u00f3digo de nuestra aplicaci\u00f3n <code>webpack://src/app</code>.</p> <p>Dentro de esta carpeta est\u00e9 localizado todo el c\u00f3digo fuente de la aplicaci\u00f3n, en nuestro caso vamos a localizar componente <code>category-edit.component</code> que crea una nueva categor\u00eda.</p> <p>Dentro del fichero ya podemos a\u00f1adir puntos de ruptura (breakpoint), en nuestro caso queremos comprobar que el nombre introducido se captura bien y se env\u00eda al service correctamente.</p> <p>Colocamos el breakpoint en la l\u00ednea de invocaci\u00f3n del service (click sobre el n\u00famero de la l\u00ednea) y desde la interfaz creamos una nueva categor\u00eda.</p> <p>Hecho esto, podemos observar que a nivel de interfaz, la aplicaci\u00f3n se detiene y aparece un panel de manejo de los puntos de interrupci\u00f3n:</p> <p></p> <p>En cuanto a la herramienta del desarrollador nos lleva al punto exacto donde hemos a\u00f1adido el breakpoint y se para en este punto ofreci\u00e9ndonos la posibilidad de explorar el contenido de las variables del c\u00f3digo:</p> <p></p> <p>Aqu\u00ed podemos comprobar que efectivamente la variable <code>category</code> tiene el valor que hemos introducido por pantalla y se propaga correctamente hacia el service.</p> <p>Para continuar con la ejecuci\u00f3n basta con darle al bot\u00f3n de <code>play</code> del panel de manejo de interrupci\u00f3n o al que aparece dentro de la herramienta de desarrollo (parte superior derecha).</p> <p>Por \u00faltimo, vamos a revisar que la petici\u00f3n REST se ha realizado correctamente al backend, para ello nos dirigimos a la pesta\u00f1a <code>Network</code> y comprobamos las peticiones realizadas:</p> <p></p> <p>Aqu\u00ed podemos observar el registro de todas las peticiones y haciendo click sobre una de ellas, obtenemos el detalle de esta.</p> <ul> <li>Header: Informaci\u00f3n de las cabeceras enviadas (aqu\u00ed podemos ver que se ha hecho un PUT a la ruta correcta).</li> <li>Payload: El cuerpo de la petici\u00f3n (vemos el cuerpo del mensaje con el nombre enviado).</li> <li>Preview: Respuesta de la petici\u00f3n normalizada (vemos la respuesta con el identificador creado para la nueva categor\u00eda).</li> </ul>"},{"location":"develop/basic/nodejs/","title":"Listado simple - Nodejs","text":"<p>Ahora que ya tenemos listo el proyecto backend de nodejs (en el puerto 8080) ya podemos empezar a codificar la soluci\u00f3n.</p>"},{"location":"develop/basic/nodejs/#primeros-pasos","title":"Primeros pasos","text":"<p>Antes de empezar</p> <p>Quiero hacer hincapi\u00e9 en Node tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. Tanto en la web de node como de express encontrar\u00e1s informaci\u00f3n detallada del proceso que vamos a seguir.</p>"},{"location":"develop/basic/nodejs/#estructurar-el-codigo","title":"Estructurar el c\u00f3digo","text":"<p>La estructura de nuestro proyecto ser\u00e1 la siguiente:</p> <p></p> <p>Vamos a aplicar una separaci\u00f3n por capas. En primer lugar, tendremos una capa de rutas para reenviar las solicitudes admitidas y cualquier informaci\u00f3n codificada en las urls de solicitud a la siguiente capa de controladores. La capa de control procesar\u00e1 las peticiones de las rutas y se comunicar\u00e1 con la capa de servicios devolviendo la respuesta de esta mediante respuestas http. En la capa de servicio se ejecutar\u00e1 toda la l\u00f3gica de la petici\u00f3n y se comunicar\u00e1 con los modelos de base de datos</p> <p>En nuestro caso una ruta es una secci\u00f3n de c\u00f3digo Express que asocia un verbo HTTP (GET, POST, PUT, DELETE, etc.), una ruta/patr\u00f3n de URL y una funci\u00f3n que se llama para manejar ese patr\u00f3n.</p> <p>\u00a1Ahora s\u00ed, vamos a programar!</p>"},{"location":"develop/basic/nodejs/#capa-de-routes","title":"Capa de Routes","text":"<p>Lo primero de vamos a crear es la carpeta principal de nuestra aplicaci\u00f3n donde estar\u00e1n contenidos los distintos elementos de la misma. Para ello creamos una carpeta llamada <code>src</code> en la ra\u00edz de nuestra aplicaci\u00f3n.</p> <p>El primero elemento que vamos a crear va a ser el fichero de rutas para la categor\u00eda. Para ello creamos una carpeta llamada <code>routes</code> en la carpeta <code>src</code> y dentro de esta carpeta crearemos un archivo llamado <code>category.routes.js</code>:</p> category.routes.js <pre><code>import { Router } from 'express';\nimport { createCategory } from '../controllers/category.controller.js';\n\nconst categoryRouter = Router();\ncategoryRouter.put('/', createCategory);\n\nexport default categoryRouter;\n</code></pre> <p>En este archivo estamos creando una ruta de tipo PUT que llamara al m\u00e9todo <code>createCategory</code> de nuestro futuro controlador de categor\u00edas (aunque todav\u00eda no lo hemos creado y por tanto fallar\u00e1).</p> <p>Ahora en nuestro archivo <code>index.js</code> vamos a a\u00f1adir lo siguiente justo despu\u00e9s de declarar la constante app:</p> index.js <pre><code>...\nimport categoryRouter from './src/routes/category.routes.js';\n...\n\n...\napp.use(cors({\norigin: '*'\n}));\n\napp.use(express.json());\napp.use('/category', categoryRouter);\n\n...\n</code></pre> <p>De este modo estamos asociando la url <code>http://localhost:8080/category</code> a nuestro router. Tambi\u00e9n usaremos <code>express.json()</code> para parsear las peticiones entrantes a formato json.</p>"},{"location":"develop/basic/nodejs/#capa-de-controller","title":"Capa de Controller","text":"<p>Lo siguiente ser\u00e1 crear el m\u00e9todo createCategory en nuestro controller. Para ello lo primero ser\u00e1 crear una carpeta <code>controllers</code> en la carpeta <code>src</code> de nuestro proyecto y dentro de esta un archivo llamado <code>category.controller.js</code>:</p> category.controller.js <pre><code>export const createCategory = async (req, res) =&gt; {\nconsole.log(req.body);\nres.status(200).json(1);\n}\n</code></pre> <p>Hemos creado la funci\u00f3n <code>createCategory</code> que recibir\u00e1 una request y una response. Estos par\u00e1metros vienen de la ruta de express y son la request y response de la petici\u00f3n HTTP. De momento simplemente vamos a hacer un <code>console.log</code> de <code>req.body</code> para ver el body de la petici\u00f3n y vamos a hacer una response 200 para indicar que todo ha ido correctamente.</p> <p>Si arrancamos el servidor y hacemos una petici\u00f3n <code>PUT</code> con Postman a <code>http://localhost:8080/category</code> con un body que pongamos formado correctamente podremos ver la salida que hemos programado en nuestro controller y en la consola de node podemos ver el contenido de <code>req.body</code>.</p> <p></p> <p></p>"},{"location":"develop/basic/nodejs/#capa-de-modelo","title":"Capa de Modelo","text":"<p>Ahora para que los datos que pasemos en el body los podamos guardar en BBDD necesitaremos un modelo y un esquema para la entidad <code>Category</code>. Vamos a crear una carpeta llamada <code>schemas</code> en la carpeta <code>src</code> de nuestro proyecto. Un schema no es m\u00e1s que un modelo de BBDD que especifica que campos estar\u00e1n presentes y cu\u00e1les ser\u00e1n sus tipos. Dentro de la carpeta de schemas creamos un archivo con el nombre <code>category.schema.js</code>:</p> category.schema.js <pre><code>import mongoose from \"mongoose\";\nconst { Schema, model } = mongoose;\nimport normalize from 'normalize-mongoose';\n\nconst categorySchema = new Schema({\nname: {\ntype: String,\nrequire: true\n}\n});\ncategorySchema.plugin(normalize);\nconst CategoryModel = model('Category', categorySchema);\n\nexport default CategoryModel;\n</code></pre> <p>En este archivo estamos definiendo nuestro schema indicando sus propiedades y tipos, en nuestro caso \u00fanicamente <code>name</code>. Adem\u00e1s del tipo tambi\u00e9n indicaremos que el campo es obligatorio con la validation require para indicar que ese campo es obligatorio. Si quieres conocer otras validaciones aqu\u00ed tienes m\u00e1s info. Aparte de definir nuestro schema tambi\u00e9n lo estamos transformado en un modelo para poder trabajar con \u00e9l. En el constructor de model le pasamos el nombre del modelo y el schema que vamos a utilizar.</p>"},{"location":"develop/basic/nodejs/#capa-de-servicio","title":"Capa de Servicio","text":"<p>Como hemos visto en nuestra estructura la capa controller no puede comunicarse con la capa modelo, debe de haber una capa intermedia, para ello vamos a crear una carpeta <code>services</code> en la carpeta <code>src</code> de nuestro proyecto y dentro un archivo <code>category.service.js</code>:</p> category.service.js <pre><code>import CategoryModel from '../schemas/category.schema.js';\n\nexport const createCategory = async function(name) {\ntry {\nconst category = new CategoryModel({ name });\nreturn await category.save();\n} catch (e) {\nthrow Error('Error creating category');\n}\n}\n</code></pre> <p>Hemos importado el modelo de categor\u00eda para poder realizar acciones sobre la BBDD y hemos creado una funci\u00f3n que recoger\u00e1 el nombre de la categor\u00eda y crear\u00e1 una nueva categor\u00eda con \u00e9l. Llamamos al m\u00e9todo save para guardar nuestra categor\u00eda y devolvemos el resultado. Ahora en nuestro m\u00e9todo del controller solo tenemos que llamar al servicio pas\u00e1ndole los par\u00e1metros que nos llegan en la petici\u00f3n:</p> category.controller.js <pre><code>import * as CategoryService from '../services/category.service.js';\n\nexport const createCategory = async (req, res) =&gt; {\nconst { name } = req.body;\ntry {\nconst category = await CategoryService.createCategory(name);\nres.status(200).json({\ncategory\n});\n} catch (err) {\nres.status(400).json({\nmsg: err.toString()\n});\n}\n}\n</code></pre> <p>Si todo ha ido correctamente llamaremos al m\u00e9todo de respuesta con el c\u00f3digo 200 y la categor\u00eda creada. En caso contrario mandaremos un c\u00f3digo de error. Si ahora de nuevo vamos a postman y volvemos a lanzar nuestra petici\u00f3n podemos ver como nos devuelve una nueva categor\u00eda:</p> <p></p>"},{"location":"develop/basic/nodejs/#resto-de-operaciones","title":"Resto de Operaciones","text":""},{"location":"develop/basic/nodejs/#recuperacion-categorias","title":"Recuperaci\u00f3n categor\u00edas","text":"<p>Ahora que ya podemos crear categor\u00edas lo siguiente ser\u00e1 crear un endpoint para recuperar las categor\u00edas creadas en nuestra base de datos. Podemos empezar a\u00f1adiendo un nuevo m\u00e9todo en nuestro servicio:</p> category.service.js <pre><code>export const getCategories = async function () {\ntry {\nreturn await CategoryModel.find().sort('name');\n} catch (e) {\nthrow Error('Error fetching categories');\n}\n}\n</code></pre> <p>Al igual que en el anterior m\u00e9todo haremos uso del modelo, pero esta vez para hacer un <code>find</code> y ordenando los resultados por el campo <code>name</code>. Al m\u00e9todo find se le pueden pasar <code>queries</code>, <code>projections</code> y <code>options</code>. Te dejo por aqu\u00ed m\u00e1s info. En nuestro caso simplemente queremos que nos devuelva todas las categor\u00edas por lo que no le pasaremos nada.</p> <p>Creamos tambi\u00e9n un m\u00e9todo en el controlador para recuperar las categor\u00edas y que har\u00e1 uso del servicio:</p> category.controller.js <pre><code>export const getCategories = async (req, res) =&gt; {\ntry {\nconst categories = await CategoryService.getCategories();\nres.status(200).json(\ncategories\n);\n} catch (err) {\nres.status(400).json({\nmsg: err.toString()\n});\n}\n}\n</code></pre> <p>Y ahora que ya tenemos el m\u00e9todo creado en el controlador lo siguiente ser\u00e1 relacionar este m\u00e9todo con una ruta. Para ello en nuestro archivo <code>category.routes.js</code> tendremos que a\u00f1adir una nueva l\u00ednea:</p> category.routes.js <pre><code>import { Router } from 'express';\nimport { createCategory, getCategories } from '../controllers/category.controller.js';\n\nconst categoryRouter = Router();\ncategoryRouter.put('/', createCategory);\ncategoryRouter.get('/', getCategories);\n\nexport default categoryRouter;\n</code></pre> <p>De este modo cuando hagamos una petici\u00f3n GET a <code>http://localhost:8080/category</code> nos devolver\u00e1 el listado de categor\u00edas existentes: </p> <p></p>"},{"location":"develop/basic/nodejs/#actualizar-categoria","title":"Actualizar categor\u00eda","text":"<p>Ahora vamos a por el m\u00e9todo para actualizar nuestras categor\u00edas. En el servicio creamos el siguiente m\u00e9todo:</p> category.service.js <pre><code>export const updateCategory = async (id, name) =&gt; {\ntry {\nconst category = await CategoryModel.findById(id);\nif (!category) {\nthrow Error('There is no category with that Id');\n}    return await CategoryModel.findByIdAndUpdate(id, {name});\n} catch (e) {\nthrow Error(e);\n}\n}\n</code></pre> <p>A este m\u00e9todo le pasaremos de entrada el <code>id</code> y el <code>nombre</code>. Con ese <code>id</code> realizaremos una b\u00fasqueda para asegurarnos que esa categor\u00eda existe en nuestra base de datos. Si existe la categor\u00eda haremos una petici\u00f3n con <code>findByIdAndUpdate</code> donde el primer par\u00e1metro es el <code>id</code> y el segundo es el resto de los campos de nuestra entidad. </p> <p>En el controlador creamos el m\u00e9todo correspondiente:</p> category.controller.js <pre><code>export const updateCategory = async (req, res) =&gt; {\nconst categoryId = req.params.id;\nconst { name } = req.body;\ntry {\nawait CategoryService.updateCategory(categoryId, name);\nres.status(200).json(1);\n} catch (err) {\nres.status(400).json({\nmsg: err.toString()\n});\n}\n}\n</code></pre> <p>Aqu\u00ed recogeremos el par\u00e1metro <code>id</code> que nos vendr\u00e1 en la url, por ejemplo: <code>http://localhost:8080/category/1</code>. Esto lo hacemos con <code>req.params.id</code>. El <code>id</code> es el nombre de la variable que le daremos en el router como veremos m\u00e1s adelante.  Y una vez creado el m\u00e9todo en el controlador tendremos que a\u00f1adir la ruta en nuestro fichero de rutas correspondiente, pero como ya hemos dicho tendremos que indicar que nuestra ruta espera un par\u00e1metro id, lo haremos de la siguiente forma:</p> category.routes.js <pre><code>import { Router } from 'express';\nimport { createCategory, getCategories, updateCategory } from '../controllers/category.controller.js';\n\nconst categoryRouter = Router();\ncategoryRouter.put('/', createCategory);\ncategoryRouter.get('/', getCategories);\ncategoryRouter.put('/:id', updateCategory);\n\nexport default categoryRouter;\n</code></pre> <p>Y volvemos a probar en Postman:</p> <p></p> <p>Y si hacemos de nuevo un <code>GET</code> vemos como la categor\u00eda se ha modificado correctamente:</p> <p></p>"},{"location":"develop/basic/nodejs/#borrado-categoria","title":"Borrado categor\u00eda","text":"<p>Ya solo nos faltar\u00eda la operaci\u00f3n de <code>delete</code> para completar nuestro CRUD, en el servicio a\u00f1adimos un nuevo m\u00e9todo:</p> category.service.js <pre><code>export const deleteCategory = async (id) =&gt; {\ntry {\nconst category = await CategoryModel.findById(id);\nif (!category) {\nthrow Error('There is no category with that Id');\n}\nreturn await CategoryModel.findByIdAndDelete(id);\n} catch (e) {\nthrow Error('Error deleting category');\n}\n}\n</code></pre> <p>Como vemos es muy parecido al update, recuperamos el <code>id</code> de los par\u00e1metros de la ruta y en este caso llamaremos al m\u00e9todo <code>findByIdAndDelete</code>. En nuestro controlador creamos el m\u00e9todo correspondiente:</p> category.controller.js <pre><code>export const deleteCategory = async (req, res) =&gt; {\nconst categoryId = req.params.id;\ntry {\nconst deletedCategory = await CategoryService.deleteCategory(categoryId);\nres.status(200).json({\ncategory: deletedCategory\n});\n} catch (err) {\nres.status(400).json({\nmsg: err.toString()\n});\n}\n}\n</code></pre> <p>Y de nuevo a\u00f1adimos la ruta correspondiente al archivo de rutas:</p> category.routes.js <pre><code>import { Router } from 'express';\nimport { createCategory, getCategories, updateCategory, deleteCategory } from '../controllers/category.controller.js';\n\nconst categoryRouter = Router();\ncategoryRouter.put('/', createCategory);\ncategoryRouter.get('/', getCategories);\ncategoryRouter.put('/:id', updateCategory);\ncategoryRouter.delete('/:id', deleteCategory);\n\nexport default categoryRouter;\n</code></pre> <p>Y de nuevo, probamos en postman:</p> <p></p> <p>Hacemos un get para comprobar que se ha borrado de nuestra base de datos:</p> <p></p>"},{"location":"develop/basic/nodejs/#capa-de-middleware-validaciones","title":"Capa de Middleware (Validaciones)","text":"<p>Antes de pasar a nuestro siguiente CRUD vamos a ver en que consiste la <code>Capa de Middleware</code>.  Un <code>middleware</code> es un c\u00f3digo que se ejecuta antes de que una petici\u00f3n http llegue a nuestro manejador de rutas o antes de que el cliente reciba una respuesta. </p> <p>En nuestro caso vamos a crear un middleware para asegurarnos que todos los campos que necesitamos en nuestras entidades vienen en el body de la petici\u00f3n. Vamos a crear una carpeta <code>middlewares</code> en la carpeta <code>src</code> de nuestro proyecto y dentro crearemos el fichero <code>validateFields.js</code>:</p> validateFields.js <pre><code>import { response } from 'express';\nimport { validationResult } from 'express-validator';\n\nconst validateFields = (req, res = response, next) =&gt; {\nconst errors = validationResult(req);\nif (!errors.isEmpty()) {\nreturn res.status(400).json({\nerrors: errors.mapped()\n});\n}\nnext();\n}\n\nexport default validateFields;\n</code></pre> <p>En este m\u00e9todo nos ayudaremos de la librer\u00eda <code>express-validator</code> para ver los errores que tenemos en nuestras rutas. Para ello llamaremos a la funci\u00f3n <code>validationResult</code> que nos devolver\u00e1 un array de errores que m\u00e1s tarde definiremos. Si el array no va vac\u00edo es porque se ha producido alg\u00fan error en las validaciones y ejecutara la response con un c\u00f3digo de error.</p> <p>Ahora definiremos las validaciones en nuestro archivo de rutas, deber\u00eda quedar de la siguiente manera:</p> category.routes.js <pre><code>import { Router } from 'express';\nimport { check } from 'express-validator';\nimport validateFields from '../middlewares/validateFields.js';\nimport { getCategories, createCategory, deleteCategory, updateCategory } from '../controllers/category.controller.js';\nconst categoryRouter = Router();\n\ncategoryRouter.put('/:id', [\ncheck('name').not().isEmpty(),\nvalidateFields\n], updateCategory);\n\ncategoryRouter.put('/', [\ncheck('name').not().isEmpty(),\nvalidateFields\n], createCategory);\n\ncategoryRouter.get('/', getCategories);\ncategoryRouter.delete('/:id', deleteCategory);\n\nexport default categoryRouter;\n</code></pre> <p>Aqu\u00ed nos ayudamos de nuevo de <code>express-validator</code> y de su m\u00e9todo <code>check</code>. Para las rutas en las que necesitemos validaciones, a\u00f1adimos un array como segundo par\u00e1metro. En este array vamos a\u00f1adiendo todas las validaciones que necesitemos. En nuestro caso solo queremos que el campo name no sea vac\u00edo, pero existen muchas m\u00e1s validaciones que puedes encontrar en la documentaci\u00f3n de express-validator. Importamos nuestro middleware y lo a\u00f1adimos en la \u00faltima posici\u00f3n de este array. </p> <p>De este modo no se realizar\u00e1n las peticiones que no pasen las validaciones:</p> <p></p> <p>Y con esto habremos terminado nuestro primer CRUD.</p>"},{"location":"develop/basic/nodejs/#depuracion","title":"Depuraci\u00f3n","text":"<p>Una parte muy importante del desarrollo es tener la capacidad de depurar nuestro c\u00f3digo, en este apartado vamos a explicar como se realiza <code>debug</code> en Backend.</p> <p>Esta parte se realiza con las herramientas incluidas dentro de nuestro IDE favorito, en este caso vamos a utilizar el Visual Estudio.</p> <p>Lo primero que debemos hacer es configurar el modo <code>Debug</code> de nuestro proyecto.</p> <p>Para ello nos dirigimos a la opci\u00f3n <code>Run and Debug</code> y creamos el fichero de launch necesario:</p> <p></p> <p>Esto nos crear\u00e1 el fichero necesario y ya podremos arrancar la aplicaci\u00f3n mediante esta herramienta presionando el bot\u00f3n <code>Launch Program</code> (seleccionamos tipo de aplicaci\u00f3n Node y el script de arranque que ser\u00e1 el que hemos utilizado en el desarrollo):</p> <p></p> <p>Arrancada la aplicaci\u00f3n de este modo, vamos a depurar la operaci\u00f3n de crear categor\u00eda.</p> <p>Para ello vamos a abrir nuestro fichero donde tenemos la implementaci\u00f3n del servicio de creaci\u00f3n de la capa de la l\u00f3gica de negocio <code>category.service.js</code>.</p> <p>Dentro del fichero ya podemos a\u00f1adir puntos de ruptura (breakpoint), en nuestro caso queremos comprobar que el nombre introducido se recibe correctamente.</p> <p>Colocamos el breakpoint en la primera l\u00ednea del m\u00e9todo (click sobre el n\u00famero de la l\u00ednea) y desde la interfaz/postman creamos una nueva categor\u00eda.</p> <p>Hecho esto, podemos observar que a nivel de interfaz/postman, la petici\u00f3n se queda esperando y el IDE mostrar\u00e1 un panel de manejo de los puntos de interrupci\u00f3n:</p> <p></p> <p>El IDE nos lleva al punto exacto donde hemos a\u00f1adido el breakpoint y se para en este punto ofreci\u00e9ndonos la posibilidad de explorar el contenido de las variables del c\u00f3digo:</p> <p></p> <p>Aqu\u00ed podemos comprobar que efectivamente la variable <code>name</code> tiene el valor que hemos introducido por pantalla/postman.</p> <p>Para continuar con la ejecuci\u00f3n basta con darle al bot\u00f3n de <code>play</code> del panel de manejo de los puntos de interrupci\u00f3n.</p>"},{"location":"develop/basic/springboot/","title":"Listado simple - Spring Boot","text":"<p>Ahora que ya tenemos listo el proyecto backend de Spring Boot (en el puerto 8080) ya podemos empezar a codificar la soluci\u00f3n.</p>"},{"location":"develop/basic/springboot/#primeros-pasos","title":"Primeros pasos","text":"<p>Antes de empezar</p> <p>Quiero hacer hincapi\u00e9 en Spring Boot tiene una documentaci\u00f3n muy extensa y completa, as\u00ed que te recomiendo que hagas uso de ella cuando tengas cualquier duda. Tanto la propia web de Spring como en el portal de tutoriales de Baeldung puedes buscar casi cualquier ejemplo que necesites.</p>"},{"location":"develop/basic/springboot/#estructurar-el-codigo","title":"Estructurar el c\u00f3digo","text":"<p>Vamos a hacer un breve refresco de la estructura del c\u00f3digo que ya se ha visto en puntos anteriores.</p> <p>Las clases deben estar agrupadas por \u00e1mbito funcional, en nuestro caso como vamos a hacer la funcionalidad de <code>Categor\u00edas</code> pues deber\u00eda estar todo dentro de un package del tipo <code>com.ccsw.tutorial.category</code>.</p> <p>Adem\u00e1s, deber\u00edamos aplicar la separaci\u00f3n por capas como ya se vi\u00f3 en el esquema:</p> <p></p> <p>La primera capa, la de <code>Controlador</code>, se encargar\u00e1 de procesar las peticiones y transformar datos. Esta capa llamar\u00e1 a la capa de <code>L\u00f3gica</code> de negocio que ejecutar\u00e1 las operaciones, ayud\u00e1ndose de otros objetos de esa misma capa de <code>L\u00f3gica</code> o bien de llamadas a datos a trav\u00e9s de la capa de <code>Acceso a Datos</code></p> <p>Ahora s\u00ed, vamos a programar!.</p>"},{"location":"develop/basic/springboot/#capa-de-operaciones-controller","title":"Capa de operaciones: Controller","text":"<p>En esta capa es donde se definen las operaciones que pueden ser consumidas por los clientes. Se caracterizan por estar anotadas con las anotaciones @Controller o @RestController y por las anotaciones @RequestMapping que nos permiten definir las rutas de acceso.</p> <p>Recomendaci\u00f3n: Breve detalle REST</p> <p>Antes de continuar te recomiendo encarecidamente que leas el Anexo: Detalle REST donde se explica brevemente como estructurar los servicios REST que veremos a continuaci\u00f3n.</p>"},{"location":"develop/basic/springboot/#controller-de-ejemplo","title":"Controller de ejemplo","text":"<p>Vamos a crear una clase <code>CategoryController.java</code> dentro del package <code>com.ccsw.tutorial.category</code> para definir las rutas de las operaciones.</p> CategoryController.java <pre><code>package com.ccsw.tutorial.category;\n\nimport java.util.List;\n\nimport org.springframework.web.bind.annotation.CrossOrigin;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport io.swagger.v3.oas.annotations.tags.Tag;\n\n/**\n * @author ccsw\n * \n */\n@Tag(name = \"Category\", description = \"API of Category\")\n@RequestMapping(value = \"/category\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class CategoryController {\n\n/**\n     * M\u00e9todo para probar el servicio\n     * \n     */\n@RequestMapping(path = \"\", method = RequestMethod.GET)\npublic String prueba() {\n\nreturn \"Probando el Controller\";\n}\n\n}\n</code></pre> <p>Ahora si arrancamos la aplicaci\u00f3n server, abrimos el Postman y creamos una petici\u00f3n GET a la url http://localhost:8080/category nos responder\u00e1 con el mensaje que hemos programado.</p>"},{"location":"develop/basic/springboot/#implementar-operaciones","title":"Implementar operaciones","text":"<p>Ahora que ya tenemos un controlador y una operaci\u00f3n de negocio ficticia, vamos a borrarla y a\u00f1adir las operaciones reales que consumir\u00e1 nuestra pantalla. Deberemos a\u00f1adir una operaci\u00f3n para listar, una para actualizar, una para guardar y una para borrar. Aunque para hacerlo m\u00e1s c\u00f3modo, utilizaremos la misma operaci\u00f3n para guardar y para actualizar. Adem\u00e1s, no vamos a trabajar directamente con datos simples, sino que usaremos objetos para recibir informaci\u00f3n y para enviar informaci\u00f3n.</p> <p>Estos objetos t\u00edpicamente se denominan DTO (Data Transfer Object) y nos sirven justamente para encapsular informaci\u00f3n que queremos transportar. En realidad no son m\u00e1s que clases pojo sencillas con propiedades, getters y setters. </p> <p>Para nuestro ejemplo crearemos una clase <code>CategoryDto</code> dentro del package <code>com.ccsw.tutorial.category.model</code> con el siguiente contenido:</p> CategoryDto.java <pre><code>package com.ccsw.tutorial.category.model;\n\n/**\n * @author ccsw\n * \n */\npublic class CategoryDto {\n\nprivate Long id;\n\nprivate String name;\n\n/**\n     * @return id\n     */\npublic Long getId() {\n\nreturn this.id;\n}\n\n/**\n     * @param id new value of {@link #getId}.\n     */\npublic void setId(Long id) {\n\nthis.id = id;\n}\n\n/**\n     * @return name\n     */\npublic String getName() {\n\nreturn this.name;\n}\n\n/**\n     * @param name new value of {@link #getName}.\n     */\npublic void setName(String name) {\n\nthis.name = name;\n}\n\n}\n</code></pre> <p>A continuaci\u00f3n utilizaremos esta clase en nuestro Controller para implementar las tres operaciones de negocio.</p> CategoryController.java <pre><code>package com.ccsw.tutorial.category;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.springframework.web.bind.annotation.CrossOrigin;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.ccsw.tutorial.category.model.CategoryDto;\n\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\n\n/**\n * @author ccsw\n * \n */\n@Tag(name = \"Category\", description = \"API of Category\")\n@RequestMapping(value = \"/category\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class CategoryController {\n\nprivate long SEQUENCE = 1;\nprivate Map&lt;Long, CategoryDto&gt; categories = new HashMap&lt;Long, CategoryDto&gt;();\n\n/**\n     * M\u00e9todo para recuperar todas las categorias\n     *\n     * @return {@link List} de {@link CategoryDto}\n     */\n@Operation(summary = \"Find\", description = \"Method that return a list of Categories\")\n@RequestMapping(path = \"\", method = RequestMethod.GET)\npublic List&lt;CategoryDto&gt; findAll() {\n\nreturn new ArrayList&lt;CategoryDto&gt;(this.categories.values());\n}\n\n/**\n     * M\u00e9todo para crear o actualizar una categoria\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n@Operation(summary = \"Save or Update\", description = \"Method that saves or updates a Category\")\n@RequestMapping(path = { \"\", \"/{id}\" }, method = RequestMethod.PUT)\npublic void save(@PathVariable(name = \"id\", required = false) Long id, @RequestBody CategoryDto dto) {\n\nCategoryDto category;\n\nif (id == null) {\ncategory = new CategoryDto();\ncategory.setId(this.SEQUENCE++);\nthis.categories.put(category.getId(), category);\n} else {\ncategory = this.categories.get(id);\n}\n\ncategory.setName(dto.getName());\n}\n\n/**\n     * M\u00e9todo para borrar una categoria\n     *\n     * @param id PK de la entidad\n     */\n@Operation(summary = \"Delete\", description = \"Method that deletes a Category\")\n@RequestMapping(path = \"/{id}\", method = RequestMethod.DELETE)\npublic void delete(@PathVariable(\"id\") Long id) {\n\nthis.categories.remove(id);\n}\n}\n</code></pre> <p>Como todav\u00eda no tenemos acceso a BD, hemos creado una variable tipo HashMap y una variable Long, que simular\u00e1n una BD y una secuencia. Tambi\u00e9n hemos implementado tres operaciones GET, PUT y DELETE que realizan las acciones necesarias por nuestra pantalla. Ahora podr\u00edamos probarlo desde el Postman con cuatro ejemplo sencillos.</p> <p>F\u00edjate que el m\u00e9todo <code>save</code> tiene dos rutas. La ruta normal <code>category/</code> y la ruta informada <code>category/3</code>. Esto es porque hemos juntado la acci\u00f3n create y update en un mismo m\u00e9todo para facilitar el desarrollo. Es totalmente v\u00e1lido y funcional.</p> <p>Atenci\u00f3n</p> <p>Los datos que se reciben pueden venir informados como un par\u00e1metro en la URL Get, como una variable en el propio path o dentro del body de la petici\u00f3n. Cada uno de ellos se recupera con una anotaci\u00f3n especial: <code>@RequestParam</code>, <code>@PathVariable</code> y <code>@RequestBody</code> respectivamente.</p> <p>Como no tenemos ning\u00fan dato dado de alta, podemos probar en primer lugar a realizar una inserci\u00f3n de datos con el m\u00e9todo PUT.</p> <p>PUT /category nos sirve para insertar <code>Categor\u00edas</code> nuevas (si no tienen el id informado) o para actualizar <code>Categor\u00edas</code> (si tienen el id informado). F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no env\u00edas datos, te dar\u00e1 un error.</p> <p> </p> <p>GET /category nos devuelve un listado de <code>Categor\u00edas</code>, siempre que hayamos insertado algo antes.</p> <p></p> <p>DELETE /category nos sirve eliminar <code>Categor\u00edas</code>. F\u00edjate que el dato del ID que se env\u00eda est\u00e1 en el path.</p> <p></p> <p>Prueba a jugar borrando categor\u00edas que no existen o modificando categor\u00edas que no existen. Tal y como est\u00e1 programado, el borrado no dar\u00e1 error, pero la modificaci\u00f3n deber\u00eda dar un NullPointerException al no existir el dato a modificar.</p>"},{"location":"develop/basic/springboot/#documentacion-openapi","title":"Documentaci\u00f3n (OpenAPI)","text":"<p>Si te acuerdas, en el punto de <code>Entorno de desarrollo</code>, a\u00f1adimos el m\u00f3dulo de OpenAPI a nuestro proyecto, y en el desarrollo de nuestro <code>Controller</code> hemos anotado tanto la clase como los m\u00e9todos con sus correspondientes etiquetas <code>@Tag</code> y <code>@Operation</code>. </p> <p>Esto nos va a ayudar a generar documentaci\u00f3n autom\u00e1tica de nuestras APIs haciendo que nuestro c\u00f3digo sea m\u00e1s mantenible y nuestra documentaci\u00f3n mucho m\u00e1s fiable.</p> <p>Para ver el resultado, con el proyecto arrancado nos dirigimos a la ruta por defecto de OpenAPI: http://localhost:8080/swagger-ui/index.html</p> <p>Aqu\u00ed podemos observar el cat\u00e1logo de endpoints generados, ver los tipos de entrada y salida e incluso realizar peticiones a los mismos. Este ser\u00e1 el contrato de nuestros endpoints, que nos ayudar\u00e1 a integrarnos con el equipo frontend (en el caso del tutorial seguramente seremos nosotros mismos).</p>"},{"location":"develop/basic/springboot/#aspectos-importantes","title":"Aspectos importantes","text":"<p>Los aspectos importantes de la capa <code>Controller</code> son:</p> <ul> <li>La clase debe estar anotada con <code>@Controller</code> o <code>@RestController</code>. Mejor usar la \u00faltima anotaci\u00f3n, ya que est\u00e1s diciendo que las operaciones son de tipo Rest y no har\u00e1 falta configurar nada</li> <li>La ruta general al controlador se define con el <code>@RequestMapping</code> global de la clase, aunque tambi\u00e9n se puede obviar esta anotaci\u00f3n y a\u00f1adir a cada una de las operaciones la ruta ra\u00edz.</li> <li>Los m\u00e9todos que queramos exponer como operaciones deben ir anotados tambi\u00e9n con <code>@RequestMapping</code> con la info:<ul> <li><code>path</code> \u2192 Que nos permite definir un path para la operaci\u00f3n, siempre sum\u00e1ndole el path de la clase (si es que tuviera)</li> <li><code>method</code> \u2192 Que nos permite definir el verbo de http que vamos a atender. Podemos tener el mismo path con diferente method, sin problema. Por lo general utilizaremos:<ul> <li>GET \u2192 Generalmente se usa para recuperar informaci\u00f3n</li> <li>POST \u2192 Se utiliza para hacer update y filtrados complejos de informaci\u00f3n</li> <li>PUT \u2192 Se utiliza para hacer save de informaci\u00f3n</li> <li>DELETE \u2192 Se utiliza para hacer borrados de informaci\u00f3n</li> </ul> </li> </ul> </li> </ul>"},{"location":"develop/basic/springboot/#capa-de-servicio-service","title":"Capa de Servicio: Service","text":"<p>Pero en realidad la cosa no funciona as\u00ed. Hemos implementado parte de la l\u00f3gica de negocio (las operaciones/acciones de guardado, borrado y listado) dentro de lo que ser\u00eda la capa de operaciones o servicios al cliente. Esta capa no debe ejecutar l\u00f3gica de negocio, tan solo debe hacer transformaciones de datos y enrutar peticiones, toda la l\u00f3gica deber\u00eda ir en la capa de servicio.</p>"},{"location":"develop/basic/springboot/#implementar-servicios","title":"Implementar servicios","text":"<p>Pues vamos a arreglarlo. Vamos a crear un servicio y vamos a mover la l\u00f3gica de negocio al servicio.</p> CategoryService.javaCategoryServiceImpl.javaCategoryController.java <pre><code>package com.ccsw.tutorial.category;\n\nimport com.ccsw.tutorial.category.model.CategoryDto;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n * \n */\npublic interface CategoryService {\n\n/**\n     * M\u00e9todo para recuperar todas las categor\u00edas\n     *\n     * @return {@link List} de {@link Category}\n     */\nList&lt;CategoryDto&gt; findAll();\n\n/**\n     * M\u00e9todo para crear o actualizar una categor\u00eda\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\nvoid save(Long id, CategoryDto dto);\n\n/**\n     * M\u00e9todo para borrar una categor\u00eda\n     *\n     * @param id PK de la entidad\n     */\nvoid delete(Long id);\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.category;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.springframework.stereotype.Service;\n\nimport com.ccsw.tutorial.category.model.CategoryDto;\n\n/**\n * @author ccsw\n *\n */\n@Service\npublic class CategoryServiceImpl implements CategoryService {\n\nprivate long SEQUENCE = 1;\nprivate Map&lt;Long, CategoryDto&gt; categories = new HashMap&lt;Long, CategoryDto&gt;();\n\n/**\n     * {@inheritDoc}\n     */\npublic List&lt;CategoryDto&gt; findAll() {\n\nreturn new ArrayList&lt;CategoryDto&gt;(this.categories.values());\n}\n\n/**\n     * {@inheritDoc}\n     */\npublic void save(Long id, CategoryDto dto) {\n\nCategoryDto category;\n\nif (id == null) {\ncategory = new CategoryDto();\ncategory.setId(this.SEQUENCE++);\nthis.categories.put(category.getId(), category);\n} else {\ncategory = this.categories.get(id);\n}\n\ncategory.setName(dto.getName());\n}\n\n/**\n     * {@inheritDoc}\n     */\npublic void delete(Long id) {\n\nthis.categories.remove(id);\n}\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.category;\n\nimport java.util.List;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.CrossOrigin;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.ccsw.tutorial.category.model.CategoryDto;\n\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\n\n/**\n * @author ccsw\n * \n */\n@Tag(name = \"Category\", description = \"API of Category\")\n@RequestMapping(value = \"/category\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class CategoryController {\n\n@Autowired\nprivate CategoryService categoryService;\n\n/**\n     * M\u00e9todo para recuperar todas las categorias\n     *\n     * @return {@link List} de {@link CategoryDto}\n     */\n@Operation(summary = \"Find\", description = \"Method that return a list of Categories\")\n@RequestMapping(path = \"\", method = RequestMethod.GET)\npublic List&lt;CategoryDto&gt; findAll() {\n\nreturn this.categoryService.findAll();\n}\n\n/**\n     * M\u00e9todo para crear o actualizar una categoria\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n@Operation(summary = \"Save or Update\", description = \"Method that saves or updates a Category\")\n@RequestMapping(path = { \"\", \"/{id}\" }, method = RequestMethod.PUT)\npublic void save(@PathVariable(name = \"id\", required = false) Long id, @RequestBody CategoryDto dto) {\n\nthis.categoryService.save(id, dto);\n}\n\n/**\n     * M\u00e9todo para borrar una categoria\n     *\n     * @param id PK de la entidad\n     */\n@Operation(summary = \"Delete\", description = \"Method that deletes a Category\")\n@RequestMapping(path = \"/{id}\", method = RequestMethod.DELETE)\npublic void delete(@PathVariable(\"id\") Long id) {\n\nthis.categoryService.delete(id);\n}\n}\n</code></pre> <p>Ahora ya tenemos bien estructurado nuestro proyecto. Ya tenemos las dos capas necesarias Controladores y Servicios y cada uno se encarga de llevar a cabo su cometido de forma correcta.</p>"},{"location":"develop/basic/springboot/#aspectos-importantes_1","title":"Aspectos importantes","text":"<p>Los aspectos importantes de la capa <code>Service</code> son:</p> <ul> <li>Toda la l\u00f3gica de negocio, operaciones y dem\u00e1s debe estar implementada en los servicios. Los controladores simplemente invocan servicios y transforman ciertos datos.</li> <li>Es buena pr\u00e1ctica que la capa de servicios se implemente usando el patr\u00f3n fachada, esto quiere decir que necesitamos tener una Interface y al menos una implementaci\u00f3n de esa Interface. Y siempre debemos interactuar con la Interface. Esto nos permitir\u00e1 a futuro poder sustituir la implementaci\u00f3n por otra diferente sin que el resto del c\u00f3digo se vea afectado. Especialmente \u00fatil cuando queremos mockear comportamientos en tests.</li> <li>La capa de servicio puede invocar a otros servicios en sus operaciones, pero nunca debe invocar a un controlador.</li> <li>Para crear un servicio se debe anotar mediante <code>@Service</code> y adem\u00e1s debe implementar la Interface del servicio. Un error muy com\u00fan al arrancar un proyecto y ver que no funcionan las llamadas, es porqu\u00e9 no existe la anotaci\u00f3n <code>@Service</code> o porqu\u00e9 no se ha implementado la Interface.</li> <li>La forma de <code>inyectar</code> y utilizar componentes manejados por Spring Boot es mediante la anotaci\u00f3n <code>@Autowired</code>. NO intentes crear un objeto de CategoryServiceImpl, ni hacer un <code>new</code>, ya que no estar\u00e1 manejado por Springboot y dar\u00e1 fallos de NullPointer. Lo mejor es dejar que Spring Boot lo gestione y utilizar las inyecciones de dependencias.</li> </ul>"},{"location":"develop/basic/springboot/#capa-de-datos-repository","title":"Capa de Datos: Repository","text":"<p>Pero no siempre vamos a acceder a los datos mediante un HasMap en memoria. En algunas ocasiones queremos que nuestro proyecto acceda a un servicio de datos como puede ser una BBDD, un servicio externo, un acceso a disco, etc. Estos accesos se deben hacer desde la capa de acceso a datos, y en concreto para nuestro ejemplo, lo haremos a trav\u00e9s de un Repository para que acceda a una BBDD.</p> <p>Para el tutorial no necesitamos configurar una BBDD externa ni complicarnos demasiado. Vamos a utilizar una librer\u00eda muy \u00fatil llamada <code>H2</code> que nos permite levantar una BBDD en memoria persistiendo los datos en memoria o en disco, de hecho ya la configuramos en el apartado de <code>Entorno de desarrollo</code>.</p>"},{"location":"develop/basic/springboot/#implementar-entity","title":"Implementar Entity","text":"<p>Lo primero que haremos ser\u00e1 crear nuestra entity con la que vamos a persistir y recuperar informaci\u00f3n. Las entidades igual que los DTOs deber\u00edan estar agrupados dentro del package <code>model</code> de cada funcionalidad, as\u00ed que vamos a crear una nueva clase java.</p> Category.java <pre><code>package com.ccsw.tutorial.category.model;\n\nimport jakarta.persistence.*;\n\n/**\n * @author ccsw\n * \n */\n@Entity\n@Table(name = \"category\")\npublic class Category {\n\n@Id\n@GeneratedValue(strategy = GenerationType.IDENTITY)\n@Column(name = \"id\", nullable = false)\nprivate Long id;\n\n@Column(name = \"name\", nullable = false)\nprivate String name;\n\n/**\n     * @return id\n     */\npublic Long getId() {\n\nreturn this.id;\n}\n\n/**\n     * @param id new value of {@link #getId}.\n     */\npublic void setId(Long id) {\n\nthis.id = id;\n}\n\n/**\n     * @return name\n     */\npublic String getName() {\n\nreturn this.name;\n}\n\n/**\n     * @param name new value of {@link #getName}.\n     */\npublic void setName(String name) {\n\nthis.name = name;\n}\n\n}\n</code></pre> <p>Si te fijas, la Entity suele ser muy similar a un DTO, tiene unas propiedades y sus getters y setters. Pero a diferencia de los DTOs, esta clase tiene una serie de anotaciones que permiten a JPA hacer su magia y generar consultas SQL a la BBDD. En este ejemplo vemos 4 anotaciones importantes:</p> <ul> <li><code>@Entity</code> \u2192 Le indica a Springboot que se trata de una clase que implementa una Entidad de BBDD. Sin esta anotaci\u00f3n no es posible hacer queries.</li> <li><code>@Table</code> \u2192 Le indica a JPA el nombre y el schema de la tabla que representa esta clase. Por claridad se deber\u00eda poner siempre, aunque si el nombre de la tabla es igual al nombre de la clase no es necesaria la anotaci\u00f3n.</li> <li><code>@Id</code> y <code>@GeneratedValue</code> \u2192 Le indica a JPA que esta propiedad es la que mapea una Primary Key y adem\u00e1s que esta PK se genera con la estrategia que se le indique en la anotaci\u00f3n <code>@GeneratedValue</code>, que puede ser:<ul> <li>Generaci\u00f3n de PK por <code>Secuence</code>, la que utiliza Oracle, en este caso habr\u00e1 que indicarle un nombre de secuencia.</li> <li>Generaci\u00f3n de PK por <code>Indentity</code>, la que utiliza MySql o SQLServer, el auto-incremental. </li> <li>Generaci\u00f3n de PK por <code>Table</code>, en algunas BBDD se permite tener una tabla donde se almacenan como registros todas las secuencias.</li> <li>Generaci\u00f3n de PK <code>Auto</code>, elige la mejor estrategia en funci\u00f3n de la BBDD que hemos seleccionado.</li> </ul> </li> <li><code>@Column</code> \u2192 Le indica a JPA que esta propiedad mapea una columna de la tabla y le especifica el nombre de la columna. Al igual que la anotaci\u00f3nd de <code>Table</code>, esta anotaci\u00f3n no es necesaria aunque si es muy recomendable. Por claridad se deber\u00eda poner siempre, aunque si el nombre de la columna es igual al nombre de la propiedad no es necesaria la anotaci\u00f3n.</li> </ul> <p>Hay muchas otras anotaciones, pero estas son las b\u00e1sicas, ya ir\u00e1s aprendiendo otras.</p> <p>Consejo</p> <p>Para definir las PK de las tablas, intenta evitar una PK compuesta de m\u00e1s de una columna. La programaci\u00f3n se hace muy compleja y las magias que hace JPA en la oscuridad se complican mucho. Mi recomendaci\u00f3n es que siempre utilices una PK n\u00famerica, en la medida de lo posible, y si es necesario, crees \u00edndices compuestos de b\u00fasqueda o checks compuestos para evitar duplicidades.</p>"},{"location":"develop/basic/springboot/#juego-de-datos-de-bbdd","title":"Juego de datos de BBDD","text":"<p>Springboot autom\u00e1ticamente cuando arranque el proyecto escaner\u00e1 todas las <code>@Entity</code> y crear\u00e1 las estructuras de las tablas en la BBDD en memoria, gracias a las anotaciones que hemos puesto.  Adem\u00e1s de esto, lanzar\u00e1 los scripts de construcci\u00f3n de BBDD que tenemos en la carpeta <code>src/main/resources/</code>. As\u00ed que, teniendo clara la estructura de la <code>Entity</code> podemos configurar los ficheros con los juegos de datos que queramos, y para ello vamos a utilizar el fichero <code>data.sql</code> que creamos en su momento. </p> <p>Sabemos que la tabla se llamar\u00e1 <code>category</code> y que tendr\u00e1 dos columnas, una columna <code>id</code>, que ser\u00e1 la PK autom\u00e1tica, y una columna <code>name</code>. Podemos escribir el siguiente script para rellenar datos:</p> data.sql <pre><code>INSERT INTO category(name) VALUES ('Eurogames');\nINSERT INTO category(name) VALUES ('Ameritrash');\nINSERT INTO category(name) VALUES ('Familiar');\n</code></pre>"},{"location":"develop/basic/springboot/#implementar-repository","title":"Implementar Repository","text":"<p>Ahora que ya tenemos el juego de datos y la entidad implementada, vamos a ver como acceder a BBDD desde Java. Esto lo haremos con un <code>Repository</code>. Existen varias formas de utilizar los repositories, desde el todo autom\u00e1tico y magia de JPA hasta el repositorio manual en el que hay que codificar todo. En el tutorial voy a explicar varias formas de implementarlo para este CRUD y los siguientes CRUDs.</p> <p>Como ya se dijo en puntos anteriores, el acceso a datos se debe hacer siempre a trav\u00e9s de un <code>Repository</code>, as\u00ed que vamos a implementar uno. En esta capa, al igual que pasaba con los services, es recomendable utilizar el patr\u00f3n fachada, para poder sustituir implementaciones sin afectar al c\u00f3digo.</p> CategoryRepository.java <pre><code>package com.ccsw.tutorial.category;\n\nimport com.ccsw.tutorial.category.model.Category;\nimport org.springframework.data.repository.CrudRepository;\n\n/**\n * @author ccsw\n *\n */\npublic interface CategoryRepository extends CrudRepository&lt;Category, Long&gt; {\n\n}\n</code></pre> <p>\u00bfQu\u00e9 te parece?, sencillo, \u00bfno?. Spring ya tiene una implementaci\u00f3n por defecto de un CrudRepository, tan solo tenemos que crear una interface que extienda de la interface <code>CrudRepository</code> pas\u00e1ndole como tipos la <code>Entity</code> y el tipo de la Primary Key. Con eso Spring construye el resto y nos provee de los m\u00e9todos t\u00edpicos y necesarios para un CRUD.</p> <p>Ahora vamos a utilizarla en \u00e9l <code>Service</code>, pero hay un problema. \u00c9l <code>Repository</code> devuelve un objeto tipo <code>Category</code> y \u00e9l <code>Service</code> y <code>Controller</code> devuelven un objeto tipo <code>CategoryDto</code>. Esto es porque en cada capa se debe con un \u00e1mbito de modelos diferente. Podr\u00edamos hacer que todo el back trabajara con <code>Category</code> que son entidades de persistencia, pero no es lo correcto y nos podr\u00eda llevar a cometer errores, o modificar el objeto y que sin que nosotros lo orden\u00e1semos se persistiera ese cambio en BBDD.</p> <p>El \u00e1mbito de trabajo de las capas con el que solemos trabajar y est\u00e1 m\u00e1s extendido es el siguiente:</p> <p></p> <ul> <li>Los datos que vienen y van al cliente, deber\u00edan ser en la mayor\u00eda de los casos datos en formato json</li> <li>Al entrar en un <code>Controller</code> esos datos json se transforman en un DTO. Al salir del <code>Controller</code> hacia el cliente, esos DTOs se transforman en formato json. Estas conversiones son autom\u00e1ticas, las hace Springboot (en realidad las hace la librer\u00eda de jackson codehaus).</li> <li>Cuando un <code>Controller</code> ejecuta una llamada a un <code>Service</code>, generalmente le pasa sus datos en DTO, y el <code>Service</code> se encarga de transformar esto a una <code>Entity</code>. A la inversa, cuando un <code>Service</code> responde a un <code>Controller</code>, \u00e9l responde con una <code>Entity</code> y el <code>Controller</code> ya se encargar\u00e1 de transformarlo a DTO.</li> <li>Por \u00faltimo, para los <code>Repository</code>, siempre se trabaja de entrada y salida con objetos tipo <code>Entity</code></li> </ul> <p>Parece un l\u00edo, pero ya ver\u00e1s como es muy sencillo ahora que veremos el ejemplo. Una \u00faltima cosa, para hacer esas transformaciones, las podemos hacer a mano usando getters y setters o bien utilizar el objeto <code>DozerBeanMapper</code> que hemos configurado al principio.</p> <p>El c\u00f3digo deber\u00eda quedar as\u00ed:</p> CategoryServiceImpl.javaCategoryService.javaCategoryController.java <pre><code>package com.ccsw.tutorial.category;\n\nimport com.ccsw.tutorial.category.model.Category;\nimport com.ccsw.tutorial.category.model.CategoryDto;\nimport jakarta.transaction.Transactional;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Service\n@Transactional\npublic class CategoryServiceImpl implements CategoryService {\n\n@Autowired\nCategoryRepository categoryRepository;\n\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic List&lt;Category&gt; findAll() {\n\nreturn (List&lt;Category&gt;) this.categoryRepository.findAll();\n}\n\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic void save(Long id, CategoryDto dto) {\n\nCategory category;\n\nif (id == null) {\ncategory = new Category();\n} else {\ncategory = this.categoryRepository.findById(id).orElse(null);\n}\n\ncategory.setName(dto.getName());\n\nthis.categoryRepository.save(category);\n}\n\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic void delete(Long id) throws Exception {\n\nif(this.categoryRepository.findById(id).orElse(null) == null){\nthrow new Exception(\"Not exists\");\n}\n\nthis.categoryRepository.deleteById(id);\n}\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.category;\n\nimport com.ccsw.tutorial.category.model.Category;\nimport com.ccsw.tutorial.category.model.CategoryDto;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n * \n */\npublic interface CategoryService {\n\n/**\n     * M\u00e9todo para recuperar todas las {@link Category}\n     *\n     * @return {@link List} de {@link Category}\n     */\nList&lt;Category&gt; findAll();\n\n/**\n     * M\u00e9todo para crear o actualizar una {@link Category}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\nvoid save(Long id, CategoryDto dto);\n\n/**\n     * M\u00e9todo para borrar una {@link Category}\n     *\n     * @param id PK de la entidad\n     */\nvoid delete(Long id) throws Exception;\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.category;\n\nimport com.ccsw.tutorial.category.model.Category;\nimport com.ccsw.tutorial.category.model.CategoryDto;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport org.dozer.DozerBeanMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * @author ccsw\n *\n */\n@Tag(name = \"Category\", description = \"API of Category\")\n@RequestMapping(value = \"/category\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class CategoryController {\n\n@Autowired\nCategoryService categoryService;\n\n@Autowired\nDozerBeanMapper mapper;\n/**\n     * M\u00e9todo para recuperar todas las {@link Category}\n     *\n     * @return {@link List} de {@link CategoryDto}\n     */\n@Operation(summary = \"Find\", description = \"Method that return a list of Categories\"\n)\n@RequestMapping(path = \"\", method = RequestMethod.GET)\npublic List&lt;CategoryDto&gt; findAll() {\n\nList&lt;Category&gt; categories = this.categoryService.findAll();\n\nreturn categories.stream().map(e -&gt; mapper.map(e, CategoryDto.class)).collect(Collectors.toList());\n}\n\n/**\n     * M\u00e9todo para crear o actualizar una {@link Category}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n@Operation(summary = \"Save or Update\", description = \"Method that saves or updates a Category\"\n)\n@RequestMapping(path = { \"\", \"/{id}\" }, method = RequestMethod.PUT)\npublic void save(@PathVariable(name = \"id\", required = false) Long id, @RequestBody CategoryDto dto) {\n\nthis.categoryService.save(id, dto);\n}\n\n/**\n     * M\u00e9todo para borrar una {@link Category}\n     *\n     * @param id PK de la entidad\n     */\n@Operation(summary = \"Delete\", description = \"Method that deletes a Category\")\n@RequestMapping(path = \"/{id}\", method = RequestMethod.DELETE)\npublic void delete(@PathVariable(\"id\") Long id) throws Exception {\n\nthis.categoryService.delete(id);\n}\n\n}\n</code></pre> <p>El <code>Service</code> no tiene nada raro, simplemente accede al <code>Repository</code> (siempre anotado como <code>@Autowired</code>) y recupera datos o los guarda. F\u00edjate en el caso especial del save que la \u00fanica diferencia es que en un caso tendr\u00e1 <code>id != null</code> y por tanto internamente har\u00e1 un update, y en otro caso tendr\u00e1 <code>id == null</code> y por tanto internamente har\u00e1 un save.</p> <p>En cuanto a la interface, lo \u00fanico que cambiamos fue los objetos de respuesta, que ahora pasan a ser de tipo <code>Category</code>. Los de entrada se mantienen como <code>CategoryDto</code>.</p> <p>Por \u00faltimo, en \u00e9l <code>Controller</code> se puede ver como se utiliza el conversor de <code>DozerBeanMapper</code> (siempre anotado como <code>@Autowired</code>), que permite traducir una lista a un tipo concreto, o un objeto \u00fanico a un tipo concreto. La forma de hacer estas conversiones siempre es por nombre de propiedad. Las propiedades del objeto destino se deben llamar igual que las propiedades del objeto origen. En caso contrario se quedar\u00e1n a null.</p> <p>Ojo con el mapeo</p> <p>Ojo a esta \u00faltima frase, debe quedar meridianamente claro. La forma de mapear de un objeto origen a un objeto destino siempre es a trav\u00e9s del nombre. Los getters del origen deben ser iguales a los getters del destino. Si hay una letra diferente o unas may\u00fasculas o min\u00fasculas diferentes NO realizar\u00e1 el mapeo y se quedar\u00e1 la propiedad a null.</p> <p>Para terminar, cuando queramos realizar un mapeo masivo de los diferentes registros, tenemos que itulizar la API Stream de Java, que nos proporciona una forma sencilla de realizar estas operativas, sobre colecciones de elementos, mediante el uso del m\u00e9todo intermedio <code>map</code> y el reductor por defecto para listas. Te recomiendo echarle un ojo a la teor\u00eda de Introducci\u00f3n a API Java Streams.</p> <p>BBDD</p> <p>Si quires ver el contenido de la base de datos puedes acceder a un IDE web autopublicado por H2 en la ruta <code>http://localhost:8080/h2-console</code></p>"},{"location":"develop/basic/springboot/#aspectos-importantes_2","title":"Aspectos importantes","text":"<p>Los aspectos importantes de la capa <code>Repository</code> son:</p> <ul> <li>Al igual que los <code>Service</code>, se debe utilizar el patr\u00f3n fachada, por lo que tendremos una Interface y posiblemente una implementaci\u00f3n.</li> <li>A menudo la implementaci\u00f3n la hace internamente Spring Boot, pero hay veces que podemos hacer una implementaci\u00f3n manual. Lo veremos en siguientes puntos.</li> <li>Los <code>Repository</code> trabajan siempre con <code>Entity</code> que no son m\u00e1s que mapeos de una tabla o de una vista que existe en BBDD.</li> <li>Los <code>Repository</code> no contienen l\u00f3gica de negocio, ni transformaciones, simplemente acceder a datos, persisten o devuelven informaci\u00f3n.</li> <li>Los <code>Repository</code> JAM\u00c1S deben llamar a otros <code>Repository</code> ni <code>Service</code>.</li> <li>Intenta que tus clases <code>Entity</code> sean lo m\u00e1s sencillas posible, sobre todo en cuanto a Primary Keys, se simplificar\u00e1 mucho el desarrollo.</li> </ul>"},{"location":"develop/basic/springboot/#capa-de-testing-tdd","title":"Capa de Testing: TDD","text":"<p>Por \u00faltimo y aunque no deber\u00eda ser lo \u00faltimo que se desarrolla sino todo lo contrario, deber\u00eda ser lo primero en desarrollar, tenemos la bater\u00eda de pruebas. Con fines did\u00e1cticos, he querido ense\u00f1arte un ciclo de desarrollo para ir recorriendo las diferentes capas de una aplicaci\u00f3n, pero en realidad, para realizar el desarrollo deber\u00eda aplicar TDD (Test Driven Development). Si quieres aprender las reglas b\u00e1sicas de como aplicar TDD al desarrollo diario, te recomiendo que leas el Anexo. TDD.</p> <p>En este caso, y sin que sirva de precedente, ya tenemos implementados los m\u00e9todos de la aplicaci\u00f3n, y ahora vamos a testearlos. Existen muchas formas de testing en funci\u00f3n del componente o la capa que se quiera testear. En realidad, a medida que vayas programando ir\u00e1s aprendiendo todas ellas, de momento realizaremos dos tipos de test simples que prueben las casu\u00edsticas de los m\u00e9todos.</p> <p>El enfoque que seguiremos en este tutorial ser\u00e1 realizar las pruebas mediante test unitarios y test de integraci\u00f3n.</p> <ul> <li>Test unitarios: Se trata de pruebas estrictamente relativas a la calidad est\u00e1tica del c\u00f3digo de una determinada operaci\u00f3n de la capa de la l\u00f3gica de negocio (Service). Estas pruebas no inicializan el contexto de Spring y deben simular todas las piezas ajenas a la funcionalidad testeada.</li> <li>Test de integraci\u00f3n: Se tratan de pruebas completas de un determinado endpoint que conlleva inicializar el contexto de Spring (base de datos incluida) y realizar una llama REST para comprobar el flujo completo de la API.</li> </ul> <p>Lo primero ser\u00e1 conocer que queremos probar y para ello nos vamos a hacer una lista:</p> <p>Test unitarios:</p> <ul> <li>Prueba de listado, debe probar la l\u00f3gica dentro de la operaci\u00f3n de negocio de consulta de <code>Categor\u00eda</code></li> <li>Prueba de creaci\u00f3n, debe probar la l\u00f3gica dentro de la operaci\u00f3n de negocio de creaci\u00f3n una nueva <code>Categor\u00eda</code></li> <li>Prueba de modificaci\u00f3n, debe probar la l\u00f3gica dentro de la operaci\u00f3n de negocio de modificaci\u00f3n una <code>Categor\u00eda</code> existente</li> <li>Prueba de borrado, debe probar la l\u00f3gica dentro de la operaci\u00f3n de negocio de borrado de una <code>Categor\u00eda</code> existente</li> </ul> <p>Test de integraci\u00f3n:</p> <ul> <li>Prueba de listado, debe recuperar los elementos de la tabla <code>Categor\u00eda</code></li> <li>Prueba de creaci\u00f3n, debe crear una nueva <code>Categor\u00eda</code></li> <li>Prueba de modificaci\u00f3n correcta, debe modificar una <code>Categor\u00eda</code> existente</li> <li>Prueba de modificaci\u00f3n incorrecta, debe dar error al modificar una <code>Categor\u00eda</code> que no existe</li> <li>Prueba de borrado correcta, debe borrar una <code>Categor\u00eda</code> existente</li> <li>Prueba de borrado incorrecta, debe dar error al borrar una <code>Categor\u00eda</code> que no existe</li> </ul> <p>Se podr\u00edan hacer muchos m\u00e1s tests, pero creo que con esos son suficientes para que entiendas como se comporta esta capa. Si te fijas, hay que probar tanto los resultados correctos como los resultados incorrectos. El usuario no siempre se va a comportar como nosotros pensamos.</p> <p>Pues vamos a ello.</p>"},{"location":"develop/basic/springboot/#pruebas-de-listado","title":"Pruebas de listado","text":"<p>Vamos a empezar haciendo una clase de test dentro de la carpeta <code>src/test/java</code>. No queremos que los test formen parte del c\u00f3digo productivo de la aplicaci\u00f3n, por eso utilizamos esa ruta que queda fuera del package general de la aplicaci\u00f3n.</p> <p>Crearemos las clases (en la package <code>category</code>):</p> <ul> <li>Test unitarios: <code>com.ccsw.tutorial.category.CategoryTest</code></li> <li>Test de integraci\u00f3n: <code>com.ccsw.tutorial.category.CategoryIT</code> </li> </ul> CategoryTest.javaCategoryIT.java <pre><code>package com.ccsw.tutorial.category;\n\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\n@ExtendWith(MockitoExtension.class)\npublic class CategoryTest {\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.category;\n\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.web.client.TestRestTemplate;\nimport org.springframework.boot.web.server.LocalServerPort;\nimport org.springframework.test.annotation.DirtiesContext;\n\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\npublic class CategoryIT {\n\n@LocalServerPort\nprivate int port;\n\n@Autowired\nprivate TestRestTemplate restTemplate;\n\n}\n</code></pre> <p>Estas clases son sencillas y tan solo tienen anotaciones espec\u00edficas de Spring Boot para cada tipo de test:</p> <ul> <li><code>@SpringBootTest</code>. Esta anotaci\u00f3n lo que hace es inicializar el contexto de Spring cada vez que se inician los test de jUnit. Aunque el contexto tarda unos segundos en arrancar, lo bueno que tiene es que solo se inicializa una vez y se lanzan todos los jUnits en bater\u00eda con el mismo contexto.</li> <li><code>@DirtiesContext</code>. Esta anotaci\u00f3n le indica a Spring que los test van a ser transaccionales, y por tanto cuando termine la ejecuci\u00f3n de cada uno de los test, autom\u00e1ticamente por la anotaci\u00f3n de arriba, Spring har\u00e1 un rearranque parcial del contexto y dejar\u00e1 el estado de la BBDD como estaba inicialmente.</li> <li><code>@ExtendWith</code>. Esta anotaci\u00f3n le indica a Spring que no debe inicializar el contexto, ya que se trata de test est\u00e1ticos que no lo requieren.</li> </ul> <p>Para las pruebas de integraci\u00f3n nos faltar\u00e1 configurar la aplicaci\u00f3n de test, al igual que hicimos con la aplicaci\u00f3n 'productiva'. Deberemos abrir el fichero <code>src/test/resources/application.properties</code> y a\u00f1adir la configuraci\u00f3n de la BBDD. Para este tutorial vamos a utilizar la misma BBDD que la aplicaci\u00f3n productiva, pero de normal la aplicaci\u00f3n se conectar\u00e1 a una BBDD, generalmente f\u00edsica, mientras que los test jUnit se conectar\u00e1n a otra BBDD, generalmente en memoria.</p> application.properties <pre><code>#Database\nspring.datasource.url=jdbc:h2:mem:testdb\nspring.datasource.username=sa\nspring.datasource.password=sa\nspring.datasource.driver-class-name=org.h2.Driver\n\nspring.jpa.database-platform=org.hibernate.dialect.H2Dialect\nspring.jpa.defer-datasource-initialization=true\n</code></pre> <p>Con todo esto ya podemos crear nuestro primer test. Iremos a las clases <code>CategoryIT</code> y <code>CategoryTest</code> donde a\u00f1adiremos un m\u00e9todo p\u00fablico. Los test siempre tienen que ser m\u00e9todos p\u00fablicos que devuelvan el tipo <code>void</code>.</p> CategoryTest.javaCategoryIT.java <pre><code>package com.ccsw.tutorial.category;\n\nimport com.ccsw.tutorial.category.model.Category;\nimport com.ccsw.tutorial.category.model.CategoryDto;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n@ExtendWith(MockitoExtension.class)\npublic class CategoryTest {\n\n@Mock\nprivate CategoryRepository categoryRepository;\n@InjectMocks\nprivate CategoryServiceImpl categoryService;\n@Test\npublic void findAllShouldReturnAllCategories() {\nList&lt;Category&gt; list = new ArrayList&lt;&gt;();\nlist.add(mock(Category.class));\nwhen(categoryRepository.findAll()).thenReturn(list);\nList&lt;Category&gt; categories = categoryService.findAll();\nassertNotNull(categories);\nassertEquals(1, categories.size());\n}\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.category;\n\nimport com.ccsw.tutorial.category.model.CategoryDto;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;    import org.springframework.boot.test.web.client.TestRestTemplate;\nimport org.springframework.boot.web.server.LocalServerPort;\nimport org.springframework.core.ParameterizedTypeReference;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.test.annotation.DirtiesContext;\nimport java.util.List;\nimport static org.junit.jupiter.api.Assertions.*;\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\npublic class CategoryIT {\n\npublic static final String LOCALHOST = \"http://localhost:\";\npublic static final String SERVICE_PATH = \"/category\";\n@LocalServerPort\nprivate int port;\n\n@Autowired\nprivate TestRestTemplate restTemplate;\n\nParameterizedTypeReference&lt;List&lt;CategoryDto&gt;&gt; responseType = new ParameterizedTypeReference&lt;List&lt;CategoryDto&gt;&gt;(){};\n@Test\npublic void findAllShouldReturnAllCategories() {\nResponseEntity&lt;List&lt;CategoryDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.GET, null, responseType);\nassertNotNull(response);\nassertEquals(3, response.getBody().size());\n}\n}\n</code></pre> <p>Es muy importante marcar cada m\u00e9todo de prueba con la anotaci\u00f3n <code>@Test</code>, en caso contrario no se ejecutar\u00e1. Lo que se debe hacer en cada m\u00e9todo que implementemos es probar una y solo una acci\u00f3n. </p> <p>En los ejemplos anteriores <code>(CategoryTest)</code>, por un lado hemos comprobado el m\u00e9todo <code>findAll()</code> el cual por debajo invoca una llamada al repository de categor\u00eda, la cual hemos simulado con una respuesta ficticia limit\u00e1ndonos \u00fanicamente a la l\u00f3gica contenida en la operaci\u00f3n de negocio.</p> <p>Mientras que por otro lado <code>(CategoryIT)</code>, hemos probado la llamando al m\u00e9todo <code>GET</code> del endpoint <code>http://localhost:XXXX/category</code> comprobando que realmente nos devuelve 3 resultados, que son los que hay en BBDD inicialmente.</p> <p>Muy importante: Nomenclatura de los tests</p> <p>La nomenclatura de los m\u00e9todos de test debe sigue una estructura determinada. Hay muchas formas de nombrar a los m\u00e9todos, pero nosotros solemos utilizar la estructura 'should', para indicar lo que va a hacer. En el ejemplo anterior el m\u00e9todo 'findAll' debe devolver 'AllCategories'. De esta forma sabemos cu\u00e1l es la intenci\u00f3n del test, y si por cualquier motivo diera un fallo, sabemos que es lo que NO est\u00e1 funcionando de nuestra aplicaci\u00f3n.</p> <p>Para comprobar que el test funciona, podemos darle bot\u00f3n derecho sobre la clase de <code>CategoryIT</code> y pulsar en <code>Run as</code> -&gt; <code>JUnit Test</code>. Si todo funciona correctamente, deber\u00e1 aparecer una pantalla de ejecuci\u00f3n y todos nuestros tests (en este caso solo uno) corriendo correctamente (en verde). El proceso es el mismo para la clase <code>CategoryTest</code>.</p> <p></p>"},{"location":"develop/basic/springboot/#pruebas-de-creacion","title":"Pruebas de creaci\u00f3n","text":"<p>Vamos con los siguientes test, los que probar\u00e1n una creaci\u00f3n de una nueva <code>Categor\u00eda</code>. A\u00f1adimos el siguiente m\u00e9todo a la clase de test:</p> CategoryTest.javaCategoryIT.java <pre><code>public static final String CATEGORY_NAME = \"CAT1\";\n\n@Test\npublic void saveNotExistsCategoryIdShouldInsert() {\n\nCategoryDto categoryDto = new CategoryDto();\ncategoryDto.setName(CATEGORY_NAME);\n\nArgumentCaptor&lt;Category&gt; category = ArgumentCaptor.forClass(Category.class);\n\ncategoryService.save(null, categoryDto);\n\nverify(categoryRepository).save(category.capture());\n\nassertEquals(CATEGORY_NAME, category.getValue().getName());\n}\n</code></pre> <pre><code>public static final Long NEW_CATEGORY_ID = 4L;\npublic static final String NEW_CATEGORY_NAME = \"CAT4\";\n\n@Test\npublic void saveWithoutIdShouldCreateNewCategory() {\n\nCategoryDto dto = new CategoryDto();\ndto.setName(NEW_CATEGORY_NAME);\n\nrestTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.PUT, new HttpEntity&lt;&gt;(dto), Void.class);\n\nResponseEntity&lt;List&lt;CategoryDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.GET, null, responseType);\nassertNotNull(response);\nassertEquals(4, response.getBody().size());\n\nCategoryDto categorySearch = response.getBody().stream().filter(item -&gt; item.getId().equals(NEW_CATEGORY_ID)).findFirst().orElse(null);\nassertNotNull(categorySearch);\nassertEquals(NEW_CATEGORY_NAME, categorySearch.getName());\n}\n</code></pre> <p>En el primer caso, estamos construyendo un objeto <code>CategoryDto</code> para darle un nombre a la <code>Categor\u00eda</code> e invocamos a la operaci\u00f3n <code>save</code> pasandole un ID a nulo. Para identificar que el funcionamiento es el esperado, capturamos la categor\u00eda que se proporciona al repository al intentar realizar la acci\u00f3n ficticia de guardado y comprobamos que el valor es el que se proporciona en la invocaci\u00f3n.</p> <p>De forma similar en el segundo caso, estamos construyendo un objeto <code>CategoryDto</code> para darle un nombre a la <code>Categor\u00eda</code> e invocamos al m\u00e9todo <code>PUT</code> sin a\u00f1adir en la ruta referencia al identificador. Seguidamente, recuperamos de nuevo la lista de categor\u00edas y en este caso deber\u00eda tener 4 resultados. Hacemos un filtrado buscando la nueva <code>Categor\u00eda</code> que deber\u00eda tener un ID = 4 y deber\u00eda ser la que acabamos de crear. </p> <p>Si ejecutamos, veremos que ambos test ahora aparecen en verde.</p>"},{"location":"develop/basic/springboot/#pruebas-de-modificacion","title":"Pruebas de modificaci\u00f3n","text":"<p>Para este caso de prueba, vamos a realizar varios test, como hemos comentado anteriormente. Tenemos que probar que es lo que pasa cuando intentamos modificar un elemento que existe, pero tambi\u00e9n debemos probar que es lo que pasa cuando intentamos modificar un elemento que no existe.</p> <p>Empezamos con el sencillo, un test que pruebe una modificaci\u00f3n existente.</p> CategoryTest.javaCategoryIT.java <pre><code>public static final Long EXISTS_CATEGORY_ID = 1L;\n\n@Test\npublic void saveExistsCategoryIdShouldUpdate() {\n\nCategoryDto categoryDto = new CategoryDto();\ncategoryDto.setName(CATEGORY_NAME);\n\nCategory category = mock(Category.class);\nwhen(categoryRepository.findById(EXISTS_CATEGORY_ID)).thenReturn(Optional.of(category));\n\ncategoryService.save(EXISTS_CATEGORY_ID, categoryDto);\n\nverify(categoryRepository).save(category);\n}\n</code></pre> <pre><code>public static final Long MODIFY_CATEGORY_ID = 3L;\n\n@Test\npublic void modifyWithExistIdShouldModifyCategory() {\n\nCategoryDto dto = new CategoryDto();\ndto.setName(NEW_CATEGORY_NAME);\n\nrestTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + MODIFY_CATEGORY_ID, HttpMethod.PUT, new HttpEntity&lt;&gt;(dto), Void.class);\n\nResponseEntity&lt;List&lt;CategoryDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.GET, null, responseType);\nassertNotNull(response);\nassertEquals(3, response.getBody().size());\n\nCategoryDto categorySearch = response.getBody().stream().filter(item -&gt; item.getId().equals(MODIFY_CATEGORY_ID)).findFirst().orElse(null);\nassertNotNull(categorySearch);\nassertEquals(NEW_CATEGORY_NAME, categorySearch.getName());\n}\n</code></pre> <p>En el caso de los test unitarios, comprobamos la l\u00f3gica de la modificaci\u00f3n simulando que el repository nos devuelve una categor\u00eda que modificar y verificado que se invoca el guardado sobre la misma.</p> <p>En el caso de los test de integraci\u00f3n, la misma filosof\u00eda que en el test anterior, pero esta vez modificamos la <code>Categor\u00eda</code> de ID = 3. Luego la filtramos y vemos que realmente se ha modificado. Adem\u00e1s comprobamos que el listado de todas los registros sigue siendo 3 y no se ha creado un nuevo registro.</p> <p>En el siguiente test, probaremos un resultado err\u00f3neo.</p> CategoryIT.java <pre><code>@Test\npublic void modifyWithNotExistIdShouldInternalError() {\n\nCategoryDto dto = new CategoryDto();\ndto.setName(NEW_CATEGORY_NAME);\n\nResponseEntity&lt;?&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + NEW_CATEGORY_ID, HttpMethod.PUT, new HttpEntity&lt;&gt;(dto), Void.class);\n\nassertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());\n}\n</code></pre> <p>Intentamos modificar el ID = 4, que no deber\u00eda existir en BBDD y por tanto lo que se espera en el test es que lance un <code>500 Internal Server Error</code> al llamar al m\u00e9todo <code>PUT</code>.</p>"},{"location":"develop/basic/springboot/#pruebas-de-borrado","title":"Pruebas de borrado","text":"<p>Ya por \u00faltimo implementamos las pruebas de borrado.</p> CategoryTest.javaCategoryIT.java <pre><code>@Test\npublic void deleteExistsCategoryIdShouldDelete() throws Exception {\n\nCategory category = mock(Category.class);\nwhen(categoryRepository.findById(EXISTS_CATEGORY_ID)).thenReturn(Optional.of(category));\n\ncategoryService.delete(EXISTS_CATEGORY_ID);\n\nverify(categoryRepository).deleteById(EXISTS_CATEGORY_ID);\n}\n</code></pre> <pre><code>public static final Long DELETE_CATEGORY_ID = 2L;\n\n@Test\npublic void deleteWithExistsIdShouldDeleteCategory() {\n\nrestTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + DELETE_CATEGORY_ID, HttpMethod.DELETE, null, Void.class);\n\nResponseEntity&lt;List&lt;CategoryDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.GET, null, responseType);\nassertNotNull(response);\nassertEquals(2, response.getBody().size());\n}\n\n@Test\npublic void deleteWithNotExistsIdShouldInternalError() {\n\nResponseEntity&lt;?&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + NEW_CATEGORY_ID, HttpMethod.DELETE, null, Void.class);\n\nassertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());\n}\n</code></pre> <p>En cuanto al test unitario, se invoca a la operaci\u00f3n <code>delete</code> y se verifica que la operaci\u00f3n requerida del repository es invocado con el atributo correcto.    </p> <p>En lo relativo a las pruebas de integraci\u00f3n, en el primer test, se invoca el m\u00e9todo <code>DELETE</code> y posteriormente se comprueba que el listado tiene un tama\u00f1o de 2 (uno menos que el original). Mientras que en el segundo test, se comprueba que con ID no v\u00e1lido, devuelve un <code>500 Internal Server Error</code>.</p> <p>Con esto tendr\u00edamos m\u00e1s o menos probados los casos b\u00e1sicos de nuestra aplicaci\u00f3n y tendr\u00edamos una peque\u00f1a red de seguridad que nos ayudar\u00eda por si a futuro necesitamos hacer alg\u00fan cambio o evolutivo.</p>"},{"location":"develop/basic/springboot/#que-hemos-aprendido","title":"\u00bfQ\u00fae hemos aprendido?","text":"<p>Resumiendo un poco los pasos que hemos seguido:</p> <ul> <li>Hay que definir y agrupar por \u00e1mbito funcional, hemos creado el package <code>com.ccsw.tutorial.category</code> para aglutinar todas las clases.</li> <li>Lo primero que debemos empezar a construir siempre son los test, aunque en este cap\u00edtulo del tutorial lo hemos hecho al rev\u00e9s solo con fines did\u00e1cticos. En los siguientes cap\u00edtulos lo haremos de forma correcta, y esto nos ayudar\u00e1 a pensar y dise\u00f1ar que es lo que queremos implementar realmente.</li> <li>La implementaci\u00f3n de la aplicaci\u00f3n se deber\u00eda separar por capas:<ul> <li><code>Controller</code> \u2192 Maneja las peticiones de entrada del cliente y realiza transformaciones. No ejecuta directamente l\u00f3gica de negocio, para eso utiliza llamadas a la siguiente capa.</li> <li><code>Service</code> \u2192 Ejecuta la l\u00f3gica de negocio en sus m\u00e9todos o llamando a otros objetos de la misma capa. No ejecuta directamente accesos a datos, para eso utiliza la siguiente capa.</li> <li><code>Repository</code> \u2192 Realiza los accesos a datos de lectura y escritura. NUNCA debe llamar a otros objetos de la misma capa ni de capas anteriores.</li> </ul> </li> <li>Hay que tener en cuenta los objetos modelo que se mueven en cada capa. Generalmente son:<ul> <li><code>Json</code> \u2192 Los datos que vienen y van del cliente al <code>Controller</code>.</li> <li><code>DTO</code> \u2192 Los datos se mueven dentro del <code>Controller</code> y sirven para invocar llamadas. Tambi\u00e9n son los datos que devuelve un <code>Controller</code>.</li> <li><code>Entity</code> \u2192 Los datos que sirven para persistir y leer datos de una BBDD y que NUNCA deber\u00edan ir m\u00e1s all\u00e1 del <code>Controller</code>.</li> </ul> </li> </ul>"},{"location":"develop/basic/springboot/#depuracion","title":"Depuraci\u00f3n","text":"<p>Una parte muy importante del desarrollo es tener la capacidad de depurar nuestro c\u00f3digo, en este apartado vamos a explicar como se realiza <code>debug</code> en Backend.</p> <p>Esta parte se realiza con las herramientas incluidas dentro de nuestro IDE favorito, en este caso vamos a utilizar el Eclipse.</p> <p>Lo primero que debemos hacer es arrancar la aplicaci\u00f3n en modo <code>Debug</code>:</p> <p></p> <p>Arrancada la aplicaci\u00f3n en este modo, vamos a depurar la operaci\u00f3n de crear categor\u00eda.</p> <p>Para ello vamos a abrir nuestro fichero donde tenemos la implementaci\u00f3n del servicio de creaci\u00f3n de la capa de la l\u00f3gica de negocio <code>CategoryServiceImpl</code>.</p> <p>Dentro del fichero ya podemos a\u00f1adir puntos de ruptura (breakpoint), en nuestro caso queremos comprobar que el nombre introducido se recibe correctamente.</p> <p>Colocamos el breakpoint en la primera l\u00ednea del m\u00e9todo (click sobre el n\u00famero de la l\u00ednea) y desde la interfaz/postman creamos una nueva categor\u00eda.</p> <p>Hecho esto, podemos observar que a nivel de interfaz/postman, la petici\u00f3n se queda esperando y el IDE pasa modo <code>Debug</code> (la primera vez nos preguntar\u00e1 si queremos hacerlo, le decimos que si):</p> <p></p> <p>El IDE nos lleva al punto exacto donde hemos a\u00f1adido el breakpoint y se para en este punto ofreci\u00e9ndonos la posibilidad de explorar el contenido de las variables del c\u00f3digo:</p> <p></p> <p>Aqu\u00ed podemos comprobar que efectivamente el atributo <code>name</code> de la variable <code>dto</code> tiene el valor que hemos introducido por pantalla/postman.</p> <p>Para continuar con la ejecuci\u00f3n basta con darle al bot\u00f3n de <code>play</code> de la barra de herramientas superior.</p> <p>Nota: para volver al modo <code>Java</code> de Eclipse, presionamos el bot\u00f3n que se sit\u00faa a la izquierda del modo <code>Debug</code> en el que ha entrado el IDE autom\u00e1ticamente.</p>"},{"location":"develop/filtered/angular/","title":"Listado filtrado - Angular","text":"<p>En este punto ya tenemos dos listados, uno b\u00e1sico y otro paginado. Ahora vamos a implementar un listado un poco diferente, con filtros y con una presentaci\u00f3n un tanto distinta.</p> <p>Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.</p>"},{"location":"develop/filtered/angular/#crear-componentes","title":"Crear componentes","text":"<p>Vamos a desarrollar el listado de <code>Juegos</code>. Este listado es un tanto peculiar, porque no tiene una tabla como tal, sino que tiene una tabla con \"tiles\" para cada uno de los juegos. Necesitaremos un componente para el listado y otro componente para el detalle del juego. Tambi\u00e9n necesitaremos otro componente para el dialogo de edici\u00f3n / alta.</p> <p>Manos a la obra:</p> <pre><code>ng generate module game\n\nng generate component game/game-list\nng generate component game/game-list/game-item\nng generate component game/game-edit\n\nng generate service game/game\n</code></pre> <p>Y a\u00f1adimos el nuevo m\u00f3dulo al <code>app.module.ts</code> como hemos hecho con el resto de m\u00f3dulos.</p> Game.ts <pre><code>import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { CoreModule } from './core/core.module';\nimport { CategoryModule } from './category/category.module';\nimport { AuthorModule } from './author/author.module';\nimport { GameModule } from './game/game.module';\n\n@NgModule({\ndeclarations: [\nAppComponent\n],\nimports: [\nBrowserModule,\nAppRoutingModule,\nCoreModule,\nCategoryModule,\nAuthorModule,\nGameModule,\nBrowserAnimationsModule\n],\nproviders: [],\nbootstrap: [AppComponent]\n})\nexport class AppModule { }\n</code></pre>"},{"location":"develop/filtered/angular/#crear-el-modelo","title":"Crear el modelo","text":"<p>Lo primero que vamos a hacer es crear el modelo en <code>game/model/Game.ts</code> con todas las propiedades necesarias para trabajar con un juego:</p> Game.ts <pre><code>import { Category } from \"src/app/category/model/Category\";\nimport { Author } from \"src/app/author/model/Author\";\n\nexport class Game {\nid: number;\ntitle: string;\nage: number;\ncategory: Category;\nauthor: Author;\n}\n</code></pre> <p>Como ves, el juego tiene dos objetos para mapear categor\u00eda y autor.</p>"},{"location":"develop/filtered/angular/#anadir-el-punto-de-entrada","title":"A\u00f1adir el punto de entrada","text":"<p>A\u00f1adimos la ruta al men\u00fa para que podamos navegar a esta pantalla:</p> app-routing.module.ts <pre><code>import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { AuthorListComponent } from './author/author-list/author-list.component';\nimport { CategoryListComponent } from './category/category-list/category-list.component';\nimport { GameListComponent } from './game/game-list/game-list.component';\nconst routes: Routes = [\n{ path: '', redirectTo: '/games', pathMatch: 'full'},\n{ path: 'categories', component: CategoryListComponent },\n{ path: 'authors', component: AuthorListComponent },\n{ path: 'games', component: GameListComponent },\n];\n\n@NgModule({\nimports: [RouterModule.forRoot(routes)],\nexports: [RouterModule]\n})\nexport class AppRoutingModule { }\n</code></pre> <p>Adem\u00e1s, hemos a\u00f1adido una regla adicional con el path vac\u00edo para indicar que si no pone ruta, por defecto la p\u00e1gina inicial redirija al path <code>/games</code>, que es nuevo path que hemos a\u00f1adido.</p>"},{"location":"develop/filtered/angular/#implementar-servicio","title":"Implementar servicio","text":"<p>A continuaci\u00f3n implementamos el servicio y mockeamos datos de ejemplo:</p> mock-games.tsgame.service.ts <pre><code>import { Game } from \"./Game\";\n\nexport const GAME_DATA: Game[] = [\n{ id: 1, title: 'Juego 1', age: 6, category: { id: 1, name: 'Categor\u00eda 1' }, author: { id: 1, name: 'Autor 1', nationality: 'Nacionalidad 1' } },\n{ id: 2, title: 'Juego 2', age: 8, category: { id: 1, name: 'Categor\u00eda 1' }, author: { id: 2, name: 'Autor 2', nationality: 'Nacionalidad 2' } },\n{ id: 3, title: 'Juego 3', age: 4, category: { id: 1, name: 'Categor\u00eda 1' }, author: { id: 3, name: 'Autor 3', nationality: 'Nacionalidad 3' } },\n{ id: 4, title: 'Juego 4', age: 10, category: { id: 2, name: 'Categor\u00eda 2' }, author: { id: 1, name: 'Autor 1', nationality: 'Nacionalidad 1' } },\n{ id: 5, title: 'Juego 5', age: 16, category: { id: 2, name: 'Categor\u00eda 2' }, author: { id: 2, name: 'Autor 2', nationality: 'Nacionalidad 2' } },\n{ id: 6, title: 'Juego 6', age: 16, category: { id: 2, name: 'Categor\u00eda 2' }, author: { id: 3, name: 'Autor 3', nationality: 'Nacionalidad 3' } },\n{ id: 7, title: 'Juego 7', age: 12, category: { id: 3, name: 'Categor\u00eda 3' }, author: { id: 1, name: 'Autor 1', nationality: 'Nacionalidad 1' } },\n{ id: 8, title: 'Juego 8', age: 14, category: { id: 3, name: 'Categor\u00eda 3' }, author: { id: 2, name: 'Autor 2', nationality: 'Nacionalidad 2' } },\n]\n</code></pre> <pre><code>import { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Game } from './model/Game';\nimport { GAME_DATA } from './model/mock-games';\n\n@Injectable({\nprovidedIn: 'root'\n})\nexport class GameService {\n\nconstructor() { }\n\ngetGames(title?: String, categoryId?: number): Observable&lt;Game[]&gt; {\nreturn of(GAME_DATA);\n}\n\nsaveGame(game: Game): Observable&lt;void&gt; {\nreturn of(null);\n}\n\n}\n</code></pre>"},{"location":"develop/filtered/angular/#implementar-listado","title":"Implementar listado","text":"<p>Ya tenemos las operaciones del servicio con datoos, as\u00ed que ahora vamos a por el listado filtrado.</p> game-list.component.htmlgame-list.component.scssgame-list.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1&gt;Cat\u00e1logo de juegos&lt;/h1&gt;\n\n    &lt;div class=\"filters\"&gt;\n        &lt;form&gt;\n            &lt;mat-form-field&gt;\n                &lt;mat-label&gt;T\u00edtulo del juego&lt;/mat-label&gt;\n                &lt;input type=\"text\" matInput placeholder=\"T\u00edtulo del juego\" [(ngModel)]=\"filterTitle\" name=\"title\"&gt;\n            &lt;/mat-form-field&gt;\n\n            &lt;mat-form-field&gt;\n                &lt;mat-label&gt;Categor\u00eda del juego&lt;/mat-label&gt;\n                &lt;mat-select disableRipple [(ngModel)]=\"filterCategory\" name=\"category\"&gt;\n                    &lt;mat-option *ngFor=\"let category of categories\" [value]=\"category\"&gt;{{category.name}}&lt;/mat-option&gt;\n                &lt;/mat-select&gt;\n            &lt;/mat-form-field&gt;    \n        &lt;/form&gt;\n\n        &lt;div class=\"buttons\"&gt;\n            &lt;button mat-stroked-button (click)=\"onCleanFilter()\"&gt;Limpiar&lt;/button&gt; \n            &lt;button mat-stroked-button (click)=\"onSearch()\"&gt;Filtrar&lt;/button&gt; \n        &lt;/div&gt;   \n    &lt;/div&gt;   \n\n    &lt;div class=\"game-list\"&gt;\n        &lt;app-game-item *ngFor=\"let game of games; let i = index;\" (click)=\"editGame(game)\"&gt;\n        &lt;/app-game-item&gt;\n    &lt;/div&gt;\n\n    &lt;div class=\"buttons\"&gt;\n        &lt;button mat-flat-button color=\"primary\" (click)=\"createGame()\"&gt;Nuevo juego&lt;/button&gt;            \n    &lt;/div&gt;   \n&lt;/div&gt;\n</code></pre> <pre><code>.container {\nmargin: 20px;\n\n.filters {\ndisplay: flex;\n\nmat-form-field {\nwidth: 300px;\nmargin-right: 20px;\n}\n\n.buttons {\nflex: auto;\nalign-self: center;\n\nbutton {\nmargin-left: 15px;\n}\n}\n}\n\n.game-list { margin-top: 20px;\nmargin-bottom: 20px;\n\ndisplay: flex;\nflex-flow: wrap;\noverflow: auto;  }\n\n.buttons {\ntext-align: right;\n}\n}\n\nbutton {\nwidth: 125px;\n}\n</code></pre> <pre><code>import { Component, OnInit } from '@angular/core';\nimport { MatDialog } from '@angular/material/dialog';\nimport { CategoryService } from 'src/app/category/category.service';\nimport { Category } from 'src/app/category/model/Category';\nimport { GameEditComponent } from '../game-edit/game-edit.component';\nimport { GameService } from '../game.service';\nimport { Game } from '../model/Game';\n\n@Component({\nselector: 'app-game-list',\ntemplateUrl: './game-list.component.html',\nstyleUrls: ['./game-list.component.scss']\n})\nexport class GameListComponent implements OnInit {\n\ncategories : Category[];\ngames: Game[];\nfilterCategory: Category;\nfilterTitle: string;\n\nconstructor(\nprivate gameService: GameService,\nprivate categoryService: CategoryService,\npublic dialog: MatDialog,\n) { }\n\nngOnInit(): void {\n\nthis.gameService.getGames().subscribe(\ngames =&gt; this.games = games\n);\n\nthis.categoryService.getCategories().subscribe(\ncategories =&gt; this.categories = categories\n);\n}\n\nonCleanFilter(): void {\nthis.filterTitle = null;\nthis.filterCategory = null;\n\nthis.onSearch();\n}\n\nonSearch(): void {\n\nlet title = this.filterTitle;\nlet categoryId = this.filterCategory != null ? this.filterCategory.id : null;\n\nthis.gameService.getGames(title, categoryId).subscribe(\ngames =&gt; this.games = games\n);\n}\n\ncreateGame() {    const dialogRef = this.dialog.open(GameEditComponent, {\ndata: {}\n});\n\ndialogRef.afterClosed().subscribe(result =&gt; {\nthis.ngOnInit();\n});    }  editGame(game: Game) {\nconst dialogRef = this.dialog.open(GameEditComponent, {\ndata: { game: game }\n});\n\ndialogRef.afterClosed().subscribe(result =&gt; {\nthis.onSearch();\n});\n}\n}\n</code></pre> <p>Recuerda, de nuevo, que todos los componentes de Angular que utilicemos hay que importarlos en el m\u00f3dulo padre correspondiente para que se puedan precargar correctamente.</p> game.module.ts <pre><code>import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { GameListComponent } from './game-list/game-list.component';\nimport { GameEditComponent } from './game-edit/game-edit.component';\nimport { GameItemComponent } from './game-list/game-item/game-item.component';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { MatButtonModule } from '@angular/material/button';\nimport { MatOptionModule } from '@angular/material/core';\nimport { MatDialogModule } from '@angular/material/dialog';\nimport { MatFormFieldModule } from '@angular/material/form-field';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatInputModule } from '@angular/material/input';\nimport { MatPaginatorModule } from '@angular/material/paginator';\nimport { MatSelectModule } from '@angular/material/select';\nimport { MatTableModule } from '@angular/material/table';\nimport { MatCardModule } from '@angular/material/card';\n\n\n@NgModule({\ndeclarations: [\nGameListComponent,\nGameEditComponent,\nGameItemComponent\n],\nimports: [\nCommonModule,\nMatTableModule,\nMatIconModule, MatButtonModule,\nMatDialogModule,\nMatFormFieldModule,\nMatInputModule,\nFormsModule,\nReactiveFormsModule,\nMatPaginatorModule,\nMatOptionModule,\nMatSelectModule,\nMatCardModule,\n]\n})\nexport class GameModule { }\n</code></pre> <p>Con todos estos cambios y si refrescamos el navegador, deber\u00eda verse una pantalla similar a esta:</p> <p></p> <p>Tenemos una pantalla con una secci\u00f3n de filtros en la parte superior, donde podemos introducir un texto o seleccionar una categor\u00eda de un dropdown, un listado que de momento tiene todos los componentes b\u00e1sicos en una fila uno detr\u00e1s del otro, y un bot\u00f3n para crear juegos nuevos.</p> <p>Dropdown</p> <p>El componente <code>Dropdown</code> es uno de los componentes m\u00e1s utilizados en las pantallas y formularios de Angular. Ves familiariz\u00e1ndote con \u00e9l porque lo vas a usar mucho. Es bastante potente y medianamente sencillo de utilizar. Los datos del listado pueden ser din\u00e1micos (desde servidor) o est\u00e1ticos (si los valores ya los tienes prefijados).</p>"},{"location":"develop/filtered/angular/#implementar-detalle-del-item","title":"Implementar detalle del item","text":"<p>Ahora vamos a implementar el detalle de cada uno de los items que forman el listado. Para ello lo primero que haremos ser\u00e1 pasarle la informaci\u00f3n del juego a cada componente como un dato de entrada <code>Input</code> hacia el componente.</p> game-list.component.html <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1&gt;Cat\u00e1logo de juegos&lt;/h1&gt;\n\n    &lt;div class=\"filters\"&gt;\n        &lt;form&gt;\n            &lt;mat-form-field&gt;\n                &lt;mat-label&gt;T\u00edtulo del juego&lt;/mat-label&gt;\n                &lt;input type=\"text\" matInput placeholder=\"T\u00edtulo del juego\" [(ngModel)]=\"filterTitle\" name=\"title\"&gt;\n            &lt;/mat-form-field&gt;\n\n            &lt;mat-form-field&gt;\n                &lt;mat-label&gt;Categor\u00eda del juego&lt;/mat-label&gt;\n                &lt;mat-select disableRipple [(ngModel)]=\"filterCategory\" name=\"category\"&gt;\n                    &lt;mat-option *ngFor=\"let category of categories\" [value]=\"category\"&gt;{{category.name}}&lt;/mat-option&gt;\n                &lt;/mat-select&gt;\n            &lt;/mat-form-field&gt;    \n        &lt;/form&gt;\n\n        &lt;div class=\"buttons\"&gt;\n            &lt;button mat-stroked-button (click)=\"onCleanFilter()\"&gt;Limpiar&lt;/button&gt; \n            &lt;button mat-stroked-button (click)=\"onSearch()\"&gt;Filtrar&lt;/button&gt; \n        &lt;/div&gt;   \n    &lt;/div&gt;   \n\n    &lt;div class=\"game-list\"&gt;\n&lt;app-game-item *ngFor=\"let game of games; let i = index;\" (click)=\"editGame(game)\" [game]=\"game\"&gt;\n&lt;/app-game-item&gt;\n    &lt;/div&gt;\n\n    &lt;div class=\"buttons\"&gt;\n        &lt;button mat-flat-button color=\"primary\" (click)=\"createGame()\"&gt;Nuevo juego&lt;/button&gt;            \n    &lt;/div&gt;   \n&lt;/div&gt;\n</code></pre> <p>Tambi\u00e9n vamos a necesitar una foto de ejemplo para poner dentro de la tarjeta detalle de los juegos. Vamos a utilizar esta imagen:</p> <p></p> <p>Desc\u00e1rgala y d\u00e9jala dentro del proyecto en <code>assets/foto.png</code>. Y ya para terminar, implementamos el componente de detalle:</p> game-item.component.htmlgame-item.component.scssgame-item.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;mat-card&gt;\n        &lt;div class=\"photo\"&gt;\n            &lt;img src=\"./assets/foto.png\"&gt;\n        &lt;/div&gt;\n        &lt;div class=\"detail\"&gt;\n            &lt;div class=\"title\"&gt;{{game.title}}&lt;/div&gt;\n            &lt;div class=\"properties\"&gt;\n                &lt;div&gt;&lt;i&gt;Edad recomendada: &lt;/i&gt;+{{game.age}}&lt;/div&gt;\n                &lt;div&gt;&lt;i&gt;Categor\u00eda: &lt;/i&gt;{{game.category.name}}&lt;/div&gt;\n                &lt;div&gt;&lt;i&gt;Autor: &lt;/i&gt;{{game.author.name}}&lt;/div&gt;\n                &lt;div&gt;&lt;i&gt;Nacionalidad: &lt;/i&gt;{{game.author.nationality}}&lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/mat-card&gt;\n&lt;/div&gt;\n</code></pre> <pre><code>.container {\ndisplay: flex;\nwidth: 325px;\n\nmat-card {\nwidth: 100%;\nmargin: 10px;\ndisplay: flex;\n\n.photo {\nmargin-right: 10px;\n\nimg {\nwidth: 80px;\nheight: 80px;\n}\n}\n\n.detail {\n.title {\nfont-size: 14px;\nfont-weight: bold;\n}\n\n.properties {\nfont-size: 11px;\n\ndiv {\nheight: 15px;\n}                }\n}\n}\n}    </code></pre> <pre><code>import { Component, OnInit, Input } from '@angular/core';\nimport { Game } from '../../model/Game';\n\n@Component({\nselector: 'app-game-item',\ntemplateUrl: './game-item.component.html',\nstyleUrls: ['./game-item.component.scss']\n})\nexport class GameItemComponent implements OnInit {\n\n@Input() game: Game;\nconstructor() { }\n\nngOnInit(): void {\n}\n\n}\n</code></pre> <p>Ahora si que deber\u00eda quedar algo similar a esta pantalla:</p> <p></p>"},{"location":"develop/filtered/angular/#implementar-dialogo-de-edicion","title":"Implementar dialogo de edici\u00f3n","text":"<p>Ya solo nos falta el \u00faltimo paso, implementar el cuadro de edici\u00f3n / alta de un nuevo juego. Pero tenemos un peque\u00f1o problema, y es que al crear o editar un juego debemos seleccionar una <code>Categor\u00eda</code> y un <code>Autor</code>. </p> <p>Para la <code>Categor\u00eda</code> no tenemos ning\u00fan problema, pero para el <code>Autor</code> no tenemos un servicio que nos devuelva todos los autores, solo tenemos un servicio que nos devuelve una <code>Page</code> de autores.</p> <p>As\u00ed que lo primero que haremos ser\u00e1 implementar una operaci\u00f3n <code>getAllAuthors</code> para poder recuperar una lista.</p> mock-authors-list.tsauthor.service.ts <pre><code>import { Author } from \"./Author\";\n\nexport const AUTHOR_DATA_LIST : Author[] = [\n{ id: 1, name: 'Klaus Teuber', nationality: 'Alemania' },\n{ id: 2, name: 'Matt Leacock', nationality: 'Estados Unidos' },\n{ id: 3, name: 'Keng Leong Yeo', nationality: 'Singapur' },\n{ id: 4, name: 'Gil Hova', nationality: 'Estados Unidos'},\n{ id: 5, name: 'Kelly Adams', nationality: 'Estados Unidos' },\n]    </code></pre> <pre><code>import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Pageable } from '../core/model/page/Pageable';\nimport { Author } from './model/Author';\nimport { AuthorPage } from './model/AuthorPage';\nimport { AUTHOR_DATA_LIST } from './model/mock-authors-list';\n@Injectable({\nprovidedIn: 'root'\n})\nexport class AuthorService {\n\nconstructor(\nprivate http: HttpClient\n) { }\n\ngetAuthors(pageable: Pageable): Observable&lt;AuthorPage&gt; {\nreturn this.http.post&lt;AuthorPage&gt;('http://localhost:8080/author', {pageable:pageable});\n}\n\nsaveAuthor(author: Author): Observable&lt;void&gt; {\n\nlet url = 'http://localhost:8080/author';\nif (author.id != null) url += '/'+author.id;\n\nreturn this.http.put&lt;void&gt;(url, author);\n}\n\ndeleteAuthor(idAuthor : number): Observable&lt;void&gt; {\nreturn this.http.delete&lt;void&gt;('http://localhost:8080/author/'+idAuthor);\n}    getAllAuthors(): Observable&lt;Author[]&gt; {\nreturn of(AUTHOR_DATA_LIST);\n}\n}\n</code></pre> <p>Ahora s\u00ed que tenemos todo listo para implementar el cuadro de dialogo para dar de alta o editar juegos.</p> game-edit.component.htmlgame-edit.component.scssgame-edit.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1 *ngIf=\"game.id == null\"&gt;Crear juego&lt;/h1&gt;\n    &lt;h1 *ngIf=\"game.id != null\"&gt;Modificar juego&lt;/h1&gt;\n\n    &lt;form&gt;\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;Identificador&lt;/mat-label&gt;\n            &lt;input type=\"text\" matInput placeholder=\"Identificador\" [(ngModel)]=\"game.id\" name=\"id\" disabled&gt;\n        &lt;/mat-form-field&gt;\n\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;T\u00edtulo&lt;/mat-label&gt;\n            &lt;input type=\"text\" matInput placeholder=\"T\u00edtulo del juego\" [(ngModel)]=\"game.title\" name=\"title\" required&gt;\n            &lt;mat-error&gt;El t\u00edtulo no puede estar vac\u00edo&lt;/mat-error&gt;\n        &lt;/mat-form-field&gt;\n\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;Edad recomendada&lt;/mat-label&gt;\n            &lt;input type=\"number\" matInput placeholder=\"Edad recomendada\" [(ngModel)]=\"game.age\" name=\"age\" required&gt;\n            &lt;mat-error&gt;La edad no puede estar vac\u00eda&lt;/mat-error&gt;\n        &lt;/mat-form-field&gt;\n\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;Categor\u00eda&lt;/mat-label&gt;\n            &lt;mat-select disableRipple [(ngModel)]=\"game.category\" name=\"category\" required&gt;\n                &lt;mat-option *ngFor=\"let category of categories\" [value]=\"category\"&gt;{{category.name}}&lt;/mat-option&gt;\n            &lt;/mat-select&gt;\n            &lt;mat-error&gt;La categor\u00eda no puede estar vac\u00eda&lt;/mat-error&gt;\n        &lt;/mat-form-field&gt;\n\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;Autor&lt;/mat-label&gt;\n            &lt;mat-select disableRipple [(ngModel)]=\"game.author\" name=\"author\" required&gt;\n                &lt;mat-option *ngFor=\"let author of authors\" [value]=\"author\"&gt;{{author.name}}&lt;/mat-option&gt;\n            &lt;/mat-select&gt;\n            &lt;mat-error&gt;El autor no puede estar vac\u00edo&lt;/mat-error&gt;\n        &lt;/mat-form-field&gt;\n    &lt;/form&gt;\n\n    &lt;div class=\"buttons\"&gt;\n        &lt;button mat-stroked-button (click)=\"onClose()\"&gt;Cerrar&lt;/button&gt;\n        &lt;button mat-flat-button color=\"primary\" (click)=\"onSave()\"&gt;Guardar&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <pre><code>.container {\nmin-width: 350px;\nmax-width: 500px;\nwidth: 100%;\n\nform {\ndisplay: flex;\nflex-direction: column;\nmargin-bottom:20px;\n}\n\n.buttons {\ntext-align: right;\n\nbutton {\nmargin-left: 10px;\n}\n}\n}\n</code></pre> <pre><code>import { Component, Inject, OnInit } from '@angular/core';\nimport { MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';\nimport { AuthorService } from 'src/app/author/author.service';\nimport { Author } from 'src/app/author/model/Author';\nimport { CategoryService } from 'src/app/category/category.service';\nimport { Category } from 'src/app/category/model/Category';\nimport { GameService } from '../game.service';\nimport { Game } from '../model/Game';\n\n@Component({\nselector: 'app-game-edit',\ntemplateUrl: './game-edit.component.html',\nstyleUrls: ['./game-edit.component.scss']\n})\nexport class GameEditComponent implements OnInit {\n\ngame: Game; authors: Author[];\ncategories: Category[];\n\nconstructor(\npublic dialogRef: MatDialogRef&lt;GameEditComponent&gt;,\n@Inject(MAT_DIALOG_DATA) public data: any,\nprivate gameService: GameService,\nprivate categoryService: CategoryService,\nprivate authorService: AuthorService,\n) { }\n\nngOnInit(): void {\nif (this.data.game != null) {\nthis.game = Object.assign({}, this.data.game);\n}\nelse {\nthis.game = new Game();\n}\n\nthis.categoryService.getCategories().subscribe(\ncategories =&gt; {\nthis.categories = categories;\n\nif (this.game.category != null) {\nlet categoryFilter: Category[] = categories.filter(category =&gt; category.id == this.data.game.category.id);\nif (categoryFilter != null) {\nthis.game.category = categoryFilter[0];\n}\n}\n}\n);\n\nthis.authorService.getAllAuthors().subscribe(\nauthors =&gt; {\nthis.authors = authors\n\nif (this.game.author != null) {\nlet authorFilter: Author[] = authors.filter(author =&gt; author.id == this.data.game.author.id);\nif (authorFilter != null) {\nthis.game.author = authorFilter[0];\n}\n}\n}\n);\n}\n\nonSave() {\nthis.gameService.saveGame(this.game).subscribe(result =&gt; {\nthis.dialogRef.close();\n});    }  onClose() {\nthis.dialogRef.close();\n}\n\n}\n</code></pre> <p>Como puedes ver, para rellenar los componentes seleccionables de dropdown, hemos realizado una consulta al servicio para recuperar todos los autores y categorias, y en la respuesta de cada uno de ellos, hemos buscado en los resultados cual es el que coincide con el ID enviado desde el listado, y ese es el que hemos fijado en el objeto <code>Game</code>.</p> <p>De esta forma, no estamos cogiendo directamente los datos del listado, sino que no estamos asegurando que los datos de autor y de categor\u00eda son los que vienen del servicio, siempre filtrando por su ID.</p>"},{"location":"develop/filtered/angular/#conectar-con-backend","title":"Conectar con Backend","text":"<p>Antes de seguir</p> <p>Antes de seguir con este punto, debes implementar el c\u00f3digo de backend en la tecnolog\u00eda que quieras (Springboot o Nodejs). Si has empezado este cap\u00edtulo implementando el frontend, por favor accede a la secci\u00f3n correspondiente de backend para poder continuar con el tutorial. Una vez tengas implementadas todas las operaciones para este listado, puedes volver a este punto y continuar con Angular.</p> <p>Una vez implementado front y back, lo que nos queda es modificar el servicio del front para que conecte directamente con las operaciones ofrecidas por el back.</p> author-service.tsgame-service.ts <pre><code>import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Pageable } from '../core/model/page/Pageable';\nimport { Author } from './model/Author';\nimport { AuthorPage } from './model/AuthorPage';\n\n@Injectable({\nprovidedIn: 'root'\n})\nexport class AuthorService {\n\nconstructor(\nprivate http: HttpClient\n) { }\n\ngetAuthors(pageable: Pageable): Observable&lt;AuthorPage&gt; {\nreturn this.http.post&lt;AuthorPage&gt;('http://localhost:8080/author', {pageable:pageable});\n}\n\nsaveAuthor(author: Author): Observable&lt;void&gt; {\n\nlet url = 'http://localhost:8080/author';\nif (author.id != null) url += '/'+author.id;\n\nreturn this.http.put&lt;void&gt;(url, author);\n}\n\ndeleteAuthor(idAuthor : number): Observable&lt;void&gt; {\nreturn this.http.delete&lt;void&gt;('http://localhost:8080/author/'+idAuthor);\n}    getAllAuthors(): Observable&lt;Author[]&gt; {\nreturn this.http.get&lt;Author[]&gt;('http://localhost:8080/author');\n}\n}\n</code></pre> <pre><code>import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Game } from './model/Game';\n\n@Injectable({\nprovidedIn: 'root'\n})\nexport class GameService {\n\nconstructor(\nprivate http: HttpClient\n) { }\n\ngetGames(title?: String, categoryId?: number): Observable&lt;Game[]&gt; {            return this.http.get&lt;Game[]&gt;(this.composeFindUrl(title, categoryId));\n}\n\nsaveGame(game: Game): Observable&lt;void&gt; {\nlet url = 'http://localhost:8080/game';\nif (game.id != null) {\nurl += '/'+game.id;\n}\nreturn this.http.put&lt;void&gt;(url, game);\n}\n\nprivate composeFindUrl(title?: String, categoryId?: number) : string {\nlet params = '';\nif (title != null) {\nparams += 'title='+title;\n}\nif (categoryId != null) {\nif (params != '') params += \"&amp;\";\nparams += \"idCategory=\"+categoryId;\n}\nlet url = 'http://localhost:8080/game'\nif (params == '') return url;\nelse return url + '?'+params;\n}\n}\n</code></pre> <p>Y ahora si, podemos navegar por la web y ver el resultado completo.</p>"},{"location":"develop/filtered/nodejs/","title":"Listado simple - Nodejs","text":"<p>En este punto ya tenemos dos listados, uno b\u00e1sico y otro paginado. Ahora vamos a implementar un listado un poco diferente, este listado va a tener filtros de b\u00fasqueda.</p> <p>Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.</p>"},{"location":"develop/filtered/nodejs/#crear-modelos","title":"Crear Modelos","text":"<p>Lo primero que vamos a hacer es crear el modelo de author para trabajar con BBDD. En la carpeta schemas creamos el archivo <code>game.schema.js</code>:</p> game.schema.js <pre><code>import mongoose from \"mongoose\";\nconst { Schema, model } = mongoose;\nimport normalize from 'normalize-mongoose';\n\nconst gameSchema = new Schema({\ntitle: {\ntype: String,\nrequire: true\n},\nage: {\ntype: Number,\nrequire: true,\nmax: 99,\nmin: 0\n},\ncategory: {\ntype: Schema.Types.ObjectId,\nref: 'Category',\nrequired: true\n},\nauthor: {\ntype: Schema.Types.ObjectId,\nref: 'Author',\nrequired: true\n}\n});\n\ngameSchema.plugin(normalize);\nconst GameModel = model('Game', gameSchema);\n\nexport default GameModel;\n</code></pre> <p>Lo m\u00e1s novedoso aqu\u00ed es que ahora cada juego va a tener una categor\u00eda y un autor asociados. Para ello simplemente en el tipo del dato <code>Category</code> y <code>Author</code> tenemos que hacer referencia al id del esquema deseado.</p>"},{"location":"develop/filtered/nodejs/#implementar-el-service","title":"Implementar el Service","text":"<p>Creamos el service correspondiente <code>game.service.js</code>:</p> game.service.js <pre><code>import GameModel from '../schemas/game.schema.js';\n\nexport const getGames = async (title, category) =&gt; {\ntry {\nconst regexTitle = new RegExp(title, 'i');\nconst find = category? { $and: [{ title: regexTitle }, { category: category }] } : { title: regexTitle };\nreturn await GameModel.find(find).sort('id').populate('category').populate('author');\n} catch(e) {\nthrow Error('Error fetching games');\n}\n}\n\nexport const createGame = async (data) =&gt; {\ntry {\nconst game = new GameModel({\n...data,\ncategory: data.category.id,\nauthor: data.author.id,\n});\nreturn await game.save();\n} catch (e) {\nthrow Error('Error creating game');\n}\n}\n\nexport const updateGame = async (id, data) =&gt; {\ntry {\nconst game = await GameModel.findById(id);\nif (!game) {\nthrow Error('There is no game with that Id');\n}    const gameToUpdate = {\n...data,\ncategory: data.category.id,\nauthor: data.author.id,\n};\nreturn await GameModel.findByIdAndUpdate(id, gameToUpdate, { new: false });\n} catch (e) {\nthrow Error(e);\n}\n}\n</code></pre> <p>En este caso recibimos en el m\u00e9todo para recuperar juegos dos par\u00e1metros, el titulo del juego y la categor\u00eda. Aqu\u00ed vamos a utilizar una expresi\u00f3n regular para que podamos encontrar cualquier juego que contenga el titulo que pasemos en su nombre. Con la categor\u00eda tiene que ser el valor exacto de su id. El m\u00e9todo populate lo que hace es traernos toda la informaci\u00f3n de la categor\u00eda y del autor. Sino lo us\u00e1semos solo nos recuperar\u00eda el id.</p>"},{"location":"develop/filtered/nodejs/#implementar-el-controller","title":"Implementar el Controller","text":"<p>Creamos el controlador <code>game.controller.js</code>:</p> game.controller.js <pre><code>import * as GameService from '../services/game.service.js';\n\nexport const getGames = async (req, res) =&gt; {\ntry {\nconst titleToFind = req.query?.title || '';\nconst categoryToFind = req.query?.idCategory || null;\nconst games = await GameService.getGames(titleToFind, categoryToFind);\nres.status(200).json(games);\n} catch(err) {\nres.status(400).json({\nmsg: err.toString()\n});\n}\n}\n\nexport const createGame = async (req, res) =&gt; {\ntry {\nconst game = await GameService.createGame(req.body);\nres.status(200).json({\ngame\n});\n} catch (err) {\nres.status(400).json({\nmsg: err.toString()\n});\n}\n}\n\nexport const updateGame = async (req, res) =&gt; {\nconst gameId = req.params.id;\ntry {\nawait GameService.updateGame(gameId, req.body);\nres.status(200).json(1);\n} catch (err) {\nres.status(400).json({\nmsg: err.toString()\n});\n}\n}\n</code></pre> <p>Los m\u00e9todos son muy parecidos al resto de los controllers. En este caso para recuperar los datos del filtro tendremos que hacerlo con <code>req.query</code> para leer los datos que nos lleguen como query params en la url. Por ejemplo: <code>http://localhost:8080/game?title=trivial&amp;category=1</code></p>"},{"location":"develop/filtered/nodejs/#implementar-las-rutas","title":"Implementar las Rutas","text":"<p>Y por \u00faltimo creamos nuestro archivo de rutas <code>game.routes.js</code>:</p> game.routes.js <pre><code>import { Router } from 'express';\nimport { check } from 'express-validator';\nimport validateFields from '../middlewares/validateFields.js';\nimport { createGame, getGames, updateGame } from '../controllers/game.controller.js';\nconst gameRouter = Router();\n\ngameRouter.put('/:id', [\ncheck('title').not().isEmpty(),\ncheck('age').not().isEmpty(),\ncheck('age').isNumeric(),\ncheck('category.id').not().isEmpty(),\ncheck('author.id').not().isEmpty(),\nvalidateFields\n], updateGame);\n\ngameRouter.put('/', [\ncheck('title').not().isEmpty(),\ncheck('age').not().isEmpty(),\ncheck('age').isNumeric(),\ncheck('category.id').not().isEmpty(),\ncheck('author.id').not().isEmpty(),\nvalidateFields\n], createGame);\n\ngameRouter.get('/', getGames);\ngameRouter.get('/:query', getGames);\n\nexport default gameRouter;\n</code></pre> <p>En este caso hemos tenido que meter dos rutas para <code>get</code>, una para cuando se informen los filtros y otra para cuando no vayan informados. Si lo hici\u00e9ramos con una \u00fanica ruta nos fallar\u00eda en el otro caso.</p> <p>Finalmente en nuestro archivo <code>index.js</code> vamos a a\u00f1adir el nuevo router:</p> index.js <pre><code>...\n\nimport gameRouter from './src/routes/game.routes.js';\n\n...\n\napp.use('/game', gameRouter);\n\n...\n</code></pre>"},{"location":"develop/filtered/nodejs/#probar-las-operaciones","title":"Probar las operaciones","text":"<p>Y ahora que tenemos todo creado, ya podemos probarlo con Postman:</p> <p>Por un lado creamos juegos con:</p> <p> PUT /game </p> <p> PUT /game/{id} </p> <pre><code>{\n\"title\": \"Nuevo juego\",\n\"age\": \"18\",\n\"category\": {\n\"id\": \"63e8b795f7dae4b980b63202\"\n},\n\"author\": {\n\"id\": \"63e8bda064c208e065667bfa\"\n}\n}\n</code></pre> <p></p> <p>Tambi\u00e9n podemos filtrar y recuperar informaci\u00f3n:</p> <p> GET /game </p> <p> GET /game?title=xxx </p> <p> GET /game?idCategory=xxx </p> <p></p> <p></p>"},{"location":"develop/filtered/nodejs/#implementar-validaciones","title":"Implementar validaciones","text":"<p>Ahora que ya tenemos todos nuestros CRUDs creados vamos a introducir unas peque\u00f1as validaciones.</p>"},{"location":"develop/filtered/nodejs/#validacion-en-borrado","title":"Validaci\u00f3n en borrado","text":"<p>La primera validaci\u00f3n sera para que no podamos borrar categor\u00edas ni autores que tengan un juego asociado. Para ello primero tendremos que crear un m\u00e9todo en el servicio de juegos para buscar los juegos que correspondan con un campo dado. En <code>game.service.js</code> a\u00f1adimos:</p> game.service.js <pre><code>...\nexport const getGame = async (field) =&gt; {\ntry {\nreturn await GameModel.find(field);\n} catch (e) {\nthrow Error('Error fetching games');\n}\n}\n...\n</code></pre> <p>Y ahora en <code>category.service.js</code> importamos el m\u00e9todo creado y modificamos el m\u00e9todo para borrar categor\u00edas:</p> category.service.js <pre><code>...\nimport { getGame } from './game.service.js';\n...\n\n...\nexport const deleteCategory = async (id) =&gt; {\ntry {\nconst category = await CategoryModel.findById(id);\nif (!category) {\nthrow 'There is no category with that Id';\n}\nconst games = await getGame({category});\nif(games.length &gt; 0) {\nthrow 'There are games related to this category';\n}\nreturn await CategoryModel.findByIdAndDelete(id);\n} catch (e) {\nthrow Error(e);\n}\n}\n...\n</code></pre> <p>De este modo si encontramos alg\u00fan juego con esta categor\u00eda no nos dejar\u00e1 borrarla.</p> <p>Por \u00faltimo, hacemos lo mismo en <code>author.service.js</code>:</p> author.service.js <pre><code>...\nimport { getGame } from './game.service.js';\n...\n\n...\nexport const deleteAuthor = async (id) =&gt; {\ntry {\nconst author = await AuthorModel.findById(id);\nif (!author) {\nthrow 'There is no author with that Id';\n}\nconst games = await getGame({author});\nif(games.length &gt; 0) {\nthrow 'There are games related to this author';\n}\nreturn await AuthorModel.findByIdAndDelete(id);\n} catch (e) {\nthrow Error(e);\n}\n}\n...\n</code></pre>"},{"location":"develop/filtered/nodejs/#validacion-en-creacion","title":"Validaci\u00f3n en creaci\u00f3n","text":"<p>En las creaciones es conveniente validad la existencia de las entidades relacionadas para garantizar la integridad de la BBDD.</p> <p>Para esto vamos a introducir una validaci\u00f3n en la creaci\u00f3n y edici\u00f3n de los juegos para garantizar que la categor\u00eda y el autor proporcionados existen.</p> <p>En primer lugar vamos a crear los servicios de consulta de categor\u00eda y autor:</p> category.service.js <pre><code>...\nexport const getCategory = async (id) =&gt; {\ntry {\nreturn await CategoryModel.findById(id);\n} catch (e) {\nthrow Error('There is no category with that Id');\n}\n}\n...\n</code></pre> author.service.js <pre><code>...\nexport const getAuthor = async (id) =&gt; {\ntry {\nreturn await AuthorModel.findById(id);\n} catch (e) {\nthrow Error('There is no author with that Id');\n}\n}\n...\n</code></pre> <p>Teniendo los servicios ya disponibles, vamos a a\u00f1adir las validaciones a los servicios de creaci\u00f3n y edici\u00f3n:</p> game.service.js <pre><code>...\nimport { getCategory } from './category.service.js';\nimport { getAuthor } from './author.service.js';\n...\n\n...\nexport const createGame = async (data) =&gt; {\ntry {\nconst category = await getCategory(data.category.id);\nif (!category) {\nthrow Error('There is no category with that Id');\n}\n\nconst author = await getAuthor(data.author.id);\nif (!author) {\nthrow Error('There is no author with that Id');\n}\n\nconst game = new GameModel({\n...data,\ncategory: data.category.id,\nauthor: data.author.id,\n});\nreturn await game.save();\n} catch (e) {\nthrow Error(e);\n}\n}\n...\n\n...\nexport const updateGame = async (id, data) =&gt; {\ntry {\nconst game = await GameModel.findById(id);\nif (!game) {\nthrow Error('There is no game with that Id');\n}\n\nconst category = await getCategory(data.category.id);\nif (!category) {\nthrow Error('There is no category with that Id');\n}\n\nconst author = await getAuthor(data.author.id);\nif (!author) {\nthrow Error('There is no author with that Id');\n}\n\nconst gameToUpdate = {\n...data,\ncategory: data.category.id,\nauthor: data.author.id,\n};\nreturn await GameModel.findByIdAndUpdate(id, gameToUpdate, { new: false });\n} catch (e) {\nthrow Error(e);\n}\n}\n...\n</code></pre> <p>Con esto ya tendr\u00edamos acabado nuestro CRUD.</p>"},{"location":"develop/filtered/springboot/","title":"Listado filtrado - Spring Boot","text":"<p>En este punto ya tenemos dos listados, uno b\u00e1sico y otro paginado. Ahora vamos a implementar un listado un poco diferente, este listado va a tener filtros de b\u00fasqueda.</p> <p>Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.</p>"},{"location":"develop/filtered/springboot/#crear-modelos","title":"Crear Modelos","text":"<p>Lo primero que vamos a hacer es crear los modelos para trabajar con BBDD y con peticiones hacia el front. Adem\u00e1s, tambi\u00e9n tenemos que a\u00f1adir datos al script de inicializaci\u00f3n de BBDD.</p> Game.javaGameDto.javadata.sql <pre><code>package com.ccsw.tutorial.game.model;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport com.ccsw.tutorial.category.model.Category;\n\nimport jakarta.persistence.*;\n\n\n/**\n * @author ccsw\n *\n */\n@Entity\n@Table(name = \"game\")\npublic class Game {\n\n@Id\n@GeneratedValue(strategy = GenerationType.IDENTITY)\n@Column(name = \"id\", nullable = false)\nprivate Long id;\n\n@Column(name = \"title\", nullable = false)\nprivate String title;\n\n@Column(name = \"age\", nullable = false)\nprivate String age;\n\n@ManyToOne\n@JoinColumn(name = \"category_id\", nullable = false)\nprivate Category category;\n\n@ManyToOne\n@JoinColumn(name = \"author_id\", nullable = false)\nprivate Author author;\n\n/**\n     * @return id\n     */\npublic Long getId() {\n\nreturn this.id;\n}\n\n/**\n     * @param id new value of {@link #getId}.\n     */\npublic void setId(Long id) {\n\nthis.id = id;\n}\n\n/**\n     * @return title\n     */\npublic String getTitle() {\n\nreturn this.title;\n}\n\n/**\n     * @param title new value of {@link #getTitle}.\n     */\npublic void setTitle(String title) {\n\nthis.title = title;\n}\n\n/**\n     * @return age\n     */\npublic String getAge() {\n\nreturn this.age;\n}\n\n/**\n     * @param age new value of {@link #getAge}.\n     */\npublic void setAge(String age) {\n\nthis.age = age;\n}\n\n/**\n     * @return category\n     */\npublic Category getCategory() {\n\nreturn this.category;\n}\n\n/**\n     * @param category new value of {@link #getCategory}.\n     */\npublic void setCategory(Category category) {\n\nthis.category = category;\n}\n\n/**\n     * @return author\n     */\npublic Author getAuthor() {\n\nreturn this.author;\n}\n\n/**\n     * @param author new value of {@link #getAuthor}.\n     */\npublic void setAuthor(Author author) {\n\nthis.author = author;\n}\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.game.model;\n\nimport com.ccsw.tutorial.author.model.AuthorDto;\nimport com.ccsw.tutorial.category.model.CategoryDto;\n\n/**\n * @author ccsw\n *\n */\npublic class GameDto {\n\nprivate Long id;\n\nprivate String title;\n\nprivate String age;\n\nprivate CategoryDto category;\n\nprivate AuthorDto author;\n\n/**\n     * @return id\n     */\npublic Long getId() {\n\nreturn this.id;\n}\n\n/**\n     * @param id new value of {@link #getId}.\n     */\npublic void setId(Long id) {\n\nthis.id = id;\n}\n\n/**\n     * @return title\n     */\npublic String getTitle() {\n\nreturn this.title;\n}\n\n/**\n     * @param title new value of {@link #getTitle}.\n     */\npublic void setTitle(String title) {\n\nthis.title = title;\n}\n\n/**\n     * @return age\n     */\npublic String getAge() {\n\nreturn this.age;\n}\n\n/**\n     * @param age new value of {@link #getAge}.\n     */\npublic void setAge(String age) {\n\nthis.age = age;\n}\n\n/**\n     * @return category\n     */\npublic CategoryDto getCategory() {\n\nreturn this.category;\n}\n\n/**\n     * @param category new value of {@link #getCategory}.\n     */\npublic void setCategory(CategoryDto category) {\n\nthis.category = category;\n}\n\n/**\n     * @return author\n     */\npublic AuthorDto getAuthor() {\n\nreturn this.author;\n}\n\n/**\n     * @param author new value of {@link #getAuthor}.\n     */\npublic void setAuthor(AuthorDto author) {\n\nthis.author = author;\n}\n\n}\n</code></pre> <pre><code>INSERT INTO category(name) VALUES ('Eurogames');\nINSERT INTO category(name) VALUES ('Ameritrash');\nINSERT INTO category(name) VALUES ('Familiar');\n\nINSERT INTO author(name, nationality) VALUES ('Alan R. Moon', 'US');\nINSERT INTO author(name, nationality) VALUES ('Vital Lacerda', 'PT');\nINSERT INTO author(name, nationality) VALUES ('Simone Luciani', 'IT');\nINSERT INTO author(name, nationality) VALUES ('Perepau Llistosella', 'ES');\nINSERT INTO author(name, nationality) VALUES ('Michael Kiesling', 'DE');\nINSERT INTO author(name, nationality) VALUES ('Phil Walker-Harding', 'US');\n\nINSERT INTO game(title, age, category_id, author_id) VALUES ('On Mars', '14', 1, 2);\nINSERT INTO game(title, age, category_id, author_id) VALUES ('Aventureros al tren', '8', 3, 1);\nINSERT INTO game(title, age, category_id, author_id) VALUES ('1920: Wall Street', '12', 1, 4);\nINSERT INTO game(title, age, category_id, author_id) VALUES ('Barrage', '14', 1, 3);\nINSERT INTO game(title, age, category_id, author_id) VALUES ('Los viajes de Marco Polo', '12', 1, 3);\nINSERT INTO game(title, age, category_id, author_id) VALUES ('Azul', '8', 3, 5);\n</code></pre> <p>Relaciones anidadas</p> <p>F\u00edjate que tanto la <code>Entity</code> como el <code>Dto</code> tienen relaciones con <code>Author</code> y <code>Category</code>. Gracias a Spring JPA se pueden resolver de esta forma y tener toda la informaci\u00f3n de las relaciones hijas dentro del objeto padre. Muy importante recordar que en el mundo entity las relaciones ser\u00e1n con objetos <code>Entity</code> mientras que en el mundo dto las relaciones deben ser siempre con objetos <code>Dto</code>. La utilidad beanMapper ya har\u00e1 las conversiones necesarias, siempre que tengan el mismo nombre de propiedades.</p>"},{"location":"develop/filtered/springboot/#tdd-pruebas","title":"TDD - Pruebas","text":"<p>Para desarrollar todas las operaciones, empezaremos primero dise\u00f1ando las pruebas y luego implementando el c\u00f3digo necesario que haga funcionar correctamente esas pruebas. Para ir m\u00e1s r\u00e1pido vamos a poner todas las pruebas de golpe, pero realmente se deber\u00edan crear una a una e ir implementando el c\u00f3digo necesario para esa prueba. Para evitar tantas iteraciones en el tutorial las haremos todas de golpe.</p> <p>Vamos a pararnos a pensar un poco que necesitamos en la pantalla. En este caso solo tenemos dos operaciones:</p> <ul> <li>Una consulta filtrada, que reciba datos de filtro opcionales (t\u00edtulo e idCategor\u00eda) y devuelva los datos ya filtrados</li> <li>Una operaci\u00f3n de guardado y modificaci\u00f3n</li> </ul> <p>De nuevo tendremos que desglosar esto en varios casos de prueba:</p> <ul> <li>Buscar un juego sin filtros</li> <li>Buscar un t\u00edtulo que exista</li> <li>Buscar una categor\u00eda que exista</li> <li>Buscar un t\u00edtulo y una categor\u00eda que existan</li> <li>Buscar un t\u00edtulo que no exista</li> <li>Buscar una categor\u00eda que no exista</li> <li>Buscar un t\u00edtulo y una categor\u00eda que no existan</li> <li>Crear un juego nuevo (en realidad deber\u00edamos probar diferentes combinaciones y errores)</li> <li>Modificar un juego que exista</li> <li>Modificar un juego que no exista</li> </ul> <p>Tambi\u00e9n crearemos una clase <code>GameController</code> dentro del package de <code>com.ccsw.tutorial.game</code> con la implementaci\u00f3n de los m\u00e9todos vac\u00edos, para que no falle la compilaci\u00f3n.</p> <p>\u00a1Vamos a implementar test!</p> GameController.javaGameIT.java <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.game.model.Game;\nimport com.ccsw.tutorial.game.model.GameDto;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Tag(name = \"Game\", description = \"API of Game\")\n@RequestMapping(value = \"/game\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class GameController {\n\n/**\n     * M\u00e9todo para recuperar una lista de {@link Game}\n     *\n     * @param title t\u00edtulo del juego\n     * @param idCategory PK de la categor\u00eda\n     * @return {@link List} de {@link GameDto}\n     */\n@Operation(summary = \"Find\", description = \"Method that return a filtered list of Games\")\n@RequestMapping(path = \"\", method = RequestMethod.GET)\npublic List&lt;GameDto&gt; find(@RequestParam(value = \"title\", required = false) String title,\n@RequestParam(value = \"idCategory\", required = false) Long idCategory) {\n\nreturn null;\n}\n\n/**\n     * M\u00e9todo para crear o actualizar un {@link Game}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n@Operation(summary = \"Save or Update\", description = \"Method that saves or updates a Game\")\n@RequestMapping(path = { \"\", \"/{id}\" }, method = RequestMethod.PUT)\npublic void save(@PathVariable(name = \"id\", required = false) Long id, @RequestBody GameDto dto) {\n\n}\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.author.model.AuthorDto;\nimport com.ccsw.tutorial.category.model.CategoryDto;\nimport com.ccsw.tutorial.game.model.GameDto;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.web.client.TestRestTemplate;\nimport org.springframework.boot.test.web.server.LocalServerPort;\nimport org.springframework.core.ParameterizedTypeReference;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.test.annotation.DirtiesContext;\nimport org.springframework.web.util.UriComponentsBuilder;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\npublic class GameIT {\n\npublic static final String LOCALHOST = \"http://localhost:\";\npublic static final String SERVICE_PATH = \"/game\";\n\npublic static final Long EXISTS_GAME_ID = 1L;\npublic static final Long NOT_EXISTS_GAME_ID = 0L;\nprivate static final String NOT_EXISTS_TITLE = \"NotExists\";\nprivate static final String EXISTS_TITLE = \"Aventureros\";\nprivate static final String NEW_TITLE = \"Nuevo juego\";\nprivate static final Long NOT_EXISTS_CATEGORY = 0L;\nprivate static final Long EXISTS_CATEGORY = 3L;\n\nprivate static final String TITLE_PARAM = \"title\";\nprivate static final String CATEGORY_ID_PARAM = \"idCategory\";\n\n@LocalServerPort\nprivate int port;\n\n@Autowired\nprivate TestRestTemplate restTemplate;\n\nParameterizedTypeReference&lt;List&lt;GameDto&gt;&gt; responseType = new ParameterizedTypeReference&lt;List&lt;GameDto&gt;&gt;(){};\n\nprivate String getUrlWithParams(){\nreturn UriComponentsBuilder.fromHttpUrl(LOCALHOST + port + SERVICE_PATH)\n.queryParam(TITLE_PARAM, \"{\" + TITLE_PARAM +\"}\")\n.queryParam(CATEGORY_ID_PARAM, \"{\" + CATEGORY_ID_PARAM +\"}\")\n.encode()\n.toUriString();\n}\n\n@Test\npublic void findWithoutFiltersShouldReturnAllGamesInDB() {\n\nint GAMES_WITH_FILTER = 6;\n\nMap&lt;String, Object&gt; params = new HashMap&lt;&gt;();\nparams.put(TITLE_PARAM, null);\nparams.put(CATEGORY_ID_PARAM, null);\n\nResponseEntity&lt;List&lt;GameDto&gt;&gt; response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\nassertNotNull(response);\nassertEquals(GAMES_WITH_FILTER, response.getBody().size());\n}\n\n@Test\npublic void findExistsTitleShouldReturnGames() {\n\nint GAMES_WITH_FILTER = 1;\n\nMap&lt;String, Object&gt; params = new HashMap&lt;&gt;();\nparams.put(TITLE_PARAM, EXISTS_TITLE);\nparams.put(CATEGORY_ID_PARAM, null);\n\nResponseEntity&lt;List&lt;GameDto&gt;&gt; response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\nassertNotNull(response);\nassertEquals(GAMES_WITH_FILTER, response.getBody().size());\n}\n\n@Test\npublic void findExistsCategoryShouldReturnGames() {\n\nint GAMES_WITH_FILTER = 2;\n\nMap&lt;String, Object&gt; params = new HashMap&lt;&gt;();\nparams.put(TITLE_PARAM, null);\nparams.put(CATEGORY_ID_PARAM, EXISTS_CATEGORY);\n\nResponseEntity&lt;List&lt;GameDto&gt;&gt; response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\nassertNotNull(response);\nassertEquals(GAMES_WITH_FILTER, response.getBody().size());\n}\n\n@Test\npublic void findExistsTitleAndCategoryShouldReturnGames() {\n\nint GAMES_WITH_FILTER = 1;\n\nMap&lt;String, Object&gt; params = new HashMap&lt;&gt;();\nparams.put(TITLE_PARAM, EXISTS_TITLE);\nparams.put(CATEGORY_ID_PARAM, EXISTS_CATEGORY);\n\nResponseEntity&lt;List&lt;GameDto&gt;&gt; response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\nassertNotNull(response);\nassertEquals(GAMES_WITH_FILTER, response.getBody().size());\n}\n\n@Test\npublic void findNotExistsTitleShouldReturnEmpty() {\n\nint GAMES_WITH_FILTER = 0;\n\nMap&lt;String, Object&gt; params = new HashMap&lt;&gt;();\nparams.put(TITLE_PARAM, NOT_EXISTS_TITLE);\nparams.put(CATEGORY_ID_PARAM, null);\n\nResponseEntity&lt;List&lt;GameDto&gt;&gt; response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\nassertNotNull(response);\nassertEquals(GAMES_WITH_FILTER, response.getBody().size());\n}\n\n@Test\npublic void findNotExistsCategoryShouldReturnEmpty() {\n\nint GAMES_WITH_FILTER = 0;\n\nMap&lt;String, Object&gt; params = new HashMap&lt;&gt;();\nparams.put(TITLE_PARAM, null);\nparams.put(CATEGORY_ID_PARAM, NOT_EXISTS_CATEGORY);\n\nResponseEntity&lt;List&lt;GameDto&gt;&gt; response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\nassertNotNull(response);\nassertEquals(GAMES_WITH_FILTER, response.getBody().size());\n}\n\n@Test\npublic void findNotExistsTitleOrCategoryShouldReturnEmpty() {\n\nint GAMES_WITH_FILTER = 0;\n\nMap&lt;String, Object&gt; params = new HashMap&lt;&gt;();\nparams.put(TITLE_PARAM, NOT_EXISTS_TITLE);\nparams.put(CATEGORY_ID_PARAM, NOT_EXISTS_CATEGORY);\n\nResponseEntity&lt;List&lt;GameDto&gt;&gt; response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\nassertNotNull(response);\nassertEquals(GAMES_WITH_FILTER, response.getBody().size());\n\nparams.put(TITLE_PARAM, NOT_EXISTS_TITLE);\nparams.put(CATEGORY_ID_PARAM, EXISTS_CATEGORY);\n\nresponse = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\nassertNotNull(response);\nassertEquals(GAMES_WITH_FILTER, response.getBody().size());\n\nparams.put(TITLE_PARAM, EXISTS_TITLE);\nparams.put(CATEGORY_ID_PARAM, NOT_EXISTS_CATEGORY);\n\nresponse = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\nassertNotNull(response);\nassertEquals(GAMES_WITH_FILTER, response.getBody().size());\n}\n\n@Test\npublic void saveWithoutIdShouldCreateNewGame() {\n\nGameDto dto = new GameDto();\nAuthorDto authorDto = new AuthorDto();\nauthorDto.setId(1L);\n\nCategoryDto categoryDto = new CategoryDto();\ncategoryDto.setId(1L);\n\ndto.setTitle(NEW_TITLE);\ndto.setAge(\"18\");\ndto.setAuthor(authorDto);\ndto.setCategory(categoryDto);\n\nMap&lt;String, Object&gt; params = new HashMap&lt;&gt;();\nparams.put(TITLE_PARAM, NEW_TITLE);\nparams.put(CATEGORY_ID_PARAM, null);\n\nResponseEntity&lt;List&lt;GameDto&gt;&gt; response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\nassertNotNull(response);\nassertEquals(0, response.getBody().size());\n\nrestTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.PUT, new HttpEntity&lt;&gt;(dto), Void.class);\n\nresponse = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\nassertNotNull(response);\nassertEquals(1, response.getBody().size());\n}\n\n@Test\npublic void modifyWithExistIdShouldModifyGame() {\n\nGameDto dto = new GameDto();\nAuthorDto authorDto = new AuthorDto();\nauthorDto.setId(1L);\n\nCategoryDto categoryDto = new CategoryDto();\ncategoryDto.setId(1L);\n\ndto.setTitle(NEW_TITLE);\ndto.setAge(\"18\");\ndto.setAuthor(authorDto);\ndto.setCategory(categoryDto);\n\nMap&lt;String, Object&gt; params = new HashMap&lt;&gt;();\nparams.put(TITLE_PARAM, NEW_TITLE);\nparams.put(CATEGORY_ID_PARAM, null);\n\nResponseEntity&lt;List&lt;GameDto&gt;&gt; response = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\nassertNotNull(response);\nassertEquals(0, response.getBody().size());\n\nrestTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + EXISTS_GAME_ID, HttpMethod.PUT, new HttpEntity&lt;&gt;(dto), Void.class);\n\nresponse = restTemplate.exchange(getUrlWithParams(), HttpMethod.GET, null, responseType, params);\n\nassertNotNull(response);\nassertEquals(1, response.getBody().size());\nassertEquals(EXISTS_GAME_ID, response.getBody().get(0).getId());\n}\n\n@Test\npublic void modifyWithNotExistIdShouldThrowException() {\n\nGameDto dto = new GameDto();\ndto.setTitle(NEW_TITLE);\n\nResponseEntity&lt;?&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + NOT_EXISTS_GAME_ID, HttpMethod.PUT, new HttpEntity&lt;&gt;(dto), Void.class);\n\nassertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());\n}\n\n}\n</code></pre> <p>B\u00fasquedas en BBDD</p> <p>Siempre deber\u00edamos buscar a los hijos por primary keys, nunca hay que hacerlo por una descripci\u00f3n libre, ya que el usuario podr\u00eda teclear el mismo nombre de diferentes formas y no habr\u00eda manera de buscar correctamente el resultado. As\u00ed que siempre que haya un dropdown, se debe filtrar por su ID.</p> <p>Si ahora ejecutas los jUnits, ver\u00e1s que en este caso hemos construido 10 pruebas, para cubrir los casos b\u00e1sicos del <code>Controller</code>, y todas ellas fallan la ejecuci\u00f3n. Vamos a seguir implementando el resto de capas para hacer que los test funcionen.</p>"},{"location":"develop/filtered/springboot/#controller","title":"Controller","text":"<p>De nuevo para poder compilar esta capa, nos hace falta delegar sus operaciones de l\u00f3gica de negocio en un <code>Service</code> as\u00ed que lo crearemos al mismo tiempo que lo vamos necesitando.</p> GameService.javaGameController.java <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.game.model.Game;\nimport com.ccsw.tutorial.game.model.GameDto;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\npublic interface GameService {\n\n/**\n     * Recupera los juegos filtrando opcionalmente por t\u00edtulo y/o categor\u00eda\n     *\n     * @param title t\u00edtulo del juego\n     * @param idCategory PK de la categor\u00eda\n     * @return {@link List} de {@link Game}\n     */\nList&lt;Game&gt; find(String title, Long idCategory);\n\n/**\n     * Guarda o modifica un juego, dependiendo de si el identificador est\u00e1 o no informado\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\nvoid save(Long id, GameDto dto);\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.game.model.Game;\nimport com.ccsw.tutorial.game.model.GameDto;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport org.dozer.DozerBeanMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * @author ccsw\n *\n */\n@Tag(name = \"Game\", description = \"API of Game\")\n@RequestMapping(value = \"/game\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class GameController {\n\n@Autowired\nGameService gameService;\n@Autowired\nDozerBeanMapper mapper;\n/**\n     * M\u00e9todo para recuperar una lista de {@link Game}\n     *\n     * @param title t\u00edtulo del juego\n     * @param idCategory PK de la categor\u00eda\n     * @return {@link List} de {@link GameDto}\n     */\n@Operation(summary = \"Find\", description = \"Method that return a filtered list of Games\")\n@RequestMapping(path = \"\", method = RequestMethod.GET)\npublic List&lt;GameDto&gt; find(@RequestParam(value = \"title\", required = false) String title,\n@RequestParam(value = \"idCategory\", required = false) Long idCategory) {\n\nList&lt;Game&gt; games = gameService.find(title, idCategory);\nreturn games.stream().map(e -&gt; mapper.map(e, GameDto.class)).collect(Collectors.toList());\n}\n\n/**\n     * M\u00e9todo para crear o actualizar un {@link Game}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n@Operation(summary = \"Save or Update\", description = \"Method that saves or updates a Game\")\n@RequestMapping(path = { \"\", \"/{id}\" }, method = RequestMethod.PUT)\npublic void save(@PathVariable(name = \"id\", required = false) Long id, @RequestBody GameDto dto) {\n\ngameService.save(id, dto);\n}\n\n}\n</code></pre> <p>En esta ocasi\u00f3n, para el m\u00e9todo de b\u00fasqueda hemos decidido utilizar par\u00e1metros en la URL de tal forma que nos quedar\u00e1 algo as\u00ed <code>http://localhost:8080/game/?title=xxx&amp;idCategoria=yyy</code>. Queremos recuperar el recurso <code>Game</code> que es el raiz de la ruta, pero filtrado por cero o varios par\u00e1metros.</p>"},{"location":"develop/filtered/springboot/#service","title":"Service","text":"<p>Siguiente paso, la capa de l\u00f3gica de negocio, es decir el <code>Service</code>, que por tanto har\u00e1 uso de un <code>Repository</code>.</p> GameServiceImpl.javaGameRepository.java <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.game.model.Game;\nimport com.ccsw.tutorial.game.model.GameDto;\nimport jakarta.transaction.Transactional;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Service\n@Transactional\npublic class GameServiceImpl implements GameService {\n\n@Autowired\nGameRepository gameRepository;\n\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic List&lt;Game&gt; find(String title, Long idCategory) {\n\nreturn (List&lt;Game&gt;) this.gameRepository.findAll();\n}\n\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic void save(Long id, GameDto dto) {\n\nGame game;\n\nif (id == null) {\ngame = new Game();\n} else {\ngame = this.gameRepository.findById(id).orElse(null);\n}\n\nBeanUtils.copyProperties(dto, game, \"id\", \"author\", \"category\");\nthis.gameRepository.save(game);\n}\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.game.model.Game;\nimport org.springframework.data.repository.CrudRepository;\n\n/**\n * @author ccsw\n *\n */\npublic interface GameRepository extends CrudRepository&lt;Game, Long&gt; {\n\n}\n</code></pre> <p>Este servicio tiene dos peculiaridades, remarcadas en amarillo en la clase anterior. Por un lado tenemos la consulta, que no es un listado completo ni un listado paginado, sino que es un listado con filtros. Luego veremos como se hace eso, de momento lo dejaremos como un m\u00e9todo que recibe los dos filtros.</p> <p>La segunda peculiaridad es que de cliente nos est\u00e1 llegando un <code>GameDto</code>, que internamente tiene un <code>AuthorDto</code> y un <code>CategoryDto</code>, pero nosotros lo tenemos que traducir a entidades de BBDD. No sirve con copiar las propiedades tal cual, ya que entonces Spring lo que har\u00e1 ser\u00e1 crear un objeto nuevo y persistir ese objeto nuevo de <code>Author</code> y de <code>Category</code>. Adem\u00e1s, de cliente generalmente tan solo nos llega el ID de esos objetos hijo, y no el resto de informaci\u00f3n de la entidad. Por esos motivos lo hemos ignorado del copyProperties.</p> <p>Pero de alguna forma tendremos que asignarle esos valores a la entidad <code>Game</code>. Si conocemos sus ID que es lo que generalmente llega, podemos recuperar esos objetos de BBDD y asignarlos en el objeto <code>Game</code>. Si recuerdas las reglas b\u00e1sicas, un <code>Repository</code> debe pertenecer a un solo <code>Service</code>, por lo que en lugar de llamar a m\u00e9todos de los <code>AuthorRepository</code> y <code>CategoryRepository</code> desde nuestro <code>GameServiceImpl</code>, debemos llamar a m\u00e9todos expuestos en <code>AuthorService</code> y <code>CategoryService</code>, que son los que gestionan sus repositorios. Para ello necesitaremos crear esos m\u00e9todos get en los otros <code>Services</code>. </p> <p>Y ya sabes, para implementar nuevos m\u00e9todos, antes se deben hacer las pruebas jUnit, que en este caso, por variar, cubriremos con pruebas unitarias. Recuerda que los test van en <code>src/test/java</code></p> AuthorTest.javaAuthorService.javaAuthorServiceImpl.java <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\n\nimport java.util.Optional;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\n@ExtendWith(MockitoExtension.class)\npublic class AuthorTest {\n\npublic static final Long EXISTS_AUTHOR_ID = 1L;\npublic static final Long NOT_EXISTS_AUTHOR_ID = 0L;\n\n@Mock\nprivate AuthorRepository authorRepository;\n\n@InjectMocks\nprivate AuthorServiceImpl authorService;\n\n@Test\npublic void getExistsAuthorIdShouldReturnAuthor() {\n\nAuthor author = mock(Author.class);\nwhen(author.getId()).thenReturn(EXISTS_AUTHOR_ID);\nwhen(authorRepository.findById(EXISTS_AUTHOR_ID)).thenReturn(Optional.of(author));\n\nAuthor authorResponse = authorService.get(EXISTS_AUTHOR_ID);\n\nassertNotNull(authorResponse);\n\nassertEquals(EXISTS_AUTHOR_ID, authorResponse.getId());\n}\n\n@Test\npublic void getNotExistsAuthorIdShouldReturnNull() {\n\nwhen(authorRepository.findById(NOT_EXISTS_AUTHOR_ID)).thenReturn(Optional.empty());\n\nAuthor author = authorService.get(NOT_EXISTS_AUTHOR_ID);\n\nassertNull(author);\n}\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport com.ccsw.tutorial.author.model.AuthorDto;\nimport com.ccsw.tutorial.author.model.AuthorSearchDto;\nimport org.springframework.data.domain.Page;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\npublic interface AuthorService {\n\n/**\n     * Recupera un {@link Author} a trav\u00e9s de su ID\n     *\n     * @param id PK de la entidad\n     * @return {@link Author}\n     */\nAuthor get(Long id);\n/**\n     * M\u00e9todo para recuperar un listado paginado de {@link Author}\n     *\n     * @param dto dto de b\u00fasqueda\n     * @return {@link Page} de {@link Author}\n     */\nPage&lt;Author&gt; findPage(AuthorSearchDto dto);\n\n/**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\nvoid save(Long id, AuthorDto dto);\n\n/**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     */\nvoid delete(Long id) throws Exception;\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport com.ccsw.tutorial.author.model.AuthorDto;\nimport com.ccsw.tutorial.author.model.AuthorSearchDto;\nimport jakarta.transaction.Transactional;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.domain.Page;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Service\n@Transactional\npublic class AuthorServiceImpl implements AuthorService {\n\n@Autowired\nAuthorRepository authorRepository;\n\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic Author get(Long id) {\nreturn this.authorRepository.findById(id).orElse(null);\n}\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic Page&lt;Author&gt; findPage(AuthorSearchDto dto) {\n\nreturn this.authorRepository.findAll(dto.getPageable().getPageable());\n}\n\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic void save(Long id, AuthorDto data) {\n\nAuthor author;\n\nif (id == null) {\nauthor = new Author();\n} else {\nauthor = this.get(id);\n}\n\nBeanUtils.copyProperties(data, author, \"id\");\n\nthis.authorRepository.save(author);\n}\n\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic void delete(Long id) throws Exception {\n\nif(this.get(id) == null){\nthrow new Exception(\"Not exists\");\n}\n\nthis.authorRepository.deleteById(id);\n}\n\n}\n</code></pre> <p>Y lo mismo para categor\u00edas.</p> CategoryTest.javaCategoryService.javaCategoryServiceImpl.java <pre><code>public static final Long NOT_EXISTS_CATEGORY_ID = 0L;\n\n@Test\npublic void getExistsCategoryIdShouldReturnCategory() {\n\nCategory category = mock(Category.class);\nwhen(category.getId()).thenReturn(EXISTS_CATEGORY_ID);\nwhen(categoryRepository.findById(EXISTS_CATEGORY_ID)).thenReturn(Optional.of(category));\n\nCategory categoryResponse = categoryService.get(EXISTS_CATEGORY_ID);\n\nassertNotNull(categoryResponse);\nassertEquals(EXISTS_CATEGORY_ID, category.getId());\n}\n\n@Test\npublic void getNotExistsCategoryIdShouldReturnNull() {\n\nwhen(categoryRepository.findById(NOT_EXISTS_CATEGORY_ID)).thenReturn(Optional.empty());\n\nCategory category = categoryService.get(NOT_EXISTS_CATEGORY_ID);\n\nassertNull(category);\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.category;\n\nimport com.ccsw.tutorial.category.model.Category;\nimport com.ccsw.tutorial.category.model.CategoryDto;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\npublic interface CategoryService {\n\n/**\n     * Recupera una {@link Category} a partir de su ID\n     *\n     * @param id PK de la entidad\n     * @return {@link Category}\n     */\nCategory get(Long id);\n/**\n     * M\u00e9todo para recuperar todas las {@link Category}\n     *\n     * @return {@link List} de {@link Category}\n     */\nList&lt;Category&gt; findAll();\n\n/**\n     * M\u00e9todo para crear o actualizar una {@link Category}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\nvoid save(Long id, CategoryDto dto);\n\n/**\n     * M\u00e9todo para borrar una {@link Category}\n     *\n     * @param id PK de la entidad\n     */\nvoid delete(Long id) throws Exception;\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.category;\n\nimport com.ccsw.tutorial.category.model.Category;\nimport com.ccsw.tutorial.category.model.CategoryDto;\nimport jakarta.transaction.Transactional;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Service\n@Transactional\npublic class CategoryServiceImpl implements CategoryService {\n\n@Autowired\nCategoryRepository categoryRepository;\n\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic Category get(Long id) {\nreturn this.categoryRepository.findById(id).orElse(null);\n}\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic List&lt;Category&gt; findAll() {\n\nreturn (List&lt;Category&gt;) this.categoryRepository.findAll();\n}\n\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic void save(Long id, CategoryDto dto) {\n\nCategory category;\n\nif (id == null) {\ncategory = new Category();\n} else {\ncategory = this.get(id);\n}\n\ncategory.setName(dto.getName());\n\nthis.categoryRepository.save(category);\n}\n\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic void delete(Long id) throws Exception {\n\nif(this.get(id) == null){\nthrow new Exception(\"Not exists\");\n}\n\nthis.categoryRepository.deleteById(id);\n}\n\n}\n</code></pre> <p>Clean Code</p> <p>A la hora de implementar m\u00e9todos nuevos, ten siempre presente el <code>Clean Code</code>. \u00a1No dupliques c\u00f3digo!, es muy importante de cara al futuro mantenimiento. Si en nuestro m\u00e9todo <code>save</code> hac\u00edamos uso de una operaci\u00f3n <code>findById</code> y ahora hemos creado una nueva operaci\u00f3n <code>get</code>, hagamos uso de esta nueva operaci\u00f3n y no repitamos el c\u00f3digo.</p> <p>Y ahora que ya tenemos los m\u00e9todos necesarios, ya podemos implementar correctamente nuestro <code>GameServiceImpl</code>.</p> GameServiceImpl.java <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.author.AuthorService;\nimport com.ccsw.tutorial.category.CategoryService;\nimport com.ccsw.tutorial.game.model.Game;\nimport com.ccsw.tutorial.game.model.GameDto;\nimport jakarta.transaction.Transactional;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Service\n@Transactional\npublic class GameServiceImpl implements GameService {\n\n@Autowired\nGameRepository gameRepository;\n\n@Autowired\nAuthorService authorService;\n@Autowired\nCategoryService categoryService;\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic List&lt;Game&gt; find(String title, Long idCategory) {\n\nreturn this.gameRepository.findAll();\n}\n\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic void save(Long id, GameDto dto) {\n\nGame game;\n\nif (id == null) {\ngame = new Game();\n} else {\ngame = this.gameRepository.findById(id).orElse(null);\n}\n\nBeanUtils.copyProperties(dto, game, \"id\", \"author\", \"category\");\n\ngame.setAuthor(authorService.get(dto.getAuthor().getId()));\ngame.setCategory(categoryService.get(dto.getCategory().getId()));\nthis.gameRepository.save(game);\n}\n\n}\n</code></pre> <p>Ahora si que tenemos la capa de l\u00f3gica de negocio terminada, podemos pasar a la siguiente capa.</p>"},{"location":"develop/filtered/springboot/#repository","title":"Repository","text":"<p>Y llegamos a la \u00faltima capa donde, si recordamos, ten\u00edamos un m\u00e9todo que recibe dos par\u00e1metros. Necesitamos traducir esto en una consulta a la BBDD.</p> <p>Vamos a necesitar un listado filtrado por t\u00edtulo o por categor\u00eda, as\u00ed que necesitaremos pasarle esos datos y filtrar la query. Para el t\u00edtulo vamos a buscar por una cadena contenida, as\u00ed que el par\u00e1metro ser\u00e1 de tipo <code>String</code>, mientras que para la categor\u00eda vamos a buscar por su primary key, as\u00ed que el par\u00e1metro ser\u00e1 de tipo <code>Long</code>.</p> <p>Existen varias estrategias para abordar esta implementaci\u00f3n. Podr\u00edamos utilizar los QueryMethods para que Spring JPA haga su magia, pero en esta ocasi\u00f3n ser\u00eda bastante complicado encontrar un predicado correcto.</p> <p>Tambi\u00e9n podr\u00edamos hacer una implementaci\u00f3n de la interface y hacer la consulta directamente con Criteria. </p> <p>Por otro lado se podr\u00eda hacer uso de la anotaci\u00f3n @Query. Esta anotaci\u00f3n nos permite definir una consulta en SQL nativo o en JPQL (Java Persistence Query Language) y Spring JPA se encargar\u00e1 de realizar todo el mapeo y conversi\u00f3n de los datos de entrada y salida. Pero esta opci\u00f3n no es la m\u00e1s recomendable.</p>"},{"location":"develop/filtered/springboot/#specifications","title":"Specifications","text":"<p>En este caso vamos a hacer uso de las Specifications que es la opci\u00f3n m\u00e1s robusta y no presenta acoplamientos con el tipo de BBDD.</p> <p>Haciendo un resumen muy r\u00e1pido y con poco detalle, las <code>Specifications</code> sirven para generar de forma robusta las clausulas <code>where</code> de una consulta SQL. Estas clausulas se generar\u00e1n mediante <code>Predicate</code> (predicados) que realizar\u00e1n operaciones de comparaci\u00f3n entre un campo y un valor. </p> <p>En el siguiente ejemplo podemos verlo m\u00e1s claro: en la sentencia <code>select * from</code><code>Table</code><code>where</code><code>name = 'b\u00fasqueda'</code> tenemos un solo predicado que es <code>name = 'b\u00fasqueda'</code>. En ese predicado diferenciamos tres etiquetas:</p> <ul> <li><code>name</code> \u2192 es el campo sobre el que hacemos el predicado</li> <li><code>=</code> \u2192 es la operaci\u00f3n que realizamos</li> <li><code>'b\u00fasqueda'</code> \u2192 es el valor con el que realizamos la operaci\u00f3n</li> </ul> <p>Lo que trata de hacer <code>Specifications</code> es agregar varios predicados con <code>AND</code> o con <code>OR</code> de forma tipada en c\u00f3digo. Y \u00bfqu\u00e9 intentamos conseguir con esta forma de programar?, pues f\u00e1cil, intentamos hacer que si cambiamos alg\u00fan tipo o el nombre de alguna propiedad involucrada en la query, nos salte un fallo en tiempo de compilaci\u00f3n y nos demos cuenta de donde est\u00e1 el error.  Si utiliz\u00e1ramos queries construidas directamente con <code>String</code>, al cambiar alg\u00fan tipo o el nombre de alguna propiedad involucrada, no nos dar\u00edamos cuenta hasta que saltara un fallo en tiempo de ejecuci\u00f3n.</p> <p>Por este motivo hay que programar con <code>Specifications</code>, porque son robustas ante cambios de c\u00f3digo y tenemos que tratar de evitar las construcciones a trav\u00e9s de cadenas de texto.</p> <p>Dicho esto, \u00a1vamos a implementar!</p> <p>Lo primero que necesitaremos ser\u00e1 una clase que nos permita guardar la informaci\u00f3n de un <code>Predicate</code> para luego generar facilmente la construcci\u00f3n.  Para ello vamos a crear una clase que guarde informaci\u00f3n de los criterios de filtrado (campo, operaci\u00f3n y valor), por suerte esta clase ser\u00e1 gen\u00e9rica y la podremos usar en toda la aplicaci\u00f3n, as\u00ed que la vamos a crear en el paquete <code>com.ccsw.tutorial.common.criteria</code></p> SearchCriteria.java <pre><code>package com.ccsw.tutorial.common.criteria;\n\npublic class SearchCriteria {\n\nprivate String key;\nprivate String operation;\nprivate Object value;\n\npublic SearchCriteria(String key, String operation, Object value) {\n\nthis.key = key;\nthis.operation = operation;\nthis.value = value;\n}\n\npublic String getKey() {\nreturn key;\n}\n\npublic void setKey(String key) {\nthis.key = key;\n}\n\npublic String getOperation() {\nreturn operation;\n}\n\npublic void setOperation(String operation) {\nthis.operation = operation;\n}\n\npublic Object getValue() {\nreturn value;\n}\n\npublic void setValue(Object value) {\nthis.value = value;\n}\n\n}\n</code></pre> <p>Hecho esto pasamos a definir el <code>Specification</code> de nuestra clase la cual contendr\u00e1 la construcci\u00f3n de la consulta en funci\u00f3n de los criterios que se le proporcionan. No queremos construir los predicados directamente en nuestro <code>Service</code> ya que duplicariamos mucho c\u00f3digo, mucho mejor si hacemos una clase para centralizar la construcci\u00f3n de predicados.</p> <p>De esta forma vamos a crear una clase <code>Specification</code> por cada una de las <code>Entity</code> que queramos consultar. En nuestro caso solo vamos a generar <code>queries</code> para <code>Game</code>, as\u00ed que solo crearemos un <code>GameSpecification</code> donde construirmos los predicados.</p> GameSpecification.java <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.common.criteria.SearchCriteria;\nimport com.ccsw.tutorial.game.model.Game;\nimport jakarta.persistence.criteria.*;\nimport org.springframework.data.jpa.domain.Specification;\n\n\npublic class GameSpecification implements Specification&lt;Game&gt; {\n\nprivate static final long serialVersionUID = 1L;\n\nprivate final SearchCriteria criteria;\npublic GameSpecification(SearchCriteria criteria) {\n\nthis.criteria = criteria;\n}\n\n@Override\npublic Predicate toPredicate(Root&lt;Game&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder builder) {\nif (criteria.getOperation().equalsIgnoreCase(\":\") &amp;&amp; criteria.getValue() != null) {\nPath&lt;String&gt; path = getPath(root);\nif (path.getJavaType() == String.class) {\nreturn builder.like(path, \"%\" + criteria.getValue() + \"%\");\n} else {\nreturn builder.equal(path, criteria.getValue());\n}\n}\nreturn null;\n}\n\nprivate Path&lt;String&gt; getPath(Root&lt;Game&gt; root) {\nString key = criteria.getKey();\nString[] split = key.split(\"[.]\", 0);\n\nPath&lt;String&gt; expression = root.get(split[0]);\nfor (int i = 1; i &lt; split.length; i++) {\nexpression = expression.get(split[i]);\n}\n\nreturn expression;\n}\n\n}\n</code></pre> <p>Voy a tratar de explicar con calma cada una de las l\u00edneas marcadas, ya que son conceptos dificiles de entender hasta que no se utilizan.</p> <ul> <li> <p>Las dos primeras l\u00edneas marcadas hacen referencia a que cuando se crea un <code>Specification</code>, esta debe generar un predicado, con lo que necesita unos criterios de filtrado para poder generarlo. En el constructor le estamos pasando esos criterios de filtrado que luego utilizaremos.</p> </li> <li> <p>La tercera l\u00ednea marcada est\u00e1 seleccionando el tipo de operaci\u00f3n. En nuestro caso solo vamos a utilizar operaciones de comparaci\u00f3n. Por convenio las operaciones de comparaci\u00f3n se marcan como \":\" ya que el s\u00edmbolo = est\u00e1 reservado. Aqu\u00ed es donde podr\u00edamos a\u00f1adir otro tipo de operaciones como \"&gt;\" o \"&lt;&gt;\" o cualquiera que queramos implementar. Gu\u00e1rdate esa informaci\u00f3n que te servir\u00e1 en el ejercicio final .</p> </li> <li> <p>Las dos siguientes l\u00edneas, las de <code>return</code> est\u00e1n construyendo un <code>Predicate</code> al ser de tipo comparaci\u00f3n, si es un texto har\u00e1 un <code>like</code> y si no es texto (que es un n\u00famero o fecha) har\u00e1 un <code>equals</code>.</p> </li> <li> <p>Por \u00faltimo, tenemos un m\u00e9todo <code>getPath</code> que invocamos dentro la generaci\u00f3n del predicado y que implementamos m\u00e1s abajo. Esta funci\u00f3n nos permite explorar las sub-entidades para realizar consultas sobre los atributos de estas. Por ejemplo, si queremos navegar hasta <code>game.author.name</code>, lo que har\u00e1 la exploraci\u00f3n ser\u00e1 recuperar el atributo <code>name</code> del objeto <code>author</code> de la entidad <code>game</code>.</p> </li> </ul> <p>Una vez implementada nuestra clase de <code>Specification</code>, que lo \u00fanico que hace es recoger un criterio de filtrado y construir un predicado, y que en principio solo permite generar comparaciones de igualdad, vamos a utilizarlo dentro de nuestro <code>Service</code>:</p> GameServiceImpl.javaGameRepository.java <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.author.AuthorService;\nimport com.ccsw.tutorial.category.CategoryService;\nimport com.ccsw.tutorial.common.criteria.SearchCriteria;\nimport com.ccsw.tutorial.game.model.Game;\nimport com.ccsw.tutorial.game.model.GameDto;\nimport jakarta.transaction.Transactional;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.jpa.domain.Specification;\nimport org.springframework.stereotype.Service;\n\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Service\n@Transactional\npublic class GameServiceImpl implements GameService {\n\n@Autowired\nGameRepository gameRepository;\n\n@Autowired\nAuthorService authorService;\n\n@Autowired\nCategoryService categoryService;\n\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic List&lt;Game&gt; find(String title, Long idCategory) {\n\nGameSpecification titleSpec = new GameSpecification(new SearchCriteria(\"title\", \":\", title));\nGameSpecification categorySpec = new GameSpecification(new SearchCriteria(\"category.id\", \":\", idCategory));\nSpecification&lt;Game&gt; spec = Specification.where(titleSpec).and(categorySpec);\nreturn this.gameRepository.findAll(spec);\n}\n\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic void save(Long id, GameDto dto) {\n\nGame game;\n\nif (id == null) {\ngame = new Game();\n} else {\ngame = this.gameRepository.findById(id).orElse(null);\n}\n\nBeanUtils.copyProperties(dto, game, \"id\", \"author\", \"category\");\n\ngame.setAuthor(authorService.get(dto.getAuthor().getId()));\ngame.setCategory(categoryService.get(dto.getCategory().getId()));\n\nthis.gameRepository.save(game);\n}\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.game.model.Game;\nimport org.springframework.data.jpa.domain.Specification;\nimport org.springframework.data.jpa.repository.EntityGraph;\nimport org.springframework.data.jpa.repository.JpaSpecificationExecutor;\nimport org.springframework.data.repository.CrudRepository;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\npublic interface GameRepository extends CrudRepository&lt;Game, Long&gt;, JpaSpecificationExecutor&lt;Game&gt; {\n}\n</code></pre> <p>Lo que hemos hecho es crear los dos criterios de filtrado que necesit\u00e1bamos. En nuestro caso eran <code>title</code>, que es un atributo de la entidad <code>Game</code> y por otro lado el identificador de categor\u00eda, que en este caso, ya no es un atributo directo de la entidad, si no, de la categor\u00eda asociada, por lo que debemos navegar hasta el atributo <code>id</code> a trav\u00e9s del atributo <code>category</code> (para esto utilizamos el <code>getPath</code> que hemos visto anteriormente).</p> <p>A partir de estos dos predicados, podemos generar el <code>Specification</code> global para la consulta, uniendo los dos predicados mediante el operador <code>AND</code>.</p> <p>Una vez construido el <code>Specification</code> ya podemos usar el m\u00e9todo por defecto que nos proporciona Spring Data para dicho fin, tan solo tenemos que decirle a nuestro <code>GameRepository</code> que adem\u00e1s extender de <code>CrudRepository</code> debe extender de <code>JpaSpecificationExecutor</code>, para que pueda ejecutarlas.</p>"},{"location":"develop/filtered/springboot/#mejoras-rendimiento","title":"Mejoras rendimiento","text":"<p>Finalmente, de cara a mejorar el rendimiento de nuestros servicios vamos a hacer foco en la generaci\u00f3n de transacciones con la base de datos. Si ejecut\u00e1ramos esta petici\u00f3n tal cual lo tenemos implementado ahora mismo, en la consola ver\u00edamos lo siguiente:</p> <pre><code>Hibernate: select g1_0.id,g1_0.age,g1_0.author_id,g1_0.category_id,g1_0.title from game g1_0\nHibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=?\nHibernate: select c1_0.id,c1_0.name from category c1_0 where c1_0.id=?\nHibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=?\nHibernate: select c1_0.id,c1_0.name from category c1_0 where c1_0.id=?\nHibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=?\nHibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=?\nHibernate: select a1_0.id,a1_0.name,a1_0.nationality from author a1_0 where a1_0.id=?\n</code></pre> <p>Esto es debido a que no le hemos dado indicaciones a Spring Data de como queremos que construya las consultas con relaciones y por defecto est\u00e1 configurado para generar sub-consultas cuando tenemos tablas relacionadas.</p> <p>En nuestro caso la tabla <code>Game</code> est\u00e1 relacionada con <code>Author</code> y <code>Category</code>. Al realizar la consulta a <code>Game</code> realiza las sub-consultas por cada uno de los registros relacionados con los resultados <code>Game</code>.</p> <p>Para evitar tantas consultas contra la BBDD y realizar esto de una forma mucho m\u00e1s \u00f3ptima, podemos decirle a Spring Data el comportamiento que queremos, que en nuestro caso ser\u00e1 que haga una \u00fanica consulta y haga las sub-consultas mediante los <code>join</code> correspondientes.</p> <p>Para ello a\u00f1adimos una sobre-escritura del m\u00e9todo <code>findAll</code>, que ya ten\u00edamos implementado en <code>JpaSpecificationExecutor</code> y que utlizamos de forma heredada, pero en este caso le a\u00f1adimos la anotaci\u00f3n <code>@EntityGraph</code> con los atributos que queremos que se incluyan dentro de la consulta principal mediante <code>join</code>:</p> GameRepository.java <pre><code>package com.ccsw.tutorial.game;\n\nimport com.ccsw.tutorial.game.model.Game;\nimport org.springframework.data.jpa.domain.Specification;\nimport org.springframework.data.jpa.repository.EntityGraph;\nimport org.springframework.data.jpa.repository.JpaSpecificationExecutor;\nimport org.springframework.data.repository.CrudRepository;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\npublic interface GameRepository extends CrudRepository&lt;Game, Long&gt;, JpaSpecificationExecutor&lt;Game&gt; {\n\n@Override\n@EntityGraph(attributePaths = {\"category\", \"author\"})\nList&lt;Game&gt; findAll(Specification&lt;Game&gt; spec);\n}\n</code></pre> <p>Tras realizar este cambio, podemos observar que la nueva consulta generada es la siguiente:</p> <pre><code>Hibernate: select g1_0.id,g1_0.age,a1_0.id,a1_0.name,a1_0.nationality,c1_0.id,c1_0.name,g1_0.title from game g1_0 join author a1_0 on a1_0.id=g1_0.author_id join category c1_0 on c1_0.id=g1_0.category_id\n</code></pre> <p>Como podemos observar, ahora se realiza una \u00fanica consulta con la correspondiente transacci\u00f3n con la BBDD, y se trae todos los datos necesarios de <code>Game</code>, <code>Author</code> y <code>Category</code> sin lanzar m\u00faltiples queries.</p>"},{"location":"develop/filtered/springboot/#prueba-de-las-operaciones","title":"Prueba de las operaciones","text":"<p>Si ahora ejecutamos de nuevo los jUnits, vemos que todos los que hemos desarrollado en <code>GameIT</code> ya funcionan correctamente, e incluso el resto de test de la aplicaci\u00f3n tambi\u00e9n funcionan correctamente. </p> <p>Pruebas jUnit</p> <p>Cada vez que desarrollemos un caso de uso nuevo, debemos relanzar todas las pruebas autom\u00e1ticas que tenga la aplicaci\u00f3n. Es muy com\u00fan que al implementar alg\u00fan desarrollo nuevo, interfiramos de alguna forma en el funcionamiento de otra funcionalidad. Si lanzamos toda la bater\u00eda de pruebas, nos daremos cuenta si algo ha dejado de funcionar y podremos solucionarlo antes de llevar ese error a Producci\u00f3n. Las pruebas jUnit son nuestra red de seguridad.</p> <p>Adem\u00e1s de las pruebas autom\u00e1ticas, podemos ver como se comporta la aplicaci\u00f3n y que respuesta nos ofrece, lanzando peticiones Rest con Postman, como hemos hecho en los casos anteriores. As\u00ed que podemos levantar la aplicaci\u00f3n y lanzar las operaciones:</p> <p> GET http://localhost:8080/game  </p> <p> GET http://localhost:8080/game?title=xxx </p> <p> GET http://localhost:8080/game?idCategory=xxx </p> <p>Nos devuelve un listado filtrado de <code>Game</code>. F\u00edjate bien en la petici\u00f3n donde enviamos los filtros y la respuesta que tiene los objetos <code>Category</code> y <code>Author</code> inclu\u00eddos.</p> <p></p> <p> PUT http://localhost:8080/game   PUT http://localhost:8080/game/{id}  </p> <pre><code>{\n    \"title\": \"Nuevo juego\",\n    \"age\": \"18\",\n    \"category\": {\n        \"id\": 3\n    },\n    \"author\": {\n        \"id\": 1\n    }\n}\n</code></pre> <p>Nos sirve para insertar un <code>Game</code> nuevo (si no tienen el id informado) o para actualizar un <code>Game</code> (si tienen el id informado). F\u00edjate que para enlazar <code>Category</code> y <code>Author</code> tan solo hace falta el id de cada no de ellos, ya que en el m\u00e9todo <code>save</code> se hace una consulta <code>get</code> para recuperarlos por su id. Adem\u00e1s que no tendr\u00eda sentido enviar toda la informaci\u00f3n de esas entidades ya que no est\u00e1s dando de alta una <code>Category</code> ni un <code>Author</code>.</p> <p> </p> <p>Rendimiento en las consultas JPA</p> <p>En este punto te recomiendo que visites el Anexo. Funcionamiento JPA para conocer un poco m\u00e1s como funciona por dentro JPA y alg\u00fan peque\u00f1o truco que puede mejorar el rendimiento.</p>"},{"location":"develop/filtered/springboot/#implementar-listado-autores","title":"Implementar listado Autores","text":"<p>Antes de poder conectar front con back, si recuerdas, en la edici\u00f3n de un <code>Game</code>, nos hac\u00eda falta un listado de <code>Author</code> y un listado de <code>Category</code>. El segundo ya lo tenemos ya que lo reutilizaremos del listado de categor\u00edas que implementamos. Pero el primero no lo tenemos, porque en la pantalla que hicimos, se mostraban de forma paginada. </p> <p>As\u00ed que necesitamos implementar esa funcionalidad, y como siempre vamos de la capa de testing hacia las siguientes capas. Deber\u00edamos a\u00f1adir los siguientes m\u00e9todos:</p> AuthorIT.javaAuthorController.javaAuthorService.javaAuthorServiceImpl.java <pre><code>...\n\nParameterizedTypeReference&lt;List&lt;AuthorDto&gt;&gt; responseTypeList = new ParameterizedTypeReference&lt;List&lt;AuthorDto&gt;&gt;(){};\n\n@Test\npublic void findAllShouldReturnAllAuthor() {\n\nResponseEntity&lt;List&lt;AuthorDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.GET, null, responseTypeList);\n\nassertNotNull(response);\nassertEquals(TOTAL_AUTHORS, response.getBody().size());\n}\n\n...\n</code></pre> <pre><code>...\n\n/**\n * Recupera un listado de autores {@link Author}\n *\n * @return {@link List} de {@link AuthorDto}\n */\n@Operation(summary = \"Find\", description = \"Method that return a list of Authors\")\n@RequestMapping(path = \"\", method = RequestMethod.GET)\npublic List&lt;AuthorDto&gt; findAll() {\n\nList&lt;Author&gt; authors = this.authorService.findAll();\n\nreturn authors.stream().map(e -&gt; mapper.map(e, AuthorDto.class)).collect(Collectors.toList());\n}\n\n...\n</code></pre> <pre><code>...\n\n/**\n * Recupera un listado de autores {@link Author}\n *\n * @return {@link List} de {@link Author}\n */\nList&lt;Author&gt; findAll();\n\n...\n</code></pre> <pre><code>...\n\n/**\n * {@inheritDoc}\n */\n@Override\npublic List&lt;Author&gt; findAll() {\n\nreturn (List&lt;Author&gt;) this.authorRepository.findAll();\n}\n\n\n...\n</code></pre>"},{"location":"develop/paginated/angular/","title":"Listado paginado - Angular","text":"<p>Ya tienes tu primer CRUD desarrollado. \u00bfHa sido sencillo, verdad?.</p> <p>Ahora vamos a implementar un CRUD un poco m\u00e1s complejo, este tiene datos paginados en servidor, esto quiere decir que no nos sirve un array de datos como en el anterior ejemplo.  Para que un listado paginado en servidor funcione, el cliente debe enviar en cada petici\u00f3n que p\u00e1gina est\u00e1 solicitando y cual es el tama\u00f1o de la p\u00e1gina, para que el servidor devuelva solamente un subconjunto de datos, en lugar de devolver el listado completo.</p> <p>Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.</p>"},{"location":"develop/paginated/angular/#crear-modulo-y-componentes","title":"Crear modulo y componentes","text":"<p>Vamos a desarrollar el listado de <code>Autores</code> as\u00ed que, debemos crear los componentes:</p> <pre><code>ng generate module author\nng generate component author/author-list\nng generate component author/author-edit\n\nng generate service author/author\n</code></pre> <p>Este m\u00f3dulo lo vamos a a\u00f1adir a la aplicaci\u00f3n para que se cargue en el arranque. Abrimos el fichero <code>app.module.ts</code> y a\u00f1adimos el m\u00f3dulo:</p> app.module.ts <pre><code>import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { CoreModule } from './core/core.module';\nimport { CategoryModule } from './category/category.module';\nimport { AuthorModule } from './author/author.module';\n@NgModule({\ndeclarations: [\nAppComponent\n],\nimports: [\nBrowserModule,\nAppRoutingModule,\nCoreModule,\nCategoryModule,\nAuthorModule,\nBrowserAnimationsModule\n],\nproviders: [],\nbootstrap: [AppComponent]\n})\nexport class AppModule { }\n</code></pre>"},{"location":"develop/paginated/angular/#crear-el-modelo","title":"Crear el modelo","text":"<p>Creamos el modelo en <code>author/model/Author.ts</code> con las propiedades necesarias para trabajar con la informaci\u00f3n de un autor:</p> Author.ts <pre><code>export class Author {\nid: number;\nname: string;\nnationality: string;\n}\n</code></pre>"},{"location":"develop/paginated/angular/#anadir-el-punto-de-entrada","title":"A\u00f1adir el punto de entrada","text":"<p>A\u00f1adimos la ruta al men\u00fa para que podamos acceder a la pantalla:</p> app-routing.module.ts <pre><code>import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { CategoryListComponent } from './category/category-list/category-list.component';\nimport { AuthorListComponent } from './author/author-list/author-list.component';\n\nconst routes: Routes = [\n{ path: 'categories', component: CategoriesComponent },\n{ path: 'authors', component: AuthorListComponent },\n];\n\n@NgModule({\nimports: [RouterModule.forRoot(routes)],\nexports: [RouterModule]\n})\nexport class AppRoutingModule { }\n</code></pre>"},{"location":"develop/paginated/angular/#implementar-servicio","title":"Implementar servicio","text":"<p>Y realizamos las diferentes implementaciones. Empezaremos por el servicio. En este caso, hay un cambio sustancial con el anterior ejemplo. Al tratarse de un listado paginado, la operaci\u00f3n <code>getAuthors</code> necesita informaci\u00f3n extra acerca de que p\u00e1gina de datos debe mostrar, adem\u00e1s de que el resultado ya no ser\u00e1 un listado sino una p\u00e1gina. </p> <p>Por defecto el esquema de datos de Spring para la paginaci\u00f3n es como el siguiente:</p> Esquema de datos de paginaci\u00f3n <pre><code>{\n\"content\": [ ... &lt;listado con los resultados paginados&gt; ... ],\n\"pageable\": {\n\"pageNumber\": &lt;n\u00famero de p\u00e1gina empezando por 0&gt;,\n\"pageSize\": &lt;tama\u00f1o de p\u00e1gina&gt;,\n\"sort\": [\n{ \"property\": &lt;nombre de la propiedad a ordenar&gt;, \"direction\": &lt;direcci\u00f3n de la ordenaci\u00f3n ASC / DESC&gt; }\n]\n},\n\"totalElements\": &lt;numero total de elementos en la tabla&gt;\n}\n</code></pre> <p>As\u00ed que necesitamos poder enviar y recuperar esa informaci\u00f3n desde Angular, nos hace falta crear esos objetos. Los objetos de paginaci\u00f3n al ser comunes a toda la aplicaci\u00f3n, vamos a crearlos en <code>core/model/page</code>, mientras que la paginaci\u00f3n de <code>AuthorPage.ts</code> la crear\u00e9 en su propio model dentro de <code>author/model</code>.</p> SortPage.tsPageable.tsAuthorPage.ts <pre><code>export class SortPage {\nproperty: String;\ndirection: String;\n}\n</code></pre> <pre><code>import { SortPage } from './SortPage';\n\nexport class Pageable {\npageNumber: number;\npageSize: number;\nsort: SortPage[];\n}\n</code></pre> <pre><code>import { Pageable } from \"src/app/core/model/page/Pageable\";\nimport { Author } from \"./Author\";\n\nexport class AuthorPage {\ncontent: Author[];\npageable: Pageable;\ntotalElements: number;\n}\n</code></pre> <p>Con estos objetos creados ya podemos implementar el servicio y sus datos mockeados.</p> mock-authors.tsauthor.service.ts <pre><code>import { AuthorPage } from \"./AuthorPage\";\n\nexport const AUTHOR_DATA: AuthorPage = {\ncontent: [\n{ id: 1, name: 'Klaus Teuber', nationality: 'Alemania' },\n{ id: 2, name: 'Matt Leacock', nationality: 'Estados Unidos' },\n{ id: 3, name: 'Keng Leong Yeo', nationality: 'Singapur' },\n{ id: 4, name: 'Gil Hova', nationality: 'Estados Unidos'},\n{ id: 5, name: 'Kelly Adams', nationality: 'Estados Unidos' },\n{ id: 6, name: 'J. Alex Kavern', nationality: 'Estados Unidos' },\n{ id: 7, name: 'Corey Young', nationality: 'Estados Unidos' },\n],  pageable : {\npageSize: 5,\npageNumber: 0,\nsort: [\n{property: \"id\", direction: \"ASC\"}\n]\n},\ntotalElements: 7\n}\n</code></pre> <pre><code>import { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Pageable } from '../core/model/page/Pageable';\nimport { Author } from './model/Author';\nimport { AuthorPage } from './model/AuthorPage';\nimport { AUTHOR_DATA } from './model/mock-authors';\n\n@Injectable({\nprovidedIn: 'root'\n})\nexport class AuthorService {\n\nconstructor() { }\n\ngetAuthors(pageable: Pageable): Observable&lt;AuthorPage&gt; {\nreturn of(AUTHOR_DATA);\n}\n\nsaveAuthor(author: Author): Observable&lt;void&gt; {\nreturn of(null);\n}\n\ndeleteAuthor(idAuthor : number): Observable&lt;void&gt; {\nreturn of(null);\n}    }\n</code></pre>"},{"location":"develop/paginated/angular/#implementar-listado","title":"Implementar listado","text":"<p>Ya tenemos el servicio con los datos, ahora vamos a por el listado paginado.</p> author-list.component.htmlauthor-list.component.scssauthor-list.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1&gt;Listado de Autores&lt;/h1&gt;\n\n    &lt;mat-table [dataSource]=\"dataSource\"&gt; \n        &lt;ng-container matColumnDef=\"id\"&gt;\n            &lt;mat-header-cell *matHeaderCellDef&gt; Identificador &lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.id}} &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n        &lt;ng-container matColumnDef=\"name\"&gt;\n            &lt;mat-header-cell *matHeaderCellDef&gt; Nombre autor  &lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.name}} &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n        &lt;ng-container matColumnDef=\"nationality\"&gt;\n            &lt;mat-header-cell *matHeaderCellDef&gt; Nacionalidad  &lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt; {{element.nationality}} &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n        &lt;ng-container matColumnDef=\"action\"&gt;\n            &lt;mat-header-cell *matHeaderCellDef&gt;&lt;/mat-header-cell&gt;\n            &lt;mat-cell *matCellDef=\"let element\"&gt;\n                &lt;button mat-icon-button color=\"primary\" (click)=\"editAuthor(element)\"&gt;\n                    &lt;mat-icon&gt;edit&lt;/mat-icon&gt;\n                &lt;/button&gt;\n                &lt;button mat-icon-button color=\"accent\" (click)=\"deleteAuthor(element)\"&gt;\n                    &lt;mat-icon&gt;clear&lt;/mat-icon&gt;\n                &lt;/button&gt;\n            &lt;/mat-cell&gt;\n        &lt;/ng-container&gt;\n\n        &lt;mat-header-row *matHeaderRowDef=\"displayedColumns; sticky: true\"&gt;&lt;/mat-header-row&gt;\n        &lt;mat-row *matRowDef=\"let row; columns: displayedColumns;\"&gt;&lt;/mat-row&gt;\n    &lt;/mat-table&gt; \n\n&lt;mat-paginator (page)=\"loadPage($event)\" [pageSizeOptions]=\"[5, 10, 20]\" [pageIndex]=\"pageNumber\" [pageSize]=\"pageSize\" [length]=\"totalElements\" showFirstLastButtons&gt;&lt;/mat-paginator&gt;\n&lt;div class=\"buttons\"&gt;\n        &lt;button mat-flat-button color=\"primary\" (click)=\"createAuthor()\"&gt;Nuevo autor&lt;/button&gt; \n    &lt;/div&gt;   \n&lt;/div&gt;\n</code></pre> <pre><code>.container {\nmargin: 20px;\n\nmat-table {\nmargin-top: 10px;\nmargin-bottom: 20px;\n\n.mat-header-row {\nbackground-color:#f5f5f5;\n\n.mat-header-cell {\ntext-transform: uppercase;\nfont-weight: bold;\ncolor: #838383;\n}      }\n\n.mat-column-id {\nflex: 0 0 20%;\njustify-content: center;\n}\n\n.mat-column-action {\nflex: 0 0 10%;\njustify-content: center;\n}\n}\n\n.buttons {\ntext-align: right;\n}\n}\n</code></pre> <pre><code>import { Component, OnInit } from '@angular/core';\nimport { MatDialog } from '@angular/material/dialog';\nimport { PageEvent } from '@angular/material/paginator';\nimport { MatTableDataSource } from '@angular/material/table';\nimport { DialogConfirmationComponent } from 'src/app/core/dialog-confirmation/dialog-confirmation.component';\nimport { Pageable } from 'src/app/core/model/page/Pageable';\nimport { AuthorEditComponent } from '../author-edit/author-edit.component';\nimport { AuthorService } from '../author.service';\nimport { Author } from '../model/Author';\n\n@Component({\nselector: 'app-author-list',\ntemplateUrl: './author-list.component.html',\nstyleUrls: ['./author-list.component.scss']\n})\nexport class AuthorListComponent implements OnInit {\n\npageNumber: number = 0;\npageSize: number = 5;\ntotalElements: number = 0;\ndataSource = new MatTableDataSource&lt;Author&gt;();\ndisplayedColumns: string[] = ['id', 'name', 'nationality', 'action'];\n\nconstructor(\nprivate authorService: AuthorService,\npublic dialog: MatDialog,\n) { }\n\nngOnInit(): void {\nthis.loadPage();\n}\n\nloadPage(event?: PageEvent) {\nlet pageable : Pageable =  {\npageNumber: this.pageNumber,\npageSize: this.pageSize,\nsort: [{\nproperty: 'id',\ndirection: 'ASC'\n}]\n}\nif (event != null) {\npageable.pageSize = event.pageSize\npageable.pageNumber = event.pageIndex;\n}\nthis.authorService.getAuthors(pageable).subscribe(data =&gt; {\nthis.dataSource.data = data.content;\nthis.pageNumber = data.pageable.pageNumber;\nthis.pageSize = data.pageable.pageSize;\nthis.totalElements = data.totalElements;\n});\n}  createAuthor() {      const dialogRef = this.dialog.open(AuthorEditComponent, {\ndata: {}\n});\n\ndialogRef.afterClosed().subscribe(result =&gt; {\nthis.ngOnInit();\n});      }  editAuthor(author: Author) {    const dialogRef = this.dialog.open(AuthorEditComponent, {\ndata: { author: author }\n});\n\ndialogRef.afterClosed().subscribe(result =&gt; {\nthis.ngOnInit();\n});    }\n\ndeleteAuthor(author: Author) {    const dialogRef = this.dialog.open(DialogConfirmationComponent, {\ndata: { title: \"Eliminar autor\", description: \"Atenci\u00f3n si borra el autor se perder\u00e1n sus datos.&lt;br&gt; \u00bfDesea eliminar el autor?\" }\n});\n\ndialogRef.afterClosed().subscribe(result =&gt; {\nif (result) {\nthis.authorService.deleteAuthor(author.id).subscribe(result =&gt;  {\nthis.ngOnInit();\n}); }\n});\n}  }\n</code></pre> <p>F\u00edjate como hemos a\u00f1adido la paginaci\u00f3n. </p> <ul> <li>Al HTML le hemos a\u00f1adido un componente nuevo <code>mat-paginator</code>, lo que nos va a obligar a a\u00f1adirlo al m\u00f3dulo tambi\u00e9n como dependencia. Ese componente le hemos definido un m\u00e9todo <code>page</code> que se ejecuta cada vez que la p\u00e1gina cambia, y unas propiedades con las que calcular\u00e1 la p\u00e1gina, el tama\u00f1o y el n\u00famero total de p\u00e1ginas.</li> <li>Al Typescript le hemos tenido que a\u00f1adir esas variables y hemos creado un m\u00e9todo para cargar datos que lo que hace es construir un objeto <code>pageable</code> con los valores actuales del componente paginador y lanza la petici\u00f3n con esos datos en el body. Obviamente al ser un mock no funcionar\u00e1 el cambio de p\u00e1gina y dem\u00e1s.</li> </ul> <p>Como siempre, a\u00f1adimos las dependencias al m\u00f3dulo, vamos a intentar a\u00f1adir todas las que vamos a necesitar a futuro.</p> author.module.ts <pre><code>import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { AuthorListComponent } from './author-list/author-list.component';\nimport { AuthorEditComponent } from './author-edit/author-edit.component';\nimport { MatTableModule } from '@angular/material/table';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { MatButtonModule } from '@angular/material/button';\nimport { MatDialogModule, MAT_DIALOG_DATA } from '@angular/material/dialog';\nimport { MatFormFieldModule } from '@angular/material/form-field';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatInputModule } from '@angular/material/input';\nimport { MatPaginatorModule } from '@angular/material/paginator';\n\n\n\n@NgModule({\ndeclarations: [\nAuthorListComponent,\nAuthorEditComponent\n],\nimports: [\nCommonModule,\nMatTableModule,\nMatIconModule, MatButtonModule,\nMatDialogModule,\nMatFormFieldModule,\nMatInputModule,\nFormsModule,\nReactiveFormsModule,\nMatPaginatorModule,\n],\nproviders: [\n{\nprovide: MAT_DIALOG_DATA,\nuseValue: {},\n},\n]\n})\nexport class AuthorModule { }\n</code></pre> <p>Deber\u00eda verse algo similar a esto:</p> <p></p>"},{"location":"develop/paginated/angular/#implementar-dialogo-edicion","title":"Implementar dialogo edici\u00f3n","text":"<p>El \u00faltimo paso, es definir la pantalla de dialogo que realizar\u00e1 el alta y modificado de los datos de un <code>Autor</code>.</p> author-edit.component.htmlauthor-edit.component.scssauthor-edit.component.ts <pre><code>&lt;div class=\"container\"&gt;\n    &lt;h1 *ngIf=\"author.id == null\"&gt;Crear autor&lt;/h1&gt;\n    &lt;h1 *ngIf=\"author.id != null\"&gt;Modificar autor&lt;/h1&gt;\n\n    &lt;form&gt;\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;Identificador&lt;/mat-label&gt;\n            &lt;input type=\"text\" matInput placeholder=\"Identificador\" [(ngModel)]=\"author.id\" name=\"id\" disabled&gt;\n        &lt;/mat-form-field&gt;\n\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;Nombre&lt;/mat-label&gt;\n            &lt;input type=\"text\" matInput placeholder=\"Nombre del autor\" [(ngModel)]=\"author.name\" name=\"name\" required&gt;\n            &lt;mat-error&gt;El nombre no puede estar vac\u00edo&lt;/mat-error&gt;\n        &lt;/mat-form-field&gt;\n\n        &lt;mat-form-field&gt;\n            &lt;mat-label&gt;Nacionalidad&lt;/mat-label&gt;\n            &lt;input type=\"text\" matInput placeholder=\"Nacionalidad del autor\" [(ngModel)]=\"author.nationality\" name=\"nationality\" required&gt;\n            &lt;mat-error&gt;La nacionalidad no puede estar vac\u00eda&lt;/mat-error&gt;\n        &lt;/mat-form-field&gt;\n    &lt;/form&gt;\n\n    &lt;div class=\"buttons\"&gt;\n        &lt;button mat-stroked-button (click)=\"onClose()\"&gt;Cerrar&lt;/button&gt;\n        &lt;button mat-flat-button color=\"primary\" (click)=\"onSave()\"&gt;Guardar&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <pre><code>.container {\nmin-width: 350px;\nmax-width: 500px;\nwidth: 100%;\n\nform {\ndisplay: flex;\nflex-direction: column;\nmargin-bottom:20px;\n}\n\n.buttons {\ntext-align: right;\n\nbutton {\nmargin-left: 10px;\n}\n}\n}\n</code></pre> <pre><code>import { Component, Inject, OnInit } from '@angular/core';\nimport { MatDialogRef, MAT_DIALOG_DATA } from '@angular/material/dialog';\nimport { AuthorService } from '../author.service';\nimport { Author } from '../model/Author';\n\n@Component({\nselector: 'app-author-edit',\ntemplateUrl: './author-edit.component.html',\nstyleUrls: ['./author-edit.component.scss']\n})\nexport class AuthorEditComponent implements OnInit {\n\nauthor : Author;\n\nconstructor(\npublic dialogRef: MatDialogRef&lt;AuthorEditComponent&gt;,\n@Inject(MAT_DIALOG_DATA) public data: any,\nprivate authorService: AuthorService\n) { }\n\nngOnInit(): void {\nif (this.data.author != null) {\nthis.author = Object.assign({}, this.data.author);\n}\nelse {\nthis.author = new Author();\n}\n}\n\nonSave() {\nthis.authorService.saveAuthor(this.author).subscribe(result =&gt;  {\nthis.dialogRef.close();\n}); }  onClose() {\nthis.dialogRef.close();\n}\n\n}\n</code></pre> <p>Que deber\u00eda quedar algo as\u00ed:</p> <p></p>"},{"location":"develop/paginated/angular/#conectar-con-backend","title":"Conectar con Backend","text":"<p>Antes de seguir</p> <p>Antes de seguir con este punto, debes implementar el c\u00f3digo de backend en la tecnolog\u00eda que quieras (Springboot o Nodejs). Si has empezado este cap\u00edtulo implementando el frontend, por favor accede a la secci\u00f3n correspondiente de backend para poder continuar con el tutorial. Una vez tengas implementadas todas las operaciones para este listado, puedes volver a este punto y continuar con Angular.</p> <p>Una vez implementado front y back, lo que nos queda es modificar el servicio del front para que conecte directamente con las operaciones ofrecidas por el back.</p> author.service.ts <pre><code>import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Pageable } from '../core/model/page/Pageable';\nimport { Author } from './model/Author';\nimport { AuthorPage } from './model/AuthorPage';\n\n@Injectable({\nprovidedIn: 'root'\n})\nexport class AuthorService {\n\nconstructor(\nprivate http: HttpClient\n) { }\n\ngetAuthors(pageable: Pageable): Observable&lt;AuthorPage&gt; {\nreturn this.http.post&lt;AuthorPage&gt;('http://localhost:8080/author', {pageable:pageable});\n}\n\nsaveAuthor(author: Author): Observable&lt;void&gt; {\nlet url = 'http://localhost:8080/author';\nif (author.id != null) url += '/'+author.id;\nreturn this.http.put&lt;void&gt;(url, author);\n}\n\ndeleteAuthor(idAuthor : number): Observable&lt;void&gt; {\nreturn this.http.delete&lt;void&gt;('http://localhost:8080/author/'+idAuthor);\n}    }\n</code></pre>"},{"location":"develop/paginated/nodejs/","title":"Listado paginado - Nodejs","text":"<p>Ahora vamos a implementar las operaciones necesarias para ayudar al front a cubrir la funcionalidad del CRUD paginado en servidor.  Recuerda que para que un listado paginado en servidor funcione, el cliente debe enviar en cada petici\u00f3n que p\u00e1gina est\u00e1 solicitando y cual es el tama\u00f1o de la p\u00e1gina, para que el servidor devuelva solamente un subconjunto de datos, en lugar de devolver el listado completo.</p> <p>Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.</p>"},{"location":"develop/paginated/nodejs/#crear-modelos","title":"Crear modelos","text":"<p>Lo primero que vamos a hacer es crear el modelo de author para trabajar con BBDD. En la carpeta schemas creamos el archivo <code>author.schema.js</code>:</p> author.schema.js <pre><code>import mongoose from \"mongoose\";\nimport normalize from 'normalize-mongoose';\nimport mongoosePaginate from 'mongoose-paginate-v2';\nconst { Schema, model } = mongoose;\n\nconst authorSchema = new Schema({\nname: {\ntype: String,\nrequire: true\n},\nnationality: {\ntype: String,\nrequire: true\n}\n});\nauthorSchema.plugin(normalize);\nauthorSchema.plugin(mongoosePaginate);\n\nconst AuthorModel = model('Author', authorSchema);\n\nexport default AuthorModel;\n</code></pre>"},{"location":"develop/paginated/nodejs/#implementar-el-service","title":"Implementar el Service","text":"<p>Creamos el service correspondiente <code>author.service.js</code>:</p> author.service.js <pre><code>import AuthorModel from '../schemas/author.schema.js';\n\nexport const getAuthors = async () =&gt; {\ntry {\nreturn await AuthorModel.find().sort('id');\n} catch (e) {\nthrow Error('Error fetching authors');\n}\n}\n\nexport const createAuthor = async (data) =&gt; {\nconst { name, nationality } = data;\ntry {\nconst author = new AuthorModel({ name, nationality });\nreturn await author.save();\n} catch (e) {\nthrow Error('Error creating author');\n}\n}\n\nexport const updateAuthor = async (id, data) =&gt; {\ntry {\nconst author = await AuthorModel.findById(id);\nif (!author) {\nthrow Error('There is no author with that Id');\n}    return await AuthorModel.findByIdAndUpdate(id, data);\n} catch (e) {\nthrow Error(e);\n}\n}\n\nexport const deleteAuthor = async (id) =&gt; {\ntry {\nconst author = await AuthorModel.findById(id);\nif (!author) {\nthrow Error('There is no author with that Id');\n}\nreturn await AuthorModel.findByIdAndDelete(id);\n} catch (e) {\nthrow Error(e);\n}\n}\n\nexport const getAuthorsPageable = async (page, limit, sort) =&gt; {\nconst sortObj = {\n[sort?.property || 'name']: sort?.direction === 'DESC' ? 'DESC' : 'ASC'\n};\ntry {\nconst options = {\npage: parseInt(page) + 1,\nlimit,\nsort: sortObj\n};\n\nreturn await AuthorModel.paginate({}, options);\n} catch (e) {\nthrow Error('Error fetching authors page');\n}    }\n</code></pre> <p>Como podemos observar es muy parecido al servicio de categor\u00edas, pero hemos incluido un nuevo m\u00e9todo <code>getAuthorsPageable</code>. Este m\u00e9todo tendr\u00e1 como par\u00e1metros de entrada la p\u00e1gina que queramos mostrar, el tama\u00f1o de esta y las propiedades de ordenaci\u00f3n. Moongose nos proporciona el m\u00e9todo paginate que es muy parecido a find salvo que adem\u00e1s podemos pasar las opciones de paginaci\u00f3n y el solo realizar\u00e1 todo el trabajo.</p>"},{"location":"develop/paginated/nodejs/#implementar-el-controller","title":"Implementar el Controller","text":"<p>Creamos el controlador <code>author.controller.js</code>:</p> author.controller.js <pre><code>import * as AuthorService from '../services/author.service.js';\n\nexport const getAuthors = async (req, res) =&gt; {\ntry {\nconst authors = await AuthorService.getAuthors();\nres.status(200).json(\nauthors\n);\n} catch (err) {\nres.status(400).json({\nmsg: err.toString()\n});\n}\n}\n\nexport const createAuthor = async (req, res) =&gt; {\ntry {\nconst author = await AuthorService.createAuthor(req.body);\nres.status(200).json({\nauthor\n});\n} catch (err) {\nres.status(400).json({\nmsg: err.toString()\n});\n}\n}\n\nexport const updateAuthor = async (req, res) =&gt; {\nconst authorId = req.params.id;\ntry {\nawait AuthorService.updateAuthor(authorId, req.body);\nres.status(200).json(1);\n} catch (err) {\nres.status(400).json({\nmsg: err.toString()\n});\n}\n}\n\nexport const deleteAuthor = async (req, res) =&gt; {\nconst authorId = req.params.id;\ntry {\nconst deletedAuthor = await AuthorService.deleteAuthor(authorId);\nres.status(200).json({\nauthor: deletedAuthor\n});\n} catch (err) {\nres.status(400).json({\nmsg: err.toString()\n});\n}\n}\n\nexport const getAuthorsPageable = async (req, res) =&gt; {\nconst page = req.body.pageable.pageNumber || 0;\nconst limit = req.body.pageable.pageSize || 5;\nconst sort = req.body.pageable.sort || null;\n\ntry {\nconst response = await AuthorService.getAuthorsPageable(page, limit, sort);\nres.status(200).json({\ncontent: response.docs,\npageable: {\npageNumber: response.page - 1,\npageSize: response.limit\n},\ntotalElements: response.totalDocs\n});\n} catch (err) {\nres.status(400).json({\nmsg: err.toString()\n});\n}\n}\n</code></pre> <p>Y vemos que el m\u00e9todo getAuthorsPageable lee los datos de la request, se los pasa al servicio y por \u00faltimo transforma la response con los datos obtenidos.</p>"},{"location":"develop/paginated/nodejs/#implementar-las-rutas","title":"Implementar las Rutas","text":"<p>Creamos nuestro archivo de rutas <code>author.routes.js</code>:</p> author.routes.js <pre><code>import { Router } from 'express';\nimport { check } from 'express-validator';\nimport validateFields from '../middlewares/validateFields.js';\nimport { createAuthor, deleteAuthor, getAuthors, updateAuthor, getAuthorsPageable } from '../controllers/author.controller.js';\nconst authorRouter = Router();\n\nauthorRouter.put('/:id', [\ncheck('name').not().isEmpty(),\ncheck('nationality').not().isEmpty(),\nvalidateFields\n], updateAuthor);\n\nauthorRouter.put('/', [\ncheck('name').not().isEmpty(),\ncheck('nationality').not().isEmpty(),\nvalidateFields\n], createAuthor);\n\nauthorRouter.get('/', getAuthors);\nauthorRouter.delete('/:id', deleteAuthor);\n\nauthorRouter.post('/', [\ncheck('pageable').not().isEmpty(),\ncheck('pageable.pageSize').not().isEmpty(),\ncheck('pageable.pageNumber').not().isEmpty(),\nvalidateFields\n], getAuthorsPageable)\n\nexport default authorRouter;\n</code></pre> <p>Podemos observar que si hacemos una petici\u00f3n con get a <code>/author</code> nos devolver\u00e1 todos los autores. Pero si hacemos una petici\u00f3n post con el objeto pageable en el body realizaremos el listado paginado.</p> <p>Finalmente en nuestro archivo <code>index.js</code> vamos a a\u00f1adir el nuevo router:</p> index.js <pre><code>...\n\nimport authorRouter from './src/routes/author.routes.js';\n\n...\n\napp.use('/author', authorRouter);\n\n...\n</code></pre>"},{"location":"develop/paginated/nodejs/#probar-las-operaciones","title":"Probar las operaciones","text":"<p>Y ahora que tenemos todo creado, ya podemos probarlo con Postman:</p> <p>Por un lado creamos autores con:</p> <p> PUT /author  </p> <p> PUT /author/{id}  <pre><code>{\n\"name\" : \"Nuevo autor\",\n\"nationality\" : \"Nueva nacionalidad\"\n}\n</code></pre></p> <p>Nos sirve para insertar <code>Autores</code> nuevas (si no tienen el id informado) o para actualizar <code>Autores</code> (si tienen el id informado en la URL).  F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no te dar\u00e1 un error.</p> <p></p> <p></p> <p> DELETE /author/{id}   nos sirve eliminar <code>Autores</code>. F\u00edjate que el dato del ID que se env\u00eda est\u00e1 en el path.</p> <p></p> <p>Luego recuperamos los autores con el m\u00e9todo <code>GET</code> (antes tienes que crear unos cuantos para poder ver un listado):</p> <p></p> <p>Y por \u00faltimo listamos los autores paginados:</p> <p> POST /author </p> <pre><code>{\n\"pageable\": {\n\"pageSize\" : 4,\n\"pageNumber\" : 0,\n\"sort\" : [\n{\n\"property\": \"name\",\n\"direction\": \"ASC\"\n}\n]\n}\n}\n</code></pre> <p></p>"},{"location":"develop/paginated/springboot/","title":"Listado paginado - Spring Boot","text":"<p>Ahora vamos a implementar las operaciones necesarias para ayudar al front a cubrir la funcionalidad del CRUD paginado en servidor.  Recuerda que para que un listado paginado en servidor funcione, el cliente debe enviar en cada petici\u00f3n que p\u00e1gina est\u00e1 solicitando y cu\u00e1l es el tama\u00f1o de la p\u00e1gina, para que el servidor devuelva solamente un subconjunto de datos, en lugar de devolver el listado completo.</p> <p>Como ya conocemos como se debe desarrollar, en este ejemplo vamos a ir m\u00e1s r\u00e1pidos y nos vamos a centrar \u00fanicamente en las novedades.</p>"},{"location":"develop/paginated/springboot/#crear-modelos","title":"Crear modelos","text":"<p>Lo primero que vamos a hacer es crear los modelos para trabajar con BBDD y con peticiones hacia el front. Adem\u00e1s, tambi\u00e9n tenemos que a\u00f1adir datos al script de inicializaci\u00f3n de BBDD, siempre respetando la nomenclatura que le hemos dado a la tabla y columnas de BBDD.</p> Author.javaAuthorDto.javadata.sql <pre><code>package com.ccsw.tutorial.author.model;\n\nimport jakarta.persistence.*;\n\n/**\n * @author ccsw\n *\n */\n@Entity\n@Table(name = \"author\")\npublic class Author {\n\n@Id\n@GeneratedValue(strategy = GenerationType.IDENTITY)\n@Column(name = \"id\", nullable = false)\nprivate Long id;\n\n@Column(name = \"name\", nullable = false)\nprivate String name;\n\n@Column(name = \"nationality\")\nprivate String nationality;\n\n/**\n     * @return id\n     */\npublic Long getId() {\n\nreturn this.id;\n}\n\n/**\n     * @param id new value of {@link #getId}.\n     */\npublic void setId(Long id) {\n\nthis.id = id;\n}\n\n/**\n     * @return name\n     */\npublic String getName() {\n\nreturn this.name;\n}\n\n/**\n     * @param name new value of {@link #getName}.\n     */\npublic void setName(String name) {\n\nthis.name = name;\n}\n\n/**\n     * @return nationality\n     */\npublic String getNationality() {\n\nreturn this.nationality;\n}\n\n/**\n     * @param nationality new value of {@link #getNationality}.\n     */\npublic void setNationality(String nationality) {\n\nthis.nationality = nationality;\n}\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.author.model;\n\n/**\n * @author ccsw\n *\n */\npublic class AuthorDto {\n\nprivate Long id;\n\nprivate String name;\n\nprivate String nationality;\n\n/**\n     * @return id\n     */\npublic Long getId() {\n\nreturn this.id;\n}\n\n/**\n     * @param id new value of {@link #getId}.\n     */\npublic void setId(Long id) {\n\nthis.id = id;\n}\n\n/**\n     * @return name\n     */\npublic String getName() {\n\nreturn this.name;\n}\n\n/**\n     * @param name new value of {@link #getName}.\n     */\npublic void setName(String name) {\n\nthis.name = name;\n}\n\n/**\n     * @return nationality\n     */\npublic String getNationality() {\n\nreturn this.nationality;\n}\n\n/**\n     * @param nationality new value of {@link #getNationality}.\n     */\npublic void setNationality(String nationality) {\n\nthis.nationality = nationality;\n}\n\n}\n</code></pre> <pre><code>INSERT INTO category(name) VALUES ('Eurogames');\nINSERT INTO category(name) VALUES ('Ameritrash');\nINSERT INTO category(name) VALUES ('Familiar');\n\nINSERT INTO author(name, nationality) VALUES ('Alan R. Moon', 'US');\nINSERT INTO author(name, nationality) VALUES ('Vital Lacerda', 'PT');\nINSERT INTO author(name, nationality) VALUES ('Simone Luciani', 'IT');\nINSERT INTO author(name, nationality) VALUES ('Perepau Llistosella', 'ES');\nINSERT INTO author(name, nationality) VALUES ('Michael Kiesling', 'DE');\nINSERT INTO author(name, nationality) VALUES ('Phil Walker-Harding', 'US');\n</code></pre>"},{"location":"develop/paginated/springboot/#implementar-tdd-pruebas","title":"Implementar TDD - Pruebas","text":"<p>Para desarrollar todas las operaciones, empezaremos primero dise\u00f1ando las pruebas y luego implementando el c\u00f3digo necesario que haga funcionar correctamente esas pruebas. Para ir m\u00e1s r\u00e1pido vamos a poner todas las pruebas de golpe, pero realmente se deber\u00edan crear una a una e ir implementando el c\u00f3digo necesario para esa prueba. Para evitar tantas iteraciones en el tutorial las haremos todas de golpe.</p> <p>Vamos a pararnos a pensar un poco que necesitamos en la pantalla. Ahora mismo nos sirve con:</p> <ul> <li>Una consulta paginada, que reciba datos de la p\u00e1gina a consultar y devuelva los datos paginados</li> <li>Una operaci\u00f3n de guardado y modificaci\u00f3n</li> <li>Una operaci\u00f3n de borrado</li> </ul> <p>Para la primera prueba que hemos descrito (consulta paginada) se necesita un objeto que contenga los datos de la p\u00e1gina a consultar. As\u00ed que crearemos una clase <code>AuthorSearchDto</code> para utilizarlo como 'paginador'.</p> <p>Para ello, en primer lugar, deberemos a\u00f1adir una clase que vamos a utilizar como envoltorio para las peticiones de paginaci\u00f3n en el proyecto. Hacemos esto para desacoplar la interface de Springboot de nuestro contrato de entrada. Crearemos esta clase en el paquete <code>com.ccsw.tutorial.common.pagination</code>.</p> PageableRequest.java <pre><code>package com.ccsw.tutorial.common.pagination;\n\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport org.springframework.data.domain.*;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class PageableRequest implements Serializable {\n\nprivate static final long serialVersionUID = 1L;\n\nprivate int pageNumber;\n\nprivate int pageSize;\n\nprivate List&lt;SortRequest&gt; sort;\n\npublic PageableRequest() {\n\nsort = new ArrayList&lt;&gt;();\n}\n\npublic PageableRequest(int pageNumber, int pageSize) {\n\nthis();\nthis.pageNumber = pageNumber;\nthis.pageSize = pageSize;\n}\n\npublic PageableRequest(int pageNumber, int pageSize, List&lt;SortRequest&gt; sort) {\n\nthis();\nthis.pageNumber = pageNumber;\nthis.pageSize = pageSize;\nthis.sort = sort;\n}\n\npublic int getPageNumber() {\nreturn pageNumber;\n}\n\npublic void setPageNumber(int pageNumber) {\nthis.pageNumber = pageNumber;\n}\n\npublic int getPageSize() {\nreturn pageSize;\n}\n\npublic void setPageSize(int pageSize) {\nthis.pageSize = pageSize;\n}\n\npublic List&lt;SortRequest&gt; getSort() {\nreturn sort;\n}\n\npublic void setSort(List&lt;SortRequest&gt; sort) {\nthis.sort = sort;\n}\n\n@JsonIgnore\npublic Pageable getPageable() {\n\nreturn PageRequest.of(this.pageNumber, this.pageSize, Sort.by(sort.stream().map(e -&gt; new Sort.Order(e.getDirection(), e.getProperty())).collect(Collectors.toList())));\n}\n\npublic static class SortRequest implements Serializable {\n\nprivate static final long serialVersionUID = 1L;\n\nprivate String property;\n\nprivate Sort.Direction direction;\n\nprotected String getProperty() {\nreturn property;\n}\n\nprotected void setProperty(String property) {\nthis.property = property;\n}\n\nprotected Sort.Direction getDirection() {\nreturn direction;\n}\n\nprotected void setDirection(Sort.Direction direction) {\nthis.direction = direction;\n}\n}\n\n}\n</code></pre> <p>Adicionalmente necesitaremos una clase para deserializar las respuestas de Page recibidas en los test que vamos a implementar. Para ello creamos la clase necesaria dentro de la fuente de la carpeta de los <code>test</code> en el paquete <code>com.ccsw.tutorial.config</code>. Esto solo hace falta porque necesitamos leer la respuesta paginada en el test, si no hicieramos test, no har\u00eda falta.</p> ResponsePage.java <pre><code>package com.ccsw.tutorial.config;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport org.springframework.data.domain.PageImpl;\nimport org.springframework.data.domain.PageRequest;\nimport org.springframework.data.domain.Pageable;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class ResponsePage&lt;T&gt; extends PageImpl&lt;T&gt; {\n\nprivate static final long serialVersionUID = 1L;\n\n@JsonCreator(mode = JsonCreator.Mode.PROPERTIES)\npublic ResponsePage(@JsonProperty(\"content\") List&lt;T&gt; content,\n@JsonProperty(\"number\") int number,\n@JsonProperty(\"size\") int size,\n@JsonProperty(\"totalElements\") Long totalElements,\n@JsonProperty(\"pageable\") JsonNode pageable,\n@JsonProperty(\"last\") boolean last,\n@JsonProperty(\"totalPages\") int totalPages,\n@JsonProperty(\"sort\") JsonNode sort,\n@JsonProperty(\"first\") boolean first,\n@JsonProperty(\"numberOfElements\") int numberOfElements) {\n\nsuper(content, PageRequest.of(number, size), totalElements);\n}\n\npublic ResponsePage(List&lt;T&gt; content, Pageable pageable, long total) {\nsuper(content, pageable, total);\n}\n\npublic ResponsePage(List&lt;T&gt; content) {\nsuper(content);\n}\n\npublic ResponsePage() {\nsuper(new ArrayList&lt;&gt;());\n}\n\n}\n</code></pre> <p>Paginaci\u00f3n en Springframework</p> <p>Cuando utilicemos paginaci\u00f3n en Springframework, debemos recordar que ya vienen implementados algunos objetos que podemos utilizar y que nos facilitan la vida. Es el caso de <code>Pageable</code> y <code>Page</code>.</p> <ul> <li>El objeto <code>Pageable</code> no es m\u00e1s que una interface que le permite a Spring JPA saber que p\u00e1gina se quiere buscar, cual es el tama\u00f1o de p\u00e1gina y cuales son las propiedades de ordenaci\u00f3n que se debe lanzar en la consulta.</li> <li>El objeto <code>PageRequest</code> es una utilidad que permite crear objetos de tipo <code>Pageable</code> de forma sencilla. Se utiliza mucho para codificaci\u00f3n de test.</li> <li>El objeto <code>Page</code> no es m\u00e1s que un contenedor que engloba la informaci\u00f3n b\u00e1sica de la p\u00e1gina que se est\u00e1 consultando (n\u00famero de p\u00e1gina, tama\u00f1o de p\u00e1gina, n\u00famero total de resultados) y el conjunto de datos de la BBDD que contiene esa p\u00e1gina una vez han sido buscados y ordenados.</li> </ul> <p>Tambi\u00e9n crearemos una clase <code>AuthorController</code> dentro del package de <code>com.ccsw.tutorial.author</code> con la implementaci\u00f3n de los m\u00e9todos vac\u00edos, para que no falle la compilaci\u00f3n.</p> <p>\u00a1Vamos a implementar test!</p> AuthorSearchDto.javaAuthorController.javaAuthorIT.java <pre><code>package com.ccsw.tutorial.author.model;\n\nimport com.ccsw.tutorial.common.pagination.PageableRequest;\n\n/**\n * @author ccsw\n *\n */\npublic class AuthorSearchDto {\n\nprivate PageableRequest pageable;\n\npublic PageableRequest getPageable() {\nreturn pageable;\n}\n\npublic void setPageable(PageableRequest pageable) {\nthis.pageable = pageable;\n}\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport com.ccsw.tutorial.author.model.AuthorDto;\nimport com.ccsw.tutorial.author.model.AuthorSearchDto;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport org.springframework.data.domain.Page;\nimport org.springframework.web.bind.annotation.*;\n\n/**\n * @author ccsw\n *\n */\n@Tag(name = \"Author\", description = \"API of Author\")\n@RequestMapping(value = \"/author\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class AuthorController {\n\n/**\n     * M\u00e9todo para recuperar un listado paginado de {@link Author}\n     *\n     * @param dto dto de b\u00fasqueda\n     * @return {@link Page} de {@link AuthorDto}\n     */\n@Operation(summary = \"Find Page\", description = \"Method that return a page of Authors\")\n@RequestMapping(path = \"\", method = RequestMethod.POST)\npublic Page&lt;AuthorDto&gt; findPage(@RequestBody AuthorSearchDto dto) {\n\nreturn null;\n}\n\n/**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n@Operation(summary = \"Save or Update\", description = \"Method that saves or updates a Author\")\n@RequestMapping(path = { \"\", \"/{id}\" }, method = RequestMethod.PUT)\npublic void save(@PathVariable(name = \"id\", required = false) Long id, @RequestBody AuthorDto dto) {\n\n}\n\n/**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     */\n@Operation(summary = \"Delete\", description = \"Method that deletes a Author\")\n@RequestMapping(path = \"/{id}\", method = RequestMethod.DELETE)\npublic void delete(@PathVariable(\"id\") Long id) throws Exception {\n\n}\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.AuthorDto;\nimport com.ccsw.tutorial.author.model.AuthorSearchDto;\nimport com.ccsw.tutorial.common.pagination.PageableRequest;\nimport com.ccsw.tutorial.config.ResponsePage;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.web.client.TestRestTemplate;\nimport org.springframework.boot.test.web.server.LocalServerPort;\nimport org.springframework.core.ParameterizedTypeReference;\nimport org.springframework.http.*;\nimport org.springframework.test.annotation.DirtiesContext;\n\nimport java.util.List;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\n\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)\n@DirtiesContext(classMode = DirtiesContext.ClassMode.BEFORE_EACH_TEST_METHOD)\npublic class AuthorIT {\n\npublic static final String LOCALHOST = \"http://localhost:\";\npublic static final String SERVICE_PATH = \"/author\";\n\npublic static final Long DELETE_AUTHOR_ID = 6L;\npublic static final Long MODIFY_AUTHOR_ID = 3L;\npublic static final String NEW_AUTHOR_NAME = \"Nuevo Autor\";\npublic static final String NEW_NATIONALITY = \"Nueva Nacionalidad\";\n\nprivate static final int TOTAL_AUTHORS = 6;\nprivate static final int PAGE_SIZE = 5;\n\n@LocalServerPort\nprivate int port;\n\n@Autowired\nprivate TestRestTemplate restTemplate;\n\nParameterizedTypeReference&lt;ResponsePage&lt;AuthorDto&gt;&gt; responseTypePage = new ParameterizedTypeReference&lt;ResponsePage&lt;AuthorDto&gt;&gt;(){};\n\n@Test\npublic void findFirstPageWithFiveSizeShouldReturnFirstFiveResults() {\n\nAuthorSearchDto searchDto = new AuthorSearchDto();\nsearchDto.setPageable(new PageableRequest(0, PAGE_SIZE));\n\nResponseEntity&lt;ResponsePage&lt;AuthorDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.POST, new HttpEntity&lt;&gt;(searchDto), responseTypePage);\n\nassertNotNull(response);\nassertEquals(TOTAL_AUTHORS, response.getBody().getTotalElements());\nassertEquals(PAGE_SIZE, response.getBody().getContent().size());\n}\n\n@Test\npublic void findSecondPageWithFiveSizeShouldReturnLastResult() {\n\nint elementsCount = TOTAL_AUTHORS - PAGE_SIZE;\n\nAuthorSearchDto searchDto = new AuthorSearchDto();\nsearchDto.setPageable(new PageableRequest(1, PAGE_SIZE));\n\nResponseEntity&lt;ResponsePage&lt;AuthorDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.POST, new HttpEntity&lt;&gt;(searchDto), responseTypePage);\n\nassertNotNull(response);\nassertEquals(TOTAL_AUTHORS, response.getBody().getTotalElements());\nassertEquals(elementsCount, response.getBody().getContent().size());\n}\n\n@Test\npublic void saveWithoutIdShouldCreateNewAuthor() {\n\nlong newAuthorId = TOTAL_AUTHORS + 1;\nlong newAuthorSize = TOTAL_AUTHORS + 1;\n\nAuthorDto dto = new AuthorDto();\ndto.setName(NEW_AUTHOR_NAME);\ndto.setNationality(NEW_NATIONALITY);\n\nrestTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.PUT, new HttpEntity&lt;&gt;(dto), Void.class);\n\nAuthorSearchDto searchDto = new AuthorSearchDto();\nsearchDto.setPageable(new PageableRequest(0, (int) newAuthorSize));\n\nResponseEntity&lt;ResponsePage&lt;AuthorDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.POST, new HttpEntity&lt;&gt;(searchDto), responseTypePage);\n\nassertNotNull(response);\nassertEquals(newAuthorSize, response.getBody().getTotalElements());\n\nAuthorDto author = response.getBody().getContent().stream().filter(item -&gt; item.getId().equals(newAuthorId)).findFirst().orElse(null);\nassertNotNull(author);\nassertEquals(NEW_AUTHOR_NAME, author.getName());\n}\n\n@Test\npublic void modifyWithExistIdShouldModifyAuthor() {\n\nAuthorDto dto = new AuthorDto();\ndto.setName(NEW_AUTHOR_NAME);\ndto.setNationality(NEW_NATIONALITY);\n\nrestTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + MODIFY_AUTHOR_ID, HttpMethod.PUT, new HttpEntity&lt;&gt;(dto), Void.class);\n\nAuthorSearchDto searchDto = new AuthorSearchDto();\nsearchDto.setPageable(new PageableRequest(0, PAGE_SIZE));\n\nResponseEntity&lt;ResponsePage&lt;AuthorDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.POST, new HttpEntity&lt;&gt;(searchDto), responseTypePage);\n\nassertNotNull(response);\nassertEquals(TOTAL_AUTHORS, response.getBody().getTotalElements());\n\nAuthorDto author = response.getBody().getContent().stream().filter(item -&gt; item.getId().equals(MODIFY_AUTHOR_ID)).findFirst().orElse(null);\nassertNotNull(author);\nassertEquals(NEW_AUTHOR_NAME, author.getName());\nassertEquals(NEW_NATIONALITY, author.getNationality());\n}\n\n@Test\npublic void modifyWithNotExistIdShouldThrowException() {\n\nlong authorId = TOTAL_AUTHORS + 1;\n\nAuthorDto dto = new AuthorDto();\ndto.setName(NEW_AUTHOR_NAME);\n\nResponseEntity&lt;?&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + authorId, HttpMethod.PUT, new HttpEntity&lt;&gt;(dto), Void.class);\n\nassertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());\n}\n\n@Test\npublic void deleteWithExistsIdShouldDeleteCategory() {\n\nlong newAuthorsSize = TOTAL_AUTHORS - 1;\n\nrestTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + DELETE_AUTHOR_ID, HttpMethod.DELETE, null, Void.class);\n\nAuthorSearchDto searchDto = new AuthorSearchDto();\nsearchDto.setPageable(new PageableRequest(0, TOTAL_AUTHORS));\n\nResponseEntity&lt;ResponsePage&lt;AuthorDto&gt;&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH, HttpMethod.POST, new HttpEntity&lt;&gt;(searchDto), responseTypePage);\n\nassertNotNull(response);\nassertEquals(newAuthorsSize, response.getBody().getTotalElements());\n}\n\n@Test\npublic void deleteWithNotExistsIdShouldThrowException() {\n\nlong deleteAuthorId = TOTAL_AUTHORS + 1;\n\nResponseEntity&lt;?&gt; response = restTemplate.exchange(LOCALHOST + port + SERVICE_PATH + \"/\" + deleteAuthorId, HttpMethod.DELETE, null, Void.class);\n\nassertEquals(HttpStatus.INTERNAL_SERVER_ERROR, response.getStatusCode());\n}\n\n}\n</code></pre> <p>Cuidado con las clases de Test</p> <p>Recuerda que el c\u00f3digo de aplicaci\u00f3n debe ir en <code>src/main/java</code>, mientras que las clases de test deben ir en <code>src/test/java</code> para que no se mezclen unas con otras y se empaquete todo en el artefacto final. En este caso <code>AuthorIT.java</code> va en el directorio de test <code>src/test/java</code>.</p> <p>Si ejecutamos los test, el resultado ser\u00e1 7 maravillosos test que fallan su ejecuci\u00f3n. Es normal, puesto que no hemos implementado nada de c\u00f3digo de aplicaci\u00f3n para corresponder esos test.</p>"},{"location":"develop/paginated/springboot/#implementar-controller","title":"Implementar Controller","text":"<p>Si recuerdas, esta capa de <code>Controller</code> es la que tiene los endpoints de entrada a la aplicaci\u00f3n. Nosotros ya tenemos definidas 3 operaciones, que hemos dise\u00f1ado directamente desde los tests. Ahora vamos a implementar esos m\u00e9todos con el c\u00f3digo necesario para que los test funcionen correctamente, y teniendo en mente que debemos apoyarnos en las capas inferiores <code>Service</code> y <code>Repository</code> para repartir l\u00f3gica de negocio y acceso a datos.</p> AuthorController.javaAuthorService.java <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport com.ccsw.tutorial.author.model.AuthorDto;\nimport com.ccsw.tutorial.author.model.AuthorSearchDto;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport org.dozer.DozerBeanMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.PageImpl;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * @author ccsw\n *\n */\n@Tag(name = \"Author\", description = \"API of Author\")\n@RequestMapping(value = \"/author\")\n@RestController\n@CrossOrigin(origins = \"*\")\npublic class AuthorController {\n\n@Autowired\nAuthorService authorService;\n@Autowired\nDozerBeanMapper mapper;\n\n/**\n     * M\u00e9todo para recuperar un listado paginado de {@link Author}\n     *\n     * @param dto dto de b\u00fasqueda\n     * @return {@link Page} de {@link AuthorDto}\n     */\n@Operation(summary = \"Find Page\", description = \"Method that return a page of Authors\")\n@RequestMapping(path = \"\", method = RequestMethod.POST)\npublic Page&lt;AuthorDto&gt; findPage(@RequestBody AuthorSearchDto dto) {\n\nPage&lt;Author&gt; page = this.authorService.findPage(dto);\n\nreturn new PageImpl&lt;&gt;(page.getContent().stream().map(e -&gt; mapper.map(e, AuthorDto.class)).collect(Collectors.toList()), page.getPageable(), page.getTotalElements());\n}\n\n/**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\n@Operation(summary = \"Save or Update\", description = \"Method that saves or updates a Author\")\n@RequestMapping(path = { \"\", \"/{id}\" }, method = RequestMethod.PUT)\npublic void save(@PathVariable(name = \"id\", required = false) Long id, @RequestBody AuthorDto dto) {\n\nthis.authorService.save(id, dto);\n}\n\n/**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     */\n@Operation(summary = \"Delete\", description = \"Method that deletes a Author\")\n@RequestMapping(path = \"/{id}\", method = RequestMethod.DELETE)\npublic void delete(@PathVariable(\"id\") Long id) throws Exception {\n\nthis.authorService.delete(id);\n}\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport com.ccsw.tutorial.author.model.AuthorDto;\nimport com.ccsw.tutorial.author.model.AuthorSearchDto;\nimport org.springframework.data.domain.Page;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\npublic interface AuthorService {\n\n/**\n     * M\u00e9todo para recuperar un listado paginado de {@link Author}\n     *\n     * @param dto dto de b\u00fasqueda\n     * @return {@link Page} de {@link Author}\n     */\nPage&lt;Author&gt; findPage(AuthorSearchDto dto);\n\n/**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     * @param dto datos de la entidad\n     */\nvoid save(Long id, AuthorDto dto);\n\n/**\n     * M\u00e9todo para crear o actualizar un {@link Author}\n     *\n     * @param id PK de la entidad\n     */\nvoid delete(Long id) throws Exception;\n\n}\n</code></pre> <p>Si te fijas, hemos trasladado toda la l\u00f3gica a llamadas al <code>AuthorService</code> que hemos inyectado, y para que no falle la compilaci\u00f3n hemos creado una interface con los m\u00e9todos necesarios.</p> <p>En la clase <code>AuthorController</code> es donde se hacen las conversiones de cara al cliente, pasaremos de un <code>Page&lt;Author&gt;</code> (modelo entidad) a un <code>Page&lt;AuthorDto&gt;</code> (modelo DTO) con la ayuda del beanMapper. Recuerda que al cliente no le deben llegar modelos entidades sino DTOs.</p> <p>Adem\u00e1s, el m\u00e9todo de carga <code>findPage</code> ya no es un m\u00e9todo de tipo <code>GET</code>, ahora es de tipo <code>POST</code> porque le tenemos que enviar los datos de la paginaci\u00f3n para que Spring JPA pueda hacer su magia.</p> <p>Ahora debemos implementar la siguiente capa.</p>"},{"location":"develop/paginated/springboot/#implementar-service","title":"Implementar Service","text":"<p>La siguiente capa que vamos a implementar es justamente la capa que contiene toda la l\u00f3gica de negocio, hace uso del <code>Repository</code> para acceder a los datos, y recibe llamadas generalmente de los <code>Controller</code>.</p> AuthorServiceImpl.javaAuthorRepository.java <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport com.ccsw.tutorial.author.model.AuthorDto;\nimport com.ccsw.tutorial.author.model.AuthorSearchDto;\nimport jakarta.transaction.Transactional;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.domain.Page;\nimport org.springframework.stereotype.Service;\n\nimport java.util.List;\n\n/**\n * @author ccsw\n *\n */\n@Service\n@Transactional\npublic class AuthorServiceImpl implements AuthorService {\n\n@Autowired\nAuthorRepository authorRepository;\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic Page&lt;Author&gt; findPage(AuthorSearchDto dto) {\n\nreturn this.authorRepository.findAll(dto.getPageable().getPageable());\n}\n\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic void save(Long id, AuthorDto data) {\n\nAuthor author;\n\nif (id == null) {\nauthor = new Author();\n} else {\nauthor = this.authorRepository.findById(id).orElse(null);\n}\n\nBeanUtils.copyProperties(data, author, \"id\");\nthis.authorRepository.save(author);\n}\n\n/**\n     * {@inheritDoc}\n     */\n@Override\npublic void delete(Long id) throws Exception {\n\nif(this.authorRepository.findById(id).orElse(null) == null){\nthrow new Exception(\"Not exists\");\n}\n\nthis.authorRepository.deleteById(id);\n}\n\n}\n</code></pre> <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.repository.CrudRepository;\n\n/**\n * @author ccsw\n *\n */\npublic interface AuthorRepository extends CrudRepository&lt;Author, Long&gt; {\n}\n</code></pre> <p>De nuevo pasa lo mismo que con la capa anterior, aqu\u00ed delegamos muchas operaciones de consulta y guardado de datos en <code>AuthorRepository</code>. Hemos tenido que crearlo como interface para que no falle la compilaci\u00f3n. Recuerda que cuando creamos un <code>Repository</code> es de gran ayuda hacerlo extender de <code>CrudRepository&lt;T, ID&gt;</code> ya que tiene muchos m\u00e9todos implementados de base que nos pueden servir, como el <code>delete</code> o el <code>save</code>.</p> <p>F\u00edjate tambi\u00e9n que cuando queremos copiar m\u00e1s de un dato de una clase a otra, tenemos una utilidad llamada <code>BeanUtils</code> que nos permite realizar esa copia (siempre que las propiedades de ambas clases se llamen igual). Adem\u00e1s, en nuestro ejemplo hemos ignorado el 'id' para que no nos copie un null a la clase destino.</p>"},{"location":"develop/paginated/springboot/#implementar-repository","title":"Implementar Repository","text":"<p>Y llegamos a la \u00faltima capa, la que est\u00e1 m\u00e1s cerca de los datos finales. Tenemos la siguiente interface:</p> AuthorRepository.java <pre><code>package com.ccsw.tutorial.author;\n\nimport com.ccsw.tutorial.author.model.Author;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.repository.CrudRepository;\n\n/**\n * @author ccsw\n *\n */\npublic interface AuthorRepository extends CrudRepository&lt;Author, Long&gt; {\n\n/**\n     * M\u00e9todo para recuperar un listado paginado de {@link Author}\n     *\n     * @param pageable pageable\n     * @return {@link Page} de {@link Author}\n     */\nPage&lt;Author&gt; findAll(Pageable pageable);\n\n}\n</code></pre> <p>Si te fijas, este <code>Repository</code> ya no est\u00e1 vac\u00edo como el anterior, no nos sirve con las operaciones b\u00e1sicas del <code>CrudRepository</code> en este caso hemos tenido que a\u00f1adir un m\u00e9todo nuevo al que pasandole un objeto de tipo <code>Pageable</code> nos devuelva una <code>Page</code>.</p> <p>Pues bien, resulta que la m\u00e1gina de Spring JPA en este caso har\u00e1 su trabajo y nosotros no necesitamos implementar ninguna query, Spring ya entiende que un <code>findAll</code> significa que debe recuperar todos los datos de la tabla <code>Author</code> (que es la tabla que tiene como <code>generico</code> en <code>CrudRepository</code>) y adem\u00e1s deben estar paginados ya que el m\u00e9todo devuelve un objeto tipo <code>Page</code>. Nos ahorra tener que generar una sql para buscar una p\u00e1gina concreta de datos y hacer un <code>count</code> de la tabla para obtener el total de resultados. Para ver otros ejemplos y m\u00e1s informaci\u00f3n, visita la p\u00e1gina de QueryMethods. Realmente se puede hacer much\u00edsimas cosas con solo escribir el nombre del m\u00e9todo, sin tener que pensar ni teclear ninguna sql.</p> <p>Con esto ya lo tendr\u00edamos todo. </p>"},{"location":"develop/paginated/springboot/#probar-las-operaciones","title":"Probar las operaciones","text":"<p>Si ahora ejecutamos los test jUnit, veremos que todos funcionan y est\u00e1n en verde. Hemos implementado todas nuestras pruebas y la aplicaci\u00f3n es correcta.</p> <p></p> <p>Aun as\u00ed, debemos realizar pruebas con el postman para ver los resultados que nos ofrece el back. Para ello, tienes que levantar la aplici\u00f3n y ejecutar las siguientes operaciones:</p> <p> POST /author  <pre><code>{\n    \"pageable\": {\n        \"pageSize\" : 4,\n        \"pageNumber\" : 0,\n        \"sort\" : [\n            {\n                \"property\": \"name\",\n                \"direction\": \"ASC\"\n            }\n        ]\n    }\n}\n</code></pre> Nos devuelve un listado paginado de <code>Autores</code>. F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no env\u00edas datos con formato <code>Pageable</code>, te dar\u00e1 un error. Tambi\u00e9n f\u00edjate que la respuesta es de tipo <code>Page</code>. Prueba a jugar con los datos de paginaci\u00f3n e incluso de ordenaci\u00f3n. No hemos programado ninguna SQL pero Spring hace su magia.</p> <p></p> <p> PUT /author  </p> <p> PUT /author/{id}  <pre><code>{\n    \"name\" : \"Nuevo autor\",\n    \"nationality\" : \"Nueva nacionalidad\"\n}\n</code></pre> Nos sirve para insertar <code>Autores</code> nuevas (si no tienen el id informado) o para actualizar <code>Autores</code> (si tienen el id informado en la URL).  F\u00edjate que los datos que se env\u00edan est\u00e1n en el body como formato JSON (parte izquierda de la imagen). Si no te dar\u00e1 un error.</p> <p> </p> <p> DELETE /author/{id}   nos sirve eliminar <code>Autores</code>. F\u00edjate que el dato del ID que se env\u00eda est\u00e1 en el path.</p> <p></p>"},{"location":"install/angular/","title":"Entorno de desarrollo - Angular","text":""},{"location":"install/angular/#instalacion-de-herramientas","title":"Instalaci\u00f3n de herramientas","text":"<p>Las herramientas b\u00e1sicas que vamos a utilizar para esta tecnolog\u00eda son:</p> <ul> <li>Visual Studio Code</li> <li>Nodejs</li> <li>Angular CLI</li> </ul>"},{"location":"install/angular/#visual-studio-code","title":"Visual Studio Code","text":"<p>Lo primero de todo es instalar el IDE para el desarrollo front.</p> <p>Te recomiendo utilizar Visual Studio Code, en un IDE que a nosotros nos gusta mucho y tiene muchos plugins configurables. Puedes entrar en su p\u00e1gina y descargarte la versi\u00f3n estable.</p>"},{"location":"install/angular/#nodejs","title":"Nodejs","text":"<p>El siguiente paso ser\u00e1 instalar el motor de Nodejs. Entrando en la p\u00e1gina de descargas e instalando la \u00faltima versi\u00f3n estable. Con esta herramienta podremos compilar y ejecutar aplicaciones basadas en Javascript y Typescript, e instalar y gestionar las dependencias de las aplicaciones.</p>"},{"location":"install/angular/#angular-cli","title":"Angular CLI","text":"<p>Por \u00faltimo vamos a instalar una capa de gesti\u00f3n por encima de Nodejs que nos ayudar\u00e1 en concreto con la funcionalida de Angular. En concreto instalaremos el CLI de Angular. Para poder instalarlo, tan solo hay que abrir una consola de msdos y ejecutar el comando y Nodejs ya har\u00e1 el resto:</p> <pre><code>npm install -g @angular/cli\n</code></pre> <p>Y con esto ya tendremos todo instalado, listo para empezar a crear los proyectos.</p>"},{"location":"install/angular/#creacion-de-proyecto","title":"Creaci\u00f3n de proyecto","text":"<p>La mayor\u00eda de los proyectos con Angular en los que trabajamos normalmente, suelen ser proyectos web usando las librer\u00edas mas comunes de angular, como Angular Material.</p> <p>Crear un proyecto de Angular es muy sencillo si tienes instalado el CLI de Angular. Lo primero abrir una consola de msdos y posicionarte en el directorio raiz donde quieres crear tu proyecto Angular, y ejecutamos lo siguiente:</p> <pre><code>ng new tutorial --strict=false\n</code></pre> <p>El propio CLI nos ir\u00e1 realizando una serie de preguntas.</p> <p>Would you like to add Angular routing? (y/N)</p> <p><code>Preferiblemente: y</code></p> <p>Which stylesheet format would you like to use?</p> <p><code>Preferiblemente: SCSS</code></p> <p>En el caso del tutorial como vamos a tener dos proyectos para nuestra aplicaci\u00f3n (front y back), para poder seguir correctamente las explicaciones, voy a renombrar la carpeta para poder diferenciarla del otro proyecto. A partir de ahora se llamar\u00e1 <code>client</code>.</p> <p>Info</p> <p>Si durante el desarrollo del proyecto necesitas a\u00f1adir nuevos m\u00f3dulos al proyecto Angular, ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor de dependencias de Nodejs, directamente en consola ejecuta el comando <code>npm update</code> y descargar\u00e1 e instalar\u00e1 las nuevas dependencias.</p>"},{"location":"install/angular/#arrancar-el-proyecto","title":"Arrancar el proyecto","text":"<p>Para arrancar el proyecto, tan solo necesitamos ejecutar en consola el siguiente comando siempre dentro del directorio creado por Angular CLI:</p> <pre><code>ng serve\n</code></pre> <p>Angular compilar\u00e1 el c\u00f3digo fuente, levantar\u00e1 un servidor local al que podremos acceder por defecto mediante la URL: http://localhost:4200/</p> <p>Y ya podemos empezar a trabajar con Angular.</p> <p>Info</p> <p>Cuando se trata de un proyecto nuevo recien descargado de un repositorio, recuerda que ser\u00e1 necesario resolver las dependencias antes de arrancar el servidor. Esto se puede realizar mediante el gestor de dependencias de Nodejs, directamente en consola ejecuta el comando <code>npm update</code> y descargar\u00e1 e instalar\u00e1 las nuevas dependencias.</p> <p>Comandos de Angular CLI</p> <p>Si necesitas m\u00e1s informaci\u00f3n sobre los comandos que ofrece Angular CLI para poder crear aplicaciones, componentes, servicios, etc. los tienes disponibles en: https://angular.io/cli#command-overview</p>"},{"location":"install/nodejs/","title":"Entorno de desarrollo - Nodejs","text":""},{"location":"install/nodejs/#instalacion-de-herramientas","title":"Instalaci\u00f3n de herramientas","text":"<p>Las herramientas b\u00e1sicas que vamos a utilizar para esta tecnolog\u00eda son:</p> <ul> <li>Visual Studio Code</li> <li>Nodejs</li> <li>MongoDB Atlas</li> <li>Postman</li> </ul>"},{"location":"install/nodejs/#visual-studio-code","title":"Visual Studio Code","text":"<p>Lo primero de todo es instalar el IDE para el desarrollo en node si no lo has hecho previamente.</p> <p>Te recomiendo utilizar Visual Studio Code, en un IDE que a nosotros nos gusta mucho y tiene muchos plugins configurables. Puedes entrar en su p\u00e1gina y descargarte la versi\u00f3n estable.</p>"},{"location":"install/nodejs/#nodejs","title":"Nodejs","text":"<p>El siguiente paso ser\u00e1 instalar el motor de Nodejs. Entrando en la p\u00e1gina de descargas e instalando la \u00faltima versi\u00f3n estable. Con esta herramienta podremos compilar y ejecutar aplicaciones basadas en Javascript y Typescript, e instalar y gestionar las dependencias de las aplicaciones.</p>"},{"location":"install/nodejs/#mongodb-atlas","title":"MongoDB Atlas","text":"<p>Tambi\u00e9n necesitaremos crear una cuenta de MongoDB Atlas para crear nuestra base de datos MongoDB en la nube.</p> <p>Accede a la URL, registrate gr\u00e1tis con cualquier cuenta de correo y elige el tipo de cuenta gratuita \ud83d\ude0a:</p> <p></p> <p>Configura el cluster a tu gusto (selecciona la opci\u00f3n gratuita en el cloud que m\u00e1s te guste) y ya tendr\u00edas una BBDD en cloud para hacer pruebas. Lo primero que se muestra es el dashboard que se ver\u00e1 algo similar a lo siguiente:</p> <p></p> <p>A continuaci\u00f3n, pulsamos en la opci\u00f3n <code>Database</code> del men\u00fa y, sobre el <code>Cluster0</code>, pulsamos tambi\u00e9n el bot\u00f3n <code>Connect</code>. Se nos abrir\u00e1 el siguiente pop-up donde tendremos que elegir la opci\u00f3n <code>Connect your application</code>:</p> <p></p> <p>En el siguiente paso es donde se nos muestra la url que tendremos que utilizar en nuestra aplicaci\u00f3n. La copiamos y guardamos para m\u00e1s tarde: </p> <p></p> <p>Pulsamos <code>Close</code> y la BBDD ya estar\u00eda creada.</p> <p>Nota: Al crear la base de datos te aprecer\u00e1 un aviso para introducir tu IP en la whitelist, aseg\u00farate no estar en la VPN cuando lo hagas, de lo contrario no tendr\u00e1s conexi\u00f3n posteriormente.</p>"},{"location":"install/nodejs/#herramientas-para-pruebas","title":"Herramientas para pruebas","text":"<p>Para poder probar las operaciones de negocio que vamos a crear, lo mejor es utilizar una herramienta que permita realizar llamadas a API Rest. Para ello te propongo utilizar Postman, en su versi\u00f3n web o en su versi\u00f3n desktop, cualquiera de las dos sirve.</p> <p>Con esta herramienta se puede generar peticiones GET, POST, PUT, DELETE contra el servidor y pasarle par\u00e1metros de forma muy sencilla y visual. Lo usaremos durante el tutorial.</p>"},{"location":"install/nodejs/#creacion-de-proyecto","title":"Creaci\u00f3n de proyecto","text":"<p>Para la creaci\u00f3n de nuestro proyecto Node nos crearemos una carpeta con el nombre que deseemos y accederemos a ella con la consola de comandos de windows. Una vez dentro ejecutaremos el siguiente comando para inicializar nuestro proyecto con npm:</p> <pre><code>npm init\n</code></pre> <p>Cuando ejecutemos este comando nos pedir\u00e1 los valores para distintos par\u00e1metros de nuestro proyecto. Aconsejo solo cambiar el nombre y el resto dejarlo por defecto pulsando enter para cada valor. Una vez que hayamos terminado se nos habr\u00e1 generado un fichero <code>package.json</code> que contendr\u00e1 informaci\u00f3n b\u00e1sica de nuestro proyecto. Dentro de este fichero tendremos que a\u00f1adir un nuevo par\u00e1metro <code>type</code> con el valor <code>module</code>, esto nos permitir\u00e1 importar nuestros m\u00f3dulos con el est\u00e1ndar ES:</p> <pre><code>{\n\"name\": \"tutorialNode\",\n\"version\": \"1.0.0\",\n\"description\": \"\",\n\"main\": \"index.js\",\n\"scripts\": {\n\"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n},\n\"keywords\": [],\n\"author\": \"\",\n\"license\": \"ISC\",\n\"type\": \"module\"\n}\n</code></pre>"},{"location":"install/nodejs/#instalar-dependencias","title":"Instalar dependencias","text":"<p>En ese fichero aparte de la informaci\u00f3n de nuestro proyecto tambi\u00e9n tendremos que a\u00f1adir las dependencias que usara nuestra aplicaci\u00f3n. </p> <p>Para a\u00f1adir las dependencias, desde la consola de comandos y situados en la misma carpeta donde se haya creado el fichero <code>package.json</code> vamos a teclear los siguientes comandos:</p> <pre><code>npm i express\nnpm i express-validator\nnpm i dotenv\nnpm i mongoose\nnpm i mongoose-paginate-v2\nnpm i normalize-mongoose\nnpm i cors\nnpm i nodemon --save-dev\n</code></pre> <p>Tambi\u00e9n podr\u00edamos haber instalado todas a la vez en dos l\u00edneas: </p> <pre><code>npm i express express-validator dotenv  mongoose mongoose-paginate-v2 normalize-mongoose cors\nnpm i nodemon --save-dev\n</code></pre> <p>Las dependencias que acabamos de instalar son las siguientes: </p> <ul> <li>Express es un framework de Node que nos facilitara mucho la tarea a la hora de crear nuestra aplicaci\u00f3n.</li> <li>Dotenv es una librer\u00eda para usar variables de entorno.</li> <li>Mongoose es una librer\u00eda ODM que nos ayudara a los accesos a BBDD.</li> <li>Nodemon es una herramienta que nos ayuda reiniciando nuestro servidor cuando detecta un cambio en alguno de nuestros ficheros y as\u00ed no tener que hacerlo manualmente.</li> <li>Cors es una herramienta que nos ayuda a configurar el CORS de nuestra app para que posteriormente podemos conectarlo al front.</li> </ul> <p>Ahora podemos fijarnos en nuestro fichero <code>package.json</code> donde se habr\u00e1n a\u00f1adido dos nuevos par\u00e1metros: <code>dependencies</code> y <code>devDependencies</code>. La diferencia est\u00e1 en que las <code>devDependencies</code> solo se utilizar en la fase de desarrollo de nuestro proyecto y las <code>dependencies</code> se utilizar\u00e1n en todo momento.</p>"},{"location":"install/nodejs/#configurar-la-bbdd","title":"Configurar la BBDD","text":"<p>A partir de aqu\u00ed ya podemos abrir Visual Studio Code, el IDE recomendado, y abrir la carpeta del proyecto para poder configurarlo y programarlo. Lo primero ser\u00e1 configurar el acceso con la BBDD.</p> <p>Para ello vamos a crear en la ra\u00edz de nuestro proyecto una carpeta <code>config</code> dentro de la cual crearemos un archivo llamado <code>db.js</code>. Este archivo exportar\u00e1 una funci\u00f3n que recibe una url de nuestra BBDD y la conectar\u00e1 con mongoose. El contenido de este archivo debe ser el siguiente:</p> db.js <pre><code>import mongoose from 'mongoose';\n\nconst connectDB = async (url) =&gt; {\n\ntry {\nawait mongoose.connect(url);\nconsole.log('BBDD connected');\n} catch (error) {\nthrow new Error('Error initiating BBDD:' + error);\n}\n}\n\nexport default connectDB;\n</code></pre> <p>Ahora vamos a crear en la ra\u00edz de nuestro proyecto un archivo con el nombre <code>.env</code>. Este archivo tendr\u00e1 las variables de entorno de nuestro proyecto. Es aqu\u00ed donde pondremos la url que obtuvimos al crear nuestra BBDD. As\u00ed pues, crearemos una nueva variable y pegaremos la URL. Tambi\u00e9n vamos a configurar el puerto del servidor.</p> .env <pre><code>MONGODB_URL='mongodb+srv://&lt;user&gt;:&lt;pass&gt;@&lt;url&gt;.mongodb.net/?retryWrites=true&amp;w=majority'\nPORT='8080'\n</code></pre>"},{"location":"install/nodejs/#arrancar-el-proyecto","title":"Arrancar el proyecto","text":"<p>Con toda esa configuraci\u00f3n, ahora ya podemos crear nuestra p\u00e1gina inicial. Dentro del fichero <code>package.json</code>, en concreto en el contenido de <code>main</code> vemos que nos indica el valor de <code>index.js</code>. Este ser\u00e1 el punto de entrada a nuestra aplicaci\u00f3n, pero este fichero todav\u00eda no existe, as\u00ed que lo crearemos con el siguiente contenido:</p> index.js <pre><code>import express from 'express';\nimport cors from 'cors';\nimport connectDB from './config/db.js';\nimport { config } from 'dotenv';\n\nconfig();\nconnectDB(process.env.MONGODB_URL);\nconst app = express();\n\napp.use(cors({\norigin: '*'\n}));\n\napp.listen(process.env.PORT, () =&gt; {\nconsole.log(`Server running on port ${process.env.PORT}`);\n});\n</code></pre> <p>El funcionamiento de este c\u00f3digo, resumiendo mucho, es el siguiente. Configurar la base de datos, configurar el CORS para que posteriormente podamos realizar peticiones desde el front y crea un servidor con express en el puerto <code>8080</code>.</p> <p>Pero antes, para poder ejecutar nuestro servidor debemos modificar el fichero <code>package.json</code>, y a\u00f1adir un script de arranque. A\u00f1adiremos la siguiente l\u00ednea:</p> <pre><code>\"dev\": \"nodemon ./index.js\"\n</code></pre> <p>Y ahora s\u00ed, desde la consola de comando ya podemos ejecutar el siguiente comando:</p> <pre><code>npm run dev\n</code></pre> <p>y ya podremos ver en la consola como la aplicaci\u00f3n ha arrancado correctamente con el mensaje que le hemos a\u00f1adido.</p>"},{"location":"install/springboot/","title":"Entorno de desarrollo - Spring Boot","text":""},{"location":"install/springboot/#instalacion-de-herramientas","title":"Instalaci\u00f3n de herramientas","text":"<p>Las herramientas b\u00e1sicas que vamos a utilizar para esta tecnolog\u00eda son:</p> <ul> <li>Eclipse IDE</li> <li>Maven (viene por defecto con Eclipse IDE)</li> <li>Java 19</li> <li>Postman</li> </ul>"},{"location":"install/springboot/#instalacion-de-ide-eclipse","title":"Instalaci\u00f3n de IDE - Eclipse","text":"<p>Necesitamos instalar un IDE de desarrollo, en nuestro caso ser\u00e1 Eclipse IDE y la m\u00e1quina virtual de java necesaria para ejecutar el c\u00f3digo. Recomendamos Java 19, que es la versi\u00f3n con la que est\u00e1 desarrollado y probado el tutorial. </p> <p>Para instalar el IDE deber\u00e1s acceder a la web de Eclipse IDE y descargarte la \u00faltima versi\u00f3n del instalador. Una vez lo ejecutes te pedir\u00e1 el tipo de instalaci\u00f3n que deseas instalar. Por lo general con la de \"Eclipse IDE for Java Developers\" es suficiente. Con esta versi\u00f3n ya tiene integrado los plugins de Maven y Git.</p>"},{"location":"install/springboot/#instalacion-de-java","title":"Instalaci\u00f3n de Java","text":"<p>Una vez instalado eclipse, debes asegurarte que est\u00e1 usando por defecto la versi\u00f3n de Java 19 y para ello deber\u00e1s instalarla. Desc\u00e1rgala del siguiente enlace. Es posible que te pida un registro de correo, utiliza el email que quieras (corporativo o personal). Revisa bien el enlace para buscar y descargar la versi\u00f3n 19 para Windows: </p> <p></p> <p>Ya solo queda a\u00f1adir Java al Eclipse. Para ello, abre el men\u00fa <code>Window -&gt; Preferences</code>:</p> <p></p> <p>y dentro de la secci\u00f3n <code>Java - Installed JREs</code> a\u00f1ade la versi\u00f3n que acabas de descargar, siempre pulsando el bot\u00f3n <code>Add...</code> y buscando el directorio <code>home</code> de la instalaci\u00f3n de Java. Adem\u00e1s, la debes marcar como <code>default</code>.</p> <p></p>"},{"location":"install/springboot/#configuracion-de-ide-eclipse","title":"Configuraci\u00f3n de IDE - Eclipse","text":"<p>Como complemento al Eclipse, con el fin de crear c\u00f3digo homog\u00e9neo y mantenible, vamos a configurar el formateador de c\u00f3digo autom\u00e1tico.</p> <p>Para ello de nuevo abrimos el men\u00fa <code>Window -&gt; Preferences</code>, nos vamos a la secci\u00f3n <code>Formatter</code> de Java:</p> <p></p> <p>Aqu\u00ed crearemos un nuevo perfil heredando la configuraci\u00f3n por defecto.</p> <p></p> <p>En el nuevo perfil configuramos que se use espacios en vez de tabuladores con sangrado de 4 caracteres.</p> <p></p> <p>Una vez cofigurado el nuevo formateador debemos activar que se aplique en el guardado. Para ello volvemos acceder a las preferencias de Eclipse y nos dirigimos a la sub secci\u00f3n <code>Save Actions</code> del la secci\u00f3n <code>Editor</code> nuevamente de Java.</p> <p></p> <p>Aqu\u00ed aplicamos la configuraci\u00f3n deseada.</p> <p></p>"},{"location":"install/springboot/#herramientas-para-pruebas","title":"Herramientas para pruebas","text":"<p>Para poder probar las operaciones de negocio que vamos a crear, lo mejor es utilizar una herramienta que permita realizar llamadas a API Rest. Para ello te propongo utilizar Postman, en su versi\u00f3n web o en su versi\u00f3n desktop, cualquiera de las dos sirve.</p> <p>Con esta herramienta se puede generar peticiones GET, POST, PUT, DELETE contra el servidor y pasarle par\u00e1metros de forma muy sencilla y visual. Lo usaremos durante el tutorial.</p>"},{"location":"install/springboot/#creacion-de-proyecto","title":"Creaci\u00f3n de proyecto","text":"<p>La mayor\u00eda de los proyectos SpringBoot en los que trabajamos normalmente, suelen ser proyectos web sencillos con pocas dependencias de terceros o incluso proyectos basados en micro-servicios que ejecutan pocas acciones. Ahora tienes que preparar el proyecto SpringBoot,</p>"},{"location":"install/springboot/#crear-con-initilizr","title":"Crear con Initilizr","text":"<p>Vamos a ver como configurar paso a paso un proyecto de cero, con las librer\u00edas que vamos a utilizar en el tutorial.</p>"},{"location":"install/springboot/#como-usarlo","title":"\u00bfComo usarlo?","text":"<p>Spring ha creado una p\u00e1gina interactiva que permite crear y configurar proyectos en diferentes lenguajes, con diferentes versiones de Spring Boot y a\u00f1adi\u00e9ndole los m\u00f3dulos que nosotros queramos.</p> <p>Esta p\u00e1gina est\u00e1 disponible desde Spring Initializr. Para seguir el ejemplo del tutorial, entraremos en la web y seleccionaremos los siguientes datos:</p> <ul> <li>Tipo de proyecto: Maven</li> <li>Lenguage: Java</li> <li>Versi\u00f3n Spring boot: 3.0.4 (o alguna similar)</li> <li>Group: com.ccsw</li> <li>ArtifactId: tutorial</li> <li>Versi\u00f3n Java: 19</li> <li>Dependencias: Spring Web, Spring Data JPA, H2 Database</li> </ul> <p></p> <p>Esto nos generar\u00e1 un proyecto que ya vendr\u00e1 configurado con Spring Web, JPA y H2 para crear una BBDD en memoria de ejemplo con la que trabajaremos durante el tutorial</p>"},{"location":"install/springboot/#importar-en-eclipse","title":"Importar en eclipse","text":"<p>El siguiente paso, es descomprimir el proyecto generado e importarlo como proyecto Maven. Abrimos el eclipse, pulsamos en File \u2192 Import y seleccionamos <code>Existing Maven Projects</code>. Buscamos el proyecto y le damos a importar.</p>"},{"location":"install/springboot/#configurar-las-dependencias","title":"Configurar las dependencias","text":"<p>Lo primero que vamos a hacer es a\u00f1adir las dependencias a algunas librer\u00edas que vamos a utilizar. Abriremos el fichero <code>pom.xml</code> que nos ha generado el Spring Initilizr y a\u00f1adiremos las siguientes l\u00edneas:</p> pom.xml <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n&lt;parent&gt;\n&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n&lt;version&gt;3.0.4&lt;/version&gt;\n&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n&lt;/parent&gt;\n\n&lt;groupId&gt;com.ccsw&lt;/groupId&gt;\n&lt;artifactId&gt;tutorial&lt;/artifactId&gt;\n&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n&lt;name&gt;tutorial&lt;/name&gt;\n&lt;description&gt;Tutorial project for Spring Boot&lt;/description&gt;\n\n&lt;properties&gt;\n&lt;java.version&gt;19&lt;/java.version&gt;\n&lt;/properties&gt;\n\n&lt;dependencies&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n&lt;/dependency&gt;\n\n&lt;dependency&gt;\n&lt;groupId&gt;org.springdoc&lt;/groupId&gt;\n&lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;\n&lt;version&gt;2.0.3&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.hibernate&lt;/groupId&gt;\n&lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;\n&lt;version&gt;8.0.0.Final&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;net.sf.dozer&lt;/groupId&gt;\n&lt;artifactId&gt;dozer&lt;/artifactId&gt;\n&lt;version&gt;5.5.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;com.h2database&lt;/groupId&gt;\n&lt;artifactId&gt;h2&lt;/artifactId&gt;\n&lt;scope&gt;runtime&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n&lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n\n&lt;build&gt;\n&lt;plugins&gt;\n&lt;plugin&gt;\n&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n&lt;/plugin&gt;\n&lt;/plugins&gt;\n&lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <p>Hemos a\u00f1adido las dependencias de que nos permite utilizar Open API para documentar nuestras APIs. Adem\u00e1s de esa dependencia, hemos a\u00f1adido una utilidad para hacer mapeos entre objetos y para configurar los servicios Rest. M\u00e1s adelante veremos como se utilizan.</p>"},{"location":"install/springboot/#configurar-librerias","title":"Configurar librer\u00edas","text":"<p>El siguiente punto es crear las clases de configuraci\u00f3n para las librer\u00edas que hemos a\u00f1adido. Para ello vamos a crear un package de configuraci\u00f3n general de la aplicaci\u00f3n <code>com.ccsw.tutorial.config</code> donde crearemos una clase que llamaremos <code>BeanDozerConfig</code> y usaremos para configurar el bean de Dozer.</p> BeanDozerConfig.java <pre><code>package com.ccsw.tutorial.config;\n\nimport org.dozer.DozerBeanMapper;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * @author ccsw\n * \n*/\n@Configuration\npublic class BeanDozerConfig {\n\n@Bean\npublic DozerBeanMapper getDozerBeanMapper() {\n\nreturn new DozerBeanMapper();\n}\n\n}\n</code></pre> <p>Esta configuraci\u00f3n nos permitir\u00e1 luego hacer transformaciones entre objetos de forma muy sencilla. Ya lo iremos viendo m\u00e1s adelante. Listo, ya podemos empezar a desarrollar nuestros servicios.</p>"},{"location":"install/springboot/#configurar-la-bbdd","title":"Configurar la BBDD","text":"<p>Por \u00faltimo, vamos a dejar configurada la BBDD en memoria. Para ello crearemos un fichero, de momento en blanco, dentro de <code>src/main/resources/</code>:</p> <ul> <li>data.sql \u2192 Ser\u00e1 el fichero que utilizaremos para rellenar con datos iniciales el esquema de BBDD</li> </ul> <p>Este fichero no puede estar vac\u00edo, ya que si no dar\u00e1 un error al arrancar. Puedes a\u00f1adirle la siguiente query (que no hace nada) para que pueda arrancar el proyecto.</p> <p><code>select 1 from dual;</code></p> <p>Y ahora le vamos a decir a Spring Boot que la BBDD ser\u00e1 en memoria, que use un motor de H2 y que la cree autom\u00e1ticamente desde el modelo y que utilice el fichero <code>data.sql</code> (por defecto) para cargar datos en esta. Para ello hay que configurar el fichero <code>application.properties</code> que est\u00e1 dentro de <code>src/main/resources/</code>:</p> application.properties <pre><code>  #Database\nspring.datasource.url=jdbc:h2:mem:testdb\nspring.datasource.username=sa\nspring.datasource.password=sa\nspring.datasource.driver-class-name=org.h2.Driver\n\nspring.jpa.database-platform=org.hibernate.dialect.H2Dialect\nspring.jpa.defer-datasource-initialization=true\nspring.jpa.show-sql=true\n\nspring.h2.console.enabled=true\n</code></pre>"},{"location":"install/springboot/#arrancar-el-proyecto","title":"Arrancar el proyecto","text":"<p>Por \u00faltimo ya solo nos queda arrancar el proyecto creado. Para ello buscaremos la clase <code>TutorialApplication.java</code> (o la clase principal del proyecto) y con el bot\u00f3n derecho seleccionaremos Run As \u2192 Java Application. La aplicaci\u00f3n al estar basada en Spring Boot arrancar\u00e1 internamente un Tomcat embebido donde se despliega el proyecto. </p> <p>Si hab\u00e9is seguido el tutorial la aplicaci\u00f3n estar\u00e1 disponible en http://localhost:8080, aunque de momento a\u00fan no tenemos nada accesible y nos dar\u00e1 una p\u00e1gina de error <code>Whitelabel Error Page</code>, error 404. Eso significa que el Tomcat embedido nos ha contestado pero no sabe que devolvernos porque no hemos implementado todav\u00eda nada.</p>"}]}